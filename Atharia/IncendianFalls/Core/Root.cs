using System;
using System.Collections;

using System.Collections.Generic;

namespace Atharia.Model {

public interface ILogger {
  void Info(string str);
  void Warning(string str);
  void Error(string str);
}

public struct VersionAndIncarnation<T> {
  public int version;
  public T incarnation;
  public VersionAndIncarnation(int version, T incarnation) {
    this.version = version;
    this.incarnation = incarnation;
  }
}

public class Root {
  private static readonly int VERSION_HASH_MULTIPLIER = 179424673;
  private static readonly int NEXT_ID_HASH_MULTIPLIER = 373587883;

  private void CheckRootsEqual(Root a, Root b) {
    if (a != b) {
      throw new System.Exception("Given objects aren't from the same root!");
    }
  }

  public readonly ILogger logger;

  // This *always* points to a live RootIncarnation. When we snapshot, we eagerly
  // make a new one of these.
  private RootIncarnation rootIncarnation;

  bool locked;

  // 0 means everything

  readonly SortedDictionary<int, List<ISquareCaveLevelControllerEffectObserver>> observersForSquareCaveLevelController =
      new SortedDictionary<int, List<ISquareCaveLevelControllerEffectObserver>>();
  readonly List<SquareCaveLevelControllerCreateEffect> effectsSquareCaveLevelControllerCreateEffect =
      new List<SquareCaveLevelControllerCreateEffect>();
  readonly List<SquareCaveLevelControllerDeleteEffect> effectsSquareCaveLevelControllerDeleteEffect =
      new List<SquareCaveLevelControllerDeleteEffect>();

  readonly SortedDictionary<int, List<IRidgeLevelControllerEffectObserver>> observersForRidgeLevelController =
      new SortedDictionary<int, List<IRidgeLevelControllerEffectObserver>>();
  readonly List<RidgeLevelControllerCreateEffect> effectsRidgeLevelControllerCreateEffect =
      new List<RidgeLevelControllerCreateEffect>();
  readonly List<RidgeLevelControllerDeleteEffect> effectsRidgeLevelControllerDeleteEffect =
      new List<RidgeLevelControllerDeleteEffect>();

  readonly SortedDictionary<int, List<IGauntletLevelControllerEffectObserver>> observersForGauntletLevelController =
      new SortedDictionary<int, List<IGauntletLevelControllerEffectObserver>>();
  readonly List<GauntletLevelControllerCreateEffect> effectsGauntletLevelControllerCreateEffect =
      new List<GauntletLevelControllerCreateEffect>();
  readonly List<GauntletLevelControllerDeleteEffect> effectsGauntletLevelControllerDeleteEffect =
      new List<GauntletLevelControllerDeleteEffect>();

  readonly SortedDictionary<int, List<IPreGauntletLevelControllerEffectObserver>> observersForPreGauntletLevelController =
      new SortedDictionary<int, List<IPreGauntletLevelControllerEffectObserver>>();
  readonly List<PreGauntletLevelControllerCreateEffect> effectsPreGauntletLevelControllerCreateEffect =
      new List<PreGauntletLevelControllerCreateEffect>();
  readonly List<PreGauntletLevelControllerDeleteEffect> effectsPreGauntletLevelControllerDeleteEffect =
      new List<PreGauntletLevelControllerDeleteEffect>();

  readonly SortedDictionary<int, List<IRavashrikeLevelControllerEffectObserver>> observersForRavashrikeLevelController =
      new SortedDictionary<int, List<IRavashrikeLevelControllerEffectObserver>>();
  readonly List<RavashrikeLevelControllerCreateEffect> effectsRavashrikeLevelControllerCreateEffect =
      new List<RavashrikeLevelControllerCreateEffect>();
  readonly List<RavashrikeLevelControllerDeleteEffect> effectsRavashrikeLevelControllerDeleteEffect =
      new List<RavashrikeLevelControllerDeleteEffect>();

  readonly SortedDictionary<int, List<IPentagonalCaveLevelControllerEffectObserver>> observersForPentagonalCaveLevelController =
      new SortedDictionary<int, List<IPentagonalCaveLevelControllerEffectObserver>>();
  readonly List<PentagonalCaveLevelControllerCreateEffect> effectsPentagonalCaveLevelControllerCreateEffect =
      new List<PentagonalCaveLevelControllerCreateEffect>();
  readonly List<PentagonalCaveLevelControllerDeleteEffect> effectsPentagonalCaveLevelControllerDeleteEffect =
      new List<PentagonalCaveLevelControllerDeleteEffect>();

  readonly SortedDictionary<int, List<ICliffLevelControllerEffectObserver>> observersForCliffLevelController =
      new SortedDictionary<int, List<ICliffLevelControllerEffectObserver>>();
  readonly List<CliffLevelControllerCreateEffect> effectsCliffLevelControllerCreateEffect =
      new List<CliffLevelControllerCreateEffect>();
  readonly List<CliffLevelControllerDeleteEffect> effectsCliffLevelControllerDeleteEffect =
      new List<CliffLevelControllerDeleteEffect>();

  readonly SortedDictionary<int, List<ILevelEffectObserver>> observersForLevel =
      new SortedDictionary<int, List<ILevelEffectObserver>>();
  readonly List<LevelCreateEffect> effectsLevelCreateEffect =
      new List<LevelCreateEffect>();
  readonly List<LevelDeleteEffect> effectsLevelDeleteEffect =
      new List<LevelDeleteEffect>();
  readonly List<LevelSetControllerEffect> effectsLevelSetControllerEffect =
      new List<LevelSetControllerEffect>();
  readonly List<LevelSetTimeEffect> effectsLevelSetTimeEffect =
      new List<LevelSetTimeEffect>();

  readonly SortedDictionary<int, List<ITimeAnchorTTCEffectObserver>> observersForTimeAnchorTTC =
      new SortedDictionary<int, List<ITimeAnchorTTCEffectObserver>>();
  readonly List<TimeAnchorTTCCreateEffect> effectsTimeAnchorTTCCreateEffect =
      new List<TimeAnchorTTCCreateEffect>();
  readonly List<TimeAnchorTTCDeleteEffect> effectsTimeAnchorTTCDeleteEffect =
      new List<TimeAnchorTTCDeleteEffect>();

  readonly SortedDictionary<int, List<ITerrainTileEffectObserver>> observersForTerrainTile =
      new SortedDictionary<int, List<ITerrainTileEffectObserver>>();
  readonly List<TerrainTileCreateEffect> effectsTerrainTileCreateEffect =
      new List<TerrainTileCreateEffect>();
  readonly List<TerrainTileDeleteEffect> effectsTerrainTileDeleteEffect =
      new List<TerrainTileDeleteEffect>();
  readonly List<TerrainTileSetElevationEffect> effectsTerrainTileSetElevationEffect =
      new List<TerrainTileSetElevationEffect>();

  readonly SortedDictionary<int, List<IITerrainTileComponentMutBunchEffectObserver>> observersForITerrainTileComponentMutBunch =
      new SortedDictionary<int, List<IITerrainTileComponentMutBunchEffectObserver>>();
  readonly List<ITerrainTileComponentMutBunchCreateEffect> effectsITerrainTileComponentMutBunchCreateEffect =
      new List<ITerrainTileComponentMutBunchCreateEffect>();
  readonly List<ITerrainTileComponentMutBunchDeleteEffect> effectsITerrainTileComponentMutBunchDeleteEffect =
      new List<ITerrainTileComponentMutBunchDeleteEffect>();

  readonly SortedDictionary<int, List<ITerrainEffectObserver>> observersForTerrain =
      new SortedDictionary<int, List<ITerrainEffectObserver>>();
  readonly List<TerrainCreateEffect> effectsTerrainCreateEffect =
      new List<TerrainCreateEffect>();
  readonly List<TerrainDeleteEffect> effectsTerrainDeleteEffect =
      new List<TerrainDeleteEffect>();
  readonly List<TerrainSetPatternEffect> effectsTerrainSetPatternEffect =
      new List<TerrainSetPatternEffect>();

  readonly SortedDictionary<int, List<IStaircaseTTCEffectObserver>> observersForStaircaseTTC =
      new SortedDictionary<int, List<IStaircaseTTCEffectObserver>>();
  readonly List<StaircaseTTCCreateEffect> effectsStaircaseTTCCreateEffect =
      new List<StaircaseTTCCreateEffect>();
  readonly List<StaircaseTTCDeleteEffect> effectsStaircaseTTCDeleteEffect =
      new List<StaircaseTTCDeleteEffect>();
  readonly List<StaircaseTTCSetDestinationLevelEffect> effectsStaircaseTTCSetDestinationLevelEffect =
      new List<StaircaseTTCSetDestinationLevelEffect>();
  readonly List<StaircaseTTCSetDestinationLevelPortalIndexEffect> effectsStaircaseTTCSetDestinationLevelPortalIndexEffect =
      new List<StaircaseTTCSetDestinationLevelPortalIndexEffect>();

  readonly SortedDictionary<int, List<IWallTTCEffectObserver>> observersForWallTTC =
      new SortedDictionary<int, List<IWallTTCEffectObserver>>();
  readonly List<WallTTCCreateEffect> effectsWallTTCCreateEffect =
      new List<WallTTCCreateEffect>();
  readonly List<WallTTCDeleteEffect> effectsWallTTCDeleteEffect =
      new List<WallTTCDeleteEffect>();

  readonly SortedDictionary<int, List<IBloodTTCEffectObserver>> observersForBloodTTC =
      new SortedDictionary<int, List<IBloodTTCEffectObserver>>();
  readonly List<BloodTTCCreateEffect> effectsBloodTTCCreateEffect =
      new List<BloodTTCCreateEffect>();
  readonly List<BloodTTCDeleteEffect> effectsBloodTTCDeleteEffect =
      new List<BloodTTCDeleteEffect>();

  readonly SortedDictionary<int, List<IRocksTTCEffectObserver>> observersForRocksTTC =
      new SortedDictionary<int, List<IRocksTTCEffectObserver>>();
  readonly List<RocksTTCCreateEffect> effectsRocksTTCCreateEffect =
      new List<RocksTTCCreateEffect>();
  readonly List<RocksTTCDeleteEffect> effectsRocksTTCDeleteEffect =
      new List<RocksTTCDeleteEffect>();

  readonly SortedDictionary<int, List<IDownstairsTTCEffectObserver>> observersForDownstairsTTC =
      new SortedDictionary<int, List<IDownstairsTTCEffectObserver>>();
  readonly List<DownstairsTTCCreateEffect> effectsDownstairsTTCCreateEffect =
      new List<DownstairsTTCCreateEffect>();
  readonly List<DownstairsTTCDeleteEffect> effectsDownstairsTTCDeleteEffect =
      new List<DownstairsTTCDeleteEffect>();

  readonly SortedDictionary<int, List<IUpstairsTTCEffectObserver>> observersForUpstairsTTC =
      new SortedDictionary<int, List<IUpstairsTTCEffectObserver>>();
  readonly List<UpstairsTTCCreateEffect> effectsUpstairsTTCCreateEffect =
      new List<UpstairsTTCCreateEffect>();
  readonly List<UpstairsTTCDeleteEffect> effectsUpstairsTTCDeleteEffect =
      new List<UpstairsTTCDeleteEffect>();

  readonly SortedDictionary<int, List<ICaveTTCEffectObserver>> observersForCaveTTC =
      new SortedDictionary<int, List<ICaveTTCEffectObserver>>();
  readonly List<CaveTTCCreateEffect> effectsCaveTTCCreateEffect =
      new List<CaveTTCCreateEffect>();
  readonly List<CaveTTCDeleteEffect> effectsCaveTTCDeleteEffect =
      new List<CaveTTCDeleteEffect>();

  readonly SortedDictionary<int, List<IFallsTTCEffectObserver>> observersForFallsTTC =
      new SortedDictionary<int, List<IFallsTTCEffectObserver>>();
  readonly List<FallsTTCCreateEffect> effectsFallsTTCCreateEffect =
      new List<FallsTTCCreateEffect>();
  readonly List<FallsTTCDeleteEffect> effectsFallsTTCDeleteEffect =
      new List<FallsTTCDeleteEffect>();

  readonly SortedDictionary<int, List<IMagmaTTCEffectObserver>> observersForMagmaTTC =
      new SortedDictionary<int, List<IMagmaTTCEffectObserver>>();
  readonly List<MagmaTTCCreateEffect> effectsMagmaTTCCreateEffect =
      new List<MagmaTTCCreateEffect>();
  readonly List<MagmaTTCDeleteEffect> effectsMagmaTTCDeleteEffect =
      new List<MagmaTTCDeleteEffect>();

  readonly SortedDictionary<int, List<ICliffTTCEffectObserver>> observersForCliffTTC =
      new SortedDictionary<int, List<ICliffTTCEffectObserver>>();
  readonly List<CliffTTCCreateEffect> effectsCliffTTCCreateEffect =
      new List<CliffTTCCreateEffect>();
  readonly List<CliffTTCDeleteEffect> effectsCliffTTCDeleteEffect =
      new List<CliffTTCDeleteEffect>();

  readonly SortedDictionary<int, List<IRavaNestTTCEffectObserver>> observersForRavaNestTTC =
      new SortedDictionary<int, List<IRavaNestTTCEffectObserver>>();
  readonly List<RavaNestTTCCreateEffect> effectsRavaNestTTCCreateEffect =
      new List<RavaNestTTCCreateEffect>();
  readonly List<RavaNestTTCDeleteEffect> effectsRavaNestTTCDeleteEffect =
      new List<RavaNestTTCDeleteEffect>();

  readonly SortedDictionary<int, List<ICliffLandingTTCEffectObserver>> observersForCliffLandingTTC =
      new SortedDictionary<int, List<ICliffLandingTTCEffectObserver>>();
  readonly List<CliffLandingTTCCreateEffect> effectsCliffLandingTTCCreateEffect =
      new List<CliffLandingTTCCreateEffect>();
  readonly List<CliffLandingTTCDeleteEffect> effectsCliffLandingTTCDeleteEffect =
      new List<CliffLandingTTCDeleteEffect>();

  readonly SortedDictionary<int, List<IStoneTTCEffectObserver>> observersForStoneTTC =
      new SortedDictionary<int, List<IStoneTTCEffectObserver>>();
  readonly List<StoneTTCCreateEffect> effectsStoneTTCCreateEffect =
      new List<StoneTTCCreateEffect>();
  readonly List<StoneTTCDeleteEffect> effectsStoneTTCDeleteEffect =
      new List<StoneTTCDeleteEffect>();

  readonly SortedDictionary<int, List<IGrassTTCEffectObserver>> observersForGrassTTC =
      new SortedDictionary<int, List<IGrassTTCEffectObserver>>();
  readonly List<GrassTTCCreateEffect> effectsGrassTTCCreateEffect =
      new List<GrassTTCCreateEffect>();
  readonly List<GrassTTCDeleteEffect> effectsGrassTTCDeleteEffect =
      new List<GrassTTCDeleteEffect>();

  readonly SortedDictionary<int, List<IManaPotionEffectObserver>> observersForManaPotion =
      new SortedDictionary<int, List<IManaPotionEffectObserver>>();
  readonly List<ManaPotionCreateEffect> effectsManaPotionCreateEffect =
      new List<ManaPotionCreateEffect>();
  readonly List<ManaPotionDeleteEffect> effectsManaPotionDeleteEffect =
      new List<ManaPotionDeleteEffect>();

  readonly SortedDictionary<int, List<IHealthPotionEffectObserver>> observersForHealthPotion =
      new SortedDictionary<int, List<IHealthPotionEffectObserver>>();
  readonly List<HealthPotionCreateEffect> effectsHealthPotionCreateEffect =
      new List<HealthPotionCreateEffect>();
  readonly List<HealthPotionDeleteEffect> effectsHealthPotionDeleteEffect =
      new List<HealthPotionDeleteEffect>();

  readonly SortedDictionary<int, List<IInertiaRingEffectObserver>> observersForInertiaRing =
      new SortedDictionary<int, List<IInertiaRingEffectObserver>>();
  readonly List<InertiaRingCreateEffect> effectsInertiaRingCreateEffect =
      new List<InertiaRingCreateEffect>();
  readonly List<InertiaRingDeleteEffect> effectsInertiaRingDeleteEffect =
      new List<InertiaRingDeleteEffect>();

  readonly SortedDictionary<int, List<IGlaiveEffectObserver>> observersForGlaive =
      new SortedDictionary<int, List<IGlaiveEffectObserver>>();
  readonly List<GlaiveCreateEffect> effectsGlaiveCreateEffect =
      new List<GlaiveCreateEffect>();
  readonly List<GlaiveDeleteEffect> effectsGlaiveDeleteEffect =
      new List<GlaiveDeleteEffect>();

  readonly SortedDictionary<int, List<IArmorEffectObserver>> observersForArmor =
      new SortedDictionary<int, List<IArmorEffectObserver>>();
  readonly List<ArmorCreateEffect> effectsArmorCreateEffect =
      new List<ArmorCreateEffect>();
  readonly List<ArmorDeleteEffect> effectsArmorDeleteEffect =
      new List<ArmorDeleteEffect>();

  readonly SortedDictionary<int, List<IRandEffectObserver>> observersForRand =
      new SortedDictionary<int, List<IRandEffectObserver>>();
  readonly List<RandCreateEffect> effectsRandCreateEffect =
      new List<RandCreateEffect>();
  readonly List<RandDeleteEffect> effectsRandDeleteEffect =
      new List<RandDeleteEffect>();
  readonly List<RandSetRandEffect> effectsRandSetRandEffect =
      new List<RandSetRandEffect>();

  readonly SortedDictionary<int, List<IWanderAICapabilityUCEffectObserver>> observersForWanderAICapabilityUC =
      new SortedDictionary<int, List<IWanderAICapabilityUCEffectObserver>>();
  readonly List<WanderAICapabilityUCCreateEffect> effectsWanderAICapabilityUCCreateEffect =
      new List<WanderAICapabilityUCCreateEffect>();
  readonly List<WanderAICapabilityUCDeleteEffect> effectsWanderAICapabilityUCDeleteEffect =
      new List<WanderAICapabilityUCDeleteEffect>();

  readonly SortedDictionary<int, List<ICounteringUCEffectObserver>> observersForCounteringUC =
      new SortedDictionary<int, List<ICounteringUCEffectObserver>>();
  readonly List<CounteringUCCreateEffect> effectsCounteringUCCreateEffect =
      new List<CounteringUCCreateEffect>();
  readonly List<CounteringUCDeleteEffect> effectsCounteringUCDeleteEffect =
      new List<CounteringUCDeleteEffect>();

  readonly SortedDictionary<int, List<IShieldingUCEffectObserver>> observersForShieldingUC =
      new SortedDictionary<int, List<IShieldingUCEffectObserver>>();
  readonly List<ShieldingUCCreateEffect> effectsShieldingUCCreateEffect =
      new List<ShieldingUCCreateEffect>();
  readonly List<ShieldingUCDeleteEffect> effectsShieldingUCDeleteEffect =
      new List<ShieldingUCDeleteEffect>();

  readonly SortedDictionary<int, List<IEvaporateImpulseEffectObserver>> observersForEvaporateImpulse =
      new SortedDictionary<int, List<IEvaporateImpulseEffectObserver>>();
  readonly List<EvaporateImpulseCreateEffect> effectsEvaporateImpulseCreateEffect =
      new List<EvaporateImpulseCreateEffect>();
  readonly List<EvaporateImpulseDeleteEffect> effectsEvaporateImpulseDeleteEffect =
      new List<EvaporateImpulseDeleteEffect>();

  readonly SortedDictionary<int, List<ITimeCloneAICapabilityUCEffectObserver>> observersForTimeCloneAICapabilityUC =
      new SortedDictionary<int, List<ITimeCloneAICapabilityUCEffectObserver>>();
  readonly List<TimeCloneAICapabilityUCCreateEffect> effectsTimeCloneAICapabilityUCCreateEffect =
      new List<TimeCloneAICapabilityUCCreateEffect>();
  readonly List<TimeCloneAICapabilityUCDeleteEffect> effectsTimeCloneAICapabilityUCDeleteEffect =
      new List<TimeCloneAICapabilityUCDeleteEffect>();

  readonly SortedDictionary<int, List<IUnleashBideImpulseEffectObserver>> observersForUnleashBideImpulse =
      new SortedDictionary<int, List<IUnleashBideImpulseEffectObserver>>();
  readonly List<UnleashBideImpulseCreateEffect> effectsUnleashBideImpulseCreateEffect =
      new List<UnleashBideImpulseCreateEffect>();
  readonly List<UnleashBideImpulseDeleteEffect> effectsUnleashBideImpulseDeleteEffect =
      new List<UnleashBideImpulseDeleteEffect>();

  readonly SortedDictionary<int, List<IContinueBidingImpulseEffectObserver>> observersForContinueBidingImpulse =
      new SortedDictionary<int, List<IContinueBidingImpulseEffectObserver>>();
  readonly List<ContinueBidingImpulseCreateEffect> effectsContinueBidingImpulseCreateEffect =
      new List<ContinueBidingImpulseCreateEffect>();
  readonly List<ContinueBidingImpulseDeleteEffect> effectsContinueBidingImpulseDeleteEffect =
      new List<ContinueBidingImpulseDeleteEffect>();

  readonly SortedDictionary<int, List<IStartBidingImpulseEffectObserver>> observersForStartBidingImpulse =
      new SortedDictionary<int, List<IStartBidingImpulseEffectObserver>>();
  readonly List<StartBidingImpulseCreateEffect> effectsStartBidingImpulseCreateEffect =
      new List<StartBidingImpulseCreateEffect>();
  readonly List<StartBidingImpulseDeleteEffect> effectsStartBidingImpulseDeleteEffect =
      new List<StartBidingImpulseDeleteEffect>();

  readonly SortedDictionary<int, List<IBideAICapabilityUCEffectObserver>> observersForBideAICapabilityUC =
      new SortedDictionary<int, List<IBideAICapabilityUCEffectObserver>>();
  readonly List<BideAICapabilityUCCreateEffect> effectsBideAICapabilityUCCreateEffect =
      new List<BideAICapabilityUCCreateEffect>();
  readonly List<BideAICapabilityUCDeleteEffect> effectsBideAICapabilityUCDeleteEffect =
      new List<BideAICapabilityUCDeleteEffect>();
  readonly List<BideAICapabilityUCSetChargeEffect> effectsBideAICapabilityUCSetChargeEffect =
      new List<BideAICapabilityUCSetChargeEffect>();

  readonly SortedDictionary<int, List<IFireImpulseEffectObserver>> observersForFireImpulse =
      new SortedDictionary<int, List<IFireImpulseEffectObserver>>();
  readonly List<FireImpulseCreateEffect> effectsFireImpulseCreateEffect =
      new List<FireImpulseCreateEffect>();
  readonly List<FireImpulseDeleteEffect> effectsFireImpulseDeleteEffect =
      new List<FireImpulseDeleteEffect>();

  readonly SortedDictionary<int, List<ICounterImpulseEffectObserver>> observersForCounterImpulse =
      new SortedDictionary<int, List<ICounterImpulseEffectObserver>>();
  readonly List<CounterImpulseCreateEffect> effectsCounterImpulseCreateEffect =
      new List<CounterImpulseCreateEffect>();
  readonly List<CounterImpulseDeleteEffect> effectsCounterImpulseDeleteEffect =
      new List<CounterImpulseDeleteEffect>();

  readonly SortedDictionary<int, List<IDefendImpulseEffectObserver>> observersForDefendImpulse =
      new SortedDictionary<int, List<IDefendImpulseEffectObserver>>();
  readonly List<DefendImpulseCreateEffect> effectsDefendImpulseCreateEffect =
      new List<DefendImpulseCreateEffect>();
  readonly List<DefendImpulseDeleteEffect> effectsDefendImpulseDeleteEffect =
      new List<DefendImpulseDeleteEffect>();

  readonly SortedDictionary<int, List<IAttackImpulseEffectObserver>> observersForAttackImpulse =
      new SortedDictionary<int, List<IAttackImpulseEffectObserver>>();
  readonly List<AttackImpulseCreateEffect> effectsAttackImpulseCreateEffect =
      new List<AttackImpulseCreateEffect>();
  readonly List<AttackImpulseDeleteEffect> effectsAttackImpulseDeleteEffect =
      new List<AttackImpulseDeleteEffect>();

  readonly SortedDictionary<int, List<IPursueImpulseEffectObserver>> observersForPursueImpulse =
      new SortedDictionary<int, List<IPursueImpulseEffectObserver>>();
  readonly List<PursueImpulseCreateEffect> effectsPursueImpulseCreateEffect =
      new List<PursueImpulseCreateEffect>();
  readonly List<PursueImpulseDeleteEffect> effectsPursueImpulseDeleteEffect =
      new List<PursueImpulseDeleteEffect>();

  readonly SortedDictionary<int, List<IKillDirectiveEffectObserver>> observersForKillDirective =
      new SortedDictionary<int, List<IKillDirectiveEffectObserver>>();
  readonly List<KillDirectiveCreateEffect> effectsKillDirectiveCreateEffect =
      new List<KillDirectiveCreateEffect>();
  readonly List<KillDirectiveDeleteEffect> effectsKillDirectiveDeleteEffect =
      new List<KillDirectiveDeleteEffect>();

  readonly SortedDictionary<int, List<IAttackAICapabilityUCEffectObserver>> observersForAttackAICapabilityUC =
      new SortedDictionary<int, List<IAttackAICapabilityUCEffectObserver>>();
  readonly List<AttackAICapabilityUCCreateEffect> effectsAttackAICapabilityUCCreateEffect =
      new List<AttackAICapabilityUCCreateEffect>();
  readonly List<AttackAICapabilityUCDeleteEffect> effectsAttackAICapabilityUCDeleteEffect =
      new List<AttackAICapabilityUCDeleteEffect>();
  readonly List<AttackAICapabilityUCSetKillDirectiveEffect> effectsAttackAICapabilityUCSetKillDirectiveEffect =
      new List<AttackAICapabilityUCSetKillDirectiveEffect>();

  readonly SortedDictionary<int, List<IMoveImpulseEffectObserver>> observersForMoveImpulse =
      new SortedDictionary<int, List<IMoveImpulseEffectObserver>>();
  readonly List<MoveImpulseCreateEffect> effectsMoveImpulseCreateEffect =
      new List<MoveImpulseCreateEffect>();
  readonly List<MoveImpulseDeleteEffect> effectsMoveImpulseDeleteEffect =
      new List<MoveImpulseDeleteEffect>();

  readonly SortedDictionary<int, List<IUnitEffectObserver>> observersForUnit =
      new SortedDictionary<int, List<IUnitEffectObserver>>();
  readonly List<UnitCreateEffect> effectsUnitCreateEffect =
      new List<UnitCreateEffect>();
  readonly List<UnitDeleteEffect> effectsUnitDeleteEffect =
      new List<UnitDeleteEffect>();
  readonly List<UnitSetAliveEffect> effectsUnitSetAliveEffect =
      new List<UnitSetAliveEffect>();
  readonly List<UnitSetLifeEndTimeEffect> effectsUnitSetLifeEndTimeEffect =
      new List<UnitSetLifeEndTimeEffect>();
  readonly List<UnitSetLocationEffect> effectsUnitSetLocationEffect =
      new List<UnitSetLocationEffect>();
  readonly List<UnitSetHpEffect> effectsUnitSetHpEffect =
      new List<UnitSetHpEffect>();
  readonly List<UnitSetMpEffect> effectsUnitSetMpEffect =
      new List<UnitSetMpEffect>();
  readonly List<UnitSetNextActionTimeEffect> effectsUnitSetNextActionTimeEffect =
      new List<UnitSetNextActionTimeEffect>();

  readonly SortedDictionary<int, List<IIUnitComponentMutBunchEffectObserver>> observersForIUnitComponentMutBunch =
      new SortedDictionary<int, List<IIUnitComponentMutBunchEffectObserver>>();
  readonly List<IUnitComponentMutBunchCreateEffect> effectsIUnitComponentMutBunchCreateEffect =
      new List<IUnitComponentMutBunchCreateEffect>();
  readonly List<IUnitComponentMutBunchDeleteEffect> effectsIUnitComponentMutBunchDeleteEffect =
      new List<IUnitComponentMutBunchDeleteEffect>();

  readonly SortedDictionary<int, List<INoImpulseEffectObserver>> observersForNoImpulse =
      new SortedDictionary<int, List<INoImpulseEffectObserver>>();
  readonly List<NoImpulseCreateEffect> effectsNoImpulseCreateEffect =
      new List<NoImpulseCreateEffect>();
  readonly List<NoImpulseDeleteEffect> effectsNoImpulseDeleteEffect =
      new List<NoImpulseDeleteEffect>();

  readonly SortedDictionary<int, List<IExecutionStateEffectObserver>> observersForExecutionState =
      new SortedDictionary<int, List<IExecutionStateEffectObserver>>();
  readonly List<ExecutionStateCreateEffect> effectsExecutionStateCreateEffect =
      new List<ExecutionStateCreateEffect>();
  readonly List<ExecutionStateDeleteEffect> effectsExecutionStateDeleteEffect =
      new List<ExecutionStateDeleteEffect>();
  readonly List<ExecutionStateSetActingUnitEffect> effectsExecutionStateSetActingUnitEffect =
      new List<ExecutionStateSetActingUnitEffect>();
  readonly List<ExecutionStateSetActingUnitDidActionEffect> effectsExecutionStateSetActingUnitDidActionEffect =
      new List<ExecutionStateSetActingUnitDidActionEffect>();
  readonly List<ExecutionStateSetRemainingPreActingUnitComponentsEffect> effectsExecutionStateSetRemainingPreActingUnitComponentsEffect =
      new List<ExecutionStateSetRemainingPreActingUnitComponentsEffect>();
  readonly List<ExecutionStateSetRemainingPostActingUnitComponentsEffect> effectsExecutionStateSetRemainingPostActingUnitComponentsEffect =
      new List<ExecutionStateSetRemainingPostActingUnitComponentsEffect>();

  readonly SortedDictionary<int, List<IIPostActingUCWeakMutBunchEffectObserver>> observersForIPostActingUCWeakMutBunch =
      new SortedDictionary<int, List<IIPostActingUCWeakMutBunchEffectObserver>>();
  readonly List<IPostActingUCWeakMutBunchCreateEffect> effectsIPostActingUCWeakMutBunchCreateEffect =
      new List<IPostActingUCWeakMutBunchCreateEffect>();
  readonly List<IPostActingUCWeakMutBunchDeleteEffect> effectsIPostActingUCWeakMutBunchDeleteEffect =
      new List<IPostActingUCWeakMutBunchDeleteEffect>();

  readonly SortedDictionary<int, List<IIPreActingUCWeakMutBunchEffectObserver>> observersForIPreActingUCWeakMutBunch =
      new SortedDictionary<int, List<IIPreActingUCWeakMutBunchEffectObserver>>();
  readonly List<IPreActingUCWeakMutBunchCreateEffect> effectsIPreActingUCWeakMutBunchCreateEffect =
      new List<IPreActingUCWeakMutBunchCreateEffect>();
  readonly List<IPreActingUCWeakMutBunchDeleteEffect> effectsIPreActingUCWeakMutBunchDeleteEffect =
      new List<IPreActingUCWeakMutBunchDeleteEffect>();

  readonly SortedDictionary<int, List<IGameEffectObserver>> observersForGame =
      new SortedDictionary<int, List<IGameEffectObserver>>();
  readonly List<GameCreateEffect> effectsGameCreateEffect =
      new List<GameCreateEffect>();
  readonly List<GameDeleteEffect> effectsGameDeleteEffect =
      new List<GameDeleteEffect>();
  readonly List<GameSetPlayerEffect> effectsGameSetPlayerEffect =
      new List<GameSetPlayerEffect>();
  readonly List<GameSetLevelEffect> effectsGameSetLevelEffect =
      new List<GameSetLevelEffect>();
  readonly List<GameSetTimeEffect> effectsGameSetTimeEffect =
      new List<GameSetTimeEffect>();

  readonly SortedDictionary<int, List<IIUnitEventMutListEffectObserver>> observersForIUnitEventMutList =
      new SortedDictionary<int, List<IIUnitEventMutListEffectObserver>>();
  readonly List<IUnitEventMutListCreateEffect> effectsIUnitEventMutListCreateEffect =
      new List<IUnitEventMutListCreateEffect>();
  readonly List<IUnitEventMutListDeleteEffect> effectsIUnitEventMutListDeleteEffect =
      new List<IUnitEventMutListDeleteEffect>();
  readonly List<IUnitEventMutListAddEffect> effectsIUnitEventMutListAddEffect =
      new List<IUnitEventMutListAddEffect>();
  readonly List<IUnitEventMutListRemoveEffect> effectsIUnitEventMutListRemoveEffect =
      new List<IUnitEventMutListRemoveEffect>();

  readonly SortedDictionary<int, List<ILocationMutListEffectObserver>> observersForLocationMutList =
      new SortedDictionary<int, List<ILocationMutListEffectObserver>>();
  readonly List<LocationMutListCreateEffect> effectsLocationMutListCreateEffect =
      new List<LocationMutListCreateEffect>();
  readonly List<LocationMutListDeleteEffect> effectsLocationMutListDeleteEffect =
      new List<LocationMutListDeleteEffect>();
  readonly List<LocationMutListAddEffect> effectsLocationMutListAddEffect =
      new List<LocationMutListAddEffect>();
  readonly List<LocationMutListRemoveEffect> effectsLocationMutListRemoveEffect =
      new List<LocationMutListRemoveEffect>();

  readonly SortedDictionary<int, List<IIRequestMutListEffectObserver>> observersForIRequestMutList =
      new SortedDictionary<int, List<IIRequestMutListEffectObserver>>();
  readonly List<IRequestMutListCreateEffect> effectsIRequestMutListCreateEffect =
      new List<IRequestMutListCreateEffect>();
  readonly List<IRequestMutListDeleteEffect> effectsIRequestMutListDeleteEffect =
      new List<IRequestMutListDeleteEffect>();
  readonly List<IRequestMutListAddEffect> effectsIRequestMutListAddEffect =
      new List<IRequestMutListAddEffect>();
  readonly List<IRequestMutListRemoveEffect> effectsIRequestMutListRemoveEffect =
      new List<IRequestMutListRemoveEffect>();

  readonly SortedDictionary<int, List<ILevelMutSetEffectObserver>> observersForLevelMutSet =
      new SortedDictionary<int, List<ILevelMutSetEffectObserver>>();
  readonly List<LevelMutSetCreateEffect> effectsLevelMutSetCreateEffect =
      new List<LevelMutSetCreateEffect>();
  readonly List<LevelMutSetDeleteEffect> effectsLevelMutSetDeleteEffect =
      new List<LevelMutSetDeleteEffect>();
  readonly List<LevelMutSetAddEffect> effectsLevelMutSetAddEffect =
      new List<LevelMutSetAddEffect>();
  readonly List<LevelMutSetRemoveEffect> effectsLevelMutSetRemoveEffect =
      new List<LevelMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<ICounteringUCWeakMutSetEffectObserver>> observersForCounteringUCWeakMutSet =
      new SortedDictionary<int, List<ICounteringUCWeakMutSetEffectObserver>>();
  readonly List<CounteringUCWeakMutSetCreateEffect> effectsCounteringUCWeakMutSetCreateEffect =
      new List<CounteringUCWeakMutSetCreateEffect>();
  readonly List<CounteringUCWeakMutSetDeleteEffect> effectsCounteringUCWeakMutSetDeleteEffect =
      new List<CounteringUCWeakMutSetDeleteEffect>();
  readonly List<CounteringUCWeakMutSetAddEffect> effectsCounteringUCWeakMutSetAddEffect =
      new List<CounteringUCWeakMutSetAddEffect>();
  readonly List<CounteringUCWeakMutSetRemoveEffect> effectsCounteringUCWeakMutSetRemoveEffect =
      new List<CounteringUCWeakMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IShieldingUCWeakMutSetEffectObserver>> observersForShieldingUCWeakMutSet =
      new SortedDictionary<int, List<IShieldingUCWeakMutSetEffectObserver>>();
  readonly List<ShieldingUCWeakMutSetCreateEffect> effectsShieldingUCWeakMutSetCreateEffect =
      new List<ShieldingUCWeakMutSetCreateEffect>();
  readonly List<ShieldingUCWeakMutSetDeleteEffect> effectsShieldingUCWeakMutSetDeleteEffect =
      new List<ShieldingUCWeakMutSetDeleteEffect>();
  readonly List<ShieldingUCWeakMutSetAddEffect> effectsShieldingUCWeakMutSetAddEffect =
      new List<ShieldingUCWeakMutSetAddEffect>();
  readonly List<ShieldingUCWeakMutSetRemoveEffect> effectsShieldingUCWeakMutSetRemoveEffect =
      new List<ShieldingUCWeakMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IAttackAICapabilityUCWeakMutSetEffectObserver>> observersForAttackAICapabilityUCWeakMutSet =
      new SortedDictionary<int, List<IAttackAICapabilityUCWeakMutSetEffectObserver>>();
  readonly List<AttackAICapabilityUCWeakMutSetCreateEffect> effectsAttackAICapabilityUCWeakMutSetCreateEffect =
      new List<AttackAICapabilityUCWeakMutSetCreateEffect>();
  readonly List<AttackAICapabilityUCWeakMutSetDeleteEffect> effectsAttackAICapabilityUCWeakMutSetDeleteEffect =
      new List<AttackAICapabilityUCWeakMutSetDeleteEffect>();
  readonly List<AttackAICapabilityUCWeakMutSetAddEffect> effectsAttackAICapabilityUCWeakMutSetAddEffect =
      new List<AttackAICapabilityUCWeakMutSetAddEffect>();
  readonly List<AttackAICapabilityUCWeakMutSetRemoveEffect> effectsAttackAICapabilityUCWeakMutSetRemoveEffect =
      new List<AttackAICapabilityUCWeakMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<ITimeCloneAICapabilityUCWeakMutSetEffectObserver>> observersForTimeCloneAICapabilityUCWeakMutSet =
      new SortedDictionary<int, List<ITimeCloneAICapabilityUCWeakMutSetEffectObserver>>();
  readonly List<TimeCloneAICapabilityUCWeakMutSetCreateEffect> effectsTimeCloneAICapabilityUCWeakMutSetCreateEffect =
      new List<TimeCloneAICapabilityUCWeakMutSetCreateEffect>();
  readonly List<TimeCloneAICapabilityUCWeakMutSetDeleteEffect> effectsTimeCloneAICapabilityUCWeakMutSetDeleteEffect =
      new List<TimeCloneAICapabilityUCWeakMutSetDeleteEffect>();
  readonly List<TimeCloneAICapabilityUCWeakMutSetAddEffect> effectsTimeCloneAICapabilityUCWeakMutSetAddEffect =
      new List<TimeCloneAICapabilityUCWeakMutSetAddEffect>();
  readonly List<TimeCloneAICapabilityUCWeakMutSetRemoveEffect> effectsTimeCloneAICapabilityUCWeakMutSetRemoveEffect =
      new List<TimeCloneAICapabilityUCWeakMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IArmorMutSetEffectObserver>> observersForArmorMutSet =
      new SortedDictionary<int, List<IArmorMutSetEffectObserver>>();
  readonly List<ArmorMutSetCreateEffect> effectsArmorMutSetCreateEffect =
      new List<ArmorMutSetCreateEffect>();
  readonly List<ArmorMutSetDeleteEffect> effectsArmorMutSetDeleteEffect =
      new List<ArmorMutSetDeleteEffect>();
  readonly List<ArmorMutSetAddEffect> effectsArmorMutSetAddEffect =
      new List<ArmorMutSetAddEffect>();
  readonly List<ArmorMutSetRemoveEffect> effectsArmorMutSetRemoveEffect =
      new List<ArmorMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IInertiaRingMutSetEffectObserver>> observersForInertiaRingMutSet =
      new SortedDictionary<int, List<IInertiaRingMutSetEffectObserver>>();
  readonly List<InertiaRingMutSetCreateEffect> effectsInertiaRingMutSetCreateEffect =
      new List<InertiaRingMutSetCreateEffect>();
  readonly List<InertiaRingMutSetDeleteEffect> effectsInertiaRingMutSetDeleteEffect =
      new List<InertiaRingMutSetDeleteEffect>();
  readonly List<InertiaRingMutSetAddEffect> effectsInertiaRingMutSetAddEffect =
      new List<InertiaRingMutSetAddEffect>();
  readonly List<InertiaRingMutSetRemoveEffect> effectsInertiaRingMutSetRemoveEffect =
      new List<InertiaRingMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IGlaiveMutSetEffectObserver>> observersForGlaiveMutSet =
      new SortedDictionary<int, List<IGlaiveMutSetEffectObserver>>();
  readonly List<GlaiveMutSetCreateEffect> effectsGlaiveMutSetCreateEffect =
      new List<GlaiveMutSetCreateEffect>();
  readonly List<GlaiveMutSetDeleteEffect> effectsGlaiveMutSetDeleteEffect =
      new List<GlaiveMutSetDeleteEffect>();
  readonly List<GlaiveMutSetAddEffect> effectsGlaiveMutSetAddEffect =
      new List<GlaiveMutSetAddEffect>();
  readonly List<GlaiveMutSetRemoveEffect> effectsGlaiveMutSetRemoveEffect =
      new List<GlaiveMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IManaPotionMutSetEffectObserver>> observersForManaPotionMutSet =
      new SortedDictionary<int, List<IManaPotionMutSetEffectObserver>>();
  readonly List<ManaPotionMutSetCreateEffect> effectsManaPotionMutSetCreateEffect =
      new List<ManaPotionMutSetCreateEffect>();
  readonly List<ManaPotionMutSetDeleteEffect> effectsManaPotionMutSetDeleteEffect =
      new List<ManaPotionMutSetDeleteEffect>();
  readonly List<ManaPotionMutSetAddEffect> effectsManaPotionMutSetAddEffect =
      new List<ManaPotionMutSetAddEffect>();
  readonly List<ManaPotionMutSetRemoveEffect> effectsManaPotionMutSetRemoveEffect =
      new List<ManaPotionMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IHealthPotionMutSetEffectObserver>> observersForHealthPotionMutSet =
      new SortedDictionary<int, List<IHealthPotionMutSetEffectObserver>>();
  readonly List<HealthPotionMutSetCreateEffect> effectsHealthPotionMutSetCreateEffect =
      new List<HealthPotionMutSetCreateEffect>();
  readonly List<HealthPotionMutSetDeleteEffect> effectsHealthPotionMutSetDeleteEffect =
      new List<HealthPotionMutSetDeleteEffect>();
  readonly List<HealthPotionMutSetAddEffect> effectsHealthPotionMutSetAddEffect =
      new List<HealthPotionMutSetAddEffect>();
  readonly List<HealthPotionMutSetRemoveEffect> effectsHealthPotionMutSetRemoveEffect =
      new List<HealthPotionMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IWanderAICapabilityUCMutSetEffectObserver>> observersForWanderAICapabilityUCMutSet =
      new SortedDictionary<int, List<IWanderAICapabilityUCMutSetEffectObserver>>();
  readonly List<WanderAICapabilityUCMutSetCreateEffect> effectsWanderAICapabilityUCMutSetCreateEffect =
      new List<WanderAICapabilityUCMutSetCreateEffect>();
  readonly List<WanderAICapabilityUCMutSetDeleteEffect> effectsWanderAICapabilityUCMutSetDeleteEffect =
      new List<WanderAICapabilityUCMutSetDeleteEffect>();
  readonly List<WanderAICapabilityUCMutSetAddEffect> effectsWanderAICapabilityUCMutSetAddEffect =
      new List<WanderAICapabilityUCMutSetAddEffect>();
  readonly List<WanderAICapabilityUCMutSetRemoveEffect> effectsWanderAICapabilityUCMutSetRemoveEffect =
      new List<WanderAICapabilityUCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<ITimeCloneAICapabilityUCMutSetEffectObserver>> observersForTimeCloneAICapabilityUCMutSet =
      new SortedDictionary<int, List<ITimeCloneAICapabilityUCMutSetEffectObserver>>();
  readonly List<TimeCloneAICapabilityUCMutSetCreateEffect> effectsTimeCloneAICapabilityUCMutSetCreateEffect =
      new List<TimeCloneAICapabilityUCMutSetCreateEffect>();
  readonly List<TimeCloneAICapabilityUCMutSetDeleteEffect> effectsTimeCloneAICapabilityUCMutSetDeleteEffect =
      new List<TimeCloneAICapabilityUCMutSetDeleteEffect>();
  readonly List<TimeCloneAICapabilityUCMutSetAddEffect> effectsTimeCloneAICapabilityUCMutSetAddEffect =
      new List<TimeCloneAICapabilityUCMutSetAddEffect>();
  readonly List<TimeCloneAICapabilityUCMutSetRemoveEffect> effectsTimeCloneAICapabilityUCMutSetRemoveEffect =
      new List<TimeCloneAICapabilityUCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IAttackAICapabilityUCMutSetEffectObserver>> observersForAttackAICapabilityUCMutSet =
      new SortedDictionary<int, List<IAttackAICapabilityUCMutSetEffectObserver>>();
  readonly List<AttackAICapabilityUCMutSetCreateEffect> effectsAttackAICapabilityUCMutSetCreateEffect =
      new List<AttackAICapabilityUCMutSetCreateEffect>();
  readonly List<AttackAICapabilityUCMutSetDeleteEffect> effectsAttackAICapabilityUCMutSetDeleteEffect =
      new List<AttackAICapabilityUCMutSetDeleteEffect>();
  readonly List<AttackAICapabilityUCMutSetAddEffect> effectsAttackAICapabilityUCMutSetAddEffect =
      new List<AttackAICapabilityUCMutSetAddEffect>();
  readonly List<AttackAICapabilityUCMutSetRemoveEffect> effectsAttackAICapabilityUCMutSetRemoveEffect =
      new List<AttackAICapabilityUCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<ICounteringUCMutSetEffectObserver>> observersForCounteringUCMutSet =
      new SortedDictionary<int, List<ICounteringUCMutSetEffectObserver>>();
  readonly List<CounteringUCMutSetCreateEffect> effectsCounteringUCMutSetCreateEffect =
      new List<CounteringUCMutSetCreateEffect>();
  readonly List<CounteringUCMutSetDeleteEffect> effectsCounteringUCMutSetDeleteEffect =
      new List<CounteringUCMutSetDeleteEffect>();
  readonly List<CounteringUCMutSetAddEffect> effectsCounteringUCMutSetAddEffect =
      new List<CounteringUCMutSetAddEffect>();
  readonly List<CounteringUCMutSetRemoveEffect> effectsCounteringUCMutSetRemoveEffect =
      new List<CounteringUCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IShieldingUCMutSetEffectObserver>> observersForShieldingUCMutSet =
      new SortedDictionary<int, List<IShieldingUCMutSetEffectObserver>>();
  readonly List<ShieldingUCMutSetCreateEffect> effectsShieldingUCMutSetCreateEffect =
      new List<ShieldingUCMutSetCreateEffect>();
  readonly List<ShieldingUCMutSetDeleteEffect> effectsShieldingUCMutSetDeleteEffect =
      new List<ShieldingUCMutSetDeleteEffect>();
  readonly List<ShieldingUCMutSetAddEffect> effectsShieldingUCMutSetAddEffect =
      new List<ShieldingUCMutSetAddEffect>();
  readonly List<ShieldingUCMutSetRemoveEffect> effectsShieldingUCMutSetRemoveEffect =
      new List<ShieldingUCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IBideAICapabilityUCMutSetEffectObserver>> observersForBideAICapabilityUCMutSet =
      new SortedDictionary<int, List<IBideAICapabilityUCMutSetEffectObserver>>();
  readonly List<BideAICapabilityUCMutSetCreateEffect> effectsBideAICapabilityUCMutSetCreateEffect =
      new List<BideAICapabilityUCMutSetCreateEffect>();
  readonly List<BideAICapabilityUCMutSetDeleteEffect> effectsBideAICapabilityUCMutSetDeleteEffect =
      new List<BideAICapabilityUCMutSetDeleteEffect>();
  readonly List<BideAICapabilityUCMutSetAddEffect> effectsBideAICapabilityUCMutSetAddEffect =
      new List<BideAICapabilityUCMutSetAddEffect>();
  readonly List<BideAICapabilityUCMutSetRemoveEffect> effectsBideAICapabilityUCMutSetRemoveEffect =
      new List<BideAICapabilityUCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<ITimeAnchorTTCMutSetEffectObserver>> observersForTimeAnchorTTCMutSet =
      new SortedDictionary<int, List<ITimeAnchorTTCMutSetEffectObserver>>();
  readonly List<TimeAnchorTTCMutSetCreateEffect> effectsTimeAnchorTTCMutSetCreateEffect =
      new List<TimeAnchorTTCMutSetCreateEffect>();
  readonly List<TimeAnchorTTCMutSetDeleteEffect> effectsTimeAnchorTTCMutSetDeleteEffect =
      new List<TimeAnchorTTCMutSetDeleteEffect>();
  readonly List<TimeAnchorTTCMutSetAddEffect> effectsTimeAnchorTTCMutSetAddEffect =
      new List<TimeAnchorTTCMutSetAddEffect>();
  readonly List<TimeAnchorTTCMutSetRemoveEffect> effectsTimeAnchorTTCMutSetRemoveEffect =
      new List<TimeAnchorTTCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IStaircaseTTCMutSetEffectObserver>> observersForStaircaseTTCMutSet =
      new SortedDictionary<int, List<IStaircaseTTCMutSetEffectObserver>>();
  readonly List<StaircaseTTCMutSetCreateEffect> effectsStaircaseTTCMutSetCreateEffect =
      new List<StaircaseTTCMutSetCreateEffect>();
  readonly List<StaircaseTTCMutSetDeleteEffect> effectsStaircaseTTCMutSetDeleteEffect =
      new List<StaircaseTTCMutSetDeleteEffect>();
  readonly List<StaircaseTTCMutSetAddEffect> effectsStaircaseTTCMutSetAddEffect =
      new List<StaircaseTTCMutSetAddEffect>();
  readonly List<StaircaseTTCMutSetRemoveEffect> effectsStaircaseTTCMutSetRemoveEffect =
      new List<StaircaseTTCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IWallTTCMutSetEffectObserver>> observersForWallTTCMutSet =
      new SortedDictionary<int, List<IWallTTCMutSetEffectObserver>>();
  readonly List<WallTTCMutSetCreateEffect> effectsWallTTCMutSetCreateEffect =
      new List<WallTTCMutSetCreateEffect>();
  readonly List<WallTTCMutSetDeleteEffect> effectsWallTTCMutSetDeleteEffect =
      new List<WallTTCMutSetDeleteEffect>();
  readonly List<WallTTCMutSetAddEffect> effectsWallTTCMutSetAddEffect =
      new List<WallTTCMutSetAddEffect>();
  readonly List<WallTTCMutSetRemoveEffect> effectsWallTTCMutSetRemoveEffect =
      new List<WallTTCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IBloodTTCMutSetEffectObserver>> observersForBloodTTCMutSet =
      new SortedDictionary<int, List<IBloodTTCMutSetEffectObserver>>();
  readonly List<BloodTTCMutSetCreateEffect> effectsBloodTTCMutSetCreateEffect =
      new List<BloodTTCMutSetCreateEffect>();
  readonly List<BloodTTCMutSetDeleteEffect> effectsBloodTTCMutSetDeleteEffect =
      new List<BloodTTCMutSetDeleteEffect>();
  readonly List<BloodTTCMutSetAddEffect> effectsBloodTTCMutSetAddEffect =
      new List<BloodTTCMutSetAddEffect>();
  readonly List<BloodTTCMutSetRemoveEffect> effectsBloodTTCMutSetRemoveEffect =
      new List<BloodTTCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IRocksTTCMutSetEffectObserver>> observersForRocksTTCMutSet =
      new SortedDictionary<int, List<IRocksTTCMutSetEffectObserver>>();
  readonly List<RocksTTCMutSetCreateEffect> effectsRocksTTCMutSetCreateEffect =
      new List<RocksTTCMutSetCreateEffect>();
  readonly List<RocksTTCMutSetDeleteEffect> effectsRocksTTCMutSetDeleteEffect =
      new List<RocksTTCMutSetDeleteEffect>();
  readonly List<RocksTTCMutSetAddEffect> effectsRocksTTCMutSetAddEffect =
      new List<RocksTTCMutSetAddEffect>();
  readonly List<RocksTTCMutSetRemoveEffect> effectsRocksTTCMutSetRemoveEffect =
      new List<RocksTTCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IDownstairsTTCMutSetEffectObserver>> observersForDownstairsTTCMutSet =
      new SortedDictionary<int, List<IDownstairsTTCMutSetEffectObserver>>();
  readonly List<DownstairsTTCMutSetCreateEffect> effectsDownstairsTTCMutSetCreateEffect =
      new List<DownstairsTTCMutSetCreateEffect>();
  readonly List<DownstairsTTCMutSetDeleteEffect> effectsDownstairsTTCMutSetDeleteEffect =
      new List<DownstairsTTCMutSetDeleteEffect>();
  readonly List<DownstairsTTCMutSetAddEffect> effectsDownstairsTTCMutSetAddEffect =
      new List<DownstairsTTCMutSetAddEffect>();
  readonly List<DownstairsTTCMutSetRemoveEffect> effectsDownstairsTTCMutSetRemoveEffect =
      new List<DownstairsTTCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IUpstairsTTCMutSetEffectObserver>> observersForUpstairsTTCMutSet =
      new SortedDictionary<int, List<IUpstairsTTCMutSetEffectObserver>>();
  readonly List<UpstairsTTCMutSetCreateEffect> effectsUpstairsTTCMutSetCreateEffect =
      new List<UpstairsTTCMutSetCreateEffect>();
  readonly List<UpstairsTTCMutSetDeleteEffect> effectsUpstairsTTCMutSetDeleteEffect =
      new List<UpstairsTTCMutSetDeleteEffect>();
  readonly List<UpstairsTTCMutSetAddEffect> effectsUpstairsTTCMutSetAddEffect =
      new List<UpstairsTTCMutSetAddEffect>();
  readonly List<UpstairsTTCMutSetRemoveEffect> effectsUpstairsTTCMutSetRemoveEffect =
      new List<UpstairsTTCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<ICaveTTCMutSetEffectObserver>> observersForCaveTTCMutSet =
      new SortedDictionary<int, List<ICaveTTCMutSetEffectObserver>>();
  readonly List<CaveTTCMutSetCreateEffect> effectsCaveTTCMutSetCreateEffect =
      new List<CaveTTCMutSetCreateEffect>();
  readonly List<CaveTTCMutSetDeleteEffect> effectsCaveTTCMutSetDeleteEffect =
      new List<CaveTTCMutSetDeleteEffect>();
  readonly List<CaveTTCMutSetAddEffect> effectsCaveTTCMutSetAddEffect =
      new List<CaveTTCMutSetAddEffect>();
  readonly List<CaveTTCMutSetRemoveEffect> effectsCaveTTCMutSetRemoveEffect =
      new List<CaveTTCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IFallsTTCMutSetEffectObserver>> observersForFallsTTCMutSet =
      new SortedDictionary<int, List<IFallsTTCMutSetEffectObserver>>();
  readonly List<FallsTTCMutSetCreateEffect> effectsFallsTTCMutSetCreateEffect =
      new List<FallsTTCMutSetCreateEffect>();
  readonly List<FallsTTCMutSetDeleteEffect> effectsFallsTTCMutSetDeleteEffect =
      new List<FallsTTCMutSetDeleteEffect>();
  readonly List<FallsTTCMutSetAddEffect> effectsFallsTTCMutSetAddEffect =
      new List<FallsTTCMutSetAddEffect>();
  readonly List<FallsTTCMutSetRemoveEffect> effectsFallsTTCMutSetRemoveEffect =
      new List<FallsTTCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IMagmaTTCMutSetEffectObserver>> observersForMagmaTTCMutSet =
      new SortedDictionary<int, List<IMagmaTTCMutSetEffectObserver>>();
  readonly List<MagmaTTCMutSetCreateEffect> effectsMagmaTTCMutSetCreateEffect =
      new List<MagmaTTCMutSetCreateEffect>();
  readonly List<MagmaTTCMutSetDeleteEffect> effectsMagmaTTCMutSetDeleteEffect =
      new List<MagmaTTCMutSetDeleteEffect>();
  readonly List<MagmaTTCMutSetAddEffect> effectsMagmaTTCMutSetAddEffect =
      new List<MagmaTTCMutSetAddEffect>();
  readonly List<MagmaTTCMutSetRemoveEffect> effectsMagmaTTCMutSetRemoveEffect =
      new List<MagmaTTCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<ICliffTTCMutSetEffectObserver>> observersForCliffTTCMutSet =
      new SortedDictionary<int, List<ICliffTTCMutSetEffectObserver>>();
  readonly List<CliffTTCMutSetCreateEffect> effectsCliffTTCMutSetCreateEffect =
      new List<CliffTTCMutSetCreateEffect>();
  readonly List<CliffTTCMutSetDeleteEffect> effectsCliffTTCMutSetDeleteEffect =
      new List<CliffTTCMutSetDeleteEffect>();
  readonly List<CliffTTCMutSetAddEffect> effectsCliffTTCMutSetAddEffect =
      new List<CliffTTCMutSetAddEffect>();
  readonly List<CliffTTCMutSetRemoveEffect> effectsCliffTTCMutSetRemoveEffect =
      new List<CliffTTCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IRavaNestTTCMutSetEffectObserver>> observersForRavaNestTTCMutSet =
      new SortedDictionary<int, List<IRavaNestTTCMutSetEffectObserver>>();
  readonly List<RavaNestTTCMutSetCreateEffect> effectsRavaNestTTCMutSetCreateEffect =
      new List<RavaNestTTCMutSetCreateEffect>();
  readonly List<RavaNestTTCMutSetDeleteEffect> effectsRavaNestTTCMutSetDeleteEffect =
      new List<RavaNestTTCMutSetDeleteEffect>();
  readonly List<RavaNestTTCMutSetAddEffect> effectsRavaNestTTCMutSetAddEffect =
      new List<RavaNestTTCMutSetAddEffect>();
  readonly List<RavaNestTTCMutSetRemoveEffect> effectsRavaNestTTCMutSetRemoveEffect =
      new List<RavaNestTTCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<ICliffLandingTTCMutSetEffectObserver>> observersForCliffLandingTTCMutSet =
      new SortedDictionary<int, List<ICliffLandingTTCMutSetEffectObserver>>();
  readonly List<CliffLandingTTCMutSetCreateEffect> effectsCliffLandingTTCMutSetCreateEffect =
      new List<CliffLandingTTCMutSetCreateEffect>();
  readonly List<CliffLandingTTCMutSetDeleteEffect> effectsCliffLandingTTCMutSetDeleteEffect =
      new List<CliffLandingTTCMutSetDeleteEffect>();
  readonly List<CliffLandingTTCMutSetAddEffect> effectsCliffLandingTTCMutSetAddEffect =
      new List<CliffLandingTTCMutSetAddEffect>();
  readonly List<CliffLandingTTCMutSetRemoveEffect> effectsCliffLandingTTCMutSetRemoveEffect =
      new List<CliffLandingTTCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IStoneTTCMutSetEffectObserver>> observersForStoneTTCMutSet =
      new SortedDictionary<int, List<IStoneTTCMutSetEffectObserver>>();
  readonly List<StoneTTCMutSetCreateEffect> effectsStoneTTCMutSetCreateEffect =
      new List<StoneTTCMutSetCreateEffect>();
  readonly List<StoneTTCMutSetDeleteEffect> effectsStoneTTCMutSetDeleteEffect =
      new List<StoneTTCMutSetDeleteEffect>();
  readonly List<StoneTTCMutSetAddEffect> effectsStoneTTCMutSetAddEffect =
      new List<StoneTTCMutSetAddEffect>();
  readonly List<StoneTTCMutSetRemoveEffect> effectsStoneTTCMutSetRemoveEffect =
      new List<StoneTTCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IGrassTTCMutSetEffectObserver>> observersForGrassTTCMutSet =
      new SortedDictionary<int, List<IGrassTTCMutSetEffectObserver>>();
  readonly List<GrassTTCMutSetCreateEffect> effectsGrassTTCMutSetCreateEffect =
      new List<GrassTTCMutSetCreateEffect>();
  readonly List<GrassTTCMutSetDeleteEffect> effectsGrassTTCMutSetDeleteEffect =
      new List<GrassTTCMutSetDeleteEffect>();
  readonly List<GrassTTCMutSetAddEffect> effectsGrassTTCMutSetAddEffect =
      new List<GrassTTCMutSetAddEffect>();
  readonly List<GrassTTCMutSetRemoveEffect> effectsGrassTTCMutSetRemoveEffect =
      new List<GrassTTCMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<IUnitMutSetEffectObserver>> observersForUnitMutSet =
      new SortedDictionary<int, List<IUnitMutSetEffectObserver>>();
  readonly List<UnitMutSetCreateEffect> effectsUnitMutSetCreateEffect =
      new List<UnitMutSetCreateEffect>();
  readonly List<UnitMutSetDeleteEffect> effectsUnitMutSetDeleteEffect =
      new List<UnitMutSetDeleteEffect>();
  readonly List<UnitMutSetAddEffect> effectsUnitMutSetAddEffect =
      new List<UnitMutSetAddEffect>();
  readonly List<UnitMutSetRemoveEffect> effectsUnitMutSetRemoveEffect =
      new List<UnitMutSetRemoveEffect>();

  readonly SortedDictionary<int, List<ITerrainTileByLocationMutMapEffectObserver>> observersForTerrainTileByLocationMutMap =
      new SortedDictionary<int, List<ITerrainTileByLocationMutMapEffectObserver>>();
  readonly List<TerrainTileByLocationMutMapCreateEffect> effectsTerrainTileByLocationMutMapCreateEffect =
      new List<TerrainTileByLocationMutMapCreateEffect>();
  readonly List<TerrainTileByLocationMutMapDeleteEffect> effectsTerrainTileByLocationMutMapDeleteEffect =
      new List<TerrainTileByLocationMutMapDeleteEffect>();
  readonly List<TerrainTileByLocationMutMapAddEffect> effectsTerrainTileByLocationMutMapAddEffect =
      new List<TerrainTileByLocationMutMapAddEffect>();
  readonly List<TerrainTileByLocationMutMapRemoveEffect> effectsTerrainTileByLocationMutMapRemoveEffect =
      new List<TerrainTileByLocationMutMapRemoveEffect>();

  public Root(ILogger logger) {
    this.logger = logger;
    int initialVersion = 1;
    int initialNextId = 1;
    int initialHash = VERSION_HASH_MULTIPLIER * initialVersion + NEXT_ID_HASH_MULTIPLIER * initialNextId;
    rootIncarnation = new RootIncarnation(initialVersion, initialNextId, initialHash);
    this.locked = true;
  }

  public Root(ILogger logger, RootIncarnation rootIncarnation) {
    this.logger = logger;
    this.rootIncarnation = rootIncarnation;
    this.locked = false;
    this.Snapshot();
    this.locked = true;
  }

  public int version { get { return rootIncarnation.version; } }

  public RootIncarnation Snapshot() {
    CheckUnlocked();
    RootIncarnation oldIncarnation = rootIncarnation;
    int newHash = oldIncarnation.hash;
    int newVersion = oldIncarnation.version + 1;
    rootIncarnation =
        new RootIncarnation(
            newVersion, oldIncarnation.nextId, newHash, oldIncarnation);
    return oldIncarnation;
  }

  public delegate T ITransaction<T>();

  public T Transact<T>(ITransaction<T> transaction) {
    var stopwatch = new System.Diagnostics.Stopwatch();
    stopwatch.Start();

    if (!locked) {
      throw new Exception("Can't unlock, not locked!");
    }
    locked = false;
    // var rollbackPoint = Snapshot();
    try {
      return transaction();
    } catch (Exception e) {
      // logger.Error("Rolling back because of error: " + e.Message + "\n" + e.StackTrace);
      // Revert(rollbackPoint);
      logger.Error("Encountered error in transaction: " + e.Message + "\n" + e.StackTrace);
      throw;
    } finally {
      if (locked) {
        logger.Error("Can't lock, already locked!");
        Environment.Exit(1);
      }
      locked = true;
      // CheckForViolations();

      stopwatch.Stop();
      var calculationDuration = stopwatch.Elapsed.TotalMilliseconds;

      stopwatch = new System.Diagnostics.Stopwatch();
      stopwatch.Start();
      FlushEvents();
      stopwatch.Stop();
      var flushEventsDuration = stopwatch.Elapsed.TotalMilliseconds;

      logger.Info("Transaction run time " + calculationDuration + ", observers run time " + flushEventsDuration);
    }
  }

  public void CheckUnlocked() {
    if (locked) {
      throw new Exception("Can't proceed, superstructure is locked!");
    }
  }

  private int NewId() {
    this.UpdateHashOnNextIdChange(rootIncarnation.nextId, rootIncarnation.nextId + 1);
    return rootIncarnation.nextId++;
  }

  private void UpdateHashOnNextIdChange(int oldNextId, int newNextId) {
    int oldIdAndVersionHashContribution =
        VERSION_HASH_MULTIPLIER * rootIncarnation.version +
        NEXT_ID_HASH_MULTIPLIER * oldNextId;
    int newIdAndVersionHashContribution =
        VERSION_HASH_MULTIPLIER * rootIncarnation.version +
        NEXT_ID_HASH_MULTIPLIER * newNextId;
    rootIncarnation.hash =
        rootIncarnation.hash -
        oldIdAndVersionHashContribution +
        newIdAndVersionHashContribution;
  }

  private int RecalculateEntireHash() {
    int result =
        VERSION_HASH_MULTIPLIER * rootIncarnation.version +
        NEXT_ID_HASH_MULTIPLIER * rootIncarnation.nextId;

    foreach (var entry in this.rootIncarnation.incarnationsSquareCaveLevelController) {
      result += GetSquareCaveLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRidgeLevelController) {
      result += GetRidgeLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGauntletLevelController) {
      result += GetGauntletLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsPreGauntletLevelController) {
      result += GetPreGauntletLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRavashrikeLevelController) {
      result += GetRavashrikeLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsPentagonalCaveLevelController) {
      result += GetPentagonalCaveLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCliffLevelController) {
      result += GetCliffLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLevel) {
      result += GetLevelHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTimeAnchorTTC) {
      result += GetTimeAnchorTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTerrainTile) {
      result += GetTerrainTileHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsITerrainTileComponentMutBunch) {
      result += GetITerrainTileComponentMutBunchHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTerrain) {
      result += GetTerrainHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsStaircaseTTC) {
      result += GetStaircaseTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWallTTC) {
      result += GetWallTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBloodTTC) {
      result += GetBloodTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRocksTTC) {
      result += GetRocksTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDownstairsTTC) {
      result += GetDownstairsTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsUpstairsTTC) {
      result += GetUpstairsTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCaveTTC) {
      result += GetCaveTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFallsTTC) {
      result += GetFallsTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMagmaTTC) {
      result += GetMagmaTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCliffTTC) {
      result += GetCliffTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRavaNestTTC) {
      result += GetRavaNestTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCliffLandingTTC) {
      result += GetCliffLandingTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsStoneTTC) {
      result += GetStoneTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGrassTTC) {
      result += GetGrassTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsManaPotion) {
      result += GetManaPotionHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsHealthPotion) {
      result += GetHealthPotionHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsInertiaRing) {
      result += GetInertiaRingHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGlaive) {
      result += GetGlaiveHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsArmor) {
      result += GetArmorHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRand) {
      result += GetRandHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWanderAICapabilityUC) {
      result += GetWanderAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCounteringUC) {
      result += GetCounteringUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsShieldingUC) {
      result += GetShieldingUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsEvaporateImpulse) {
      result += GetEvaporateImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTimeCloneAICapabilityUC) {
      result += GetTimeCloneAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsUnleashBideImpulse) {
      result += GetUnleashBideImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsContinueBidingImpulse) {
      result += GetContinueBidingImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsStartBidingImpulse) {
      result += GetStartBidingImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBideAICapabilityUC) {
      result += GetBideAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFireImpulse) {
      result += GetFireImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCounterImpulse) {
      result += GetCounterImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDefendImpulse) {
      result += GetDefendImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsAttackImpulse) {
      result += GetAttackImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsPursueImpulse) {
      result += GetPursueImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKillDirective) {
      result += GetKillDirectiveHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsAttackAICapabilityUC) {
      result += GetAttackAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMoveImpulse) {
      result += GetMoveImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsUnit) {
      result += GetUnitHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIUnitComponentMutBunch) {
      result += GetIUnitComponentMutBunchHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsNoImpulse) {
      result += GetNoImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsExecutionState) {
      result += GetExecutionStateHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIPostActingUCWeakMutBunch) {
      result += GetIPostActingUCWeakMutBunchHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIPreActingUCWeakMutBunch) {
      result += GetIPreActingUCWeakMutBunchHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGame) {
      result += GetGameHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIUnitEventMutList) {
      result += GetIUnitEventMutListHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLocationMutList) {
      result += GetLocationMutListHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIRequestMutList) {
      result += GetIRequestMutListHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLevelMutSet) {
      result += GetLevelMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCounteringUCWeakMutSet) {
      result += GetCounteringUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsShieldingUCWeakMutSet) {
      result += GetShieldingUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet) {
      result += GetAttackAICapabilityUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet) {
      result += GetTimeCloneAICapabilityUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsArmorMutSet) {
      result += GetArmorMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsInertiaRingMutSet) {
      result += GetInertiaRingMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGlaiveMutSet) {
      result += GetGlaiveMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsManaPotionMutSet) {
      result += GetManaPotionMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsHealthPotionMutSet) {
      result += GetHealthPotionMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWanderAICapabilityUCMutSet) {
      result += GetWanderAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet) {
      result += GetTimeCloneAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsAttackAICapabilityUCMutSet) {
      result += GetAttackAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCounteringUCMutSet) {
      result += GetCounteringUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsShieldingUCMutSet) {
      result += GetShieldingUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBideAICapabilityUCMutSet) {
      result += GetBideAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTimeAnchorTTCMutSet) {
      result += GetTimeAnchorTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsStaircaseTTCMutSet) {
      result += GetStaircaseTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWallTTCMutSet) {
      result += GetWallTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBloodTTCMutSet) {
      result += GetBloodTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRocksTTCMutSet) {
      result += GetRocksTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDownstairsTTCMutSet) {
      result += GetDownstairsTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsUpstairsTTCMutSet) {
      result += GetUpstairsTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCaveTTCMutSet) {
      result += GetCaveTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFallsTTCMutSet) {
      result += GetFallsTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMagmaTTCMutSet) {
      result += GetMagmaTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCliffTTCMutSet) {
      result += GetCliffTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRavaNestTTCMutSet) {
      result += GetRavaNestTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCliffLandingTTCMutSet) {
      result += GetCliffLandingTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsStoneTTCMutSet) {
      result += GetStoneTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGrassTTCMutSet) {
      result += GetGrassTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsUnitMutSet) {
      result += GetUnitMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTerrainTileByLocationMutMap) {
      result += GetTerrainTileByLocationMutMapHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    return result;
  }

  public void CheckForViolations() {
    List<string> violations = new List<string>();

    foreach (var obj in this.AllSquareCaveLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRidgeLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGauntletLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllPreGauntletLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRavashrikeLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllPentagonalCaveLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCliffLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLevel()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTimeAnchorTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTerrainTile()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllITerrainTileComponentMutBunch()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTerrain()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllStaircaseTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWallTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBloodTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRocksTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDownstairsTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllUpstairsTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCaveTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFallsTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMagmaTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCliffTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRavaNestTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCliffLandingTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllStoneTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGrassTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllManaPotion()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllHealthPotion()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllInertiaRing()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGlaive()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllArmor()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRand()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWanderAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCounteringUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllShieldingUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllEvaporateImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTimeCloneAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllUnleashBideImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllContinueBidingImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllStartBidingImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBideAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFireImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCounterImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDefendImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllAttackImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllPursueImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKillDirective()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllAttackAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMoveImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllUnit()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIUnitComponentMutBunch()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllNoImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllExecutionState()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIPostActingUCWeakMutBunch()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIPreActingUCWeakMutBunch()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGame()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIUnitEventMutList()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLocationMutList()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIRequestMutList()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLevelMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCounteringUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllShieldingUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllAttackAICapabilityUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTimeCloneAICapabilityUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllArmorMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllInertiaRingMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGlaiveMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllManaPotionMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllHealthPotionMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWanderAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTimeCloneAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllAttackAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCounteringUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllShieldingUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBideAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTimeAnchorTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllStaircaseTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWallTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBloodTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRocksTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDownstairsTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllUpstairsTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCaveTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFallsTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMagmaTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCliffTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRavaNestTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCliffLandingTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllStoneTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGrassTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllUnitMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTerrainTileByLocationMutMap()) {
      obj.CheckForNullViolations(violations);
    }

    SortedSet<int> reachableIds = new SortedSet<int>();
    foreach (var rootStruct in this.AllGame()) {
      rootStruct.FindReachableObjects(reachableIds);
    }
    foreach (var obj in this.AllSquareCaveLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRidgeLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGauntletLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllPreGauntletLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRavashrikeLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllPentagonalCaveLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCliffLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLevel()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTimeAnchorTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTerrainTile()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllITerrainTileComponentMutBunch()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTerrain()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllStaircaseTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWallTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBloodTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRocksTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDownstairsTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllUpstairsTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCaveTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFallsTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMagmaTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCliffTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRavaNestTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCliffLandingTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllStoneTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGrassTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllManaPotion()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllHealthPotion()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllInertiaRing()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGlaive()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllArmor()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRand()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWanderAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCounteringUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllShieldingUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllEvaporateImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTimeCloneAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllUnleashBideImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllContinueBidingImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllStartBidingImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBideAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFireImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCounterImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDefendImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllAttackImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllPursueImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKillDirective()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllAttackAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMoveImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllUnit()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIUnitComponentMutBunch()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllNoImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllExecutionState()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIPostActingUCWeakMutBunch()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIPreActingUCWeakMutBunch()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGame()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIUnitEventMutList()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLocationMutList()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIRequestMutList()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLevelMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCounteringUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllShieldingUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllAttackAICapabilityUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTimeCloneAICapabilityUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllArmorMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllInertiaRingMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGlaiveMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllManaPotionMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllHealthPotionMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWanderAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTimeCloneAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllAttackAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCounteringUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllShieldingUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBideAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTimeAnchorTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllStaircaseTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWallTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBloodTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRocksTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDownstairsTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllUpstairsTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCaveTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFallsTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMagmaTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCliffTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRavaNestTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCliffLandingTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllStoneTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGrassTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllUnitMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTerrainTileByLocationMutMap()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }

    if (violations.Count > 0) {
      string message = "Found violations!\n";
      foreach (var violation in violations) {
        message += violation + "\n";
      }
      throw new Exception(message);
    }
  }

  public void FlushEvents() {



    var copyOfObserversForSquareCaveLevelController =
        new SortedDictionary<int, List<ISquareCaveLevelControllerEffectObserver>>();
    foreach (var entry in observersForSquareCaveLevelController) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForSquareCaveLevelController.Add(
          objectId,
          new List<ISquareCaveLevelControllerEffectObserver>(
              observers));
    }

    var copyOfObserversForRidgeLevelController =
        new SortedDictionary<int, List<IRidgeLevelControllerEffectObserver>>();
    foreach (var entry in observersForRidgeLevelController) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForRidgeLevelController.Add(
          objectId,
          new List<IRidgeLevelControllerEffectObserver>(
              observers));
    }

    var copyOfObserversForGauntletLevelController =
        new SortedDictionary<int, List<IGauntletLevelControllerEffectObserver>>();
    foreach (var entry in observersForGauntletLevelController) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForGauntletLevelController.Add(
          objectId,
          new List<IGauntletLevelControllerEffectObserver>(
              observers));
    }

    var copyOfObserversForPreGauntletLevelController =
        new SortedDictionary<int, List<IPreGauntletLevelControllerEffectObserver>>();
    foreach (var entry in observersForPreGauntletLevelController) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForPreGauntletLevelController.Add(
          objectId,
          new List<IPreGauntletLevelControllerEffectObserver>(
              observers));
    }

    var copyOfObserversForRavashrikeLevelController =
        new SortedDictionary<int, List<IRavashrikeLevelControllerEffectObserver>>();
    foreach (var entry in observersForRavashrikeLevelController) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForRavashrikeLevelController.Add(
          objectId,
          new List<IRavashrikeLevelControllerEffectObserver>(
              observers));
    }

    var copyOfObserversForPentagonalCaveLevelController =
        new SortedDictionary<int, List<IPentagonalCaveLevelControllerEffectObserver>>();
    foreach (var entry in observersForPentagonalCaveLevelController) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForPentagonalCaveLevelController.Add(
          objectId,
          new List<IPentagonalCaveLevelControllerEffectObserver>(
              observers));
    }

    var copyOfObserversForCliffLevelController =
        new SortedDictionary<int, List<ICliffLevelControllerEffectObserver>>();
    foreach (var entry in observersForCliffLevelController) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForCliffLevelController.Add(
          objectId,
          new List<ICliffLevelControllerEffectObserver>(
              observers));
    }

    var copyOfObserversForLevel =
        new SortedDictionary<int, List<ILevelEffectObserver>>();
    foreach (var entry in observersForLevel) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForLevel.Add(
          objectId,
          new List<ILevelEffectObserver>(
              observers));
    }

    var copyOfObserversForTimeAnchorTTC =
        new SortedDictionary<int, List<ITimeAnchorTTCEffectObserver>>();
    foreach (var entry in observersForTimeAnchorTTC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForTimeAnchorTTC.Add(
          objectId,
          new List<ITimeAnchorTTCEffectObserver>(
              observers));
    }

    var copyOfObserversForTerrainTile =
        new SortedDictionary<int, List<ITerrainTileEffectObserver>>();
    foreach (var entry in observersForTerrainTile) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForTerrainTile.Add(
          objectId,
          new List<ITerrainTileEffectObserver>(
              observers));
    }

    var copyOfObserversForITerrainTileComponentMutBunch =
        new SortedDictionary<int, List<IITerrainTileComponentMutBunchEffectObserver>>();
    foreach (var entry in observersForITerrainTileComponentMutBunch) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForITerrainTileComponentMutBunch.Add(
          objectId,
          new List<IITerrainTileComponentMutBunchEffectObserver>(
              observers));
    }

    var copyOfObserversForTerrain =
        new SortedDictionary<int, List<ITerrainEffectObserver>>();
    foreach (var entry in observersForTerrain) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForTerrain.Add(
          objectId,
          new List<ITerrainEffectObserver>(
              observers));
    }

    var copyOfObserversForStaircaseTTC =
        new SortedDictionary<int, List<IStaircaseTTCEffectObserver>>();
    foreach (var entry in observersForStaircaseTTC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForStaircaseTTC.Add(
          objectId,
          new List<IStaircaseTTCEffectObserver>(
              observers));
    }

    var copyOfObserversForWallTTC =
        new SortedDictionary<int, List<IWallTTCEffectObserver>>();
    foreach (var entry in observersForWallTTC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForWallTTC.Add(
          objectId,
          new List<IWallTTCEffectObserver>(
              observers));
    }

    var copyOfObserversForBloodTTC =
        new SortedDictionary<int, List<IBloodTTCEffectObserver>>();
    foreach (var entry in observersForBloodTTC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForBloodTTC.Add(
          objectId,
          new List<IBloodTTCEffectObserver>(
              observers));
    }

    var copyOfObserversForRocksTTC =
        new SortedDictionary<int, List<IRocksTTCEffectObserver>>();
    foreach (var entry in observersForRocksTTC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForRocksTTC.Add(
          objectId,
          new List<IRocksTTCEffectObserver>(
              observers));
    }

    var copyOfObserversForDownstairsTTC =
        new SortedDictionary<int, List<IDownstairsTTCEffectObserver>>();
    foreach (var entry in observersForDownstairsTTC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForDownstairsTTC.Add(
          objectId,
          new List<IDownstairsTTCEffectObserver>(
              observers));
    }

    var copyOfObserversForUpstairsTTC =
        new SortedDictionary<int, List<IUpstairsTTCEffectObserver>>();
    foreach (var entry in observersForUpstairsTTC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForUpstairsTTC.Add(
          objectId,
          new List<IUpstairsTTCEffectObserver>(
              observers));
    }

    var copyOfObserversForCaveTTC =
        new SortedDictionary<int, List<ICaveTTCEffectObserver>>();
    foreach (var entry in observersForCaveTTC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForCaveTTC.Add(
          objectId,
          new List<ICaveTTCEffectObserver>(
              observers));
    }

    var copyOfObserversForFallsTTC =
        new SortedDictionary<int, List<IFallsTTCEffectObserver>>();
    foreach (var entry in observersForFallsTTC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForFallsTTC.Add(
          objectId,
          new List<IFallsTTCEffectObserver>(
              observers));
    }

    var copyOfObserversForMagmaTTC =
        new SortedDictionary<int, List<IMagmaTTCEffectObserver>>();
    foreach (var entry in observersForMagmaTTC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForMagmaTTC.Add(
          objectId,
          new List<IMagmaTTCEffectObserver>(
              observers));
    }

    var copyOfObserversForCliffTTC =
        new SortedDictionary<int, List<ICliffTTCEffectObserver>>();
    foreach (var entry in observersForCliffTTC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForCliffTTC.Add(
          objectId,
          new List<ICliffTTCEffectObserver>(
              observers));
    }

    var copyOfObserversForRavaNestTTC =
        new SortedDictionary<int, List<IRavaNestTTCEffectObserver>>();
    foreach (var entry in observersForRavaNestTTC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForRavaNestTTC.Add(
          objectId,
          new List<IRavaNestTTCEffectObserver>(
              observers));
    }

    var copyOfObserversForCliffLandingTTC =
        new SortedDictionary<int, List<ICliffLandingTTCEffectObserver>>();
    foreach (var entry in observersForCliffLandingTTC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForCliffLandingTTC.Add(
          objectId,
          new List<ICliffLandingTTCEffectObserver>(
              observers));
    }

    var copyOfObserversForStoneTTC =
        new SortedDictionary<int, List<IStoneTTCEffectObserver>>();
    foreach (var entry in observersForStoneTTC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForStoneTTC.Add(
          objectId,
          new List<IStoneTTCEffectObserver>(
              observers));
    }

    var copyOfObserversForGrassTTC =
        new SortedDictionary<int, List<IGrassTTCEffectObserver>>();
    foreach (var entry in observersForGrassTTC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForGrassTTC.Add(
          objectId,
          new List<IGrassTTCEffectObserver>(
              observers));
    }

    var copyOfObserversForManaPotion =
        new SortedDictionary<int, List<IManaPotionEffectObserver>>();
    foreach (var entry in observersForManaPotion) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForManaPotion.Add(
          objectId,
          new List<IManaPotionEffectObserver>(
              observers));
    }

    var copyOfObserversForHealthPotion =
        new SortedDictionary<int, List<IHealthPotionEffectObserver>>();
    foreach (var entry in observersForHealthPotion) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForHealthPotion.Add(
          objectId,
          new List<IHealthPotionEffectObserver>(
              observers));
    }

    var copyOfObserversForInertiaRing =
        new SortedDictionary<int, List<IInertiaRingEffectObserver>>();
    foreach (var entry in observersForInertiaRing) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForInertiaRing.Add(
          objectId,
          new List<IInertiaRingEffectObserver>(
              observers));
    }

    var copyOfObserversForGlaive =
        new SortedDictionary<int, List<IGlaiveEffectObserver>>();
    foreach (var entry in observersForGlaive) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForGlaive.Add(
          objectId,
          new List<IGlaiveEffectObserver>(
              observers));
    }

    var copyOfObserversForArmor =
        new SortedDictionary<int, List<IArmorEffectObserver>>();
    foreach (var entry in observersForArmor) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForArmor.Add(
          objectId,
          new List<IArmorEffectObserver>(
              observers));
    }

    var copyOfObserversForRand =
        new SortedDictionary<int, List<IRandEffectObserver>>();
    foreach (var entry in observersForRand) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForRand.Add(
          objectId,
          new List<IRandEffectObserver>(
              observers));
    }

    var copyOfObserversForWanderAICapabilityUC =
        new SortedDictionary<int, List<IWanderAICapabilityUCEffectObserver>>();
    foreach (var entry in observersForWanderAICapabilityUC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForWanderAICapabilityUC.Add(
          objectId,
          new List<IWanderAICapabilityUCEffectObserver>(
              observers));
    }

    var copyOfObserversForCounteringUC =
        new SortedDictionary<int, List<ICounteringUCEffectObserver>>();
    foreach (var entry in observersForCounteringUC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForCounteringUC.Add(
          objectId,
          new List<ICounteringUCEffectObserver>(
              observers));
    }

    var copyOfObserversForShieldingUC =
        new SortedDictionary<int, List<IShieldingUCEffectObserver>>();
    foreach (var entry in observersForShieldingUC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForShieldingUC.Add(
          objectId,
          new List<IShieldingUCEffectObserver>(
              observers));
    }

    var copyOfObserversForEvaporateImpulse =
        new SortedDictionary<int, List<IEvaporateImpulseEffectObserver>>();
    foreach (var entry in observersForEvaporateImpulse) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForEvaporateImpulse.Add(
          objectId,
          new List<IEvaporateImpulseEffectObserver>(
              observers));
    }

    var copyOfObserversForTimeCloneAICapabilityUC =
        new SortedDictionary<int, List<ITimeCloneAICapabilityUCEffectObserver>>();
    foreach (var entry in observersForTimeCloneAICapabilityUC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForTimeCloneAICapabilityUC.Add(
          objectId,
          new List<ITimeCloneAICapabilityUCEffectObserver>(
              observers));
    }

    var copyOfObserversForUnleashBideImpulse =
        new SortedDictionary<int, List<IUnleashBideImpulseEffectObserver>>();
    foreach (var entry in observersForUnleashBideImpulse) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForUnleashBideImpulse.Add(
          objectId,
          new List<IUnleashBideImpulseEffectObserver>(
              observers));
    }

    var copyOfObserversForContinueBidingImpulse =
        new SortedDictionary<int, List<IContinueBidingImpulseEffectObserver>>();
    foreach (var entry in observersForContinueBidingImpulse) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForContinueBidingImpulse.Add(
          objectId,
          new List<IContinueBidingImpulseEffectObserver>(
              observers));
    }

    var copyOfObserversForStartBidingImpulse =
        new SortedDictionary<int, List<IStartBidingImpulseEffectObserver>>();
    foreach (var entry in observersForStartBidingImpulse) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForStartBidingImpulse.Add(
          objectId,
          new List<IStartBidingImpulseEffectObserver>(
              observers));
    }

    var copyOfObserversForBideAICapabilityUC =
        new SortedDictionary<int, List<IBideAICapabilityUCEffectObserver>>();
    foreach (var entry in observersForBideAICapabilityUC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForBideAICapabilityUC.Add(
          objectId,
          new List<IBideAICapabilityUCEffectObserver>(
              observers));
    }

    var copyOfObserversForFireImpulse =
        new SortedDictionary<int, List<IFireImpulseEffectObserver>>();
    foreach (var entry in observersForFireImpulse) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForFireImpulse.Add(
          objectId,
          new List<IFireImpulseEffectObserver>(
              observers));
    }

    var copyOfObserversForCounterImpulse =
        new SortedDictionary<int, List<ICounterImpulseEffectObserver>>();
    foreach (var entry in observersForCounterImpulse) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForCounterImpulse.Add(
          objectId,
          new List<ICounterImpulseEffectObserver>(
              observers));
    }

    var copyOfObserversForDefendImpulse =
        new SortedDictionary<int, List<IDefendImpulseEffectObserver>>();
    foreach (var entry in observersForDefendImpulse) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForDefendImpulse.Add(
          objectId,
          new List<IDefendImpulseEffectObserver>(
              observers));
    }

    var copyOfObserversForAttackImpulse =
        new SortedDictionary<int, List<IAttackImpulseEffectObserver>>();
    foreach (var entry in observersForAttackImpulse) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForAttackImpulse.Add(
          objectId,
          new List<IAttackImpulseEffectObserver>(
              observers));
    }

    var copyOfObserversForPursueImpulse =
        new SortedDictionary<int, List<IPursueImpulseEffectObserver>>();
    foreach (var entry in observersForPursueImpulse) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForPursueImpulse.Add(
          objectId,
          new List<IPursueImpulseEffectObserver>(
              observers));
    }

    var copyOfObserversForKillDirective =
        new SortedDictionary<int, List<IKillDirectiveEffectObserver>>();
    foreach (var entry in observersForKillDirective) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForKillDirective.Add(
          objectId,
          new List<IKillDirectiveEffectObserver>(
              observers));
    }

    var copyOfObserversForAttackAICapabilityUC =
        new SortedDictionary<int, List<IAttackAICapabilityUCEffectObserver>>();
    foreach (var entry in observersForAttackAICapabilityUC) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForAttackAICapabilityUC.Add(
          objectId,
          new List<IAttackAICapabilityUCEffectObserver>(
              observers));
    }

    var copyOfObserversForMoveImpulse =
        new SortedDictionary<int, List<IMoveImpulseEffectObserver>>();
    foreach (var entry in observersForMoveImpulse) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForMoveImpulse.Add(
          objectId,
          new List<IMoveImpulseEffectObserver>(
              observers));
    }

    var copyOfObserversForUnit =
        new SortedDictionary<int, List<IUnitEffectObserver>>();
    foreach (var entry in observersForUnit) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForUnit.Add(
          objectId,
          new List<IUnitEffectObserver>(
              observers));
    }

    var copyOfObserversForIUnitComponentMutBunch =
        new SortedDictionary<int, List<IIUnitComponentMutBunchEffectObserver>>();
    foreach (var entry in observersForIUnitComponentMutBunch) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForIUnitComponentMutBunch.Add(
          objectId,
          new List<IIUnitComponentMutBunchEffectObserver>(
              observers));
    }

    var copyOfObserversForNoImpulse =
        new SortedDictionary<int, List<INoImpulseEffectObserver>>();
    foreach (var entry in observersForNoImpulse) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForNoImpulse.Add(
          objectId,
          new List<INoImpulseEffectObserver>(
              observers));
    }

    var copyOfObserversForExecutionState =
        new SortedDictionary<int, List<IExecutionStateEffectObserver>>();
    foreach (var entry in observersForExecutionState) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForExecutionState.Add(
          objectId,
          new List<IExecutionStateEffectObserver>(
              observers));
    }

    var copyOfObserversForIPostActingUCWeakMutBunch =
        new SortedDictionary<int, List<IIPostActingUCWeakMutBunchEffectObserver>>();
    foreach (var entry in observersForIPostActingUCWeakMutBunch) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForIPostActingUCWeakMutBunch.Add(
          objectId,
          new List<IIPostActingUCWeakMutBunchEffectObserver>(
              observers));
    }

    var copyOfObserversForIPreActingUCWeakMutBunch =
        new SortedDictionary<int, List<IIPreActingUCWeakMutBunchEffectObserver>>();
    foreach (var entry in observersForIPreActingUCWeakMutBunch) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForIPreActingUCWeakMutBunch.Add(
          objectId,
          new List<IIPreActingUCWeakMutBunchEffectObserver>(
              observers));
    }

    var copyOfObserversForGame =
        new SortedDictionary<int, List<IGameEffectObserver>>();
    foreach (var entry in observersForGame) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForGame.Add(
          objectId,
          new List<IGameEffectObserver>(
              observers));
    }

    var copyOfObserversForIUnitEventMutList =
        new SortedDictionary<int, List<IIUnitEventMutListEffectObserver>>();
    foreach (var entry in observersForIUnitEventMutList) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForIUnitEventMutList.Add(
          objectId,
          new List<IIUnitEventMutListEffectObserver>(
              observers));
    }

    var copyOfObserversForLocationMutList =
        new SortedDictionary<int, List<ILocationMutListEffectObserver>>();
    foreach (var entry in observersForLocationMutList) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForLocationMutList.Add(
          objectId,
          new List<ILocationMutListEffectObserver>(
              observers));
    }

    var copyOfObserversForIRequestMutList =
        new SortedDictionary<int, List<IIRequestMutListEffectObserver>>();
    foreach (var entry in observersForIRequestMutList) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForIRequestMutList.Add(
          objectId,
          new List<IIRequestMutListEffectObserver>(
              observers));
    }

    var copyOfObserversForLevelMutSet =
        new SortedDictionary<int, List<ILevelMutSetEffectObserver>>();
    foreach (var entry in observersForLevelMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForLevelMutSet.Add(
          objectId,
          new List<ILevelMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForCounteringUCWeakMutSet =
        new SortedDictionary<int, List<ICounteringUCWeakMutSetEffectObserver>>();
    foreach (var entry in observersForCounteringUCWeakMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForCounteringUCWeakMutSet.Add(
          objectId,
          new List<ICounteringUCWeakMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForShieldingUCWeakMutSet =
        new SortedDictionary<int, List<IShieldingUCWeakMutSetEffectObserver>>();
    foreach (var entry in observersForShieldingUCWeakMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForShieldingUCWeakMutSet.Add(
          objectId,
          new List<IShieldingUCWeakMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForAttackAICapabilityUCWeakMutSet =
        new SortedDictionary<int, List<IAttackAICapabilityUCWeakMutSetEffectObserver>>();
    foreach (var entry in observersForAttackAICapabilityUCWeakMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForAttackAICapabilityUCWeakMutSet.Add(
          objectId,
          new List<IAttackAICapabilityUCWeakMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForTimeCloneAICapabilityUCWeakMutSet =
        new SortedDictionary<int, List<ITimeCloneAICapabilityUCWeakMutSetEffectObserver>>();
    foreach (var entry in observersForTimeCloneAICapabilityUCWeakMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForTimeCloneAICapabilityUCWeakMutSet.Add(
          objectId,
          new List<ITimeCloneAICapabilityUCWeakMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForArmorMutSet =
        new SortedDictionary<int, List<IArmorMutSetEffectObserver>>();
    foreach (var entry in observersForArmorMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForArmorMutSet.Add(
          objectId,
          new List<IArmorMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForInertiaRingMutSet =
        new SortedDictionary<int, List<IInertiaRingMutSetEffectObserver>>();
    foreach (var entry in observersForInertiaRingMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForInertiaRingMutSet.Add(
          objectId,
          new List<IInertiaRingMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForGlaiveMutSet =
        new SortedDictionary<int, List<IGlaiveMutSetEffectObserver>>();
    foreach (var entry in observersForGlaiveMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForGlaiveMutSet.Add(
          objectId,
          new List<IGlaiveMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForManaPotionMutSet =
        new SortedDictionary<int, List<IManaPotionMutSetEffectObserver>>();
    foreach (var entry in observersForManaPotionMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForManaPotionMutSet.Add(
          objectId,
          new List<IManaPotionMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForHealthPotionMutSet =
        new SortedDictionary<int, List<IHealthPotionMutSetEffectObserver>>();
    foreach (var entry in observersForHealthPotionMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForHealthPotionMutSet.Add(
          objectId,
          new List<IHealthPotionMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForWanderAICapabilityUCMutSet =
        new SortedDictionary<int, List<IWanderAICapabilityUCMutSetEffectObserver>>();
    foreach (var entry in observersForWanderAICapabilityUCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForWanderAICapabilityUCMutSet.Add(
          objectId,
          new List<IWanderAICapabilityUCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForTimeCloneAICapabilityUCMutSet =
        new SortedDictionary<int, List<ITimeCloneAICapabilityUCMutSetEffectObserver>>();
    foreach (var entry in observersForTimeCloneAICapabilityUCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForTimeCloneAICapabilityUCMutSet.Add(
          objectId,
          new List<ITimeCloneAICapabilityUCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForAttackAICapabilityUCMutSet =
        new SortedDictionary<int, List<IAttackAICapabilityUCMutSetEffectObserver>>();
    foreach (var entry in observersForAttackAICapabilityUCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForAttackAICapabilityUCMutSet.Add(
          objectId,
          new List<IAttackAICapabilityUCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForCounteringUCMutSet =
        new SortedDictionary<int, List<ICounteringUCMutSetEffectObserver>>();
    foreach (var entry in observersForCounteringUCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForCounteringUCMutSet.Add(
          objectId,
          new List<ICounteringUCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForShieldingUCMutSet =
        new SortedDictionary<int, List<IShieldingUCMutSetEffectObserver>>();
    foreach (var entry in observersForShieldingUCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForShieldingUCMutSet.Add(
          objectId,
          new List<IShieldingUCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForBideAICapabilityUCMutSet =
        new SortedDictionary<int, List<IBideAICapabilityUCMutSetEffectObserver>>();
    foreach (var entry in observersForBideAICapabilityUCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForBideAICapabilityUCMutSet.Add(
          objectId,
          new List<IBideAICapabilityUCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForTimeAnchorTTCMutSet =
        new SortedDictionary<int, List<ITimeAnchorTTCMutSetEffectObserver>>();
    foreach (var entry in observersForTimeAnchorTTCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForTimeAnchorTTCMutSet.Add(
          objectId,
          new List<ITimeAnchorTTCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForStaircaseTTCMutSet =
        new SortedDictionary<int, List<IStaircaseTTCMutSetEffectObserver>>();
    foreach (var entry in observersForStaircaseTTCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForStaircaseTTCMutSet.Add(
          objectId,
          new List<IStaircaseTTCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForWallTTCMutSet =
        new SortedDictionary<int, List<IWallTTCMutSetEffectObserver>>();
    foreach (var entry in observersForWallTTCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForWallTTCMutSet.Add(
          objectId,
          new List<IWallTTCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForBloodTTCMutSet =
        new SortedDictionary<int, List<IBloodTTCMutSetEffectObserver>>();
    foreach (var entry in observersForBloodTTCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForBloodTTCMutSet.Add(
          objectId,
          new List<IBloodTTCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForRocksTTCMutSet =
        new SortedDictionary<int, List<IRocksTTCMutSetEffectObserver>>();
    foreach (var entry in observersForRocksTTCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForRocksTTCMutSet.Add(
          objectId,
          new List<IRocksTTCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForDownstairsTTCMutSet =
        new SortedDictionary<int, List<IDownstairsTTCMutSetEffectObserver>>();
    foreach (var entry in observersForDownstairsTTCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForDownstairsTTCMutSet.Add(
          objectId,
          new List<IDownstairsTTCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForUpstairsTTCMutSet =
        new SortedDictionary<int, List<IUpstairsTTCMutSetEffectObserver>>();
    foreach (var entry in observersForUpstairsTTCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForUpstairsTTCMutSet.Add(
          objectId,
          new List<IUpstairsTTCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForCaveTTCMutSet =
        new SortedDictionary<int, List<ICaveTTCMutSetEffectObserver>>();
    foreach (var entry in observersForCaveTTCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForCaveTTCMutSet.Add(
          objectId,
          new List<ICaveTTCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForFallsTTCMutSet =
        new SortedDictionary<int, List<IFallsTTCMutSetEffectObserver>>();
    foreach (var entry in observersForFallsTTCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForFallsTTCMutSet.Add(
          objectId,
          new List<IFallsTTCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForMagmaTTCMutSet =
        new SortedDictionary<int, List<IMagmaTTCMutSetEffectObserver>>();
    foreach (var entry in observersForMagmaTTCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForMagmaTTCMutSet.Add(
          objectId,
          new List<IMagmaTTCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForCliffTTCMutSet =
        new SortedDictionary<int, List<ICliffTTCMutSetEffectObserver>>();
    foreach (var entry in observersForCliffTTCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForCliffTTCMutSet.Add(
          objectId,
          new List<ICliffTTCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForRavaNestTTCMutSet =
        new SortedDictionary<int, List<IRavaNestTTCMutSetEffectObserver>>();
    foreach (var entry in observersForRavaNestTTCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForRavaNestTTCMutSet.Add(
          objectId,
          new List<IRavaNestTTCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForCliffLandingTTCMutSet =
        new SortedDictionary<int, List<ICliffLandingTTCMutSetEffectObserver>>();
    foreach (var entry in observersForCliffLandingTTCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForCliffLandingTTCMutSet.Add(
          objectId,
          new List<ICliffLandingTTCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForStoneTTCMutSet =
        new SortedDictionary<int, List<IStoneTTCMutSetEffectObserver>>();
    foreach (var entry in observersForStoneTTCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForStoneTTCMutSet.Add(
          objectId,
          new List<IStoneTTCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForGrassTTCMutSet =
        new SortedDictionary<int, List<IGrassTTCMutSetEffectObserver>>();
    foreach (var entry in observersForGrassTTCMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForGrassTTCMutSet.Add(
          objectId,
          new List<IGrassTTCMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForUnitMutSet =
        new SortedDictionary<int, List<IUnitMutSetEffectObserver>>();
    foreach (var entry in observersForUnitMutSet) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForUnitMutSet.Add(
          objectId,
          new List<IUnitMutSetEffectObserver>(
              observers));
    }

    var copyOfObserversForTerrainTileByLocationMutMap =
        new SortedDictionary<int, List<ITerrainTileByLocationMutMapEffectObserver>>();
    foreach (var entry in observersForTerrainTileByLocationMutMap) {
      var objectId = entry.Key;
      var observers = entry.Value;
      copyOfObserversForTerrainTileByLocationMutMap.Add(
          objectId,
          new List<ITerrainTileByLocationMutMapEffectObserver>(
              observers));
    }

    BroadcastSquareCaveLevelControllerEffects(
        copyOfObserversForSquareCaveLevelController);
           
    BroadcastRidgeLevelControllerEffects(
        copyOfObserversForRidgeLevelController);
           
    BroadcastGauntletLevelControllerEffects(
        copyOfObserversForGauntletLevelController);
           
    BroadcastPreGauntletLevelControllerEffects(
        copyOfObserversForPreGauntletLevelController);
           
    BroadcastRavashrikeLevelControllerEffects(
        copyOfObserversForRavashrikeLevelController);
           
    BroadcastPentagonalCaveLevelControllerEffects(
        copyOfObserversForPentagonalCaveLevelController);
           
    BroadcastCliffLevelControllerEffects(
        copyOfObserversForCliffLevelController);
           
    BroadcastLevelEffects(
        copyOfObserversForLevel);
           
    BroadcastTimeAnchorTTCEffects(
        copyOfObserversForTimeAnchorTTC);
           
    BroadcastTerrainTileEffects(
        copyOfObserversForTerrainTile);
           
    BroadcastITerrainTileComponentMutBunchEffects(
        copyOfObserversForITerrainTileComponentMutBunch);
           
    BroadcastTerrainEffects(
        copyOfObserversForTerrain);
           
    BroadcastStaircaseTTCEffects(
        copyOfObserversForStaircaseTTC);
           
    BroadcastWallTTCEffects(
        copyOfObserversForWallTTC);
           
    BroadcastBloodTTCEffects(
        copyOfObserversForBloodTTC);
           
    BroadcastRocksTTCEffects(
        copyOfObserversForRocksTTC);
           
    BroadcastDownstairsTTCEffects(
        copyOfObserversForDownstairsTTC);
           
    BroadcastUpstairsTTCEffects(
        copyOfObserversForUpstairsTTC);
           
    BroadcastCaveTTCEffects(
        copyOfObserversForCaveTTC);
           
    BroadcastFallsTTCEffects(
        copyOfObserversForFallsTTC);
           
    BroadcastMagmaTTCEffects(
        copyOfObserversForMagmaTTC);
           
    BroadcastCliffTTCEffects(
        copyOfObserversForCliffTTC);
           
    BroadcastRavaNestTTCEffects(
        copyOfObserversForRavaNestTTC);
           
    BroadcastCliffLandingTTCEffects(
        copyOfObserversForCliffLandingTTC);
           
    BroadcastStoneTTCEffects(
        copyOfObserversForStoneTTC);
           
    BroadcastGrassTTCEffects(
        copyOfObserversForGrassTTC);
           
    BroadcastManaPotionEffects(
        copyOfObserversForManaPotion);
           
    BroadcastHealthPotionEffects(
        copyOfObserversForHealthPotion);
           
    BroadcastInertiaRingEffects(
        copyOfObserversForInertiaRing);
           
    BroadcastGlaiveEffects(
        copyOfObserversForGlaive);
           
    BroadcastArmorEffects(
        copyOfObserversForArmor);
           
    BroadcastRandEffects(
        copyOfObserversForRand);
           
    BroadcastWanderAICapabilityUCEffects(
        copyOfObserversForWanderAICapabilityUC);
           
    BroadcastCounteringUCEffects(
        copyOfObserversForCounteringUC);
           
    BroadcastShieldingUCEffects(
        copyOfObserversForShieldingUC);
           
    BroadcastEvaporateImpulseEffects(
        copyOfObserversForEvaporateImpulse);
           
    BroadcastTimeCloneAICapabilityUCEffects(
        copyOfObserversForTimeCloneAICapabilityUC);
           
    BroadcastUnleashBideImpulseEffects(
        copyOfObserversForUnleashBideImpulse);
           
    BroadcastContinueBidingImpulseEffects(
        copyOfObserversForContinueBidingImpulse);
           
    BroadcastStartBidingImpulseEffects(
        copyOfObserversForStartBidingImpulse);
           
    BroadcastBideAICapabilityUCEffects(
        copyOfObserversForBideAICapabilityUC);
           
    BroadcastFireImpulseEffects(
        copyOfObserversForFireImpulse);
           
    BroadcastCounterImpulseEffects(
        copyOfObserversForCounterImpulse);
           
    BroadcastDefendImpulseEffects(
        copyOfObserversForDefendImpulse);
           
    BroadcastAttackImpulseEffects(
        copyOfObserversForAttackImpulse);
           
    BroadcastPursueImpulseEffects(
        copyOfObserversForPursueImpulse);
           
    BroadcastKillDirectiveEffects(
        copyOfObserversForKillDirective);
           
    BroadcastAttackAICapabilityUCEffects(
        copyOfObserversForAttackAICapabilityUC);
           
    BroadcastMoveImpulseEffects(
        copyOfObserversForMoveImpulse);
           
    BroadcastUnitEffects(
        copyOfObserversForUnit);
           
    BroadcastIUnitComponentMutBunchEffects(
        copyOfObserversForIUnitComponentMutBunch);
           
    BroadcastNoImpulseEffects(
        copyOfObserversForNoImpulse);
           
    BroadcastExecutionStateEffects(
        copyOfObserversForExecutionState);
           
    BroadcastIPostActingUCWeakMutBunchEffects(
        copyOfObserversForIPostActingUCWeakMutBunch);
           
    BroadcastIPreActingUCWeakMutBunchEffects(
        copyOfObserversForIPreActingUCWeakMutBunch);
           
    BroadcastGameEffects(
        copyOfObserversForGame);
           
    BroadcastIUnitEventMutListEffects(
        copyOfObserversForIUnitEventMutList);
           
    BroadcastLocationMutListEffects(
        copyOfObserversForLocationMutList);
           
    BroadcastIRequestMutListEffects(
        copyOfObserversForIRequestMutList);
           
    BroadcastLevelMutSetEffects(
        copyOfObserversForLevelMutSet);
           
    BroadcastCounteringUCWeakMutSetEffects(
        copyOfObserversForCounteringUCWeakMutSet);
           
    BroadcastShieldingUCWeakMutSetEffects(
        copyOfObserversForShieldingUCWeakMutSet);
           
    BroadcastAttackAICapabilityUCWeakMutSetEffects(
        copyOfObserversForAttackAICapabilityUCWeakMutSet);
           
    BroadcastTimeCloneAICapabilityUCWeakMutSetEffects(
        copyOfObserversForTimeCloneAICapabilityUCWeakMutSet);
           
    BroadcastArmorMutSetEffects(
        copyOfObserversForArmorMutSet);
           
    BroadcastInertiaRingMutSetEffects(
        copyOfObserversForInertiaRingMutSet);
           
    BroadcastGlaiveMutSetEffects(
        copyOfObserversForGlaiveMutSet);
           
    BroadcastManaPotionMutSetEffects(
        copyOfObserversForManaPotionMutSet);
           
    BroadcastHealthPotionMutSetEffects(
        copyOfObserversForHealthPotionMutSet);
           
    BroadcastWanderAICapabilityUCMutSetEffects(
        copyOfObserversForWanderAICapabilityUCMutSet);
           
    BroadcastTimeCloneAICapabilityUCMutSetEffects(
        copyOfObserversForTimeCloneAICapabilityUCMutSet);
           
    BroadcastAttackAICapabilityUCMutSetEffects(
        copyOfObserversForAttackAICapabilityUCMutSet);
           
    BroadcastCounteringUCMutSetEffects(
        copyOfObserversForCounteringUCMutSet);
           
    BroadcastShieldingUCMutSetEffects(
        copyOfObserversForShieldingUCMutSet);
           
    BroadcastBideAICapabilityUCMutSetEffects(
        copyOfObserversForBideAICapabilityUCMutSet);
           
    BroadcastTimeAnchorTTCMutSetEffects(
        copyOfObserversForTimeAnchorTTCMutSet);
           
    BroadcastStaircaseTTCMutSetEffects(
        copyOfObserversForStaircaseTTCMutSet);
           
    BroadcastWallTTCMutSetEffects(
        copyOfObserversForWallTTCMutSet);
           
    BroadcastBloodTTCMutSetEffects(
        copyOfObserversForBloodTTCMutSet);
           
    BroadcastRocksTTCMutSetEffects(
        copyOfObserversForRocksTTCMutSet);
           
    BroadcastDownstairsTTCMutSetEffects(
        copyOfObserversForDownstairsTTCMutSet);
           
    BroadcastUpstairsTTCMutSetEffects(
        copyOfObserversForUpstairsTTCMutSet);
           
    BroadcastCaveTTCMutSetEffects(
        copyOfObserversForCaveTTCMutSet);
           
    BroadcastFallsTTCMutSetEffects(
        copyOfObserversForFallsTTCMutSet);
           
    BroadcastMagmaTTCMutSetEffects(
        copyOfObserversForMagmaTTCMutSet);
           
    BroadcastCliffTTCMutSetEffects(
        copyOfObserversForCliffTTCMutSet);
           
    BroadcastRavaNestTTCMutSetEffects(
        copyOfObserversForRavaNestTTCMutSet);
           
    BroadcastCliffLandingTTCMutSetEffects(
        copyOfObserversForCliffLandingTTCMutSet);
           
    BroadcastStoneTTCMutSetEffects(
        copyOfObserversForStoneTTCMutSet);
           
    BroadcastGrassTTCMutSetEffects(
        copyOfObserversForGrassTTCMutSet);
           
    BroadcastUnitMutSetEffects(
        copyOfObserversForUnitMutSet);
           
    BroadcastTerrainTileByLocationMutMapEffects(
        copyOfObserversForTerrainTileByLocationMutMap);
           
  }

  public int GetDeterministicHashCode() {
    // int doubleCheckHash = RecalculateEntireHash();
    // Asserts.Assert(doubleCheckHash == this.rootIncarnation.hash);
    return this.rootIncarnation.hash;
  }

  public void Revert(RootIncarnation sourceIncarnation) {
    CheckUnlocked();
    // We do all the adds first so that we don't violate any strong borrows.
    // Then we do all the changes, because those might be flipping things to point
    // at things that were just made.
    // Then we do all the removes.


    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSquareCaveLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreateSquareCaveLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRidgeLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRidgeLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreateRidgeLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGauntletLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGauntletLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreateGauntletLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPreGauntletLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreatePreGauntletLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavashrikeLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreateRavashrikeLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPentagonalCaveLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreatePentagonalCaveLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCliffLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreateCliffLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLevel) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLevel.ContainsKey(sourceObjId)) {
        EffectInternalCreateLevel(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeAnchorTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateTimeAnchorTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTerrainTile) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTerrainTile.ContainsKey(sourceObjId)) {
        EffectInternalCreateTerrainTile(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsITerrainTileComponentMutBunch) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsITerrainTileComponentMutBunch.ContainsKey(sourceObjId)) {
        EffectInternalCreateITerrainTileComponentMutBunch(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTerrain) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTerrain.ContainsKey(sourceObjId)) {
        EffectInternalCreateTerrain(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStaircaseTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsStaircaseTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateStaircaseTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWallTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWallTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateWallTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBloodTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBloodTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateBloodTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRocksTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRocksTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateRocksTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDownstairsTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDownstairsTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateDownstairsTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUpstairsTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsUpstairsTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateUpstairsTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCaveTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateCaveTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFallsTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFallsTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateFallsTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMagmaTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMagmaTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateMagmaTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCliffTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateCliffTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavaNestTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRavaNestTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateRavaNestTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffLandingTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateCliffLandingTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStoneTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsStoneTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateStoneTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGrassTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGrassTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateGrassTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsManaPotion) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsManaPotion.ContainsKey(sourceObjId)) {
        EffectInternalCreateManaPotion(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHealthPotion) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsHealthPotion.ContainsKey(sourceObjId)) {
        EffectInternalCreateHealthPotion(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsInertiaRing) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsInertiaRing.ContainsKey(sourceObjId)) {
        EffectInternalCreateInertiaRing(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGlaive) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGlaive.ContainsKey(sourceObjId)) {
        EffectInternalCreateGlaive(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsArmor) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsArmor.ContainsKey(sourceObjId)) {
        EffectInternalCreateArmor(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRand) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRand.ContainsKey(sourceObjId)) {
        EffectInternalCreateRand(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWanderAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateWanderAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounteringUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCounteringUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateCounteringUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsShieldingUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsShieldingUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateShieldingUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEvaporateImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateEvaporateImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeCloneAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateTimeCloneAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnleashBideImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateUnleashBideImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsContinueBidingImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateContinueBidingImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStartBidingImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateStartBidingImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBideAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateBideAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFireImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateFireImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounterImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCounterImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateCounterImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefendImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDefendImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateDefendImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsAttackImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateAttackImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPursueImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsPursueImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreatePursueImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKillDirective) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKillDirective.ContainsKey(sourceObjId)) {
        EffectInternalCreateKillDirective(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateAttackAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMoveImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMoveImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateMoveImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnit) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsUnit.ContainsKey(sourceObjId)) {
        EffectInternalCreateUnit(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIUnitComponentMutBunch) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIUnitComponentMutBunch.ContainsKey(sourceObjId)) {
        EffectInternalCreateIUnitComponentMutBunch(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsNoImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsNoImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateNoImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsExecutionState) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsExecutionState.ContainsKey(sourceObjId)) {
        EffectInternalCreateExecutionState(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIPostActingUCWeakMutBunch) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIPostActingUCWeakMutBunch.ContainsKey(sourceObjId)) {
        EffectInternalCreateIPostActingUCWeakMutBunch(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIPreActingUCWeakMutBunch) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIPreActingUCWeakMutBunch.ContainsKey(sourceObjId)) {
        EffectInternalCreateIPreActingUCWeakMutBunch(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGame) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGame.ContainsKey(sourceObjId)) {
        EffectInternalCreateGame(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIUnitEventMutList) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIUnitEventMutList.ContainsKey(sourceObjId)) {
        EffectInternalCreateIUnitEventMutList(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLocationMutList) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLocationMutList.ContainsKey(sourceObjId)) {
        EffectInternalCreateLocationMutList(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIRequestMutList) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIRequestMutList.ContainsKey(sourceObjId)) {
        EffectInternalCreateIRequestMutList(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLevelMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLevelMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateLevelMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounteringUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCounteringUCWeakMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateCounteringUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsShieldingUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsShieldingUCWeakMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateShieldingUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackAICapabilityUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateAttackAICapabilityUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateTimeCloneAICapabilityUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsArmorMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsArmorMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateArmorMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsInertiaRingMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsInertiaRingMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateInertiaRingMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGlaiveMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGlaiveMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateGlaiveMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsManaPotionMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsManaPotionMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateManaPotionMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHealthPotionMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsHealthPotionMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateHealthPotionMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWanderAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWanderAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateWanderAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeCloneAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateTimeCloneAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsAttackAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateAttackAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounteringUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCounteringUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateCounteringUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsShieldingUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsShieldingUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateShieldingUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBideAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBideAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateBideAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeAnchorTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTimeAnchorTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateTimeAnchorTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStaircaseTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsStaircaseTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateStaircaseTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWallTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWallTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateWallTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBloodTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBloodTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateBloodTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRocksTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRocksTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateRocksTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDownstairsTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDownstairsTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateDownstairsTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUpstairsTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsUpstairsTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateUpstairsTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCaveTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateCaveTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFallsTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFallsTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateFallsTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMagmaTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMagmaTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateMagmaTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCliffTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateCliffTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavaNestTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRavaNestTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateRavaNestTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffLandingTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCliffLandingTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateCliffLandingTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStoneTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsStoneTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateStoneTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGrassTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGrassTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateGrassTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnitMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsUnitMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateUnitMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTerrainTileByLocationMutMap) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTerrainTileByLocationMutMap.ContainsKey(sourceObjId)) {
        EffectInternalCreateTerrainTileByLocationMutMap(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIUnitEventMutList) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsIUnitEventMutList.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIUnitEventMutList[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            for (int i = currentObjIncarnation.list.Count - 1; i >= 0; i--) {
              EffectIUnitEventMutListRemoveAt(objId, i);
            }
            foreach (var objIdInSourceObjIncarnation in sourceObjIncarnation.list) {
              EffectIUnitEventMutListAdd(objId, objIdInSourceObjIncarnation);
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
                  rootIncarnation.incarnationsIUnitEventMutList[objId] = sourceVersionAndObjIncarnation;

          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLocationMutList) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsLocationMutList.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLocationMutList[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            for (int i = currentObjIncarnation.list.Count - 1; i >= 0; i--) {
              EffectLocationMutListRemoveAt(objId, i);
            }
            foreach (var objIdInSourceObjIncarnation in sourceObjIncarnation.list) {
              EffectLocationMutListAdd(objId, objIdInSourceObjIncarnation);
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
                  rootIncarnation.incarnationsLocationMutList[objId] = sourceVersionAndObjIncarnation;

          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIRequestMutList) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsIRequestMutList.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIRequestMutList[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            for (int i = currentObjIncarnation.list.Count - 1; i >= 0; i--) {
              EffectIRequestMutListRemoveAt(objId, i);
            }
            foreach (var objIdInSourceObjIncarnation in sourceObjIncarnation.list) {
              EffectIRequestMutListAdd(objId, objIdInSourceObjIncarnation);
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
                  rootIncarnation.incarnationsIRequestMutList[objId] = sourceVersionAndObjIncarnation;

          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLevelMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsLevelMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLevelMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectLevelMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectLevelMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsLevelMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounteringUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCounteringUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCounteringUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectCounteringUCWeakMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectCounteringUCWeakMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsCounteringUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsShieldingUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsShieldingUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsShieldingUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectShieldingUCWeakMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectShieldingUCWeakMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsShieldingUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackAICapabilityUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectAttackAICapabilityUCWeakMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectAttackAICapabilityUCWeakMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectTimeCloneAICapabilityUCWeakMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectTimeCloneAICapabilityUCWeakMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsArmorMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsArmorMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsArmorMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectArmorMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectArmorMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsArmorMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsInertiaRingMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsInertiaRingMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsInertiaRingMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectInertiaRingMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectInertiaRingMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsInertiaRingMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGlaiveMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsGlaiveMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGlaiveMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectGlaiveMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectGlaiveMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsGlaiveMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsManaPotionMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsManaPotionMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsManaPotionMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectManaPotionMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectManaPotionMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsManaPotionMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHealthPotionMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsHealthPotionMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsHealthPotionMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectHealthPotionMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectHealthPotionMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsHealthPotionMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWanderAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsWanderAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWanderAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectWanderAICapabilityUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectWanderAICapabilityUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsWanderAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeCloneAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectTimeCloneAICapabilityUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectTimeCloneAICapabilityUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsAttackAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsAttackAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectAttackAICapabilityUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectAttackAICapabilityUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsAttackAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounteringUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCounteringUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCounteringUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectCounteringUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectCounteringUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsCounteringUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsShieldingUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsShieldingUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsShieldingUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectShieldingUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectShieldingUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsShieldingUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBideAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBideAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBideAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectBideAICapabilityUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectBideAICapabilityUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsBideAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeAnchorTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsTimeAnchorTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTimeAnchorTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectTimeAnchorTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectTimeAnchorTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsTimeAnchorTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStaircaseTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsStaircaseTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsStaircaseTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectStaircaseTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectStaircaseTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsStaircaseTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWallTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsWallTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWallTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectWallTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectWallTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsWallTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBloodTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBloodTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBloodTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectBloodTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectBloodTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsBloodTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRocksTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsRocksTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRocksTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectRocksTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectRocksTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsRocksTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDownstairsTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsDownstairsTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDownstairsTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectDownstairsTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectDownstairsTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsDownstairsTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUpstairsTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsUpstairsTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsUpstairsTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectUpstairsTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectUpstairsTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsUpstairsTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCaveTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCaveTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectCaveTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectCaveTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsCaveTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFallsTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsFallsTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFallsTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectFallsTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectFallsTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsFallsTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMagmaTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsMagmaTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMagmaTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectMagmaTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectMagmaTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsMagmaTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCliffTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCliffTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectCliffTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectCliffTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsCliffTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavaNestTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsRavaNestTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRavaNestTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectRavaNestTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectRavaNestTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsRavaNestTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffLandingTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCliffLandingTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCliffLandingTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectCliffLandingTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectCliffLandingTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsCliffLandingTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStoneTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsStoneTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsStoneTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectStoneTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectStoneTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsStoneTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGrassTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsGrassTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGrassTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectGrassTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectGrassTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsGrassTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnitMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsUnitMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsUnitMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectUnitMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectUnitMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsUnitMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTerrainTileByLocationMutMap) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsTerrainTileByLocationMutMap.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTerrainTileByLocationMutMap[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var entryInCurrentObjIncarnation in new SortedDictionary<Location, int>(currentObjIncarnation.map)) {
              var key = entryInCurrentObjIncarnation.Key;
              if (!sourceObjIncarnation.map.ContainsKey(key)) {
                EffectTerrainTileByLocationMutMapRemove(objId, key);
              }
            }
            foreach (var entryInSourceObjIncarnation in sourceObjIncarnation.map) {
              var key = entryInSourceObjIncarnation.Key;
              var element = entryInSourceObjIncarnation.Value;
              if (!currentObjIncarnation.map.ContainsKey(key)) {
                EffectTerrainTileByLocationMutMapAdd(objId, key, element);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsTerrainTileByLocationMutMap[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSquareCaveLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSquareCaveLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsSquareCaveLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRidgeLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsRidgeLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRidgeLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsRidgeLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGauntletLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsGauntletLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGauntletLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsGauntletLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPreGauntletLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsPreGauntletLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsPreGauntletLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavashrikeLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRavashrikeLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsRavashrikeLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPentagonalCaveLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsPentagonalCaveLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsPentagonalCaveLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCliffLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCliffLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsCliffLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLevel) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsLevel.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLevel[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.controller != currentObjIncarnation.controller) {
            EffectLevelSetController(objId, GetILevelController(sourceObjIncarnation.controller));
          }

          if (sourceObjIncarnation.time != currentObjIncarnation.time) {
            EffectLevelSetTime(objId, sourceObjIncarnation.time);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsLevel[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeAnchorTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTimeAnchorTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsTimeAnchorTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTerrainTile) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTerrainTile.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTerrainTile[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.elevation != currentObjIncarnation.elevation) {
            EffectTerrainTileSetElevation(objId, sourceObjIncarnation.elevation);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsTerrainTile[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsITerrainTileComponentMutBunch) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsITerrainTileComponentMutBunch.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsITerrainTileComponentMutBunch[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsITerrainTileComponentMutBunch[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTerrain) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTerrain.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTerrain[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.pattern != currentObjIncarnation.pattern) {
            EffectTerrainSetPattern(objId, sourceObjIncarnation.pattern);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsTerrain[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStaircaseTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsStaircaseTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsStaircaseTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.destinationLevel != currentObjIncarnation.destinationLevel) {
            EffectStaircaseTTCSetDestinationLevel(objId, new Level(this, sourceObjIncarnation.destinationLevel));
          }

          if (sourceObjIncarnation.destinationLevelPortalIndex != currentObjIncarnation.destinationLevelPortalIndex) {
            EffectStaircaseTTCSetDestinationLevelPortalIndex(objId, sourceObjIncarnation.destinationLevelPortalIndex);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsStaircaseTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWallTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsWallTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWallTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsWallTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBloodTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBloodTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBloodTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsBloodTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRocksTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsRocksTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRocksTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsRocksTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDownstairsTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsDownstairsTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDownstairsTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsDownstairsTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUpstairsTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsUpstairsTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsUpstairsTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsUpstairsTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCaveTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCaveTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsCaveTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFallsTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsFallsTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFallsTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsFallsTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMagmaTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMagmaTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsMagmaTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCliffTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCliffTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsCliffTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavaNestTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsRavaNestTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRavaNestTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsRavaNestTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffLandingTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCliffLandingTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsCliffLandingTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStoneTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsStoneTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsStoneTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsStoneTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGrassTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsGrassTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGrassTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsGrassTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsManaPotion) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsManaPotion.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsManaPotion[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsManaPotion[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHealthPotion) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsHealthPotion.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsHealthPotion[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsHealthPotion[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsInertiaRing) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsInertiaRing.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsInertiaRing[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsInertiaRing[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGlaive) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsGlaive.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGlaive[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsGlaive[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsArmor) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsArmor.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsArmor[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsArmor[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRand) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsRand.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRand[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.rand != currentObjIncarnation.rand) {
            EffectRandSetRand(objId, sourceObjIncarnation.rand);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsRand[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWanderAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWanderAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsWanderAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounteringUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCounteringUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCounteringUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsCounteringUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsShieldingUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsShieldingUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsShieldingUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsShieldingUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEvaporateImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsEvaporateImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsEvaporateImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeCloneAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTimeCloneAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsTimeCloneAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnleashBideImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsUnleashBideImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsUnleashBideImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsContinueBidingImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsContinueBidingImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsContinueBidingImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStartBidingImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsStartBidingImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsStartBidingImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBideAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBideAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.charge != currentObjIncarnation.charge) {
            EffectBideAICapabilityUCSetCharge(objId, sourceObjIncarnation.charge);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsBideAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsFireImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFireImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsFireImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounterImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCounterImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCounterImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsCounterImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefendImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsDefendImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDefendImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsDefendImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsAttackImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsAttackImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsAttackImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPursueImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsPursueImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsPursueImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsPursueImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKillDirective) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsKillDirective.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKillDirective[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsKillDirective[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsAttackAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.killDirective != currentObjIncarnation.killDirective) {
            EffectAttackAICapabilityUCSetKillDirective(objId, new KillDirective(this, sourceObjIncarnation.killDirective));
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsAttackAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMoveImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsMoveImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMoveImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsMoveImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnit) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsUnit.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsUnit[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.alive != currentObjIncarnation.alive) {
            EffectUnitSetAlive(objId, sourceObjIncarnation.alive);
          }

          if (sourceObjIncarnation.lifeEndTime != currentObjIncarnation.lifeEndTime) {
            EffectUnitSetLifeEndTime(objId, sourceObjIncarnation.lifeEndTime);
          }

          if (sourceObjIncarnation.location != currentObjIncarnation.location) {
            EffectUnitSetLocation(objId, sourceObjIncarnation.location);
          }

          if (sourceObjIncarnation.hp != currentObjIncarnation.hp) {
            EffectUnitSetHp(objId, sourceObjIncarnation.hp);
          }

          if (sourceObjIncarnation.mp != currentObjIncarnation.mp) {
            EffectUnitSetMp(objId, sourceObjIncarnation.mp);
          }

          if (sourceObjIncarnation.nextActionTime != currentObjIncarnation.nextActionTime) {
            EffectUnitSetNextActionTime(objId, sourceObjIncarnation.nextActionTime);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsUnit[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIUnitComponentMutBunch) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsIUnitComponentMutBunch.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIUnitComponentMutBunch[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsIUnitComponentMutBunch[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsNoImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsNoImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsNoImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsNoImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsExecutionState) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsExecutionState.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsExecutionState[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.actingUnit != currentObjIncarnation.actingUnit) {
            EffectExecutionStateSetActingUnit(objId, new Unit(this, sourceObjIncarnation.actingUnit));
          }

          if (sourceObjIncarnation.actingUnitDidAction != currentObjIncarnation.actingUnitDidAction) {
            EffectExecutionStateSetActingUnitDidAction(objId, sourceObjIncarnation.actingUnitDidAction);
          }

          if (sourceObjIncarnation.remainingPreActingUnitComponents != currentObjIncarnation.remainingPreActingUnitComponents) {
            EffectExecutionStateSetRemainingPreActingUnitComponents(objId, new IPreActingUCWeakMutBunch(this, sourceObjIncarnation.remainingPreActingUnitComponents));
          }

          if (sourceObjIncarnation.remainingPostActingUnitComponents != currentObjIncarnation.remainingPostActingUnitComponents) {
            EffectExecutionStateSetRemainingPostActingUnitComponents(objId, new IPostActingUCWeakMutBunch(this, sourceObjIncarnation.remainingPostActingUnitComponents));
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsExecutionState[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIPostActingUCWeakMutBunch) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsIPostActingUCWeakMutBunch.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIPostActingUCWeakMutBunch[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsIPostActingUCWeakMutBunch[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIPreActingUCWeakMutBunch) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsIPreActingUCWeakMutBunch.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIPreActingUCWeakMutBunch[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsIPreActingUCWeakMutBunch[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGame) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsGame.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGame[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.player != currentObjIncarnation.player) {
            EffectGameSetPlayer(objId, new Unit(this, sourceObjIncarnation.player));
          }

          if (sourceObjIncarnation.level != currentObjIncarnation.level) {
            EffectGameSetLevel(objId, new Level(this, sourceObjIncarnation.level));
          }

          if (sourceObjIncarnation.time != currentObjIncarnation.time) {
            EffectGameSetTime(objId, sourceObjIncarnation.time);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsGame[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SquareCaveLevelControllerIncarnation>>(rootIncarnation.incarnationsSquareCaveLevelController)) {
      if (!sourceIncarnation.incarnationsSquareCaveLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectSquareCaveLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RidgeLevelControllerIncarnation>>(rootIncarnation.incarnationsRidgeLevelController)) {
      if (!sourceIncarnation.incarnationsRidgeLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectRidgeLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GauntletLevelControllerIncarnation>>(rootIncarnation.incarnationsGauntletLevelController)) {
      if (!sourceIncarnation.incarnationsGauntletLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectGauntletLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<PreGauntletLevelControllerIncarnation>>(rootIncarnation.incarnationsPreGauntletLevelController)) {
      if (!sourceIncarnation.incarnationsPreGauntletLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectPreGauntletLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RavashrikeLevelControllerIncarnation>>(rootIncarnation.incarnationsRavashrikeLevelController)) {
      if (!sourceIncarnation.incarnationsRavashrikeLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectRavashrikeLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<PentagonalCaveLevelControllerIncarnation>>(rootIncarnation.incarnationsPentagonalCaveLevelController)) {
      if (!sourceIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectPentagonalCaveLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CliffLevelControllerIncarnation>>(rootIncarnation.incarnationsCliffLevelController)) {
      if (!sourceIncarnation.incarnationsCliffLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCliffLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LevelIncarnation>>(rootIncarnation.incarnationsLevel)) {
      if (!sourceIncarnation.incarnationsLevel.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectLevelDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TimeAnchorTTCIncarnation>>(rootIncarnation.incarnationsTimeAnchorTTC)) {
      if (!sourceIncarnation.incarnationsTimeAnchorTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTimeAnchorTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TerrainTileIncarnation>>(rootIncarnation.incarnationsTerrainTile)) {
      if (!sourceIncarnation.incarnationsTerrainTile.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTerrainTileDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ITerrainTileComponentMutBunchIncarnation>>(rootIncarnation.incarnationsITerrainTileComponentMutBunch)) {
      if (!sourceIncarnation.incarnationsITerrainTileComponentMutBunch.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectITerrainTileComponentMutBunchDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TerrainIncarnation>>(rootIncarnation.incarnationsTerrain)) {
      if (!sourceIncarnation.incarnationsTerrain.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTerrainDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<StaircaseTTCIncarnation>>(rootIncarnation.incarnationsStaircaseTTC)) {
      if (!sourceIncarnation.incarnationsStaircaseTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectStaircaseTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WallTTCIncarnation>>(rootIncarnation.incarnationsWallTTC)) {
      if (!sourceIncarnation.incarnationsWallTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectWallTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BloodTTCIncarnation>>(rootIncarnation.incarnationsBloodTTC)) {
      if (!sourceIncarnation.incarnationsBloodTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBloodTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RocksTTCIncarnation>>(rootIncarnation.incarnationsRocksTTC)) {
      if (!sourceIncarnation.incarnationsRocksTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectRocksTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DownstairsTTCIncarnation>>(rootIncarnation.incarnationsDownstairsTTC)) {
      if (!sourceIncarnation.incarnationsDownstairsTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectDownstairsTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<UpstairsTTCIncarnation>>(rootIncarnation.incarnationsUpstairsTTC)) {
      if (!sourceIncarnation.incarnationsUpstairsTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectUpstairsTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CaveTTCIncarnation>>(rootIncarnation.incarnationsCaveTTC)) {
      if (!sourceIncarnation.incarnationsCaveTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCaveTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FallsTTCIncarnation>>(rootIncarnation.incarnationsFallsTTC)) {
      if (!sourceIncarnation.incarnationsFallsTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectFallsTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MagmaTTCIncarnation>>(rootIncarnation.incarnationsMagmaTTC)) {
      if (!sourceIncarnation.incarnationsMagmaTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectMagmaTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CliffTTCIncarnation>>(rootIncarnation.incarnationsCliffTTC)) {
      if (!sourceIncarnation.incarnationsCliffTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCliffTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RavaNestTTCIncarnation>>(rootIncarnation.incarnationsRavaNestTTC)) {
      if (!sourceIncarnation.incarnationsRavaNestTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectRavaNestTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CliffLandingTTCIncarnation>>(rootIncarnation.incarnationsCliffLandingTTC)) {
      if (!sourceIncarnation.incarnationsCliffLandingTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCliffLandingTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<StoneTTCIncarnation>>(rootIncarnation.incarnationsStoneTTC)) {
      if (!sourceIncarnation.incarnationsStoneTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectStoneTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GrassTTCIncarnation>>(rootIncarnation.incarnationsGrassTTC)) {
      if (!sourceIncarnation.incarnationsGrassTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectGrassTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ManaPotionIncarnation>>(rootIncarnation.incarnationsManaPotion)) {
      if (!sourceIncarnation.incarnationsManaPotion.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectManaPotionDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<HealthPotionIncarnation>>(rootIncarnation.incarnationsHealthPotion)) {
      if (!sourceIncarnation.incarnationsHealthPotion.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectHealthPotionDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<InertiaRingIncarnation>>(rootIncarnation.incarnationsInertiaRing)) {
      if (!sourceIncarnation.incarnationsInertiaRing.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectInertiaRingDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GlaiveIncarnation>>(rootIncarnation.incarnationsGlaive)) {
      if (!sourceIncarnation.incarnationsGlaive.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectGlaiveDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ArmorIncarnation>>(rootIncarnation.incarnationsArmor)) {
      if (!sourceIncarnation.incarnationsArmor.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectArmorDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RandIncarnation>>(rootIncarnation.incarnationsRand)) {
      if (!sourceIncarnation.incarnationsRand.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectRandDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WanderAICapabilityUCIncarnation>>(rootIncarnation.incarnationsWanderAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectWanderAICapabilityUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CounteringUCIncarnation>>(rootIncarnation.incarnationsCounteringUC)) {
      if (!sourceIncarnation.incarnationsCounteringUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCounteringUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ShieldingUCIncarnation>>(rootIncarnation.incarnationsShieldingUC)) {
      if (!sourceIncarnation.incarnationsShieldingUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectShieldingUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<EvaporateImpulseIncarnation>>(rootIncarnation.incarnationsEvaporateImpulse)) {
      if (!sourceIncarnation.incarnationsEvaporateImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectEvaporateImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TimeCloneAICapabilityUCIncarnation>>(rootIncarnation.incarnationsTimeCloneAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTimeCloneAICapabilityUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<UnleashBideImpulseIncarnation>>(rootIncarnation.incarnationsUnleashBideImpulse)) {
      if (!sourceIncarnation.incarnationsUnleashBideImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectUnleashBideImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ContinueBidingImpulseIncarnation>>(rootIncarnation.incarnationsContinueBidingImpulse)) {
      if (!sourceIncarnation.incarnationsContinueBidingImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectContinueBidingImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<StartBidingImpulseIncarnation>>(rootIncarnation.incarnationsStartBidingImpulse)) {
      if (!sourceIncarnation.incarnationsStartBidingImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectStartBidingImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BideAICapabilityUCIncarnation>>(rootIncarnation.incarnationsBideAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsBideAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBideAICapabilityUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FireImpulseIncarnation>>(rootIncarnation.incarnationsFireImpulse)) {
      if (!sourceIncarnation.incarnationsFireImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectFireImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CounterImpulseIncarnation>>(rootIncarnation.incarnationsCounterImpulse)) {
      if (!sourceIncarnation.incarnationsCounterImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCounterImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DefendImpulseIncarnation>>(rootIncarnation.incarnationsDefendImpulse)) {
      if (!sourceIncarnation.incarnationsDefendImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectDefendImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<AttackImpulseIncarnation>>(rootIncarnation.incarnationsAttackImpulse)) {
      if (!sourceIncarnation.incarnationsAttackImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectAttackImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<PursueImpulseIncarnation>>(rootIncarnation.incarnationsPursueImpulse)) {
      if (!sourceIncarnation.incarnationsPursueImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectPursueImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KillDirectiveIncarnation>>(rootIncarnation.incarnationsKillDirective)) {
      if (!sourceIncarnation.incarnationsKillDirective.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectKillDirectiveDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<AttackAICapabilityUCIncarnation>>(rootIncarnation.incarnationsAttackAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectAttackAICapabilityUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MoveImpulseIncarnation>>(rootIncarnation.incarnationsMoveImpulse)) {
      if (!sourceIncarnation.incarnationsMoveImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectMoveImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<UnitIncarnation>>(rootIncarnation.incarnationsUnit)) {
      if (!sourceIncarnation.incarnationsUnit.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectUnitDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IUnitComponentMutBunchIncarnation>>(rootIncarnation.incarnationsIUnitComponentMutBunch)) {
      if (!sourceIncarnation.incarnationsIUnitComponentMutBunch.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectIUnitComponentMutBunchDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<NoImpulseIncarnation>>(rootIncarnation.incarnationsNoImpulse)) {
      if (!sourceIncarnation.incarnationsNoImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectNoImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ExecutionStateIncarnation>>(rootIncarnation.incarnationsExecutionState)) {
      if (!sourceIncarnation.incarnationsExecutionState.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectExecutionStateDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IPostActingUCWeakMutBunchIncarnation>>(rootIncarnation.incarnationsIPostActingUCWeakMutBunch)) {
      if (!sourceIncarnation.incarnationsIPostActingUCWeakMutBunch.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectIPostActingUCWeakMutBunchDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IPreActingUCWeakMutBunchIncarnation>>(rootIncarnation.incarnationsIPreActingUCWeakMutBunch)) {
      if (!sourceIncarnation.incarnationsIPreActingUCWeakMutBunch.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectIPreActingUCWeakMutBunchDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GameIncarnation>>(rootIncarnation.incarnationsGame)) {
      if (!sourceIncarnation.incarnationsGame.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectGameDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IUnitEventMutListIncarnation>>(rootIncarnation.incarnationsIUnitEventMutList)) {
      if (!sourceIncarnation.incarnationsIUnitEventMutList.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectIUnitEventMutListDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LocationMutListIncarnation>>(rootIncarnation.incarnationsLocationMutList)) {
      if (!sourceIncarnation.incarnationsLocationMutList.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectLocationMutListDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IRequestMutListIncarnation>>(rootIncarnation.incarnationsIRequestMutList)) {
      if (!sourceIncarnation.incarnationsIRequestMutList.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectIRequestMutListDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LevelMutSetIncarnation>>(rootIncarnation.incarnationsLevelMutSet)) {
      if (!sourceIncarnation.incarnationsLevelMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectLevelMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CounteringUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsCounteringUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsCounteringUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCounteringUCWeakMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ShieldingUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsShieldingUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsShieldingUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectShieldingUCWeakMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<AttackAICapabilityUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectAttackAICapabilityUCWeakMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TimeCloneAICapabilityUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTimeCloneAICapabilityUCWeakMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ArmorMutSetIncarnation>>(rootIncarnation.incarnationsArmorMutSet)) {
      if (!sourceIncarnation.incarnationsArmorMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectArmorMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<InertiaRingMutSetIncarnation>>(rootIncarnation.incarnationsInertiaRingMutSet)) {
      if (!sourceIncarnation.incarnationsInertiaRingMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectInertiaRingMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GlaiveMutSetIncarnation>>(rootIncarnation.incarnationsGlaiveMutSet)) {
      if (!sourceIncarnation.incarnationsGlaiveMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectGlaiveMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ManaPotionMutSetIncarnation>>(rootIncarnation.incarnationsManaPotionMutSet)) {
      if (!sourceIncarnation.incarnationsManaPotionMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectManaPotionMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<HealthPotionMutSetIncarnation>>(rootIncarnation.incarnationsHealthPotionMutSet)) {
      if (!sourceIncarnation.incarnationsHealthPotionMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectHealthPotionMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WanderAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsWanderAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsWanderAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectWanderAICapabilityUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TimeCloneAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTimeCloneAICapabilityUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<AttackAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsAttackAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsAttackAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectAttackAICapabilityUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CounteringUCMutSetIncarnation>>(rootIncarnation.incarnationsCounteringUCMutSet)) {
      if (!sourceIncarnation.incarnationsCounteringUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCounteringUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ShieldingUCMutSetIncarnation>>(rootIncarnation.incarnationsShieldingUCMutSet)) {
      if (!sourceIncarnation.incarnationsShieldingUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectShieldingUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BideAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsBideAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsBideAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBideAICapabilityUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TimeAnchorTTCMutSetIncarnation>>(rootIncarnation.incarnationsTimeAnchorTTCMutSet)) {
      if (!sourceIncarnation.incarnationsTimeAnchorTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTimeAnchorTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<StaircaseTTCMutSetIncarnation>>(rootIncarnation.incarnationsStaircaseTTCMutSet)) {
      if (!sourceIncarnation.incarnationsStaircaseTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectStaircaseTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WallTTCMutSetIncarnation>>(rootIncarnation.incarnationsWallTTCMutSet)) {
      if (!sourceIncarnation.incarnationsWallTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectWallTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BloodTTCMutSetIncarnation>>(rootIncarnation.incarnationsBloodTTCMutSet)) {
      if (!sourceIncarnation.incarnationsBloodTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBloodTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RocksTTCMutSetIncarnation>>(rootIncarnation.incarnationsRocksTTCMutSet)) {
      if (!sourceIncarnation.incarnationsRocksTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectRocksTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DownstairsTTCMutSetIncarnation>>(rootIncarnation.incarnationsDownstairsTTCMutSet)) {
      if (!sourceIncarnation.incarnationsDownstairsTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectDownstairsTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<UpstairsTTCMutSetIncarnation>>(rootIncarnation.incarnationsUpstairsTTCMutSet)) {
      if (!sourceIncarnation.incarnationsUpstairsTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectUpstairsTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CaveTTCMutSetIncarnation>>(rootIncarnation.incarnationsCaveTTCMutSet)) {
      if (!sourceIncarnation.incarnationsCaveTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCaveTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FallsTTCMutSetIncarnation>>(rootIncarnation.incarnationsFallsTTCMutSet)) {
      if (!sourceIncarnation.incarnationsFallsTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectFallsTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MagmaTTCMutSetIncarnation>>(rootIncarnation.incarnationsMagmaTTCMutSet)) {
      if (!sourceIncarnation.incarnationsMagmaTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectMagmaTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CliffTTCMutSetIncarnation>>(rootIncarnation.incarnationsCliffTTCMutSet)) {
      if (!sourceIncarnation.incarnationsCliffTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCliffTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RavaNestTTCMutSetIncarnation>>(rootIncarnation.incarnationsRavaNestTTCMutSet)) {
      if (!sourceIncarnation.incarnationsRavaNestTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectRavaNestTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CliffLandingTTCMutSetIncarnation>>(rootIncarnation.incarnationsCliffLandingTTCMutSet)) {
      if (!sourceIncarnation.incarnationsCliffLandingTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCliffLandingTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<StoneTTCMutSetIncarnation>>(rootIncarnation.incarnationsStoneTTCMutSet)) {
      if (!sourceIncarnation.incarnationsStoneTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectStoneTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GrassTTCMutSetIncarnation>>(rootIncarnation.incarnationsGrassTTCMutSet)) {
      if (!sourceIncarnation.incarnationsGrassTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectGrassTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<UnitMutSetIncarnation>>(rootIncarnation.incarnationsUnitMutSet)) {
      if (!sourceIncarnation.incarnationsUnitMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectUnitMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TerrainTileByLocationMutMapIncarnation>>(rootIncarnation.incarnationsTerrainTileByLocationMutMap)) {
      if (!sourceIncarnation.incarnationsTerrainTileByLocationMutMap.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTerrainTileByLocationMutMapDelete(id);
      }
    }

  }
       public SquareCaveLevelControllerIncarnation GetSquareCaveLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsSquareCaveLevelController[id].incarnation;
  }
  public bool SquareCaveLevelControllerExists(int id) {
    return rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(id);
  }
  public SquareCaveLevelController GetSquareCaveLevelController(int id) {
    return new SquareCaveLevelController(this, id);
  }
  public List<SquareCaveLevelController> AllSquareCaveLevelController() {
    List<SquareCaveLevelController> result = new List<SquareCaveLevelController>(rootIncarnation.incarnationsSquareCaveLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsSquareCaveLevelController.Keys) {
      result.Add(new SquareCaveLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<SquareCaveLevelController> EnumAllSquareCaveLevelController() {
    foreach (var id in rootIncarnation.incarnationsSquareCaveLevelController.Keys) {
      yield return GetSquareCaveLevelController(id);
    }
  }
  public void CheckHasSquareCaveLevelController(SquareCaveLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasSquareCaveLevelController(thing.id);
  }
  public void CheckHasSquareCaveLevelController(int id) {
    if (!rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid SquareCaveLevelController: " + id);
    }
  }
  public void AddSquareCaveLevelControllerObserver(int id, ISquareCaveLevelControllerEffectObserver observer) {
    List<ISquareCaveLevelControllerEffectObserver> obsies;
    if (!observersForSquareCaveLevelController.TryGetValue(id, out obsies)) {
      obsies = new List<ISquareCaveLevelControllerEffectObserver>();
    }
    obsies.Add(observer);
    observersForSquareCaveLevelController[id] = obsies;
  }

  public void RemoveSquareCaveLevelControllerObserver(int id, ISquareCaveLevelControllerEffectObserver observer) {
    if (observersForSquareCaveLevelController.ContainsKey(id)) {
      var list = observersForSquareCaveLevelController[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForSquareCaveLevelController.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public SquareCaveLevelController EffectSquareCaveLevelControllerCreate(
      Level level,
      int depth) {
    CheckUnlocked();
    CheckHasLevel(level);

    var id = NewId();
    var incarnation =
        new SquareCaveLevelControllerIncarnation(
            level.id,
            depth
            );
    EffectInternalCreateSquareCaveLevelController(id, rootIncarnation.version, incarnation);
    return new SquareCaveLevelController(this, id);
  }
  public void EffectInternalCreateSquareCaveLevelController(
      int id,
      int incarnationVersion,
      SquareCaveLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new SquareCaveLevelControllerCreateEffect(id);
    rootIncarnation.incarnationsSquareCaveLevelController.Add(
        id,
        new VersionAndIncarnation<SquareCaveLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    effectsSquareCaveLevelControllerCreateEffect.Add(effect);
  }

  public void EffectSquareCaveLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new SquareCaveLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsSquareCaveLevelController[id];

    rootIncarnation.incarnationsSquareCaveLevelController.Remove(id);
    effectsSquareCaveLevelControllerDeleteEffect.Add(effect);
  }

     
  public int GetSquareCaveLevelControllerHash(int id, int version, SquareCaveLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.depth.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastSquareCaveLevelControllerEffects(
      SortedDictionary<int, List<ISquareCaveLevelControllerEffectObserver>> observers) {
    foreach (var effect in effectsSquareCaveLevelControllerDeleteEffect) {
      if (observers.TryGetValue(0, out List<ISquareCaveLevelControllerEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnSquareCaveLevelControllerEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ISquareCaveLevelControllerEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnSquareCaveLevelControllerEffect(effect);
        }
        observersForSquareCaveLevelController.Remove(effect.id);
      }
    }
    effectsSquareCaveLevelControllerDeleteEffect.Clear();


    foreach (var effect in effectsSquareCaveLevelControllerCreateEffect) {
      if (observers.TryGetValue(0, out List<ISquareCaveLevelControllerEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnSquareCaveLevelControllerEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ISquareCaveLevelControllerEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnSquareCaveLevelControllerEffect(effect);
        }
      }
    }
    effectsSquareCaveLevelControllerCreateEffect.Clear();
  }
  public RidgeLevelControllerIncarnation GetRidgeLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsRidgeLevelController[id].incarnation;
  }
  public bool RidgeLevelControllerExists(int id) {
    return rootIncarnation.incarnationsRidgeLevelController.ContainsKey(id);
  }
  public RidgeLevelController GetRidgeLevelController(int id) {
    return new RidgeLevelController(this, id);
  }
  public List<RidgeLevelController> AllRidgeLevelController() {
    List<RidgeLevelController> result = new List<RidgeLevelController>(rootIncarnation.incarnationsRidgeLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsRidgeLevelController.Keys) {
      result.Add(new RidgeLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<RidgeLevelController> EnumAllRidgeLevelController() {
    foreach (var id in rootIncarnation.incarnationsRidgeLevelController.Keys) {
      yield return GetRidgeLevelController(id);
    }
  }
  public void CheckHasRidgeLevelController(RidgeLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasRidgeLevelController(thing.id);
  }
  public void CheckHasRidgeLevelController(int id) {
    if (!rootIncarnation.incarnationsRidgeLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid RidgeLevelController: " + id);
    }
  }
  public void AddRidgeLevelControllerObserver(int id, IRidgeLevelControllerEffectObserver observer) {
    List<IRidgeLevelControllerEffectObserver> obsies;
    if (!observersForRidgeLevelController.TryGetValue(id, out obsies)) {
      obsies = new List<IRidgeLevelControllerEffectObserver>();
    }
    obsies.Add(observer);
    observersForRidgeLevelController[id] = obsies;
  }

  public void RemoveRidgeLevelControllerObserver(int id, IRidgeLevelControllerEffectObserver observer) {
    if (observersForRidgeLevelController.ContainsKey(id)) {
      var list = observersForRidgeLevelController[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForRidgeLevelController.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public RidgeLevelController EffectRidgeLevelControllerCreate(
      Level level) {
    CheckUnlocked();
    CheckHasLevel(level);

    var id = NewId();
    var incarnation =
        new RidgeLevelControllerIncarnation(
            level.id
            );
    EffectInternalCreateRidgeLevelController(id, rootIncarnation.version, incarnation);
    return new RidgeLevelController(this, id);
  }
  public void EffectInternalCreateRidgeLevelController(
      int id,
      int incarnationVersion,
      RidgeLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new RidgeLevelControllerCreateEffect(id);
    rootIncarnation.incarnationsRidgeLevelController.Add(
        id,
        new VersionAndIncarnation<RidgeLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    effectsRidgeLevelControllerCreateEffect.Add(effect);
  }

  public void EffectRidgeLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new RidgeLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsRidgeLevelController[id];

    rootIncarnation.incarnationsRidgeLevelController.Remove(id);
    effectsRidgeLevelControllerDeleteEffect.Add(effect);
  }

     
  public int GetRidgeLevelControllerHash(int id, int version, RidgeLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastRidgeLevelControllerEffects(
      SortedDictionary<int, List<IRidgeLevelControllerEffectObserver>> observers) {
    foreach (var effect in effectsRidgeLevelControllerDeleteEffect) {
      if (observers.TryGetValue(0, out List<IRidgeLevelControllerEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnRidgeLevelControllerEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IRidgeLevelControllerEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnRidgeLevelControllerEffect(effect);
        }
        observersForRidgeLevelController.Remove(effect.id);
      }
    }
    effectsRidgeLevelControllerDeleteEffect.Clear();


    foreach (var effect in effectsRidgeLevelControllerCreateEffect) {
      if (observers.TryGetValue(0, out List<IRidgeLevelControllerEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnRidgeLevelControllerEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IRidgeLevelControllerEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnRidgeLevelControllerEffect(effect);
        }
      }
    }
    effectsRidgeLevelControllerCreateEffect.Clear();
  }
  public GauntletLevelControllerIncarnation GetGauntletLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsGauntletLevelController[id].incarnation;
  }
  public bool GauntletLevelControllerExists(int id) {
    return rootIncarnation.incarnationsGauntletLevelController.ContainsKey(id);
  }
  public GauntletLevelController GetGauntletLevelController(int id) {
    return new GauntletLevelController(this, id);
  }
  public List<GauntletLevelController> AllGauntletLevelController() {
    List<GauntletLevelController> result = new List<GauntletLevelController>(rootIncarnation.incarnationsGauntletLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsGauntletLevelController.Keys) {
      result.Add(new GauntletLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<GauntletLevelController> EnumAllGauntletLevelController() {
    foreach (var id in rootIncarnation.incarnationsGauntletLevelController.Keys) {
      yield return GetGauntletLevelController(id);
    }
  }
  public void CheckHasGauntletLevelController(GauntletLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasGauntletLevelController(thing.id);
  }
  public void CheckHasGauntletLevelController(int id) {
    if (!rootIncarnation.incarnationsGauntletLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid GauntletLevelController: " + id);
    }
  }
  public void AddGauntletLevelControllerObserver(int id, IGauntletLevelControllerEffectObserver observer) {
    List<IGauntletLevelControllerEffectObserver> obsies;
    if (!observersForGauntletLevelController.TryGetValue(id, out obsies)) {
      obsies = new List<IGauntletLevelControllerEffectObserver>();
    }
    obsies.Add(observer);
    observersForGauntletLevelController[id] = obsies;
  }

  public void RemoveGauntletLevelControllerObserver(int id, IGauntletLevelControllerEffectObserver observer) {
    if (observersForGauntletLevelController.ContainsKey(id)) {
      var list = observersForGauntletLevelController[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForGauntletLevelController.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public GauntletLevelController EffectGauntletLevelControllerCreate(
      Level level) {
    CheckUnlocked();
    CheckHasLevel(level);

    var id = NewId();
    var incarnation =
        new GauntletLevelControllerIncarnation(
            level.id
            );
    EffectInternalCreateGauntletLevelController(id, rootIncarnation.version, incarnation);
    return new GauntletLevelController(this, id);
  }
  public void EffectInternalCreateGauntletLevelController(
      int id,
      int incarnationVersion,
      GauntletLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new GauntletLevelControllerCreateEffect(id);
    rootIncarnation.incarnationsGauntletLevelController.Add(
        id,
        new VersionAndIncarnation<GauntletLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    effectsGauntletLevelControllerCreateEffect.Add(effect);
  }

  public void EffectGauntletLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new GauntletLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsGauntletLevelController[id];

    rootIncarnation.incarnationsGauntletLevelController.Remove(id);
    effectsGauntletLevelControllerDeleteEffect.Add(effect);
  }

     
  public int GetGauntletLevelControllerHash(int id, int version, GauntletLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastGauntletLevelControllerEffects(
      SortedDictionary<int, List<IGauntletLevelControllerEffectObserver>> observers) {
    foreach (var effect in effectsGauntletLevelControllerDeleteEffect) {
      if (observers.TryGetValue(0, out List<IGauntletLevelControllerEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnGauntletLevelControllerEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IGauntletLevelControllerEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnGauntletLevelControllerEffect(effect);
        }
        observersForGauntletLevelController.Remove(effect.id);
      }
    }
    effectsGauntletLevelControllerDeleteEffect.Clear();


    foreach (var effect in effectsGauntletLevelControllerCreateEffect) {
      if (observers.TryGetValue(0, out List<IGauntletLevelControllerEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnGauntletLevelControllerEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IGauntletLevelControllerEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnGauntletLevelControllerEffect(effect);
        }
      }
    }
    effectsGauntletLevelControllerCreateEffect.Clear();
  }
  public PreGauntletLevelControllerIncarnation GetPreGauntletLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsPreGauntletLevelController[id].incarnation;
  }
  public bool PreGauntletLevelControllerExists(int id) {
    return rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(id);
  }
  public PreGauntletLevelController GetPreGauntletLevelController(int id) {
    return new PreGauntletLevelController(this, id);
  }
  public List<PreGauntletLevelController> AllPreGauntletLevelController() {
    List<PreGauntletLevelController> result = new List<PreGauntletLevelController>(rootIncarnation.incarnationsPreGauntletLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsPreGauntletLevelController.Keys) {
      result.Add(new PreGauntletLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<PreGauntletLevelController> EnumAllPreGauntletLevelController() {
    foreach (var id in rootIncarnation.incarnationsPreGauntletLevelController.Keys) {
      yield return GetPreGauntletLevelController(id);
    }
  }
  public void CheckHasPreGauntletLevelController(PreGauntletLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasPreGauntletLevelController(thing.id);
  }
  public void CheckHasPreGauntletLevelController(int id) {
    if (!rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid PreGauntletLevelController: " + id);
    }
  }
  public void AddPreGauntletLevelControllerObserver(int id, IPreGauntletLevelControllerEffectObserver observer) {
    List<IPreGauntletLevelControllerEffectObserver> obsies;
    if (!observersForPreGauntletLevelController.TryGetValue(id, out obsies)) {
      obsies = new List<IPreGauntletLevelControllerEffectObserver>();
    }
    obsies.Add(observer);
    observersForPreGauntletLevelController[id] = obsies;
  }

  public void RemovePreGauntletLevelControllerObserver(int id, IPreGauntletLevelControllerEffectObserver observer) {
    if (observersForPreGauntletLevelController.ContainsKey(id)) {
      var list = observersForPreGauntletLevelController[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForPreGauntletLevelController.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public PreGauntletLevelController EffectPreGauntletLevelControllerCreate(
      Level level) {
    CheckUnlocked();
    CheckHasLevel(level);

    var id = NewId();
    var incarnation =
        new PreGauntletLevelControllerIncarnation(
            level.id
            );
    EffectInternalCreatePreGauntletLevelController(id, rootIncarnation.version, incarnation);
    return new PreGauntletLevelController(this, id);
  }
  public void EffectInternalCreatePreGauntletLevelController(
      int id,
      int incarnationVersion,
      PreGauntletLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new PreGauntletLevelControllerCreateEffect(id);
    rootIncarnation.incarnationsPreGauntletLevelController.Add(
        id,
        new VersionAndIncarnation<PreGauntletLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    effectsPreGauntletLevelControllerCreateEffect.Add(effect);
  }

  public void EffectPreGauntletLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new PreGauntletLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsPreGauntletLevelController[id];

    rootIncarnation.incarnationsPreGauntletLevelController.Remove(id);
    effectsPreGauntletLevelControllerDeleteEffect.Add(effect);
  }

     
  public int GetPreGauntletLevelControllerHash(int id, int version, PreGauntletLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastPreGauntletLevelControllerEffects(
      SortedDictionary<int, List<IPreGauntletLevelControllerEffectObserver>> observers) {
    foreach (var effect in effectsPreGauntletLevelControllerDeleteEffect) {
      if (observers.TryGetValue(0, out List<IPreGauntletLevelControllerEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnPreGauntletLevelControllerEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IPreGauntletLevelControllerEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnPreGauntletLevelControllerEffect(effect);
        }
        observersForPreGauntletLevelController.Remove(effect.id);
      }
    }
    effectsPreGauntletLevelControllerDeleteEffect.Clear();


    foreach (var effect in effectsPreGauntletLevelControllerCreateEffect) {
      if (observers.TryGetValue(0, out List<IPreGauntletLevelControllerEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnPreGauntletLevelControllerEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IPreGauntletLevelControllerEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnPreGauntletLevelControllerEffect(effect);
        }
      }
    }
    effectsPreGauntletLevelControllerCreateEffect.Clear();
  }
  public RavashrikeLevelControllerIncarnation GetRavashrikeLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsRavashrikeLevelController[id].incarnation;
  }
  public bool RavashrikeLevelControllerExists(int id) {
    return rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(id);
  }
  public RavashrikeLevelController GetRavashrikeLevelController(int id) {
    return new RavashrikeLevelController(this, id);
  }
  public List<RavashrikeLevelController> AllRavashrikeLevelController() {
    List<RavashrikeLevelController> result = new List<RavashrikeLevelController>(rootIncarnation.incarnationsRavashrikeLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsRavashrikeLevelController.Keys) {
      result.Add(new RavashrikeLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<RavashrikeLevelController> EnumAllRavashrikeLevelController() {
    foreach (var id in rootIncarnation.incarnationsRavashrikeLevelController.Keys) {
      yield return GetRavashrikeLevelController(id);
    }
  }
  public void CheckHasRavashrikeLevelController(RavashrikeLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasRavashrikeLevelController(thing.id);
  }
  public void CheckHasRavashrikeLevelController(int id) {
    if (!rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid RavashrikeLevelController: " + id);
    }
  }
  public void AddRavashrikeLevelControllerObserver(int id, IRavashrikeLevelControllerEffectObserver observer) {
    List<IRavashrikeLevelControllerEffectObserver> obsies;
    if (!observersForRavashrikeLevelController.TryGetValue(id, out obsies)) {
      obsies = new List<IRavashrikeLevelControllerEffectObserver>();
    }
    obsies.Add(observer);
    observersForRavashrikeLevelController[id] = obsies;
  }

  public void RemoveRavashrikeLevelControllerObserver(int id, IRavashrikeLevelControllerEffectObserver observer) {
    if (observersForRavashrikeLevelController.ContainsKey(id)) {
      var list = observersForRavashrikeLevelController[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForRavashrikeLevelController.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public RavashrikeLevelController EffectRavashrikeLevelControllerCreate(
      Level level) {
    CheckUnlocked();
    CheckHasLevel(level);

    var id = NewId();
    var incarnation =
        new RavashrikeLevelControllerIncarnation(
            level.id
            );
    EffectInternalCreateRavashrikeLevelController(id, rootIncarnation.version, incarnation);
    return new RavashrikeLevelController(this, id);
  }
  public void EffectInternalCreateRavashrikeLevelController(
      int id,
      int incarnationVersion,
      RavashrikeLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new RavashrikeLevelControllerCreateEffect(id);
    rootIncarnation.incarnationsRavashrikeLevelController.Add(
        id,
        new VersionAndIncarnation<RavashrikeLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    effectsRavashrikeLevelControllerCreateEffect.Add(effect);
  }

  public void EffectRavashrikeLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new RavashrikeLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsRavashrikeLevelController[id];

    rootIncarnation.incarnationsRavashrikeLevelController.Remove(id);
    effectsRavashrikeLevelControllerDeleteEffect.Add(effect);
  }

     
  public int GetRavashrikeLevelControllerHash(int id, int version, RavashrikeLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastRavashrikeLevelControllerEffects(
      SortedDictionary<int, List<IRavashrikeLevelControllerEffectObserver>> observers) {
    foreach (var effect in effectsRavashrikeLevelControllerDeleteEffect) {
      if (observers.TryGetValue(0, out List<IRavashrikeLevelControllerEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnRavashrikeLevelControllerEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IRavashrikeLevelControllerEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnRavashrikeLevelControllerEffect(effect);
        }
        observersForRavashrikeLevelController.Remove(effect.id);
      }
    }
    effectsRavashrikeLevelControllerDeleteEffect.Clear();


    foreach (var effect in effectsRavashrikeLevelControllerCreateEffect) {
      if (observers.TryGetValue(0, out List<IRavashrikeLevelControllerEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnRavashrikeLevelControllerEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IRavashrikeLevelControllerEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnRavashrikeLevelControllerEffect(effect);
        }
      }
    }
    effectsRavashrikeLevelControllerCreateEffect.Clear();
  }
  public PentagonalCaveLevelControllerIncarnation GetPentagonalCaveLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsPentagonalCaveLevelController[id].incarnation;
  }
  public bool PentagonalCaveLevelControllerExists(int id) {
    return rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(id);
  }
  public PentagonalCaveLevelController GetPentagonalCaveLevelController(int id) {
    return new PentagonalCaveLevelController(this, id);
  }
  public List<PentagonalCaveLevelController> AllPentagonalCaveLevelController() {
    List<PentagonalCaveLevelController> result = new List<PentagonalCaveLevelController>(rootIncarnation.incarnationsPentagonalCaveLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsPentagonalCaveLevelController.Keys) {
      result.Add(new PentagonalCaveLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<PentagonalCaveLevelController> EnumAllPentagonalCaveLevelController() {
    foreach (var id in rootIncarnation.incarnationsPentagonalCaveLevelController.Keys) {
      yield return GetPentagonalCaveLevelController(id);
    }
  }
  public void CheckHasPentagonalCaveLevelController(PentagonalCaveLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasPentagonalCaveLevelController(thing.id);
  }
  public void CheckHasPentagonalCaveLevelController(int id) {
    if (!rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid PentagonalCaveLevelController: " + id);
    }
  }
  public void AddPentagonalCaveLevelControllerObserver(int id, IPentagonalCaveLevelControllerEffectObserver observer) {
    List<IPentagonalCaveLevelControllerEffectObserver> obsies;
    if (!observersForPentagonalCaveLevelController.TryGetValue(id, out obsies)) {
      obsies = new List<IPentagonalCaveLevelControllerEffectObserver>();
    }
    obsies.Add(observer);
    observersForPentagonalCaveLevelController[id] = obsies;
  }

  public void RemovePentagonalCaveLevelControllerObserver(int id, IPentagonalCaveLevelControllerEffectObserver observer) {
    if (observersForPentagonalCaveLevelController.ContainsKey(id)) {
      var list = observersForPentagonalCaveLevelController[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForPentagonalCaveLevelController.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public PentagonalCaveLevelController EffectPentagonalCaveLevelControllerCreate(
      Level level,
      int depth) {
    CheckUnlocked();
    CheckHasLevel(level);

    var id = NewId();
    var incarnation =
        new PentagonalCaveLevelControllerIncarnation(
            level.id,
            depth
            );
    EffectInternalCreatePentagonalCaveLevelController(id, rootIncarnation.version, incarnation);
    return new PentagonalCaveLevelController(this, id);
  }
  public void EffectInternalCreatePentagonalCaveLevelController(
      int id,
      int incarnationVersion,
      PentagonalCaveLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new PentagonalCaveLevelControllerCreateEffect(id);
    rootIncarnation.incarnationsPentagonalCaveLevelController.Add(
        id,
        new VersionAndIncarnation<PentagonalCaveLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    effectsPentagonalCaveLevelControllerCreateEffect.Add(effect);
  }

  public void EffectPentagonalCaveLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new PentagonalCaveLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsPentagonalCaveLevelController[id];

    rootIncarnation.incarnationsPentagonalCaveLevelController.Remove(id);
    effectsPentagonalCaveLevelControllerDeleteEffect.Add(effect);
  }

     
  public int GetPentagonalCaveLevelControllerHash(int id, int version, PentagonalCaveLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.depth.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastPentagonalCaveLevelControllerEffects(
      SortedDictionary<int, List<IPentagonalCaveLevelControllerEffectObserver>> observers) {
    foreach (var effect in effectsPentagonalCaveLevelControllerDeleteEffect) {
      if (observers.TryGetValue(0, out List<IPentagonalCaveLevelControllerEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnPentagonalCaveLevelControllerEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IPentagonalCaveLevelControllerEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnPentagonalCaveLevelControllerEffect(effect);
        }
        observersForPentagonalCaveLevelController.Remove(effect.id);
      }
    }
    effectsPentagonalCaveLevelControllerDeleteEffect.Clear();


    foreach (var effect in effectsPentagonalCaveLevelControllerCreateEffect) {
      if (observers.TryGetValue(0, out List<IPentagonalCaveLevelControllerEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnPentagonalCaveLevelControllerEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IPentagonalCaveLevelControllerEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnPentagonalCaveLevelControllerEffect(effect);
        }
      }
    }
    effectsPentagonalCaveLevelControllerCreateEffect.Clear();
  }
  public CliffLevelControllerIncarnation GetCliffLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCliffLevelController[id].incarnation;
  }
  public bool CliffLevelControllerExists(int id) {
    return rootIncarnation.incarnationsCliffLevelController.ContainsKey(id);
  }
  public CliffLevelController GetCliffLevelController(int id) {
    return new CliffLevelController(this, id);
  }
  public List<CliffLevelController> AllCliffLevelController() {
    List<CliffLevelController> result = new List<CliffLevelController>(rootIncarnation.incarnationsCliffLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsCliffLevelController.Keys) {
      result.Add(new CliffLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<CliffLevelController> EnumAllCliffLevelController() {
    foreach (var id in rootIncarnation.incarnationsCliffLevelController.Keys) {
      yield return GetCliffLevelController(id);
    }
  }
  public void CheckHasCliffLevelController(CliffLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCliffLevelController(thing.id);
  }
  public void CheckHasCliffLevelController(int id) {
    if (!rootIncarnation.incarnationsCliffLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid CliffLevelController: " + id);
    }
  }
  public void AddCliffLevelControllerObserver(int id, ICliffLevelControllerEffectObserver observer) {
    List<ICliffLevelControllerEffectObserver> obsies;
    if (!observersForCliffLevelController.TryGetValue(id, out obsies)) {
      obsies = new List<ICliffLevelControllerEffectObserver>();
    }
    obsies.Add(observer);
    observersForCliffLevelController[id] = obsies;
  }

  public void RemoveCliffLevelControllerObserver(int id, ICliffLevelControllerEffectObserver observer) {
    if (observersForCliffLevelController.ContainsKey(id)) {
      var list = observersForCliffLevelController[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForCliffLevelController.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public CliffLevelController EffectCliffLevelControllerCreate(
      Level level,
      int depth) {
    CheckUnlocked();
    CheckHasLevel(level);

    var id = NewId();
    var incarnation =
        new CliffLevelControllerIncarnation(
            level.id,
            depth
            );
    EffectInternalCreateCliffLevelController(id, rootIncarnation.version, incarnation);
    return new CliffLevelController(this, id);
  }
  public void EffectInternalCreateCliffLevelController(
      int id,
      int incarnationVersion,
      CliffLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new CliffLevelControllerCreateEffect(id);
    rootIncarnation.incarnationsCliffLevelController.Add(
        id,
        new VersionAndIncarnation<CliffLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    effectsCliffLevelControllerCreateEffect.Add(effect);
  }

  public void EffectCliffLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new CliffLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCliffLevelController[id];

    rootIncarnation.incarnationsCliffLevelController.Remove(id);
    effectsCliffLevelControllerDeleteEffect.Add(effect);
  }

     
  public int GetCliffLevelControllerHash(int id, int version, CliffLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.depth.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastCliffLevelControllerEffects(
      SortedDictionary<int, List<ICliffLevelControllerEffectObserver>> observers) {
    foreach (var effect in effectsCliffLevelControllerDeleteEffect) {
      if (observers.TryGetValue(0, out List<ICliffLevelControllerEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCliffLevelControllerEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICliffLevelControllerEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCliffLevelControllerEffect(effect);
        }
        observersForCliffLevelController.Remove(effect.id);
      }
    }
    effectsCliffLevelControllerDeleteEffect.Clear();


    foreach (var effect in effectsCliffLevelControllerCreateEffect) {
      if (observers.TryGetValue(0, out List<ICliffLevelControllerEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCliffLevelControllerEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICliffLevelControllerEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCliffLevelControllerEffect(effect);
        }
      }
    }
    effectsCliffLevelControllerCreateEffect.Clear();
  }
  public LevelIncarnation GetLevelIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsLevel[id].incarnation;
  }
  public bool LevelExists(int id) {
    return rootIncarnation.incarnationsLevel.ContainsKey(id);
  }
  public Level GetLevel(int id) {
    return new Level(this, id);
  }
  public List<Level> AllLevel() {
    List<Level> result = new List<Level>(rootIncarnation.incarnationsLevel.Count);
    foreach (var id in rootIncarnation.incarnationsLevel.Keys) {
      result.Add(new Level(this, id));
    }
    return result;
  }
  public IEnumerator<Level> EnumAllLevel() {
    foreach (var id in rootIncarnation.incarnationsLevel.Keys) {
      yield return GetLevel(id);
    }
  }
  public void CheckHasLevel(Level thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasLevel(thing.id);
  }
  public void CheckHasLevel(int id) {
    if (!rootIncarnation.incarnationsLevel.ContainsKey(id)) {
      throw new System.Exception("Invalid Level: " + id);
    }
  }
  public void AddLevelObserver(int id, ILevelEffectObserver observer) {
    List<ILevelEffectObserver> obsies;
    if (!observersForLevel.TryGetValue(id, out obsies)) {
      obsies = new List<ILevelEffectObserver>();
    }
    obsies.Add(observer);
    observersForLevel[id] = obsies;
  }

  public void RemoveLevelObserver(int id, ILevelEffectObserver observer) {
    if (observersForLevel.ContainsKey(id)) {
      var list = observersForLevel[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForLevel.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public Level EffectLevelCreate(
      Terrain terrain,
      UnitMutSet units,
      int depth,
      ILevelController controller,
      int time) {
    CheckUnlocked();
    CheckHasTerrain(terrain);
    CheckHasUnitMutSet(units);

    var id = NewId();
    var incarnation =
        new LevelIncarnation(
            terrain.id,
            units.id,
            depth,
            controller.id,
            time
            );
    EffectInternalCreateLevel(id, rootIncarnation.version, incarnation);
    return new Level(this, id);
  }
  public void EffectInternalCreateLevel(
      int id,
      int incarnationVersion,
      LevelIncarnation incarnation) {
    CheckUnlocked();
    var effect = new LevelCreateEffect(id);
    rootIncarnation.incarnationsLevel.Add(
        id,
        new VersionAndIncarnation<LevelIncarnation>(
            incarnationVersion,
            incarnation));
    effectsLevelCreateEffect.Add(effect);
  }

  public void EffectLevelDelete(int id) {
    CheckUnlocked();
    var effect = new LevelDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsLevel[id];

    rootIncarnation.incarnationsLevel.Remove(id);
    effectsLevelDeleteEffect.Add(effect);
  }

     
  public int GetLevelHash(int id, int version, LevelIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.terrain.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.units.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.depth.GetDeterministicHashCode();
    if (!object.ReferenceEquals(incarnation.controller, null)) {
      result += id * version * 4 * incarnation.controller.GetDeterministicHashCode();
    }
    result += id * version * 5 * incarnation.time.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastLevelEffects(
      SortedDictionary<int, List<ILevelEffectObserver>> observers) {
    foreach (var effect in effectsLevelDeleteEffect) {
      if (observers.TryGetValue(0, out List<ILevelEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnLevelEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ILevelEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnLevelEffect(effect);
        }
        observersForLevel.Remove(effect.id);
      }
    }
    effectsLevelDeleteEffect.Clear();


    foreach (var effect in effectsLevelSetControllerEffect) {
      if (observers.TryGetValue(0, out List<ILevelEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnLevelEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ILevelEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnLevelEffect(effect);
        }
      }
    }
    effectsLevelSetControllerEffect.Clear();

    foreach (var effect in effectsLevelSetTimeEffect) {
      if (observers.TryGetValue(0, out List<ILevelEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnLevelEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ILevelEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnLevelEffect(effect);
        }
      }
    }
    effectsLevelSetTimeEffect.Clear();

    foreach (var effect in effectsLevelCreateEffect) {
      if (observers.TryGetValue(0, out List<ILevelEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnLevelEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ILevelEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnLevelEffect(effect);
        }
      }
    }
    effectsLevelCreateEffect.Clear();
  }

  public void EffectLevelSetController(int id, ILevelController newValue) {
    CheckUnlocked();
    CheckHasLevel(id);
    var effect = new LevelSetControllerEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsLevel[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldId = oldIncarnationAndVersion.incarnation.controller;
      oldIncarnationAndVersion.incarnation.controller = newValue.id;

    } else {
      var newIncarnation =
          new LevelIncarnation(
              oldIncarnationAndVersion.incarnation.terrain,
              oldIncarnationAndVersion.incarnation.units,
              oldIncarnationAndVersion.incarnation.depth,
              newValue.id,
              oldIncarnationAndVersion.incarnation.time);
      rootIncarnation.incarnationsLevel[id] =
          new VersionAndIncarnation<LevelIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsLevelSetControllerEffect.Add(effect);
  }

  public void EffectLevelSetTime(int id, int newValue) {
    CheckUnlocked();
    CheckHasLevel(id);
    var effect = new LevelSetTimeEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsLevel[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.time;
      oldIncarnationAndVersion.incarnation.time = newValue;

    } else {
      var newIncarnation =
          new LevelIncarnation(
              oldIncarnationAndVersion.incarnation.terrain,
              oldIncarnationAndVersion.incarnation.units,
              oldIncarnationAndVersion.incarnation.depth,
              oldIncarnationAndVersion.incarnation.controller,
              newValue);
      rootIncarnation.incarnationsLevel[id] =
          new VersionAndIncarnation<LevelIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsLevelSetTimeEffect.Add(effect);
  }
  public TimeAnchorTTCIncarnation GetTimeAnchorTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTimeAnchorTTC[id].incarnation;
  }
  public bool TimeAnchorTTCExists(int id) {
    return rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(id);
  }
  public TimeAnchorTTC GetTimeAnchorTTC(int id) {
    return new TimeAnchorTTC(this, id);
  }
  public List<TimeAnchorTTC> AllTimeAnchorTTC() {
    List<TimeAnchorTTC> result = new List<TimeAnchorTTC>(rootIncarnation.incarnationsTimeAnchorTTC.Count);
    foreach (var id in rootIncarnation.incarnationsTimeAnchorTTC.Keys) {
      result.Add(new TimeAnchorTTC(this, id));
    }
    return result;
  }
  public IEnumerator<TimeAnchorTTC> EnumAllTimeAnchorTTC() {
    foreach (var id in rootIncarnation.incarnationsTimeAnchorTTC.Keys) {
      yield return GetTimeAnchorTTC(id);
    }
  }
  public void CheckHasTimeAnchorTTC(TimeAnchorTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTimeAnchorTTC(thing.id);
  }
  public void CheckHasTimeAnchorTTC(int id) {
    if (!rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid TimeAnchorTTC: " + id);
    }
  }
  public void AddTimeAnchorTTCObserver(int id, ITimeAnchorTTCEffectObserver observer) {
    List<ITimeAnchorTTCEffectObserver> obsies;
    if (!observersForTimeAnchorTTC.TryGetValue(id, out obsies)) {
      obsies = new List<ITimeAnchorTTCEffectObserver>();
    }
    obsies.Add(observer);
    observersForTimeAnchorTTC[id] = obsies;
  }

  public void RemoveTimeAnchorTTCObserver(int id, ITimeAnchorTTCEffectObserver observer) {
    if (observersForTimeAnchorTTC.ContainsKey(id)) {
      var list = observersForTimeAnchorTTC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForTimeAnchorTTC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public TimeAnchorTTC EffectTimeAnchorTTCCreate(
      int pastVersion) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new TimeAnchorTTCIncarnation(
            pastVersion
            );
    EffectInternalCreateTimeAnchorTTC(id, rootIncarnation.version, incarnation);
    return new TimeAnchorTTC(this, id);
  }
  public void EffectInternalCreateTimeAnchorTTC(
      int id,
      int incarnationVersion,
      TimeAnchorTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new TimeAnchorTTCCreateEffect(id);
    rootIncarnation.incarnationsTimeAnchorTTC.Add(
        id,
        new VersionAndIncarnation<TimeAnchorTTCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsTimeAnchorTTCCreateEffect.Add(effect);
  }

  public void EffectTimeAnchorTTCDelete(int id) {
    CheckUnlocked();
    var effect = new TimeAnchorTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTimeAnchorTTC[id];

    rootIncarnation.incarnationsTimeAnchorTTC.Remove(id);
    effectsTimeAnchorTTCDeleteEffect.Add(effect);
  }

     
  public int GetTimeAnchorTTCHash(int id, int version, TimeAnchorTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.pastVersion.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastTimeAnchorTTCEffects(
      SortedDictionary<int, List<ITimeAnchorTTCEffectObserver>> observers) {
    foreach (var effect in effectsTimeAnchorTTCDeleteEffect) {
      if (observers.TryGetValue(0, out List<ITimeAnchorTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTimeAnchorTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITimeAnchorTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTimeAnchorTTCEffect(effect);
        }
        observersForTimeAnchorTTC.Remove(effect.id);
      }
    }
    effectsTimeAnchorTTCDeleteEffect.Clear();


    foreach (var effect in effectsTimeAnchorTTCCreateEffect) {
      if (observers.TryGetValue(0, out List<ITimeAnchorTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTimeAnchorTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITimeAnchorTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTimeAnchorTTCEffect(effect);
        }
      }
    }
    effectsTimeAnchorTTCCreateEffect.Clear();
  }
  public TerrainTileIncarnation GetTerrainTileIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTerrainTile[id].incarnation;
  }
  public bool TerrainTileExists(int id) {
    return rootIncarnation.incarnationsTerrainTile.ContainsKey(id);
  }
  public TerrainTile GetTerrainTile(int id) {
    return new TerrainTile(this, id);
  }
  public List<TerrainTile> AllTerrainTile() {
    List<TerrainTile> result = new List<TerrainTile>(rootIncarnation.incarnationsTerrainTile.Count);
    foreach (var id in rootIncarnation.incarnationsTerrainTile.Keys) {
      result.Add(new TerrainTile(this, id));
    }
    return result;
  }
  public IEnumerator<TerrainTile> EnumAllTerrainTile() {
    foreach (var id in rootIncarnation.incarnationsTerrainTile.Keys) {
      yield return GetTerrainTile(id);
    }
  }
  public void CheckHasTerrainTile(TerrainTile thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTerrainTile(thing.id);
  }
  public void CheckHasTerrainTile(int id) {
    if (!rootIncarnation.incarnationsTerrainTile.ContainsKey(id)) {
      throw new System.Exception("Invalid TerrainTile: " + id);
    }
  }
  public void AddTerrainTileObserver(int id, ITerrainTileEffectObserver observer) {
    List<ITerrainTileEffectObserver> obsies;
    if (!observersForTerrainTile.TryGetValue(id, out obsies)) {
      obsies = new List<ITerrainTileEffectObserver>();
    }
    obsies.Add(observer);
    observersForTerrainTile[id] = obsies;
  }

  public void RemoveTerrainTileObserver(int id, ITerrainTileEffectObserver observer) {
    if (observersForTerrainTile.ContainsKey(id)) {
      var list = observersForTerrainTile[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForTerrainTile.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public TerrainTile EffectTerrainTileCreate(
      int elevation,
      ITerrainTileComponentMutBunch components) {
    CheckUnlocked();
    CheckHasITerrainTileComponentMutBunch(components);

    var id = NewId();
    var incarnation =
        new TerrainTileIncarnation(
            elevation,
            components.id
            );
    EffectInternalCreateTerrainTile(id, rootIncarnation.version, incarnation);
    return new TerrainTile(this, id);
  }
  public void EffectInternalCreateTerrainTile(
      int id,
      int incarnationVersion,
      TerrainTileIncarnation incarnation) {
    CheckUnlocked();
    var effect = new TerrainTileCreateEffect(id);
    rootIncarnation.incarnationsTerrainTile.Add(
        id,
        new VersionAndIncarnation<TerrainTileIncarnation>(
            incarnationVersion,
            incarnation));
    effectsTerrainTileCreateEffect.Add(effect);
  }

  public void EffectTerrainTileDelete(int id) {
    CheckUnlocked();
    var effect = new TerrainTileDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTerrainTile[id];

    rootIncarnation.incarnationsTerrainTile.Remove(id);
    effectsTerrainTileDeleteEffect.Add(effect);
  }

     
  public int GetTerrainTileHash(int id, int version, TerrainTileIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.elevation.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.components.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastTerrainTileEffects(
      SortedDictionary<int, List<ITerrainTileEffectObserver>> observers) {
    foreach (var effect in effectsTerrainTileDeleteEffect) {
      if (observers.TryGetValue(0, out List<ITerrainTileEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTerrainTileEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITerrainTileEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTerrainTileEffect(effect);
        }
        observersForTerrainTile.Remove(effect.id);
      }
    }
    effectsTerrainTileDeleteEffect.Clear();


    foreach (var effect in effectsTerrainTileSetElevationEffect) {
      if (observers.TryGetValue(0, out List<ITerrainTileEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTerrainTileEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITerrainTileEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTerrainTileEffect(effect);
        }
      }
    }
    effectsTerrainTileSetElevationEffect.Clear();

    foreach (var effect in effectsTerrainTileCreateEffect) {
      if (observers.TryGetValue(0, out List<ITerrainTileEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTerrainTileEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITerrainTileEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTerrainTileEffect(effect);
        }
      }
    }
    effectsTerrainTileCreateEffect.Clear();
  }

  public void EffectTerrainTileSetElevation(int id, int newValue) {
    CheckUnlocked();
    CheckHasTerrainTile(id);
    var effect = new TerrainTileSetElevationEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsTerrainTile[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.elevation;
      oldIncarnationAndVersion.incarnation.elevation = newValue;

    } else {
      var newIncarnation =
          new TerrainTileIncarnation(
              newValue,
              oldIncarnationAndVersion.incarnation.components);
      rootIncarnation.incarnationsTerrainTile[id] =
          new VersionAndIncarnation<TerrainTileIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsTerrainTileSetElevationEffect.Add(effect);
  }
  public ITerrainTileComponentMutBunchIncarnation GetITerrainTileComponentMutBunchIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsITerrainTileComponentMutBunch[id].incarnation;
  }
  public bool ITerrainTileComponentMutBunchExists(int id) {
    return rootIncarnation.incarnationsITerrainTileComponentMutBunch.ContainsKey(id);
  }
  public ITerrainTileComponentMutBunch GetITerrainTileComponentMutBunch(int id) {
    return new ITerrainTileComponentMutBunch(this, id);
  }
  public List<ITerrainTileComponentMutBunch> AllITerrainTileComponentMutBunch() {
    List<ITerrainTileComponentMutBunch> result = new List<ITerrainTileComponentMutBunch>(rootIncarnation.incarnationsITerrainTileComponentMutBunch.Count);
    foreach (var id in rootIncarnation.incarnationsITerrainTileComponentMutBunch.Keys) {
      result.Add(new ITerrainTileComponentMutBunch(this, id));
    }
    return result;
  }
  public IEnumerator<ITerrainTileComponentMutBunch> EnumAllITerrainTileComponentMutBunch() {
    foreach (var id in rootIncarnation.incarnationsITerrainTileComponentMutBunch.Keys) {
      yield return GetITerrainTileComponentMutBunch(id);
    }
  }
  public void CheckHasITerrainTileComponentMutBunch(ITerrainTileComponentMutBunch thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasITerrainTileComponentMutBunch(thing.id);
  }
  public void CheckHasITerrainTileComponentMutBunch(int id) {
    if (!rootIncarnation.incarnationsITerrainTileComponentMutBunch.ContainsKey(id)) {
      throw new System.Exception("Invalid ITerrainTileComponentMutBunch: " + id);
    }
  }
  public void AddITerrainTileComponentMutBunchObserver(int id, IITerrainTileComponentMutBunchEffectObserver observer) {
    List<IITerrainTileComponentMutBunchEffectObserver> obsies;
    if (!observersForITerrainTileComponentMutBunch.TryGetValue(id, out obsies)) {
      obsies = new List<IITerrainTileComponentMutBunchEffectObserver>();
    }
    obsies.Add(observer);
    observersForITerrainTileComponentMutBunch[id] = obsies;
  }

  public void RemoveITerrainTileComponentMutBunchObserver(int id, IITerrainTileComponentMutBunchEffectObserver observer) {
    if (observersForITerrainTileComponentMutBunch.ContainsKey(id)) {
      var list = observersForITerrainTileComponentMutBunch[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForITerrainTileComponentMutBunch.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public ITerrainTileComponentMutBunch EffectITerrainTileComponentMutBunchCreate(
      ArmorMutSet membersArmorMutSet,
      InertiaRingMutSet membersInertiaRingMutSet,
      GlaiveMutSet membersGlaiveMutSet,
      ManaPotionMutSet membersManaPotionMutSet,
      HealthPotionMutSet membersHealthPotionMutSet,
      TimeAnchorTTCMutSet membersTimeAnchorTTCMutSet,
      StaircaseTTCMutSet membersStaircaseTTCMutSet,
      WallTTCMutSet membersWallTTCMutSet,
      BloodTTCMutSet membersBloodTTCMutSet,
      RocksTTCMutSet membersRocksTTCMutSet,
      DownstairsTTCMutSet membersDownstairsTTCMutSet,
      UpstairsTTCMutSet membersUpstairsTTCMutSet,
      CaveTTCMutSet membersCaveTTCMutSet,
      FallsTTCMutSet membersFallsTTCMutSet,
      MagmaTTCMutSet membersMagmaTTCMutSet,
      CliffTTCMutSet membersCliffTTCMutSet,
      RavaNestTTCMutSet membersRavaNestTTCMutSet,
      CliffLandingTTCMutSet membersCliffLandingTTCMutSet,
      StoneTTCMutSet membersStoneTTCMutSet,
      GrassTTCMutSet membersGrassTTCMutSet) {
    CheckUnlocked();
    CheckHasArmorMutSet(membersArmorMutSet);
    CheckHasInertiaRingMutSet(membersInertiaRingMutSet);
    CheckHasGlaiveMutSet(membersGlaiveMutSet);
    CheckHasManaPotionMutSet(membersManaPotionMutSet);
    CheckHasHealthPotionMutSet(membersHealthPotionMutSet);
    CheckHasTimeAnchorTTCMutSet(membersTimeAnchorTTCMutSet);
    CheckHasStaircaseTTCMutSet(membersStaircaseTTCMutSet);
    CheckHasWallTTCMutSet(membersWallTTCMutSet);
    CheckHasBloodTTCMutSet(membersBloodTTCMutSet);
    CheckHasRocksTTCMutSet(membersRocksTTCMutSet);
    CheckHasDownstairsTTCMutSet(membersDownstairsTTCMutSet);
    CheckHasUpstairsTTCMutSet(membersUpstairsTTCMutSet);
    CheckHasCaveTTCMutSet(membersCaveTTCMutSet);
    CheckHasFallsTTCMutSet(membersFallsTTCMutSet);
    CheckHasMagmaTTCMutSet(membersMagmaTTCMutSet);
    CheckHasCliffTTCMutSet(membersCliffTTCMutSet);
    CheckHasRavaNestTTCMutSet(membersRavaNestTTCMutSet);
    CheckHasCliffLandingTTCMutSet(membersCliffLandingTTCMutSet);
    CheckHasStoneTTCMutSet(membersStoneTTCMutSet);
    CheckHasGrassTTCMutSet(membersGrassTTCMutSet);

    var id = NewId();
    var incarnation =
        new ITerrainTileComponentMutBunchIncarnation(
            membersArmorMutSet.id,
            membersInertiaRingMutSet.id,
            membersGlaiveMutSet.id,
            membersManaPotionMutSet.id,
            membersHealthPotionMutSet.id,
            membersTimeAnchorTTCMutSet.id,
            membersStaircaseTTCMutSet.id,
            membersWallTTCMutSet.id,
            membersBloodTTCMutSet.id,
            membersRocksTTCMutSet.id,
            membersDownstairsTTCMutSet.id,
            membersUpstairsTTCMutSet.id,
            membersCaveTTCMutSet.id,
            membersFallsTTCMutSet.id,
            membersMagmaTTCMutSet.id,
            membersCliffTTCMutSet.id,
            membersRavaNestTTCMutSet.id,
            membersCliffLandingTTCMutSet.id,
            membersStoneTTCMutSet.id,
            membersGrassTTCMutSet.id
            );
    EffectInternalCreateITerrainTileComponentMutBunch(id, rootIncarnation.version, incarnation);
    return new ITerrainTileComponentMutBunch(this, id);
  }
  public void EffectInternalCreateITerrainTileComponentMutBunch(
      int id,
      int incarnationVersion,
      ITerrainTileComponentMutBunchIncarnation incarnation) {
    CheckUnlocked();
    var effect = new ITerrainTileComponentMutBunchCreateEffect(id);
    rootIncarnation.incarnationsITerrainTileComponentMutBunch.Add(
        id,
        new VersionAndIncarnation<ITerrainTileComponentMutBunchIncarnation>(
            incarnationVersion,
            incarnation));
    effectsITerrainTileComponentMutBunchCreateEffect.Add(effect);
  }

  public void EffectITerrainTileComponentMutBunchDelete(int id) {
    CheckUnlocked();
    var effect = new ITerrainTileComponentMutBunchDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsITerrainTileComponentMutBunch[id];

    rootIncarnation.incarnationsITerrainTileComponentMutBunch.Remove(id);
    effectsITerrainTileComponentMutBunchDeleteEffect.Add(effect);
  }

     
  public int GetITerrainTileComponentMutBunchHash(int id, int version, ITerrainTileComponentMutBunchIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.membersArmorMutSet.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.membersInertiaRingMutSet.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.membersGlaiveMutSet.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.membersManaPotionMutSet.GetDeterministicHashCode();
    result += id * version * 5 * incarnation.membersHealthPotionMutSet.GetDeterministicHashCode();
    result += id * version * 6 * incarnation.membersTimeAnchorTTCMutSet.GetDeterministicHashCode();
    result += id * version * 7 * incarnation.membersStaircaseTTCMutSet.GetDeterministicHashCode();
    result += id * version * 8 * incarnation.membersWallTTCMutSet.GetDeterministicHashCode();
    result += id * version * 9 * incarnation.membersBloodTTCMutSet.GetDeterministicHashCode();
    result += id * version * 10 * incarnation.membersRocksTTCMutSet.GetDeterministicHashCode();
    result += id * version * 11 * incarnation.membersDownstairsTTCMutSet.GetDeterministicHashCode();
    result += id * version * 12 * incarnation.membersUpstairsTTCMutSet.GetDeterministicHashCode();
    result += id * version * 13 * incarnation.membersCaveTTCMutSet.GetDeterministicHashCode();
    result += id * version * 14 * incarnation.membersFallsTTCMutSet.GetDeterministicHashCode();
    result += id * version * 15 * incarnation.membersMagmaTTCMutSet.GetDeterministicHashCode();
    result += id * version * 16 * incarnation.membersCliffTTCMutSet.GetDeterministicHashCode();
    result += id * version * 17 * incarnation.membersRavaNestTTCMutSet.GetDeterministicHashCode();
    result += id * version * 18 * incarnation.membersCliffLandingTTCMutSet.GetDeterministicHashCode();
    result += id * version * 19 * incarnation.membersStoneTTCMutSet.GetDeterministicHashCode();
    result += id * version * 20 * incarnation.membersGrassTTCMutSet.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastITerrainTileComponentMutBunchEffects(
      SortedDictionary<int, List<IITerrainTileComponentMutBunchEffectObserver>> observers) {
    foreach (var effect in effectsITerrainTileComponentMutBunchDeleteEffect) {
      if (observers.TryGetValue(0, out List<IITerrainTileComponentMutBunchEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnITerrainTileComponentMutBunchEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IITerrainTileComponentMutBunchEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnITerrainTileComponentMutBunchEffect(effect);
        }
        observersForITerrainTileComponentMutBunch.Remove(effect.id);
      }
    }
    effectsITerrainTileComponentMutBunchDeleteEffect.Clear();


    foreach (var effect in effectsITerrainTileComponentMutBunchCreateEffect) {
      if (observers.TryGetValue(0, out List<IITerrainTileComponentMutBunchEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnITerrainTileComponentMutBunchEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IITerrainTileComponentMutBunchEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnITerrainTileComponentMutBunchEffect(effect);
        }
      }
    }
    effectsITerrainTileComponentMutBunchCreateEffect.Clear();
  }
  public TerrainIncarnation GetTerrainIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTerrain[id].incarnation;
  }
  public bool TerrainExists(int id) {
    return rootIncarnation.incarnationsTerrain.ContainsKey(id);
  }
  public Terrain GetTerrain(int id) {
    return new Terrain(this, id);
  }
  public List<Terrain> AllTerrain() {
    List<Terrain> result = new List<Terrain>(rootIncarnation.incarnationsTerrain.Count);
    foreach (var id in rootIncarnation.incarnationsTerrain.Keys) {
      result.Add(new Terrain(this, id));
    }
    return result;
  }
  public IEnumerator<Terrain> EnumAllTerrain() {
    foreach (var id in rootIncarnation.incarnationsTerrain.Keys) {
      yield return GetTerrain(id);
    }
  }
  public void CheckHasTerrain(Terrain thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTerrain(thing.id);
  }
  public void CheckHasTerrain(int id) {
    if (!rootIncarnation.incarnationsTerrain.ContainsKey(id)) {
      throw new System.Exception("Invalid Terrain: " + id);
    }
  }
  public void AddTerrainObserver(int id, ITerrainEffectObserver observer) {
    List<ITerrainEffectObserver> obsies;
    if (!observersForTerrain.TryGetValue(id, out obsies)) {
      obsies = new List<ITerrainEffectObserver>();
    }
    obsies.Add(observer);
    observersForTerrain[id] = obsies;
  }

  public void RemoveTerrainObserver(int id, ITerrainEffectObserver observer) {
    if (observersForTerrain.ContainsKey(id)) {
      var list = observersForTerrain[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForTerrain.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public Terrain EffectTerrainCreate(
      Pattern pattern,
      float elevationStepHeight,
      TerrainTileByLocationMutMap tiles) {
    CheckUnlocked();
    CheckHasTerrainTileByLocationMutMap(tiles);

    var id = NewId();
    var incarnation =
        new TerrainIncarnation(
            pattern,
            elevationStepHeight,
            tiles.id
            );
    EffectInternalCreateTerrain(id, rootIncarnation.version, incarnation);
    return new Terrain(this, id);
  }
  public void EffectInternalCreateTerrain(
      int id,
      int incarnationVersion,
      TerrainIncarnation incarnation) {
    CheckUnlocked();
    var effect = new TerrainCreateEffect(id);
    rootIncarnation.incarnationsTerrain.Add(
        id,
        new VersionAndIncarnation<TerrainIncarnation>(
            incarnationVersion,
            incarnation));
    effectsTerrainCreateEffect.Add(effect);
  }

  public void EffectTerrainDelete(int id) {
    CheckUnlocked();
    var effect = new TerrainDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTerrain[id];

    rootIncarnation.incarnationsTerrain.Remove(id);
    effectsTerrainDeleteEffect.Add(effect);
  }

     
  public int GetTerrainHash(int id, int version, TerrainIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.pattern.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.elevationStepHeight.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.tiles.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastTerrainEffects(
      SortedDictionary<int, List<ITerrainEffectObserver>> observers) {
    foreach (var effect in effectsTerrainDeleteEffect) {
      if (observers.TryGetValue(0, out List<ITerrainEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTerrainEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITerrainEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTerrainEffect(effect);
        }
        observersForTerrain.Remove(effect.id);
      }
    }
    effectsTerrainDeleteEffect.Clear();


    foreach (var effect in effectsTerrainSetPatternEffect) {
      if (observers.TryGetValue(0, out List<ITerrainEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTerrainEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITerrainEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTerrainEffect(effect);
        }
      }
    }
    effectsTerrainSetPatternEffect.Clear();

    foreach (var effect in effectsTerrainCreateEffect) {
      if (observers.TryGetValue(0, out List<ITerrainEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTerrainEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITerrainEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTerrainEffect(effect);
        }
      }
    }
    effectsTerrainCreateEffect.Clear();
  }

  public void EffectTerrainSetPattern(int id, Pattern newValue) {
    CheckUnlocked();
    CheckHasTerrain(id);
    var effect = new TerrainSetPatternEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsTerrain[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.pattern;
      oldIncarnationAndVersion.incarnation.pattern = newValue;

    } else {
      var newIncarnation =
          new TerrainIncarnation(
              newValue,
              oldIncarnationAndVersion.incarnation.elevationStepHeight,
              oldIncarnationAndVersion.incarnation.tiles);
      rootIncarnation.incarnationsTerrain[id] =
          new VersionAndIncarnation<TerrainIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsTerrainSetPatternEffect.Add(effect);
  }
  public StaircaseTTCIncarnation GetStaircaseTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsStaircaseTTC[id].incarnation;
  }
  public bool StaircaseTTCExists(int id) {
    return rootIncarnation.incarnationsStaircaseTTC.ContainsKey(id);
  }
  public StaircaseTTC GetStaircaseTTC(int id) {
    return new StaircaseTTC(this, id);
  }
  public List<StaircaseTTC> AllStaircaseTTC() {
    List<StaircaseTTC> result = new List<StaircaseTTC>(rootIncarnation.incarnationsStaircaseTTC.Count);
    foreach (var id in rootIncarnation.incarnationsStaircaseTTC.Keys) {
      result.Add(new StaircaseTTC(this, id));
    }
    return result;
  }
  public IEnumerator<StaircaseTTC> EnumAllStaircaseTTC() {
    foreach (var id in rootIncarnation.incarnationsStaircaseTTC.Keys) {
      yield return GetStaircaseTTC(id);
    }
  }
  public void CheckHasStaircaseTTC(StaircaseTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasStaircaseTTC(thing.id);
  }
  public void CheckHasStaircaseTTC(int id) {
    if (!rootIncarnation.incarnationsStaircaseTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid StaircaseTTC: " + id);
    }
  }
  public void AddStaircaseTTCObserver(int id, IStaircaseTTCEffectObserver observer) {
    List<IStaircaseTTCEffectObserver> obsies;
    if (!observersForStaircaseTTC.TryGetValue(id, out obsies)) {
      obsies = new List<IStaircaseTTCEffectObserver>();
    }
    obsies.Add(observer);
    observersForStaircaseTTC[id] = obsies;
  }

  public void RemoveStaircaseTTCObserver(int id, IStaircaseTTCEffectObserver observer) {
    if (observersForStaircaseTTC.ContainsKey(id)) {
      var list = observersForStaircaseTTC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForStaircaseTTC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public StaircaseTTC EffectStaircaseTTCCreate(
      int portalIndex,
      Level destinationLevel,
      int destinationLevelPortalIndex) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new StaircaseTTCIncarnation(
            portalIndex,
            destinationLevel.id,
            destinationLevelPortalIndex
            );
    EffectInternalCreateStaircaseTTC(id, rootIncarnation.version, incarnation);
    return new StaircaseTTC(this, id);
  }
  public void EffectInternalCreateStaircaseTTC(
      int id,
      int incarnationVersion,
      StaircaseTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new StaircaseTTCCreateEffect(id);
    rootIncarnation.incarnationsStaircaseTTC.Add(
        id,
        new VersionAndIncarnation<StaircaseTTCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsStaircaseTTCCreateEffect.Add(effect);
  }

  public void EffectStaircaseTTCDelete(int id) {
    CheckUnlocked();
    var effect = new StaircaseTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsStaircaseTTC[id];

    rootIncarnation.incarnationsStaircaseTTC.Remove(id);
    effectsStaircaseTTCDeleteEffect.Add(effect);
  }

     
  public int GetStaircaseTTCHash(int id, int version, StaircaseTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.portalIndex.GetDeterministicHashCode();
    if (!object.ReferenceEquals(incarnation.destinationLevel, null)) {
      result += id * version * 2 * incarnation.destinationLevel.GetDeterministicHashCode();
    }
    result += id * version * 3 * incarnation.destinationLevelPortalIndex.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastStaircaseTTCEffects(
      SortedDictionary<int, List<IStaircaseTTCEffectObserver>> observers) {
    foreach (var effect in effectsStaircaseTTCDeleteEffect) {
      if (observers.TryGetValue(0, out List<IStaircaseTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnStaircaseTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IStaircaseTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnStaircaseTTCEffect(effect);
        }
        observersForStaircaseTTC.Remove(effect.id);
      }
    }
    effectsStaircaseTTCDeleteEffect.Clear();


    foreach (var effect in effectsStaircaseTTCSetDestinationLevelEffect) {
      if (observers.TryGetValue(0, out List<IStaircaseTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnStaircaseTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IStaircaseTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnStaircaseTTCEffect(effect);
        }
      }
    }
    effectsStaircaseTTCSetDestinationLevelEffect.Clear();

    foreach (var effect in effectsStaircaseTTCSetDestinationLevelPortalIndexEffect) {
      if (observers.TryGetValue(0, out List<IStaircaseTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnStaircaseTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IStaircaseTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnStaircaseTTCEffect(effect);
        }
      }
    }
    effectsStaircaseTTCSetDestinationLevelPortalIndexEffect.Clear();

    foreach (var effect in effectsStaircaseTTCCreateEffect) {
      if (observers.TryGetValue(0, out List<IStaircaseTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnStaircaseTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IStaircaseTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnStaircaseTTCEffect(effect);
        }
      }
    }
    effectsStaircaseTTCCreateEffect.Clear();
  }

  public void EffectStaircaseTTCSetDestinationLevel(int id, Level newValue) {
    CheckUnlocked();
    CheckHasStaircaseTTC(id);
    var effect = new StaircaseTTCSetDestinationLevelEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsStaircaseTTC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldId = oldIncarnationAndVersion.incarnation.destinationLevel;
      oldIncarnationAndVersion.incarnation.destinationLevel = newValue.id;

    } else {
      var newIncarnation =
          new StaircaseTTCIncarnation(
              oldIncarnationAndVersion.incarnation.portalIndex,
              newValue.id,
              oldIncarnationAndVersion.incarnation.destinationLevelPortalIndex);
      rootIncarnation.incarnationsStaircaseTTC[id] =
          new VersionAndIncarnation<StaircaseTTCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsStaircaseTTCSetDestinationLevelEffect.Add(effect);
  }

  public void EffectStaircaseTTCSetDestinationLevelPortalIndex(int id, int newValue) {
    CheckUnlocked();
    CheckHasStaircaseTTC(id);
    var effect = new StaircaseTTCSetDestinationLevelPortalIndexEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsStaircaseTTC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.destinationLevelPortalIndex;
      oldIncarnationAndVersion.incarnation.destinationLevelPortalIndex = newValue;

    } else {
      var newIncarnation =
          new StaircaseTTCIncarnation(
              oldIncarnationAndVersion.incarnation.portalIndex,
              oldIncarnationAndVersion.incarnation.destinationLevel,
              newValue);
      rootIncarnation.incarnationsStaircaseTTC[id] =
          new VersionAndIncarnation<StaircaseTTCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsStaircaseTTCSetDestinationLevelPortalIndexEffect.Add(effect);
  }
  public WallTTCIncarnation GetWallTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsWallTTC[id].incarnation;
  }
  public bool WallTTCExists(int id) {
    return rootIncarnation.incarnationsWallTTC.ContainsKey(id);
  }
  public WallTTC GetWallTTC(int id) {
    return new WallTTC(this, id);
  }
  public List<WallTTC> AllWallTTC() {
    List<WallTTC> result = new List<WallTTC>(rootIncarnation.incarnationsWallTTC.Count);
    foreach (var id in rootIncarnation.incarnationsWallTTC.Keys) {
      result.Add(new WallTTC(this, id));
    }
    return result;
  }
  public IEnumerator<WallTTC> EnumAllWallTTC() {
    foreach (var id in rootIncarnation.incarnationsWallTTC.Keys) {
      yield return GetWallTTC(id);
    }
  }
  public void CheckHasWallTTC(WallTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasWallTTC(thing.id);
  }
  public void CheckHasWallTTC(int id) {
    if (!rootIncarnation.incarnationsWallTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid WallTTC: " + id);
    }
  }
  public void AddWallTTCObserver(int id, IWallTTCEffectObserver observer) {
    List<IWallTTCEffectObserver> obsies;
    if (!observersForWallTTC.TryGetValue(id, out obsies)) {
      obsies = new List<IWallTTCEffectObserver>();
    }
    obsies.Add(observer);
    observersForWallTTC[id] = obsies;
  }

  public void RemoveWallTTCObserver(int id, IWallTTCEffectObserver observer) {
    if (observersForWallTTC.ContainsKey(id)) {
      var list = observersForWallTTC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForWallTTC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public WallTTC EffectWallTTCCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new WallTTCIncarnation(

            );
    EffectInternalCreateWallTTC(id, rootIncarnation.version, incarnation);
    return new WallTTC(this, id);
  }
  public void EffectInternalCreateWallTTC(
      int id,
      int incarnationVersion,
      WallTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new WallTTCCreateEffect(id);
    rootIncarnation.incarnationsWallTTC.Add(
        id,
        new VersionAndIncarnation<WallTTCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsWallTTCCreateEffect.Add(effect);
  }

  public void EffectWallTTCDelete(int id) {
    CheckUnlocked();
    var effect = new WallTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsWallTTC[id];

    rootIncarnation.incarnationsWallTTC.Remove(id);
    effectsWallTTCDeleteEffect.Add(effect);
  }

     
  public int GetWallTTCHash(int id, int version, WallTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastWallTTCEffects(
      SortedDictionary<int, List<IWallTTCEffectObserver>> observers) {
    foreach (var effect in effectsWallTTCDeleteEffect) {
      if (observers.TryGetValue(0, out List<IWallTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnWallTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IWallTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnWallTTCEffect(effect);
        }
        observersForWallTTC.Remove(effect.id);
      }
    }
    effectsWallTTCDeleteEffect.Clear();


    foreach (var effect in effectsWallTTCCreateEffect) {
      if (observers.TryGetValue(0, out List<IWallTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnWallTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IWallTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnWallTTCEffect(effect);
        }
      }
    }
    effectsWallTTCCreateEffect.Clear();
  }
  public BloodTTCIncarnation GetBloodTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBloodTTC[id].incarnation;
  }
  public bool BloodTTCExists(int id) {
    return rootIncarnation.incarnationsBloodTTC.ContainsKey(id);
  }
  public BloodTTC GetBloodTTC(int id) {
    return new BloodTTC(this, id);
  }
  public List<BloodTTC> AllBloodTTC() {
    List<BloodTTC> result = new List<BloodTTC>(rootIncarnation.incarnationsBloodTTC.Count);
    foreach (var id in rootIncarnation.incarnationsBloodTTC.Keys) {
      result.Add(new BloodTTC(this, id));
    }
    return result;
  }
  public IEnumerator<BloodTTC> EnumAllBloodTTC() {
    foreach (var id in rootIncarnation.incarnationsBloodTTC.Keys) {
      yield return GetBloodTTC(id);
    }
  }
  public void CheckHasBloodTTC(BloodTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBloodTTC(thing.id);
  }
  public void CheckHasBloodTTC(int id) {
    if (!rootIncarnation.incarnationsBloodTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid BloodTTC: " + id);
    }
  }
  public void AddBloodTTCObserver(int id, IBloodTTCEffectObserver observer) {
    List<IBloodTTCEffectObserver> obsies;
    if (!observersForBloodTTC.TryGetValue(id, out obsies)) {
      obsies = new List<IBloodTTCEffectObserver>();
    }
    obsies.Add(observer);
    observersForBloodTTC[id] = obsies;
  }

  public void RemoveBloodTTCObserver(int id, IBloodTTCEffectObserver observer) {
    if (observersForBloodTTC.ContainsKey(id)) {
      var list = observersForBloodTTC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForBloodTTC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public BloodTTC EffectBloodTTCCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new BloodTTCIncarnation(

            );
    EffectInternalCreateBloodTTC(id, rootIncarnation.version, incarnation);
    return new BloodTTC(this, id);
  }
  public void EffectInternalCreateBloodTTC(
      int id,
      int incarnationVersion,
      BloodTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new BloodTTCCreateEffect(id);
    rootIncarnation.incarnationsBloodTTC.Add(
        id,
        new VersionAndIncarnation<BloodTTCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsBloodTTCCreateEffect.Add(effect);
  }

  public void EffectBloodTTCDelete(int id) {
    CheckUnlocked();
    var effect = new BloodTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBloodTTC[id];

    rootIncarnation.incarnationsBloodTTC.Remove(id);
    effectsBloodTTCDeleteEffect.Add(effect);
  }

     
  public int GetBloodTTCHash(int id, int version, BloodTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastBloodTTCEffects(
      SortedDictionary<int, List<IBloodTTCEffectObserver>> observers) {
    foreach (var effect in effectsBloodTTCDeleteEffect) {
      if (observers.TryGetValue(0, out List<IBloodTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnBloodTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IBloodTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnBloodTTCEffect(effect);
        }
        observersForBloodTTC.Remove(effect.id);
      }
    }
    effectsBloodTTCDeleteEffect.Clear();


    foreach (var effect in effectsBloodTTCCreateEffect) {
      if (observers.TryGetValue(0, out List<IBloodTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnBloodTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IBloodTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnBloodTTCEffect(effect);
        }
      }
    }
    effectsBloodTTCCreateEffect.Clear();
  }
  public RocksTTCIncarnation GetRocksTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsRocksTTC[id].incarnation;
  }
  public bool RocksTTCExists(int id) {
    return rootIncarnation.incarnationsRocksTTC.ContainsKey(id);
  }
  public RocksTTC GetRocksTTC(int id) {
    return new RocksTTC(this, id);
  }
  public List<RocksTTC> AllRocksTTC() {
    List<RocksTTC> result = new List<RocksTTC>(rootIncarnation.incarnationsRocksTTC.Count);
    foreach (var id in rootIncarnation.incarnationsRocksTTC.Keys) {
      result.Add(new RocksTTC(this, id));
    }
    return result;
  }
  public IEnumerator<RocksTTC> EnumAllRocksTTC() {
    foreach (var id in rootIncarnation.incarnationsRocksTTC.Keys) {
      yield return GetRocksTTC(id);
    }
  }
  public void CheckHasRocksTTC(RocksTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasRocksTTC(thing.id);
  }
  public void CheckHasRocksTTC(int id) {
    if (!rootIncarnation.incarnationsRocksTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid RocksTTC: " + id);
    }
  }
  public void AddRocksTTCObserver(int id, IRocksTTCEffectObserver observer) {
    List<IRocksTTCEffectObserver> obsies;
    if (!observersForRocksTTC.TryGetValue(id, out obsies)) {
      obsies = new List<IRocksTTCEffectObserver>();
    }
    obsies.Add(observer);
    observersForRocksTTC[id] = obsies;
  }

  public void RemoveRocksTTCObserver(int id, IRocksTTCEffectObserver observer) {
    if (observersForRocksTTC.ContainsKey(id)) {
      var list = observersForRocksTTC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForRocksTTC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public RocksTTC EffectRocksTTCCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new RocksTTCIncarnation(

            );
    EffectInternalCreateRocksTTC(id, rootIncarnation.version, incarnation);
    return new RocksTTC(this, id);
  }
  public void EffectInternalCreateRocksTTC(
      int id,
      int incarnationVersion,
      RocksTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new RocksTTCCreateEffect(id);
    rootIncarnation.incarnationsRocksTTC.Add(
        id,
        new VersionAndIncarnation<RocksTTCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsRocksTTCCreateEffect.Add(effect);
  }

  public void EffectRocksTTCDelete(int id) {
    CheckUnlocked();
    var effect = new RocksTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsRocksTTC[id];

    rootIncarnation.incarnationsRocksTTC.Remove(id);
    effectsRocksTTCDeleteEffect.Add(effect);
  }

     
  public int GetRocksTTCHash(int id, int version, RocksTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastRocksTTCEffects(
      SortedDictionary<int, List<IRocksTTCEffectObserver>> observers) {
    foreach (var effect in effectsRocksTTCDeleteEffect) {
      if (observers.TryGetValue(0, out List<IRocksTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnRocksTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IRocksTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnRocksTTCEffect(effect);
        }
        observersForRocksTTC.Remove(effect.id);
      }
    }
    effectsRocksTTCDeleteEffect.Clear();


    foreach (var effect in effectsRocksTTCCreateEffect) {
      if (observers.TryGetValue(0, out List<IRocksTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnRocksTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IRocksTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnRocksTTCEffect(effect);
        }
      }
    }
    effectsRocksTTCCreateEffect.Clear();
  }
  public DownstairsTTCIncarnation GetDownstairsTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsDownstairsTTC[id].incarnation;
  }
  public bool DownstairsTTCExists(int id) {
    return rootIncarnation.incarnationsDownstairsTTC.ContainsKey(id);
  }
  public DownstairsTTC GetDownstairsTTC(int id) {
    return new DownstairsTTC(this, id);
  }
  public List<DownstairsTTC> AllDownstairsTTC() {
    List<DownstairsTTC> result = new List<DownstairsTTC>(rootIncarnation.incarnationsDownstairsTTC.Count);
    foreach (var id in rootIncarnation.incarnationsDownstairsTTC.Keys) {
      result.Add(new DownstairsTTC(this, id));
    }
    return result;
  }
  public IEnumerator<DownstairsTTC> EnumAllDownstairsTTC() {
    foreach (var id in rootIncarnation.incarnationsDownstairsTTC.Keys) {
      yield return GetDownstairsTTC(id);
    }
  }
  public void CheckHasDownstairsTTC(DownstairsTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasDownstairsTTC(thing.id);
  }
  public void CheckHasDownstairsTTC(int id) {
    if (!rootIncarnation.incarnationsDownstairsTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid DownstairsTTC: " + id);
    }
  }
  public void AddDownstairsTTCObserver(int id, IDownstairsTTCEffectObserver observer) {
    List<IDownstairsTTCEffectObserver> obsies;
    if (!observersForDownstairsTTC.TryGetValue(id, out obsies)) {
      obsies = new List<IDownstairsTTCEffectObserver>();
    }
    obsies.Add(observer);
    observersForDownstairsTTC[id] = obsies;
  }

  public void RemoveDownstairsTTCObserver(int id, IDownstairsTTCEffectObserver observer) {
    if (observersForDownstairsTTC.ContainsKey(id)) {
      var list = observersForDownstairsTTC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForDownstairsTTC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public DownstairsTTC EffectDownstairsTTCCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new DownstairsTTCIncarnation(

            );
    EffectInternalCreateDownstairsTTC(id, rootIncarnation.version, incarnation);
    return new DownstairsTTC(this, id);
  }
  public void EffectInternalCreateDownstairsTTC(
      int id,
      int incarnationVersion,
      DownstairsTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new DownstairsTTCCreateEffect(id);
    rootIncarnation.incarnationsDownstairsTTC.Add(
        id,
        new VersionAndIncarnation<DownstairsTTCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsDownstairsTTCCreateEffect.Add(effect);
  }

  public void EffectDownstairsTTCDelete(int id) {
    CheckUnlocked();
    var effect = new DownstairsTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsDownstairsTTC[id];

    rootIncarnation.incarnationsDownstairsTTC.Remove(id);
    effectsDownstairsTTCDeleteEffect.Add(effect);
  }

     
  public int GetDownstairsTTCHash(int id, int version, DownstairsTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastDownstairsTTCEffects(
      SortedDictionary<int, List<IDownstairsTTCEffectObserver>> observers) {
    foreach (var effect in effectsDownstairsTTCDeleteEffect) {
      if (observers.TryGetValue(0, out List<IDownstairsTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnDownstairsTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IDownstairsTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnDownstairsTTCEffect(effect);
        }
        observersForDownstairsTTC.Remove(effect.id);
      }
    }
    effectsDownstairsTTCDeleteEffect.Clear();


    foreach (var effect in effectsDownstairsTTCCreateEffect) {
      if (observers.TryGetValue(0, out List<IDownstairsTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnDownstairsTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IDownstairsTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnDownstairsTTCEffect(effect);
        }
      }
    }
    effectsDownstairsTTCCreateEffect.Clear();
  }
  public UpstairsTTCIncarnation GetUpstairsTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsUpstairsTTC[id].incarnation;
  }
  public bool UpstairsTTCExists(int id) {
    return rootIncarnation.incarnationsUpstairsTTC.ContainsKey(id);
  }
  public UpstairsTTC GetUpstairsTTC(int id) {
    return new UpstairsTTC(this, id);
  }
  public List<UpstairsTTC> AllUpstairsTTC() {
    List<UpstairsTTC> result = new List<UpstairsTTC>(rootIncarnation.incarnationsUpstairsTTC.Count);
    foreach (var id in rootIncarnation.incarnationsUpstairsTTC.Keys) {
      result.Add(new UpstairsTTC(this, id));
    }
    return result;
  }
  public IEnumerator<UpstairsTTC> EnumAllUpstairsTTC() {
    foreach (var id in rootIncarnation.incarnationsUpstairsTTC.Keys) {
      yield return GetUpstairsTTC(id);
    }
  }
  public void CheckHasUpstairsTTC(UpstairsTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasUpstairsTTC(thing.id);
  }
  public void CheckHasUpstairsTTC(int id) {
    if (!rootIncarnation.incarnationsUpstairsTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid UpstairsTTC: " + id);
    }
  }
  public void AddUpstairsTTCObserver(int id, IUpstairsTTCEffectObserver observer) {
    List<IUpstairsTTCEffectObserver> obsies;
    if (!observersForUpstairsTTC.TryGetValue(id, out obsies)) {
      obsies = new List<IUpstairsTTCEffectObserver>();
    }
    obsies.Add(observer);
    observersForUpstairsTTC[id] = obsies;
  }

  public void RemoveUpstairsTTCObserver(int id, IUpstairsTTCEffectObserver observer) {
    if (observersForUpstairsTTC.ContainsKey(id)) {
      var list = observersForUpstairsTTC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForUpstairsTTC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public UpstairsTTC EffectUpstairsTTCCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new UpstairsTTCIncarnation(

            );
    EffectInternalCreateUpstairsTTC(id, rootIncarnation.version, incarnation);
    return new UpstairsTTC(this, id);
  }
  public void EffectInternalCreateUpstairsTTC(
      int id,
      int incarnationVersion,
      UpstairsTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new UpstairsTTCCreateEffect(id);
    rootIncarnation.incarnationsUpstairsTTC.Add(
        id,
        new VersionAndIncarnation<UpstairsTTCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsUpstairsTTCCreateEffect.Add(effect);
  }

  public void EffectUpstairsTTCDelete(int id) {
    CheckUnlocked();
    var effect = new UpstairsTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsUpstairsTTC[id];

    rootIncarnation.incarnationsUpstairsTTC.Remove(id);
    effectsUpstairsTTCDeleteEffect.Add(effect);
  }

     
  public int GetUpstairsTTCHash(int id, int version, UpstairsTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastUpstairsTTCEffects(
      SortedDictionary<int, List<IUpstairsTTCEffectObserver>> observers) {
    foreach (var effect in effectsUpstairsTTCDeleteEffect) {
      if (observers.TryGetValue(0, out List<IUpstairsTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnUpstairsTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IUpstairsTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnUpstairsTTCEffect(effect);
        }
        observersForUpstairsTTC.Remove(effect.id);
      }
    }
    effectsUpstairsTTCDeleteEffect.Clear();


    foreach (var effect in effectsUpstairsTTCCreateEffect) {
      if (observers.TryGetValue(0, out List<IUpstairsTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnUpstairsTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IUpstairsTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnUpstairsTTCEffect(effect);
        }
      }
    }
    effectsUpstairsTTCCreateEffect.Clear();
  }
  public CaveTTCIncarnation GetCaveTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCaveTTC[id].incarnation;
  }
  public bool CaveTTCExists(int id) {
    return rootIncarnation.incarnationsCaveTTC.ContainsKey(id);
  }
  public CaveTTC GetCaveTTC(int id) {
    return new CaveTTC(this, id);
  }
  public List<CaveTTC> AllCaveTTC() {
    List<CaveTTC> result = new List<CaveTTC>(rootIncarnation.incarnationsCaveTTC.Count);
    foreach (var id in rootIncarnation.incarnationsCaveTTC.Keys) {
      result.Add(new CaveTTC(this, id));
    }
    return result;
  }
  public IEnumerator<CaveTTC> EnumAllCaveTTC() {
    foreach (var id in rootIncarnation.incarnationsCaveTTC.Keys) {
      yield return GetCaveTTC(id);
    }
  }
  public void CheckHasCaveTTC(CaveTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCaveTTC(thing.id);
  }
  public void CheckHasCaveTTC(int id) {
    if (!rootIncarnation.incarnationsCaveTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid CaveTTC: " + id);
    }
  }
  public void AddCaveTTCObserver(int id, ICaveTTCEffectObserver observer) {
    List<ICaveTTCEffectObserver> obsies;
    if (!observersForCaveTTC.TryGetValue(id, out obsies)) {
      obsies = new List<ICaveTTCEffectObserver>();
    }
    obsies.Add(observer);
    observersForCaveTTC[id] = obsies;
  }

  public void RemoveCaveTTCObserver(int id, ICaveTTCEffectObserver observer) {
    if (observersForCaveTTC.ContainsKey(id)) {
      var list = observersForCaveTTC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForCaveTTC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public CaveTTC EffectCaveTTCCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new CaveTTCIncarnation(

            );
    EffectInternalCreateCaveTTC(id, rootIncarnation.version, incarnation);
    return new CaveTTC(this, id);
  }
  public void EffectInternalCreateCaveTTC(
      int id,
      int incarnationVersion,
      CaveTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new CaveTTCCreateEffect(id);
    rootIncarnation.incarnationsCaveTTC.Add(
        id,
        new VersionAndIncarnation<CaveTTCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsCaveTTCCreateEffect.Add(effect);
  }

  public void EffectCaveTTCDelete(int id) {
    CheckUnlocked();
    var effect = new CaveTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCaveTTC[id];

    rootIncarnation.incarnationsCaveTTC.Remove(id);
    effectsCaveTTCDeleteEffect.Add(effect);
  }

     
  public int GetCaveTTCHash(int id, int version, CaveTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastCaveTTCEffects(
      SortedDictionary<int, List<ICaveTTCEffectObserver>> observers) {
    foreach (var effect in effectsCaveTTCDeleteEffect) {
      if (observers.TryGetValue(0, out List<ICaveTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCaveTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICaveTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCaveTTCEffect(effect);
        }
        observersForCaveTTC.Remove(effect.id);
      }
    }
    effectsCaveTTCDeleteEffect.Clear();


    foreach (var effect in effectsCaveTTCCreateEffect) {
      if (observers.TryGetValue(0, out List<ICaveTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCaveTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICaveTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCaveTTCEffect(effect);
        }
      }
    }
    effectsCaveTTCCreateEffect.Clear();
  }
  public FallsTTCIncarnation GetFallsTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsFallsTTC[id].incarnation;
  }
  public bool FallsTTCExists(int id) {
    return rootIncarnation.incarnationsFallsTTC.ContainsKey(id);
  }
  public FallsTTC GetFallsTTC(int id) {
    return new FallsTTC(this, id);
  }
  public List<FallsTTC> AllFallsTTC() {
    List<FallsTTC> result = new List<FallsTTC>(rootIncarnation.incarnationsFallsTTC.Count);
    foreach (var id in rootIncarnation.incarnationsFallsTTC.Keys) {
      result.Add(new FallsTTC(this, id));
    }
    return result;
  }
  public IEnumerator<FallsTTC> EnumAllFallsTTC() {
    foreach (var id in rootIncarnation.incarnationsFallsTTC.Keys) {
      yield return GetFallsTTC(id);
    }
  }
  public void CheckHasFallsTTC(FallsTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasFallsTTC(thing.id);
  }
  public void CheckHasFallsTTC(int id) {
    if (!rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid FallsTTC: " + id);
    }
  }
  public void AddFallsTTCObserver(int id, IFallsTTCEffectObserver observer) {
    List<IFallsTTCEffectObserver> obsies;
    if (!observersForFallsTTC.TryGetValue(id, out obsies)) {
      obsies = new List<IFallsTTCEffectObserver>();
    }
    obsies.Add(observer);
    observersForFallsTTC[id] = obsies;
  }

  public void RemoveFallsTTCObserver(int id, IFallsTTCEffectObserver observer) {
    if (observersForFallsTTC.ContainsKey(id)) {
      var list = observersForFallsTTC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForFallsTTC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public FallsTTC EffectFallsTTCCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new FallsTTCIncarnation(

            );
    EffectInternalCreateFallsTTC(id, rootIncarnation.version, incarnation);
    return new FallsTTC(this, id);
  }
  public void EffectInternalCreateFallsTTC(
      int id,
      int incarnationVersion,
      FallsTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new FallsTTCCreateEffect(id);
    rootIncarnation.incarnationsFallsTTC.Add(
        id,
        new VersionAndIncarnation<FallsTTCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsFallsTTCCreateEffect.Add(effect);
  }

  public void EffectFallsTTCDelete(int id) {
    CheckUnlocked();
    var effect = new FallsTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsFallsTTC[id];

    rootIncarnation.incarnationsFallsTTC.Remove(id);
    effectsFallsTTCDeleteEffect.Add(effect);
  }

     
  public int GetFallsTTCHash(int id, int version, FallsTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastFallsTTCEffects(
      SortedDictionary<int, List<IFallsTTCEffectObserver>> observers) {
    foreach (var effect in effectsFallsTTCDeleteEffect) {
      if (observers.TryGetValue(0, out List<IFallsTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnFallsTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IFallsTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnFallsTTCEffect(effect);
        }
        observersForFallsTTC.Remove(effect.id);
      }
    }
    effectsFallsTTCDeleteEffect.Clear();


    foreach (var effect in effectsFallsTTCCreateEffect) {
      if (observers.TryGetValue(0, out List<IFallsTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnFallsTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IFallsTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnFallsTTCEffect(effect);
        }
      }
    }
    effectsFallsTTCCreateEffect.Clear();
  }
  public MagmaTTCIncarnation GetMagmaTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsMagmaTTC[id].incarnation;
  }
  public bool MagmaTTCExists(int id) {
    return rootIncarnation.incarnationsMagmaTTC.ContainsKey(id);
  }
  public MagmaTTC GetMagmaTTC(int id) {
    return new MagmaTTC(this, id);
  }
  public List<MagmaTTC> AllMagmaTTC() {
    List<MagmaTTC> result = new List<MagmaTTC>(rootIncarnation.incarnationsMagmaTTC.Count);
    foreach (var id in rootIncarnation.incarnationsMagmaTTC.Keys) {
      result.Add(new MagmaTTC(this, id));
    }
    return result;
  }
  public IEnumerator<MagmaTTC> EnumAllMagmaTTC() {
    foreach (var id in rootIncarnation.incarnationsMagmaTTC.Keys) {
      yield return GetMagmaTTC(id);
    }
  }
  public void CheckHasMagmaTTC(MagmaTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasMagmaTTC(thing.id);
  }
  public void CheckHasMagmaTTC(int id) {
    if (!rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid MagmaTTC: " + id);
    }
  }
  public void AddMagmaTTCObserver(int id, IMagmaTTCEffectObserver observer) {
    List<IMagmaTTCEffectObserver> obsies;
    if (!observersForMagmaTTC.TryGetValue(id, out obsies)) {
      obsies = new List<IMagmaTTCEffectObserver>();
    }
    obsies.Add(observer);
    observersForMagmaTTC[id] = obsies;
  }

  public void RemoveMagmaTTCObserver(int id, IMagmaTTCEffectObserver observer) {
    if (observersForMagmaTTC.ContainsKey(id)) {
      var list = observersForMagmaTTC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForMagmaTTC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public MagmaTTC EffectMagmaTTCCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new MagmaTTCIncarnation(

            );
    EffectInternalCreateMagmaTTC(id, rootIncarnation.version, incarnation);
    return new MagmaTTC(this, id);
  }
  public void EffectInternalCreateMagmaTTC(
      int id,
      int incarnationVersion,
      MagmaTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new MagmaTTCCreateEffect(id);
    rootIncarnation.incarnationsMagmaTTC.Add(
        id,
        new VersionAndIncarnation<MagmaTTCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsMagmaTTCCreateEffect.Add(effect);
  }

  public void EffectMagmaTTCDelete(int id) {
    CheckUnlocked();
    var effect = new MagmaTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsMagmaTTC[id];

    rootIncarnation.incarnationsMagmaTTC.Remove(id);
    effectsMagmaTTCDeleteEffect.Add(effect);
  }

     
  public int GetMagmaTTCHash(int id, int version, MagmaTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastMagmaTTCEffects(
      SortedDictionary<int, List<IMagmaTTCEffectObserver>> observers) {
    foreach (var effect in effectsMagmaTTCDeleteEffect) {
      if (observers.TryGetValue(0, out List<IMagmaTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnMagmaTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IMagmaTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnMagmaTTCEffect(effect);
        }
        observersForMagmaTTC.Remove(effect.id);
      }
    }
    effectsMagmaTTCDeleteEffect.Clear();


    foreach (var effect in effectsMagmaTTCCreateEffect) {
      if (observers.TryGetValue(0, out List<IMagmaTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnMagmaTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IMagmaTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnMagmaTTCEffect(effect);
        }
      }
    }
    effectsMagmaTTCCreateEffect.Clear();
  }
  public CliffTTCIncarnation GetCliffTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCliffTTC[id].incarnation;
  }
  public bool CliffTTCExists(int id) {
    return rootIncarnation.incarnationsCliffTTC.ContainsKey(id);
  }
  public CliffTTC GetCliffTTC(int id) {
    return new CliffTTC(this, id);
  }
  public List<CliffTTC> AllCliffTTC() {
    List<CliffTTC> result = new List<CliffTTC>(rootIncarnation.incarnationsCliffTTC.Count);
    foreach (var id in rootIncarnation.incarnationsCliffTTC.Keys) {
      result.Add(new CliffTTC(this, id));
    }
    return result;
  }
  public IEnumerator<CliffTTC> EnumAllCliffTTC() {
    foreach (var id in rootIncarnation.incarnationsCliffTTC.Keys) {
      yield return GetCliffTTC(id);
    }
  }
  public void CheckHasCliffTTC(CliffTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCliffTTC(thing.id);
  }
  public void CheckHasCliffTTC(int id) {
    if (!rootIncarnation.incarnationsCliffTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid CliffTTC: " + id);
    }
  }
  public void AddCliffTTCObserver(int id, ICliffTTCEffectObserver observer) {
    List<ICliffTTCEffectObserver> obsies;
    if (!observersForCliffTTC.TryGetValue(id, out obsies)) {
      obsies = new List<ICliffTTCEffectObserver>();
    }
    obsies.Add(observer);
    observersForCliffTTC[id] = obsies;
  }

  public void RemoveCliffTTCObserver(int id, ICliffTTCEffectObserver observer) {
    if (observersForCliffTTC.ContainsKey(id)) {
      var list = observersForCliffTTC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForCliffTTC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public CliffTTC EffectCliffTTCCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new CliffTTCIncarnation(

            );
    EffectInternalCreateCliffTTC(id, rootIncarnation.version, incarnation);
    return new CliffTTC(this, id);
  }
  public void EffectInternalCreateCliffTTC(
      int id,
      int incarnationVersion,
      CliffTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new CliffTTCCreateEffect(id);
    rootIncarnation.incarnationsCliffTTC.Add(
        id,
        new VersionAndIncarnation<CliffTTCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsCliffTTCCreateEffect.Add(effect);
  }

  public void EffectCliffTTCDelete(int id) {
    CheckUnlocked();
    var effect = new CliffTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCliffTTC[id];

    rootIncarnation.incarnationsCliffTTC.Remove(id);
    effectsCliffTTCDeleteEffect.Add(effect);
  }

     
  public int GetCliffTTCHash(int id, int version, CliffTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastCliffTTCEffects(
      SortedDictionary<int, List<ICliffTTCEffectObserver>> observers) {
    foreach (var effect in effectsCliffTTCDeleteEffect) {
      if (observers.TryGetValue(0, out List<ICliffTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCliffTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICliffTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCliffTTCEffect(effect);
        }
        observersForCliffTTC.Remove(effect.id);
      }
    }
    effectsCliffTTCDeleteEffect.Clear();


    foreach (var effect in effectsCliffTTCCreateEffect) {
      if (observers.TryGetValue(0, out List<ICliffTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCliffTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICliffTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCliffTTCEffect(effect);
        }
      }
    }
    effectsCliffTTCCreateEffect.Clear();
  }
  public RavaNestTTCIncarnation GetRavaNestTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsRavaNestTTC[id].incarnation;
  }
  public bool RavaNestTTCExists(int id) {
    return rootIncarnation.incarnationsRavaNestTTC.ContainsKey(id);
  }
  public RavaNestTTC GetRavaNestTTC(int id) {
    return new RavaNestTTC(this, id);
  }
  public List<RavaNestTTC> AllRavaNestTTC() {
    List<RavaNestTTC> result = new List<RavaNestTTC>(rootIncarnation.incarnationsRavaNestTTC.Count);
    foreach (var id in rootIncarnation.incarnationsRavaNestTTC.Keys) {
      result.Add(new RavaNestTTC(this, id));
    }
    return result;
  }
  public IEnumerator<RavaNestTTC> EnumAllRavaNestTTC() {
    foreach (var id in rootIncarnation.incarnationsRavaNestTTC.Keys) {
      yield return GetRavaNestTTC(id);
    }
  }
  public void CheckHasRavaNestTTC(RavaNestTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasRavaNestTTC(thing.id);
  }
  public void CheckHasRavaNestTTC(int id) {
    if (!rootIncarnation.incarnationsRavaNestTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid RavaNestTTC: " + id);
    }
  }
  public void AddRavaNestTTCObserver(int id, IRavaNestTTCEffectObserver observer) {
    List<IRavaNestTTCEffectObserver> obsies;
    if (!observersForRavaNestTTC.TryGetValue(id, out obsies)) {
      obsies = new List<IRavaNestTTCEffectObserver>();
    }
    obsies.Add(observer);
    observersForRavaNestTTC[id] = obsies;
  }

  public void RemoveRavaNestTTCObserver(int id, IRavaNestTTCEffectObserver observer) {
    if (observersForRavaNestTTC.ContainsKey(id)) {
      var list = observersForRavaNestTTC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForRavaNestTTC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public RavaNestTTC EffectRavaNestTTCCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new RavaNestTTCIncarnation(

            );
    EffectInternalCreateRavaNestTTC(id, rootIncarnation.version, incarnation);
    return new RavaNestTTC(this, id);
  }
  public void EffectInternalCreateRavaNestTTC(
      int id,
      int incarnationVersion,
      RavaNestTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new RavaNestTTCCreateEffect(id);
    rootIncarnation.incarnationsRavaNestTTC.Add(
        id,
        new VersionAndIncarnation<RavaNestTTCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsRavaNestTTCCreateEffect.Add(effect);
  }

  public void EffectRavaNestTTCDelete(int id) {
    CheckUnlocked();
    var effect = new RavaNestTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsRavaNestTTC[id];

    rootIncarnation.incarnationsRavaNestTTC.Remove(id);
    effectsRavaNestTTCDeleteEffect.Add(effect);
  }

     
  public int GetRavaNestTTCHash(int id, int version, RavaNestTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastRavaNestTTCEffects(
      SortedDictionary<int, List<IRavaNestTTCEffectObserver>> observers) {
    foreach (var effect in effectsRavaNestTTCDeleteEffect) {
      if (observers.TryGetValue(0, out List<IRavaNestTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnRavaNestTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IRavaNestTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnRavaNestTTCEffect(effect);
        }
        observersForRavaNestTTC.Remove(effect.id);
      }
    }
    effectsRavaNestTTCDeleteEffect.Clear();


    foreach (var effect in effectsRavaNestTTCCreateEffect) {
      if (observers.TryGetValue(0, out List<IRavaNestTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnRavaNestTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IRavaNestTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnRavaNestTTCEffect(effect);
        }
      }
    }
    effectsRavaNestTTCCreateEffect.Clear();
  }
  public CliffLandingTTCIncarnation GetCliffLandingTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCliffLandingTTC[id].incarnation;
  }
  public bool CliffLandingTTCExists(int id) {
    return rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(id);
  }
  public CliffLandingTTC GetCliffLandingTTC(int id) {
    return new CliffLandingTTC(this, id);
  }
  public List<CliffLandingTTC> AllCliffLandingTTC() {
    List<CliffLandingTTC> result = new List<CliffLandingTTC>(rootIncarnation.incarnationsCliffLandingTTC.Count);
    foreach (var id in rootIncarnation.incarnationsCliffLandingTTC.Keys) {
      result.Add(new CliffLandingTTC(this, id));
    }
    return result;
  }
  public IEnumerator<CliffLandingTTC> EnumAllCliffLandingTTC() {
    foreach (var id in rootIncarnation.incarnationsCliffLandingTTC.Keys) {
      yield return GetCliffLandingTTC(id);
    }
  }
  public void CheckHasCliffLandingTTC(CliffLandingTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCliffLandingTTC(thing.id);
  }
  public void CheckHasCliffLandingTTC(int id) {
    if (!rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid CliffLandingTTC: " + id);
    }
  }
  public void AddCliffLandingTTCObserver(int id, ICliffLandingTTCEffectObserver observer) {
    List<ICliffLandingTTCEffectObserver> obsies;
    if (!observersForCliffLandingTTC.TryGetValue(id, out obsies)) {
      obsies = new List<ICliffLandingTTCEffectObserver>();
    }
    obsies.Add(observer);
    observersForCliffLandingTTC[id] = obsies;
  }

  public void RemoveCliffLandingTTCObserver(int id, ICliffLandingTTCEffectObserver observer) {
    if (observersForCliffLandingTTC.ContainsKey(id)) {
      var list = observersForCliffLandingTTC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForCliffLandingTTC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public CliffLandingTTC EffectCliffLandingTTCCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new CliffLandingTTCIncarnation(

            );
    EffectInternalCreateCliffLandingTTC(id, rootIncarnation.version, incarnation);
    return new CliffLandingTTC(this, id);
  }
  public void EffectInternalCreateCliffLandingTTC(
      int id,
      int incarnationVersion,
      CliffLandingTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new CliffLandingTTCCreateEffect(id);
    rootIncarnation.incarnationsCliffLandingTTC.Add(
        id,
        new VersionAndIncarnation<CliffLandingTTCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsCliffLandingTTCCreateEffect.Add(effect);
  }

  public void EffectCliffLandingTTCDelete(int id) {
    CheckUnlocked();
    var effect = new CliffLandingTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCliffLandingTTC[id];

    rootIncarnation.incarnationsCliffLandingTTC.Remove(id);
    effectsCliffLandingTTCDeleteEffect.Add(effect);
  }

     
  public int GetCliffLandingTTCHash(int id, int version, CliffLandingTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastCliffLandingTTCEffects(
      SortedDictionary<int, List<ICliffLandingTTCEffectObserver>> observers) {
    foreach (var effect in effectsCliffLandingTTCDeleteEffect) {
      if (observers.TryGetValue(0, out List<ICliffLandingTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCliffLandingTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICliffLandingTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCliffLandingTTCEffect(effect);
        }
        observersForCliffLandingTTC.Remove(effect.id);
      }
    }
    effectsCliffLandingTTCDeleteEffect.Clear();


    foreach (var effect in effectsCliffLandingTTCCreateEffect) {
      if (observers.TryGetValue(0, out List<ICliffLandingTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCliffLandingTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICliffLandingTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCliffLandingTTCEffect(effect);
        }
      }
    }
    effectsCliffLandingTTCCreateEffect.Clear();
  }
  public StoneTTCIncarnation GetStoneTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsStoneTTC[id].incarnation;
  }
  public bool StoneTTCExists(int id) {
    return rootIncarnation.incarnationsStoneTTC.ContainsKey(id);
  }
  public StoneTTC GetStoneTTC(int id) {
    return new StoneTTC(this, id);
  }
  public List<StoneTTC> AllStoneTTC() {
    List<StoneTTC> result = new List<StoneTTC>(rootIncarnation.incarnationsStoneTTC.Count);
    foreach (var id in rootIncarnation.incarnationsStoneTTC.Keys) {
      result.Add(new StoneTTC(this, id));
    }
    return result;
  }
  public IEnumerator<StoneTTC> EnumAllStoneTTC() {
    foreach (var id in rootIncarnation.incarnationsStoneTTC.Keys) {
      yield return GetStoneTTC(id);
    }
  }
  public void CheckHasStoneTTC(StoneTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasStoneTTC(thing.id);
  }
  public void CheckHasStoneTTC(int id) {
    if (!rootIncarnation.incarnationsStoneTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid StoneTTC: " + id);
    }
  }
  public void AddStoneTTCObserver(int id, IStoneTTCEffectObserver observer) {
    List<IStoneTTCEffectObserver> obsies;
    if (!observersForStoneTTC.TryGetValue(id, out obsies)) {
      obsies = new List<IStoneTTCEffectObserver>();
    }
    obsies.Add(observer);
    observersForStoneTTC[id] = obsies;
  }

  public void RemoveStoneTTCObserver(int id, IStoneTTCEffectObserver observer) {
    if (observersForStoneTTC.ContainsKey(id)) {
      var list = observersForStoneTTC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForStoneTTC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public StoneTTC EffectStoneTTCCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new StoneTTCIncarnation(

            );
    EffectInternalCreateStoneTTC(id, rootIncarnation.version, incarnation);
    return new StoneTTC(this, id);
  }
  public void EffectInternalCreateStoneTTC(
      int id,
      int incarnationVersion,
      StoneTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new StoneTTCCreateEffect(id);
    rootIncarnation.incarnationsStoneTTC.Add(
        id,
        new VersionAndIncarnation<StoneTTCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsStoneTTCCreateEffect.Add(effect);
  }

  public void EffectStoneTTCDelete(int id) {
    CheckUnlocked();
    var effect = new StoneTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsStoneTTC[id];

    rootIncarnation.incarnationsStoneTTC.Remove(id);
    effectsStoneTTCDeleteEffect.Add(effect);
  }

     
  public int GetStoneTTCHash(int id, int version, StoneTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastStoneTTCEffects(
      SortedDictionary<int, List<IStoneTTCEffectObserver>> observers) {
    foreach (var effect in effectsStoneTTCDeleteEffect) {
      if (observers.TryGetValue(0, out List<IStoneTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnStoneTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IStoneTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnStoneTTCEffect(effect);
        }
        observersForStoneTTC.Remove(effect.id);
      }
    }
    effectsStoneTTCDeleteEffect.Clear();


    foreach (var effect in effectsStoneTTCCreateEffect) {
      if (observers.TryGetValue(0, out List<IStoneTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnStoneTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IStoneTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnStoneTTCEffect(effect);
        }
      }
    }
    effectsStoneTTCCreateEffect.Clear();
  }
  public GrassTTCIncarnation GetGrassTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsGrassTTC[id].incarnation;
  }
  public bool GrassTTCExists(int id) {
    return rootIncarnation.incarnationsGrassTTC.ContainsKey(id);
  }
  public GrassTTC GetGrassTTC(int id) {
    return new GrassTTC(this, id);
  }
  public List<GrassTTC> AllGrassTTC() {
    List<GrassTTC> result = new List<GrassTTC>(rootIncarnation.incarnationsGrassTTC.Count);
    foreach (var id in rootIncarnation.incarnationsGrassTTC.Keys) {
      result.Add(new GrassTTC(this, id));
    }
    return result;
  }
  public IEnumerator<GrassTTC> EnumAllGrassTTC() {
    foreach (var id in rootIncarnation.incarnationsGrassTTC.Keys) {
      yield return GetGrassTTC(id);
    }
  }
  public void CheckHasGrassTTC(GrassTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasGrassTTC(thing.id);
  }
  public void CheckHasGrassTTC(int id) {
    if (!rootIncarnation.incarnationsGrassTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid GrassTTC: " + id);
    }
  }
  public void AddGrassTTCObserver(int id, IGrassTTCEffectObserver observer) {
    List<IGrassTTCEffectObserver> obsies;
    if (!observersForGrassTTC.TryGetValue(id, out obsies)) {
      obsies = new List<IGrassTTCEffectObserver>();
    }
    obsies.Add(observer);
    observersForGrassTTC[id] = obsies;
  }

  public void RemoveGrassTTCObserver(int id, IGrassTTCEffectObserver observer) {
    if (observersForGrassTTC.ContainsKey(id)) {
      var list = observersForGrassTTC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForGrassTTC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public GrassTTC EffectGrassTTCCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new GrassTTCIncarnation(

            );
    EffectInternalCreateGrassTTC(id, rootIncarnation.version, incarnation);
    return new GrassTTC(this, id);
  }
  public void EffectInternalCreateGrassTTC(
      int id,
      int incarnationVersion,
      GrassTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new GrassTTCCreateEffect(id);
    rootIncarnation.incarnationsGrassTTC.Add(
        id,
        new VersionAndIncarnation<GrassTTCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsGrassTTCCreateEffect.Add(effect);
  }

  public void EffectGrassTTCDelete(int id) {
    CheckUnlocked();
    var effect = new GrassTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsGrassTTC[id];

    rootIncarnation.incarnationsGrassTTC.Remove(id);
    effectsGrassTTCDeleteEffect.Add(effect);
  }

     
  public int GetGrassTTCHash(int id, int version, GrassTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastGrassTTCEffects(
      SortedDictionary<int, List<IGrassTTCEffectObserver>> observers) {
    foreach (var effect in effectsGrassTTCDeleteEffect) {
      if (observers.TryGetValue(0, out List<IGrassTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnGrassTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IGrassTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnGrassTTCEffect(effect);
        }
        observersForGrassTTC.Remove(effect.id);
      }
    }
    effectsGrassTTCDeleteEffect.Clear();


    foreach (var effect in effectsGrassTTCCreateEffect) {
      if (observers.TryGetValue(0, out List<IGrassTTCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnGrassTTCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IGrassTTCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnGrassTTCEffect(effect);
        }
      }
    }
    effectsGrassTTCCreateEffect.Clear();
  }
  public ManaPotionIncarnation GetManaPotionIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsManaPotion[id].incarnation;
  }
  public bool ManaPotionExists(int id) {
    return rootIncarnation.incarnationsManaPotion.ContainsKey(id);
  }
  public ManaPotion GetManaPotion(int id) {
    return new ManaPotion(this, id);
  }
  public List<ManaPotion> AllManaPotion() {
    List<ManaPotion> result = new List<ManaPotion>(rootIncarnation.incarnationsManaPotion.Count);
    foreach (var id in rootIncarnation.incarnationsManaPotion.Keys) {
      result.Add(new ManaPotion(this, id));
    }
    return result;
  }
  public IEnumerator<ManaPotion> EnumAllManaPotion() {
    foreach (var id in rootIncarnation.incarnationsManaPotion.Keys) {
      yield return GetManaPotion(id);
    }
  }
  public void CheckHasManaPotion(ManaPotion thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasManaPotion(thing.id);
  }
  public void CheckHasManaPotion(int id) {
    if (!rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      throw new System.Exception("Invalid ManaPotion: " + id);
    }
  }
  public void AddManaPotionObserver(int id, IManaPotionEffectObserver observer) {
    List<IManaPotionEffectObserver> obsies;
    if (!observersForManaPotion.TryGetValue(id, out obsies)) {
      obsies = new List<IManaPotionEffectObserver>();
    }
    obsies.Add(observer);
    observersForManaPotion[id] = obsies;
  }

  public void RemoveManaPotionObserver(int id, IManaPotionEffectObserver observer) {
    if (observersForManaPotion.ContainsKey(id)) {
      var list = observersForManaPotion[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForManaPotion.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public ManaPotion EffectManaPotionCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new ManaPotionIncarnation(

            );
    EffectInternalCreateManaPotion(id, rootIncarnation.version, incarnation);
    return new ManaPotion(this, id);
  }
  public void EffectInternalCreateManaPotion(
      int id,
      int incarnationVersion,
      ManaPotionIncarnation incarnation) {
    CheckUnlocked();
    var effect = new ManaPotionCreateEffect(id);
    rootIncarnation.incarnationsManaPotion.Add(
        id,
        new VersionAndIncarnation<ManaPotionIncarnation>(
            incarnationVersion,
            incarnation));
    effectsManaPotionCreateEffect.Add(effect);
  }

  public void EffectManaPotionDelete(int id) {
    CheckUnlocked();
    var effect = new ManaPotionDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsManaPotion[id];

    rootIncarnation.incarnationsManaPotion.Remove(id);
    effectsManaPotionDeleteEffect.Add(effect);
  }

     
  public int GetManaPotionHash(int id, int version, ManaPotionIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastManaPotionEffects(
      SortedDictionary<int, List<IManaPotionEffectObserver>> observers) {
    foreach (var effect in effectsManaPotionDeleteEffect) {
      if (observers.TryGetValue(0, out List<IManaPotionEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnManaPotionEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IManaPotionEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnManaPotionEffect(effect);
        }
        observersForManaPotion.Remove(effect.id);
      }
    }
    effectsManaPotionDeleteEffect.Clear();


    foreach (var effect in effectsManaPotionCreateEffect) {
      if (observers.TryGetValue(0, out List<IManaPotionEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnManaPotionEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IManaPotionEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnManaPotionEffect(effect);
        }
      }
    }
    effectsManaPotionCreateEffect.Clear();
  }
  public HealthPotionIncarnation GetHealthPotionIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsHealthPotion[id].incarnation;
  }
  public bool HealthPotionExists(int id) {
    return rootIncarnation.incarnationsHealthPotion.ContainsKey(id);
  }
  public HealthPotion GetHealthPotion(int id) {
    return new HealthPotion(this, id);
  }
  public List<HealthPotion> AllHealthPotion() {
    List<HealthPotion> result = new List<HealthPotion>(rootIncarnation.incarnationsHealthPotion.Count);
    foreach (var id in rootIncarnation.incarnationsHealthPotion.Keys) {
      result.Add(new HealthPotion(this, id));
    }
    return result;
  }
  public IEnumerator<HealthPotion> EnumAllHealthPotion() {
    foreach (var id in rootIncarnation.incarnationsHealthPotion.Keys) {
      yield return GetHealthPotion(id);
    }
  }
  public void CheckHasHealthPotion(HealthPotion thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasHealthPotion(thing.id);
  }
  public void CheckHasHealthPotion(int id) {
    if (!rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      throw new System.Exception("Invalid HealthPotion: " + id);
    }
  }
  public void AddHealthPotionObserver(int id, IHealthPotionEffectObserver observer) {
    List<IHealthPotionEffectObserver> obsies;
    if (!observersForHealthPotion.TryGetValue(id, out obsies)) {
      obsies = new List<IHealthPotionEffectObserver>();
    }
    obsies.Add(observer);
    observersForHealthPotion[id] = obsies;
  }

  public void RemoveHealthPotionObserver(int id, IHealthPotionEffectObserver observer) {
    if (observersForHealthPotion.ContainsKey(id)) {
      var list = observersForHealthPotion[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForHealthPotion.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public HealthPotion EffectHealthPotionCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new HealthPotionIncarnation(

            );
    EffectInternalCreateHealthPotion(id, rootIncarnation.version, incarnation);
    return new HealthPotion(this, id);
  }
  public void EffectInternalCreateHealthPotion(
      int id,
      int incarnationVersion,
      HealthPotionIncarnation incarnation) {
    CheckUnlocked();
    var effect = new HealthPotionCreateEffect(id);
    rootIncarnation.incarnationsHealthPotion.Add(
        id,
        new VersionAndIncarnation<HealthPotionIncarnation>(
            incarnationVersion,
            incarnation));
    effectsHealthPotionCreateEffect.Add(effect);
  }

  public void EffectHealthPotionDelete(int id) {
    CheckUnlocked();
    var effect = new HealthPotionDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsHealthPotion[id];

    rootIncarnation.incarnationsHealthPotion.Remove(id);
    effectsHealthPotionDeleteEffect.Add(effect);
  }

     
  public int GetHealthPotionHash(int id, int version, HealthPotionIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastHealthPotionEffects(
      SortedDictionary<int, List<IHealthPotionEffectObserver>> observers) {
    foreach (var effect in effectsHealthPotionDeleteEffect) {
      if (observers.TryGetValue(0, out List<IHealthPotionEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnHealthPotionEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IHealthPotionEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnHealthPotionEffect(effect);
        }
        observersForHealthPotion.Remove(effect.id);
      }
    }
    effectsHealthPotionDeleteEffect.Clear();


    foreach (var effect in effectsHealthPotionCreateEffect) {
      if (observers.TryGetValue(0, out List<IHealthPotionEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnHealthPotionEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IHealthPotionEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnHealthPotionEffect(effect);
        }
      }
    }
    effectsHealthPotionCreateEffect.Clear();
  }
  public InertiaRingIncarnation GetInertiaRingIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsInertiaRing[id].incarnation;
  }
  public bool InertiaRingExists(int id) {
    return rootIncarnation.incarnationsInertiaRing.ContainsKey(id);
  }
  public InertiaRing GetInertiaRing(int id) {
    return new InertiaRing(this, id);
  }
  public List<InertiaRing> AllInertiaRing() {
    List<InertiaRing> result = new List<InertiaRing>(rootIncarnation.incarnationsInertiaRing.Count);
    foreach (var id in rootIncarnation.incarnationsInertiaRing.Keys) {
      result.Add(new InertiaRing(this, id));
    }
    return result;
  }
  public IEnumerator<InertiaRing> EnumAllInertiaRing() {
    foreach (var id in rootIncarnation.incarnationsInertiaRing.Keys) {
      yield return GetInertiaRing(id);
    }
  }
  public void CheckHasInertiaRing(InertiaRing thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasInertiaRing(thing.id);
  }
  public void CheckHasInertiaRing(int id) {
    if (!rootIncarnation.incarnationsInertiaRing.ContainsKey(id)) {
      throw new System.Exception("Invalid InertiaRing: " + id);
    }
  }
  public void AddInertiaRingObserver(int id, IInertiaRingEffectObserver observer) {
    List<IInertiaRingEffectObserver> obsies;
    if (!observersForInertiaRing.TryGetValue(id, out obsies)) {
      obsies = new List<IInertiaRingEffectObserver>();
    }
    obsies.Add(observer);
    observersForInertiaRing[id] = obsies;
  }

  public void RemoveInertiaRingObserver(int id, IInertiaRingEffectObserver observer) {
    if (observersForInertiaRing.ContainsKey(id)) {
      var list = observersForInertiaRing[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForInertiaRing.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public InertiaRing EffectInertiaRingCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new InertiaRingIncarnation(

            );
    EffectInternalCreateInertiaRing(id, rootIncarnation.version, incarnation);
    return new InertiaRing(this, id);
  }
  public void EffectInternalCreateInertiaRing(
      int id,
      int incarnationVersion,
      InertiaRingIncarnation incarnation) {
    CheckUnlocked();
    var effect = new InertiaRingCreateEffect(id);
    rootIncarnation.incarnationsInertiaRing.Add(
        id,
        new VersionAndIncarnation<InertiaRingIncarnation>(
            incarnationVersion,
            incarnation));
    effectsInertiaRingCreateEffect.Add(effect);
  }

  public void EffectInertiaRingDelete(int id) {
    CheckUnlocked();
    var effect = new InertiaRingDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsInertiaRing[id];

    rootIncarnation.incarnationsInertiaRing.Remove(id);
    effectsInertiaRingDeleteEffect.Add(effect);
  }

     
  public int GetInertiaRingHash(int id, int version, InertiaRingIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastInertiaRingEffects(
      SortedDictionary<int, List<IInertiaRingEffectObserver>> observers) {
    foreach (var effect in effectsInertiaRingDeleteEffect) {
      if (observers.TryGetValue(0, out List<IInertiaRingEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnInertiaRingEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IInertiaRingEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnInertiaRingEffect(effect);
        }
        observersForInertiaRing.Remove(effect.id);
      }
    }
    effectsInertiaRingDeleteEffect.Clear();


    foreach (var effect in effectsInertiaRingCreateEffect) {
      if (observers.TryGetValue(0, out List<IInertiaRingEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnInertiaRingEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IInertiaRingEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnInertiaRingEffect(effect);
        }
      }
    }
    effectsInertiaRingCreateEffect.Clear();
  }
  public GlaiveIncarnation GetGlaiveIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsGlaive[id].incarnation;
  }
  public bool GlaiveExists(int id) {
    return rootIncarnation.incarnationsGlaive.ContainsKey(id);
  }
  public Glaive GetGlaive(int id) {
    return new Glaive(this, id);
  }
  public List<Glaive> AllGlaive() {
    List<Glaive> result = new List<Glaive>(rootIncarnation.incarnationsGlaive.Count);
    foreach (var id in rootIncarnation.incarnationsGlaive.Keys) {
      result.Add(new Glaive(this, id));
    }
    return result;
  }
  public IEnumerator<Glaive> EnumAllGlaive() {
    foreach (var id in rootIncarnation.incarnationsGlaive.Keys) {
      yield return GetGlaive(id);
    }
  }
  public void CheckHasGlaive(Glaive thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasGlaive(thing.id);
  }
  public void CheckHasGlaive(int id) {
    if (!rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      throw new System.Exception("Invalid Glaive: " + id);
    }
  }
  public void AddGlaiveObserver(int id, IGlaiveEffectObserver observer) {
    List<IGlaiveEffectObserver> obsies;
    if (!observersForGlaive.TryGetValue(id, out obsies)) {
      obsies = new List<IGlaiveEffectObserver>();
    }
    obsies.Add(observer);
    observersForGlaive[id] = obsies;
  }

  public void RemoveGlaiveObserver(int id, IGlaiveEffectObserver observer) {
    if (observersForGlaive.ContainsKey(id)) {
      var list = observersForGlaive[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForGlaive.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public Glaive EffectGlaiveCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new GlaiveIncarnation(

            );
    EffectInternalCreateGlaive(id, rootIncarnation.version, incarnation);
    return new Glaive(this, id);
  }
  public void EffectInternalCreateGlaive(
      int id,
      int incarnationVersion,
      GlaiveIncarnation incarnation) {
    CheckUnlocked();
    var effect = new GlaiveCreateEffect(id);
    rootIncarnation.incarnationsGlaive.Add(
        id,
        new VersionAndIncarnation<GlaiveIncarnation>(
            incarnationVersion,
            incarnation));
    effectsGlaiveCreateEffect.Add(effect);
  }

  public void EffectGlaiveDelete(int id) {
    CheckUnlocked();
    var effect = new GlaiveDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsGlaive[id];

    rootIncarnation.incarnationsGlaive.Remove(id);
    effectsGlaiveDeleteEffect.Add(effect);
  }

     
  public int GetGlaiveHash(int id, int version, GlaiveIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastGlaiveEffects(
      SortedDictionary<int, List<IGlaiveEffectObserver>> observers) {
    foreach (var effect in effectsGlaiveDeleteEffect) {
      if (observers.TryGetValue(0, out List<IGlaiveEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnGlaiveEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IGlaiveEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnGlaiveEffect(effect);
        }
        observersForGlaive.Remove(effect.id);
      }
    }
    effectsGlaiveDeleteEffect.Clear();


    foreach (var effect in effectsGlaiveCreateEffect) {
      if (observers.TryGetValue(0, out List<IGlaiveEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnGlaiveEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IGlaiveEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnGlaiveEffect(effect);
        }
      }
    }
    effectsGlaiveCreateEffect.Clear();
  }
  public ArmorIncarnation GetArmorIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsArmor[id].incarnation;
  }
  public bool ArmorExists(int id) {
    return rootIncarnation.incarnationsArmor.ContainsKey(id);
  }
  public Armor GetArmor(int id) {
    return new Armor(this, id);
  }
  public List<Armor> AllArmor() {
    List<Armor> result = new List<Armor>(rootIncarnation.incarnationsArmor.Count);
    foreach (var id in rootIncarnation.incarnationsArmor.Keys) {
      result.Add(new Armor(this, id));
    }
    return result;
  }
  public IEnumerator<Armor> EnumAllArmor() {
    foreach (var id in rootIncarnation.incarnationsArmor.Keys) {
      yield return GetArmor(id);
    }
  }
  public void CheckHasArmor(Armor thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasArmor(thing.id);
  }
  public void CheckHasArmor(int id) {
    if (!rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      throw new System.Exception("Invalid Armor: " + id);
    }
  }
  public void AddArmorObserver(int id, IArmorEffectObserver observer) {
    List<IArmorEffectObserver> obsies;
    if (!observersForArmor.TryGetValue(id, out obsies)) {
      obsies = new List<IArmorEffectObserver>();
    }
    obsies.Add(observer);
    observersForArmor[id] = obsies;
  }

  public void RemoveArmorObserver(int id, IArmorEffectObserver observer) {
    if (observersForArmor.ContainsKey(id)) {
      var list = observersForArmor[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForArmor.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public Armor EffectArmorCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new ArmorIncarnation(

            );
    EffectInternalCreateArmor(id, rootIncarnation.version, incarnation);
    return new Armor(this, id);
  }
  public void EffectInternalCreateArmor(
      int id,
      int incarnationVersion,
      ArmorIncarnation incarnation) {
    CheckUnlocked();
    var effect = new ArmorCreateEffect(id);
    rootIncarnation.incarnationsArmor.Add(
        id,
        new VersionAndIncarnation<ArmorIncarnation>(
            incarnationVersion,
            incarnation));
    effectsArmorCreateEffect.Add(effect);
  }

  public void EffectArmorDelete(int id) {
    CheckUnlocked();
    var effect = new ArmorDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsArmor[id];

    rootIncarnation.incarnationsArmor.Remove(id);
    effectsArmorDeleteEffect.Add(effect);
  }

     
  public int GetArmorHash(int id, int version, ArmorIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastArmorEffects(
      SortedDictionary<int, List<IArmorEffectObserver>> observers) {
    foreach (var effect in effectsArmorDeleteEffect) {
      if (observers.TryGetValue(0, out List<IArmorEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnArmorEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IArmorEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnArmorEffect(effect);
        }
        observersForArmor.Remove(effect.id);
      }
    }
    effectsArmorDeleteEffect.Clear();


    foreach (var effect in effectsArmorCreateEffect) {
      if (observers.TryGetValue(0, out List<IArmorEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnArmorEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IArmorEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnArmorEffect(effect);
        }
      }
    }
    effectsArmorCreateEffect.Clear();
  }
  public RandIncarnation GetRandIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsRand[id].incarnation;
  }
  public bool RandExists(int id) {
    return rootIncarnation.incarnationsRand.ContainsKey(id);
  }
  public Rand GetRand(int id) {
    return new Rand(this, id);
  }
  public List<Rand> AllRand() {
    List<Rand> result = new List<Rand>(rootIncarnation.incarnationsRand.Count);
    foreach (var id in rootIncarnation.incarnationsRand.Keys) {
      result.Add(new Rand(this, id));
    }
    return result;
  }
  public IEnumerator<Rand> EnumAllRand() {
    foreach (var id in rootIncarnation.incarnationsRand.Keys) {
      yield return GetRand(id);
    }
  }
  public void CheckHasRand(Rand thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasRand(thing.id);
  }
  public void CheckHasRand(int id) {
    if (!rootIncarnation.incarnationsRand.ContainsKey(id)) {
      throw new System.Exception("Invalid Rand: " + id);
    }
  }
  public void AddRandObserver(int id, IRandEffectObserver observer) {
    List<IRandEffectObserver> obsies;
    if (!observersForRand.TryGetValue(id, out obsies)) {
      obsies = new List<IRandEffectObserver>();
    }
    obsies.Add(observer);
    observersForRand[id] = obsies;
  }

  public void RemoveRandObserver(int id, IRandEffectObserver observer) {
    if (observersForRand.ContainsKey(id)) {
      var list = observersForRand[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForRand.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public Rand EffectRandCreate(
      int rand) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new RandIncarnation(
            rand
            );
    EffectInternalCreateRand(id, rootIncarnation.version, incarnation);
    return new Rand(this, id);
  }
  public void EffectInternalCreateRand(
      int id,
      int incarnationVersion,
      RandIncarnation incarnation) {
    CheckUnlocked();
    var effect = new RandCreateEffect(id);
    rootIncarnation.incarnationsRand.Add(
        id,
        new VersionAndIncarnation<RandIncarnation>(
            incarnationVersion,
            incarnation));
    effectsRandCreateEffect.Add(effect);
  }

  public void EffectRandDelete(int id) {
    CheckUnlocked();
    var effect = new RandDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsRand[id];

    rootIncarnation.incarnationsRand.Remove(id);
    effectsRandDeleteEffect.Add(effect);
  }

     
  public int GetRandHash(int id, int version, RandIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.rand.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastRandEffects(
      SortedDictionary<int, List<IRandEffectObserver>> observers) {
    foreach (var effect in effectsRandDeleteEffect) {
      if (observers.TryGetValue(0, out List<IRandEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnRandEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IRandEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnRandEffect(effect);
        }
        observersForRand.Remove(effect.id);
      }
    }
    effectsRandDeleteEffect.Clear();


    foreach (var effect in effectsRandSetRandEffect) {
      if (observers.TryGetValue(0, out List<IRandEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnRandEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IRandEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnRandEffect(effect);
        }
      }
    }
    effectsRandSetRandEffect.Clear();

    foreach (var effect in effectsRandCreateEffect) {
      if (observers.TryGetValue(0, out List<IRandEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnRandEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IRandEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnRandEffect(effect);
        }
      }
    }
    effectsRandCreateEffect.Clear();
  }

  public void EffectRandSetRand(int id, int newValue) {
    CheckUnlocked();
    CheckHasRand(id);
    var effect = new RandSetRandEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsRand[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.rand;
      oldIncarnationAndVersion.incarnation.rand = newValue;

    } else {
      var newIncarnation =
          new RandIncarnation(
              newValue);
      rootIncarnation.incarnationsRand[id] =
          new VersionAndIncarnation<RandIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsRandSetRandEffect.Add(effect);
  }
  public WanderAICapabilityUCIncarnation GetWanderAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsWanderAICapabilityUC[id].incarnation;
  }
  public bool WanderAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id);
  }
  public WanderAICapabilityUC GetWanderAICapabilityUC(int id) {
    return new WanderAICapabilityUC(this, id);
  }
  public List<WanderAICapabilityUC> AllWanderAICapabilityUC() {
    List<WanderAICapabilityUC> result = new List<WanderAICapabilityUC>(rootIncarnation.incarnationsWanderAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsWanderAICapabilityUC.Keys) {
      result.Add(new WanderAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<WanderAICapabilityUC> EnumAllWanderAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsWanderAICapabilityUC.Keys) {
      yield return GetWanderAICapabilityUC(id);
    }
  }
  public void CheckHasWanderAICapabilityUC(WanderAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasWanderAICapabilityUC(thing.id);
  }
  public void CheckHasWanderAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid WanderAICapabilityUC: " + id);
    }
  }
  public void AddWanderAICapabilityUCObserver(int id, IWanderAICapabilityUCEffectObserver observer) {
    List<IWanderAICapabilityUCEffectObserver> obsies;
    if (!observersForWanderAICapabilityUC.TryGetValue(id, out obsies)) {
      obsies = new List<IWanderAICapabilityUCEffectObserver>();
    }
    obsies.Add(observer);
    observersForWanderAICapabilityUC[id] = obsies;
  }

  public void RemoveWanderAICapabilityUCObserver(int id, IWanderAICapabilityUCEffectObserver observer) {
    if (observersForWanderAICapabilityUC.ContainsKey(id)) {
      var list = observersForWanderAICapabilityUC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForWanderAICapabilityUC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public WanderAICapabilityUC EffectWanderAICapabilityUCCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new WanderAICapabilityUCIncarnation(

            );
    EffectInternalCreateWanderAICapabilityUC(id, rootIncarnation.version, incarnation);
    return new WanderAICapabilityUC(this, id);
  }
  public void EffectInternalCreateWanderAICapabilityUC(
      int id,
      int incarnationVersion,
      WanderAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new WanderAICapabilityUCCreateEffect(id);
    rootIncarnation.incarnationsWanderAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<WanderAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsWanderAICapabilityUCCreateEffect.Add(effect);
  }

  public void EffectWanderAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = new WanderAICapabilityUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsWanderAICapabilityUC[id];

    rootIncarnation.incarnationsWanderAICapabilityUC.Remove(id);
    effectsWanderAICapabilityUCDeleteEffect.Add(effect);
  }

     
  public int GetWanderAICapabilityUCHash(int id, int version, WanderAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastWanderAICapabilityUCEffects(
      SortedDictionary<int, List<IWanderAICapabilityUCEffectObserver>> observers) {
    foreach (var effect in effectsWanderAICapabilityUCDeleteEffect) {
      if (observers.TryGetValue(0, out List<IWanderAICapabilityUCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnWanderAICapabilityUCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IWanderAICapabilityUCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnWanderAICapabilityUCEffect(effect);
        }
        observersForWanderAICapabilityUC.Remove(effect.id);
      }
    }
    effectsWanderAICapabilityUCDeleteEffect.Clear();


    foreach (var effect in effectsWanderAICapabilityUCCreateEffect) {
      if (observers.TryGetValue(0, out List<IWanderAICapabilityUCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnWanderAICapabilityUCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IWanderAICapabilityUCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnWanderAICapabilityUCEffect(effect);
        }
      }
    }
    effectsWanderAICapabilityUCCreateEffect.Clear();
  }
  public CounteringUCIncarnation GetCounteringUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCounteringUC[id].incarnation;
  }
  public bool CounteringUCExists(int id) {
    return rootIncarnation.incarnationsCounteringUC.ContainsKey(id);
  }
  public CounteringUC GetCounteringUC(int id) {
    return new CounteringUC(this, id);
  }
  public List<CounteringUC> AllCounteringUC() {
    List<CounteringUC> result = new List<CounteringUC>(rootIncarnation.incarnationsCounteringUC.Count);
    foreach (var id in rootIncarnation.incarnationsCounteringUC.Keys) {
      result.Add(new CounteringUC(this, id));
    }
    return result;
  }
  public IEnumerator<CounteringUC> EnumAllCounteringUC() {
    foreach (var id in rootIncarnation.incarnationsCounteringUC.Keys) {
      yield return GetCounteringUC(id);
    }
  }
  public void CheckHasCounteringUC(CounteringUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCounteringUC(thing.id);
  }
  public void CheckHasCounteringUC(int id) {
    if (!rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      throw new System.Exception("Invalid CounteringUC: " + id);
    }
  }
  public void AddCounteringUCObserver(int id, ICounteringUCEffectObserver observer) {
    List<ICounteringUCEffectObserver> obsies;
    if (!observersForCounteringUC.TryGetValue(id, out obsies)) {
      obsies = new List<ICounteringUCEffectObserver>();
    }
    obsies.Add(observer);
    observersForCounteringUC[id] = obsies;
  }

  public void RemoveCounteringUCObserver(int id, ICounteringUCEffectObserver observer) {
    if (observersForCounteringUC.ContainsKey(id)) {
      var list = observersForCounteringUC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForCounteringUC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public CounteringUC EffectCounteringUCCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new CounteringUCIncarnation(

            );
    EffectInternalCreateCounteringUC(id, rootIncarnation.version, incarnation);
    return new CounteringUC(this, id);
  }
  public void EffectInternalCreateCounteringUC(
      int id,
      int incarnationVersion,
      CounteringUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new CounteringUCCreateEffect(id);
    rootIncarnation.incarnationsCounteringUC.Add(
        id,
        new VersionAndIncarnation<CounteringUCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsCounteringUCCreateEffect.Add(effect);
  }

  public void EffectCounteringUCDelete(int id) {
    CheckUnlocked();
    var effect = new CounteringUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCounteringUC[id];

    rootIncarnation.incarnationsCounteringUC.Remove(id);
    effectsCounteringUCDeleteEffect.Add(effect);
  }

     
  public int GetCounteringUCHash(int id, int version, CounteringUCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastCounteringUCEffects(
      SortedDictionary<int, List<ICounteringUCEffectObserver>> observers) {
    foreach (var effect in effectsCounteringUCDeleteEffect) {
      if (observers.TryGetValue(0, out List<ICounteringUCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCounteringUCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICounteringUCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCounteringUCEffect(effect);
        }
        observersForCounteringUC.Remove(effect.id);
      }
    }
    effectsCounteringUCDeleteEffect.Clear();


    foreach (var effect in effectsCounteringUCCreateEffect) {
      if (observers.TryGetValue(0, out List<ICounteringUCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCounteringUCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICounteringUCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCounteringUCEffect(effect);
        }
      }
    }
    effectsCounteringUCCreateEffect.Clear();
  }
  public ShieldingUCIncarnation GetShieldingUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsShieldingUC[id].incarnation;
  }
  public bool ShieldingUCExists(int id) {
    return rootIncarnation.incarnationsShieldingUC.ContainsKey(id);
  }
  public ShieldingUC GetShieldingUC(int id) {
    return new ShieldingUC(this, id);
  }
  public List<ShieldingUC> AllShieldingUC() {
    List<ShieldingUC> result = new List<ShieldingUC>(rootIncarnation.incarnationsShieldingUC.Count);
    foreach (var id in rootIncarnation.incarnationsShieldingUC.Keys) {
      result.Add(new ShieldingUC(this, id));
    }
    return result;
  }
  public IEnumerator<ShieldingUC> EnumAllShieldingUC() {
    foreach (var id in rootIncarnation.incarnationsShieldingUC.Keys) {
      yield return GetShieldingUC(id);
    }
  }
  public void CheckHasShieldingUC(ShieldingUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasShieldingUC(thing.id);
  }
  public void CheckHasShieldingUC(int id) {
    if (!rootIncarnation.incarnationsShieldingUC.ContainsKey(id)) {
      throw new System.Exception("Invalid ShieldingUC: " + id);
    }
  }
  public void AddShieldingUCObserver(int id, IShieldingUCEffectObserver observer) {
    List<IShieldingUCEffectObserver> obsies;
    if (!observersForShieldingUC.TryGetValue(id, out obsies)) {
      obsies = new List<IShieldingUCEffectObserver>();
    }
    obsies.Add(observer);
    observersForShieldingUC[id] = obsies;
  }

  public void RemoveShieldingUCObserver(int id, IShieldingUCEffectObserver observer) {
    if (observersForShieldingUC.ContainsKey(id)) {
      var list = observersForShieldingUC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForShieldingUC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public ShieldingUC EffectShieldingUCCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new ShieldingUCIncarnation(

            );
    EffectInternalCreateShieldingUC(id, rootIncarnation.version, incarnation);
    return new ShieldingUC(this, id);
  }
  public void EffectInternalCreateShieldingUC(
      int id,
      int incarnationVersion,
      ShieldingUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new ShieldingUCCreateEffect(id);
    rootIncarnation.incarnationsShieldingUC.Add(
        id,
        new VersionAndIncarnation<ShieldingUCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsShieldingUCCreateEffect.Add(effect);
  }

  public void EffectShieldingUCDelete(int id) {
    CheckUnlocked();
    var effect = new ShieldingUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsShieldingUC[id];

    rootIncarnation.incarnationsShieldingUC.Remove(id);
    effectsShieldingUCDeleteEffect.Add(effect);
  }

     
  public int GetShieldingUCHash(int id, int version, ShieldingUCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastShieldingUCEffects(
      SortedDictionary<int, List<IShieldingUCEffectObserver>> observers) {
    foreach (var effect in effectsShieldingUCDeleteEffect) {
      if (observers.TryGetValue(0, out List<IShieldingUCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnShieldingUCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IShieldingUCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnShieldingUCEffect(effect);
        }
        observersForShieldingUC.Remove(effect.id);
      }
    }
    effectsShieldingUCDeleteEffect.Clear();


    foreach (var effect in effectsShieldingUCCreateEffect) {
      if (observers.TryGetValue(0, out List<IShieldingUCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnShieldingUCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IShieldingUCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnShieldingUCEffect(effect);
        }
      }
    }
    effectsShieldingUCCreateEffect.Clear();
  }
  public EvaporateImpulseIncarnation GetEvaporateImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsEvaporateImpulse[id].incarnation;
  }
  public bool EvaporateImpulseExists(int id) {
    return rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(id);
  }
  public EvaporateImpulse GetEvaporateImpulse(int id) {
    return new EvaporateImpulse(this, id);
  }
  public List<EvaporateImpulse> AllEvaporateImpulse() {
    List<EvaporateImpulse> result = new List<EvaporateImpulse>(rootIncarnation.incarnationsEvaporateImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsEvaporateImpulse.Keys) {
      result.Add(new EvaporateImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<EvaporateImpulse> EnumAllEvaporateImpulse() {
    foreach (var id in rootIncarnation.incarnationsEvaporateImpulse.Keys) {
      yield return GetEvaporateImpulse(id);
    }
  }
  public void CheckHasEvaporateImpulse(EvaporateImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasEvaporateImpulse(thing.id);
  }
  public void CheckHasEvaporateImpulse(int id) {
    if (!rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid EvaporateImpulse: " + id);
    }
  }
  public void AddEvaporateImpulseObserver(int id, IEvaporateImpulseEffectObserver observer) {
    List<IEvaporateImpulseEffectObserver> obsies;
    if (!observersForEvaporateImpulse.TryGetValue(id, out obsies)) {
      obsies = new List<IEvaporateImpulseEffectObserver>();
    }
    obsies.Add(observer);
    observersForEvaporateImpulse[id] = obsies;
  }

  public void RemoveEvaporateImpulseObserver(int id, IEvaporateImpulseEffectObserver observer) {
    if (observersForEvaporateImpulse.ContainsKey(id)) {
      var list = observersForEvaporateImpulse[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForEvaporateImpulse.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public EvaporateImpulse EffectEvaporateImpulseCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new EvaporateImpulseIncarnation(

            );
    EffectInternalCreateEvaporateImpulse(id, rootIncarnation.version, incarnation);
    return new EvaporateImpulse(this, id);
  }
  public void EffectInternalCreateEvaporateImpulse(
      int id,
      int incarnationVersion,
      EvaporateImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new EvaporateImpulseCreateEffect(id);
    rootIncarnation.incarnationsEvaporateImpulse.Add(
        id,
        new VersionAndIncarnation<EvaporateImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    effectsEvaporateImpulseCreateEffect.Add(effect);
  }

  public void EffectEvaporateImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new EvaporateImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsEvaporateImpulse[id];

    rootIncarnation.incarnationsEvaporateImpulse.Remove(id);
    effectsEvaporateImpulseDeleteEffect.Add(effect);
  }

     
  public int GetEvaporateImpulseHash(int id, int version, EvaporateImpulseIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastEvaporateImpulseEffects(
      SortedDictionary<int, List<IEvaporateImpulseEffectObserver>> observers) {
    foreach (var effect in effectsEvaporateImpulseDeleteEffect) {
      if (observers.TryGetValue(0, out List<IEvaporateImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnEvaporateImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IEvaporateImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnEvaporateImpulseEffect(effect);
        }
        observersForEvaporateImpulse.Remove(effect.id);
      }
    }
    effectsEvaporateImpulseDeleteEffect.Clear();


    foreach (var effect in effectsEvaporateImpulseCreateEffect) {
      if (observers.TryGetValue(0, out List<IEvaporateImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnEvaporateImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IEvaporateImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnEvaporateImpulseEffect(effect);
        }
      }
    }
    effectsEvaporateImpulseCreateEffect.Clear();
  }
  public TimeCloneAICapabilityUCIncarnation GetTimeCloneAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTimeCloneAICapabilityUC[id].incarnation;
  }
  public bool TimeCloneAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id);
  }
  public TimeCloneAICapabilityUC GetTimeCloneAICapabilityUC(int id) {
    return new TimeCloneAICapabilityUC(this, id);
  }
  public List<TimeCloneAICapabilityUC> AllTimeCloneAICapabilityUC() {
    List<TimeCloneAICapabilityUC> result = new List<TimeCloneAICapabilityUC>(rootIncarnation.incarnationsTimeCloneAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsTimeCloneAICapabilityUC.Keys) {
      result.Add(new TimeCloneAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<TimeCloneAICapabilityUC> EnumAllTimeCloneAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsTimeCloneAICapabilityUC.Keys) {
      yield return GetTimeCloneAICapabilityUC(id);
    }
  }
  public void CheckHasTimeCloneAICapabilityUC(TimeCloneAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTimeCloneAICapabilityUC(thing.id);
  }
  public void CheckHasTimeCloneAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid TimeCloneAICapabilityUC: " + id);
    }
  }
  public void AddTimeCloneAICapabilityUCObserver(int id, ITimeCloneAICapabilityUCEffectObserver observer) {
    List<ITimeCloneAICapabilityUCEffectObserver> obsies;
    if (!observersForTimeCloneAICapabilityUC.TryGetValue(id, out obsies)) {
      obsies = new List<ITimeCloneAICapabilityUCEffectObserver>();
    }
    obsies.Add(observer);
    observersForTimeCloneAICapabilityUC[id] = obsies;
  }

  public void RemoveTimeCloneAICapabilityUCObserver(int id, ITimeCloneAICapabilityUCEffectObserver observer) {
    if (observersForTimeCloneAICapabilityUC.ContainsKey(id)) {
      var list = observersForTimeCloneAICapabilityUC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForTimeCloneAICapabilityUC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public TimeCloneAICapabilityUC EffectTimeCloneAICapabilityUCCreate(
      IRequestMutList script) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new TimeCloneAICapabilityUCIncarnation(
            script.id
            );
    EffectInternalCreateTimeCloneAICapabilityUC(id, rootIncarnation.version, incarnation);
    return new TimeCloneAICapabilityUC(this, id);
  }
  public void EffectInternalCreateTimeCloneAICapabilityUC(
      int id,
      int incarnationVersion,
      TimeCloneAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new TimeCloneAICapabilityUCCreateEffect(id);
    rootIncarnation.incarnationsTimeCloneAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<TimeCloneAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsTimeCloneAICapabilityUCCreateEffect.Add(effect);
  }

  public void EffectTimeCloneAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = new TimeCloneAICapabilityUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTimeCloneAICapabilityUC[id];

    rootIncarnation.incarnationsTimeCloneAICapabilityUC.Remove(id);
    effectsTimeCloneAICapabilityUCDeleteEffect.Add(effect);
  }

     
  public int GetTimeCloneAICapabilityUCHash(int id, int version, TimeCloneAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    if (!object.ReferenceEquals(incarnation.script, null)) {
      result += id * version * 1 * incarnation.script.GetDeterministicHashCode();
    }
    return result;
  }
     
  public void BroadcastTimeCloneAICapabilityUCEffects(
      SortedDictionary<int, List<ITimeCloneAICapabilityUCEffectObserver>> observers) {
    foreach (var effect in effectsTimeCloneAICapabilityUCDeleteEffect) {
      if (observers.TryGetValue(0, out List<ITimeCloneAICapabilityUCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTimeCloneAICapabilityUCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITimeCloneAICapabilityUCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTimeCloneAICapabilityUCEffect(effect);
        }
        observersForTimeCloneAICapabilityUC.Remove(effect.id);
      }
    }
    effectsTimeCloneAICapabilityUCDeleteEffect.Clear();


    foreach (var effect in effectsTimeCloneAICapabilityUCCreateEffect) {
      if (observers.TryGetValue(0, out List<ITimeCloneAICapabilityUCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTimeCloneAICapabilityUCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITimeCloneAICapabilityUCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTimeCloneAICapabilityUCEffect(effect);
        }
      }
    }
    effectsTimeCloneAICapabilityUCCreateEffect.Clear();
  }
  public UnleashBideImpulseIncarnation GetUnleashBideImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsUnleashBideImpulse[id].incarnation;
  }
  public bool UnleashBideImpulseExists(int id) {
    return rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(id);
  }
  public UnleashBideImpulse GetUnleashBideImpulse(int id) {
    return new UnleashBideImpulse(this, id);
  }
  public List<UnleashBideImpulse> AllUnleashBideImpulse() {
    List<UnleashBideImpulse> result = new List<UnleashBideImpulse>(rootIncarnation.incarnationsUnleashBideImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsUnleashBideImpulse.Keys) {
      result.Add(new UnleashBideImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<UnleashBideImpulse> EnumAllUnleashBideImpulse() {
    foreach (var id in rootIncarnation.incarnationsUnleashBideImpulse.Keys) {
      yield return GetUnleashBideImpulse(id);
    }
  }
  public void CheckHasUnleashBideImpulse(UnleashBideImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasUnleashBideImpulse(thing.id);
  }
  public void CheckHasUnleashBideImpulse(int id) {
    if (!rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid UnleashBideImpulse: " + id);
    }
  }
  public void AddUnleashBideImpulseObserver(int id, IUnleashBideImpulseEffectObserver observer) {
    List<IUnleashBideImpulseEffectObserver> obsies;
    if (!observersForUnleashBideImpulse.TryGetValue(id, out obsies)) {
      obsies = new List<IUnleashBideImpulseEffectObserver>();
    }
    obsies.Add(observer);
    observersForUnleashBideImpulse[id] = obsies;
  }

  public void RemoveUnleashBideImpulseObserver(int id, IUnleashBideImpulseEffectObserver observer) {
    if (observersForUnleashBideImpulse.ContainsKey(id)) {
      var list = observersForUnleashBideImpulse[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForUnleashBideImpulse.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public UnleashBideImpulse EffectUnleashBideImpulseCreate(
      int weight) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new UnleashBideImpulseIncarnation(
            weight
            );
    EffectInternalCreateUnleashBideImpulse(id, rootIncarnation.version, incarnation);
    return new UnleashBideImpulse(this, id);
  }
  public void EffectInternalCreateUnleashBideImpulse(
      int id,
      int incarnationVersion,
      UnleashBideImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new UnleashBideImpulseCreateEffect(id);
    rootIncarnation.incarnationsUnleashBideImpulse.Add(
        id,
        new VersionAndIncarnation<UnleashBideImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    effectsUnleashBideImpulseCreateEffect.Add(effect);
  }

  public void EffectUnleashBideImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new UnleashBideImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsUnleashBideImpulse[id];

    rootIncarnation.incarnationsUnleashBideImpulse.Remove(id);
    effectsUnleashBideImpulseDeleteEffect.Add(effect);
  }

     
  public int GetUnleashBideImpulseHash(int id, int version, UnleashBideImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastUnleashBideImpulseEffects(
      SortedDictionary<int, List<IUnleashBideImpulseEffectObserver>> observers) {
    foreach (var effect in effectsUnleashBideImpulseDeleteEffect) {
      if (observers.TryGetValue(0, out List<IUnleashBideImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnUnleashBideImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IUnleashBideImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnUnleashBideImpulseEffect(effect);
        }
        observersForUnleashBideImpulse.Remove(effect.id);
      }
    }
    effectsUnleashBideImpulseDeleteEffect.Clear();


    foreach (var effect in effectsUnleashBideImpulseCreateEffect) {
      if (observers.TryGetValue(0, out List<IUnleashBideImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnUnleashBideImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IUnleashBideImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnUnleashBideImpulseEffect(effect);
        }
      }
    }
    effectsUnleashBideImpulseCreateEffect.Clear();
  }
  public ContinueBidingImpulseIncarnation GetContinueBidingImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsContinueBidingImpulse[id].incarnation;
  }
  public bool ContinueBidingImpulseExists(int id) {
    return rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(id);
  }
  public ContinueBidingImpulse GetContinueBidingImpulse(int id) {
    return new ContinueBidingImpulse(this, id);
  }
  public List<ContinueBidingImpulse> AllContinueBidingImpulse() {
    List<ContinueBidingImpulse> result = new List<ContinueBidingImpulse>(rootIncarnation.incarnationsContinueBidingImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsContinueBidingImpulse.Keys) {
      result.Add(new ContinueBidingImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<ContinueBidingImpulse> EnumAllContinueBidingImpulse() {
    foreach (var id in rootIncarnation.incarnationsContinueBidingImpulse.Keys) {
      yield return GetContinueBidingImpulse(id);
    }
  }
  public void CheckHasContinueBidingImpulse(ContinueBidingImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasContinueBidingImpulse(thing.id);
  }
  public void CheckHasContinueBidingImpulse(int id) {
    if (!rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid ContinueBidingImpulse: " + id);
    }
  }
  public void AddContinueBidingImpulseObserver(int id, IContinueBidingImpulseEffectObserver observer) {
    List<IContinueBidingImpulseEffectObserver> obsies;
    if (!observersForContinueBidingImpulse.TryGetValue(id, out obsies)) {
      obsies = new List<IContinueBidingImpulseEffectObserver>();
    }
    obsies.Add(observer);
    observersForContinueBidingImpulse[id] = obsies;
  }

  public void RemoveContinueBidingImpulseObserver(int id, IContinueBidingImpulseEffectObserver observer) {
    if (observersForContinueBidingImpulse.ContainsKey(id)) {
      var list = observersForContinueBidingImpulse[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForContinueBidingImpulse.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public ContinueBidingImpulse EffectContinueBidingImpulseCreate(
      int weight) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new ContinueBidingImpulseIncarnation(
            weight
            );
    EffectInternalCreateContinueBidingImpulse(id, rootIncarnation.version, incarnation);
    return new ContinueBidingImpulse(this, id);
  }
  public void EffectInternalCreateContinueBidingImpulse(
      int id,
      int incarnationVersion,
      ContinueBidingImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new ContinueBidingImpulseCreateEffect(id);
    rootIncarnation.incarnationsContinueBidingImpulse.Add(
        id,
        new VersionAndIncarnation<ContinueBidingImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    effectsContinueBidingImpulseCreateEffect.Add(effect);
  }

  public void EffectContinueBidingImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new ContinueBidingImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsContinueBidingImpulse[id];

    rootIncarnation.incarnationsContinueBidingImpulse.Remove(id);
    effectsContinueBidingImpulseDeleteEffect.Add(effect);
  }

     
  public int GetContinueBidingImpulseHash(int id, int version, ContinueBidingImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastContinueBidingImpulseEffects(
      SortedDictionary<int, List<IContinueBidingImpulseEffectObserver>> observers) {
    foreach (var effect in effectsContinueBidingImpulseDeleteEffect) {
      if (observers.TryGetValue(0, out List<IContinueBidingImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnContinueBidingImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IContinueBidingImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnContinueBidingImpulseEffect(effect);
        }
        observersForContinueBidingImpulse.Remove(effect.id);
      }
    }
    effectsContinueBidingImpulseDeleteEffect.Clear();


    foreach (var effect in effectsContinueBidingImpulseCreateEffect) {
      if (observers.TryGetValue(0, out List<IContinueBidingImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnContinueBidingImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IContinueBidingImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnContinueBidingImpulseEffect(effect);
        }
      }
    }
    effectsContinueBidingImpulseCreateEffect.Clear();
  }
  public StartBidingImpulseIncarnation GetStartBidingImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsStartBidingImpulse[id].incarnation;
  }
  public bool StartBidingImpulseExists(int id) {
    return rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(id);
  }
  public StartBidingImpulse GetStartBidingImpulse(int id) {
    return new StartBidingImpulse(this, id);
  }
  public List<StartBidingImpulse> AllStartBidingImpulse() {
    List<StartBidingImpulse> result = new List<StartBidingImpulse>(rootIncarnation.incarnationsStartBidingImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsStartBidingImpulse.Keys) {
      result.Add(new StartBidingImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<StartBidingImpulse> EnumAllStartBidingImpulse() {
    foreach (var id in rootIncarnation.incarnationsStartBidingImpulse.Keys) {
      yield return GetStartBidingImpulse(id);
    }
  }
  public void CheckHasStartBidingImpulse(StartBidingImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasStartBidingImpulse(thing.id);
  }
  public void CheckHasStartBidingImpulse(int id) {
    if (!rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid StartBidingImpulse: " + id);
    }
  }
  public void AddStartBidingImpulseObserver(int id, IStartBidingImpulseEffectObserver observer) {
    List<IStartBidingImpulseEffectObserver> obsies;
    if (!observersForStartBidingImpulse.TryGetValue(id, out obsies)) {
      obsies = new List<IStartBidingImpulseEffectObserver>();
    }
    obsies.Add(observer);
    observersForStartBidingImpulse[id] = obsies;
  }

  public void RemoveStartBidingImpulseObserver(int id, IStartBidingImpulseEffectObserver observer) {
    if (observersForStartBidingImpulse.ContainsKey(id)) {
      var list = observersForStartBidingImpulse[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForStartBidingImpulse.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public StartBidingImpulse EffectStartBidingImpulseCreate(
      int weight) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new StartBidingImpulseIncarnation(
            weight
            );
    EffectInternalCreateStartBidingImpulse(id, rootIncarnation.version, incarnation);
    return new StartBidingImpulse(this, id);
  }
  public void EffectInternalCreateStartBidingImpulse(
      int id,
      int incarnationVersion,
      StartBidingImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new StartBidingImpulseCreateEffect(id);
    rootIncarnation.incarnationsStartBidingImpulse.Add(
        id,
        new VersionAndIncarnation<StartBidingImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    effectsStartBidingImpulseCreateEffect.Add(effect);
  }

  public void EffectStartBidingImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new StartBidingImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsStartBidingImpulse[id];

    rootIncarnation.incarnationsStartBidingImpulse.Remove(id);
    effectsStartBidingImpulseDeleteEffect.Add(effect);
  }

     
  public int GetStartBidingImpulseHash(int id, int version, StartBidingImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastStartBidingImpulseEffects(
      SortedDictionary<int, List<IStartBidingImpulseEffectObserver>> observers) {
    foreach (var effect in effectsStartBidingImpulseDeleteEffect) {
      if (observers.TryGetValue(0, out List<IStartBidingImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnStartBidingImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IStartBidingImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnStartBidingImpulseEffect(effect);
        }
        observersForStartBidingImpulse.Remove(effect.id);
      }
    }
    effectsStartBidingImpulseDeleteEffect.Clear();


    foreach (var effect in effectsStartBidingImpulseCreateEffect) {
      if (observers.TryGetValue(0, out List<IStartBidingImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnStartBidingImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IStartBidingImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnStartBidingImpulseEffect(effect);
        }
      }
    }
    effectsStartBidingImpulseCreateEffect.Clear();
  }
  public BideAICapabilityUCIncarnation GetBideAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBideAICapabilityUC[id].incarnation;
  }
  public bool BideAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id);
  }
  public BideAICapabilityUC GetBideAICapabilityUC(int id) {
    return new BideAICapabilityUC(this, id);
  }
  public List<BideAICapabilityUC> AllBideAICapabilityUC() {
    List<BideAICapabilityUC> result = new List<BideAICapabilityUC>(rootIncarnation.incarnationsBideAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsBideAICapabilityUC.Keys) {
      result.Add(new BideAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<BideAICapabilityUC> EnumAllBideAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsBideAICapabilityUC.Keys) {
      yield return GetBideAICapabilityUC(id);
    }
  }
  public void CheckHasBideAICapabilityUC(BideAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBideAICapabilityUC(thing.id);
  }
  public void CheckHasBideAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid BideAICapabilityUC: " + id);
    }
  }
  public void AddBideAICapabilityUCObserver(int id, IBideAICapabilityUCEffectObserver observer) {
    List<IBideAICapabilityUCEffectObserver> obsies;
    if (!observersForBideAICapabilityUC.TryGetValue(id, out obsies)) {
      obsies = new List<IBideAICapabilityUCEffectObserver>();
    }
    obsies.Add(observer);
    observersForBideAICapabilityUC[id] = obsies;
  }

  public void RemoveBideAICapabilityUCObserver(int id, IBideAICapabilityUCEffectObserver observer) {
    if (observersForBideAICapabilityUC.ContainsKey(id)) {
      var list = observersForBideAICapabilityUC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForBideAICapabilityUC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public BideAICapabilityUC EffectBideAICapabilityUCCreate(
      int charge) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new BideAICapabilityUCIncarnation(
            charge
            );
    EffectInternalCreateBideAICapabilityUC(id, rootIncarnation.version, incarnation);
    return new BideAICapabilityUC(this, id);
  }
  public void EffectInternalCreateBideAICapabilityUC(
      int id,
      int incarnationVersion,
      BideAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new BideAICapabilityUCCreateEffect(id);
    rootIncarnation.incarnationsBideAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<BideAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsBideAICapabilityUCCreateEffect.Add(effect);
  }

  public void EffectBideAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = new BideAICapabilityUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBideAICapabilityUC[id];

    rootIncarnation.incarnationsBideAICapabilityUC.Remove(id);
    effectsBideAICapabilityUCDeleteEffect.Add(effect);
  }

     
  public int GetBideAICapabilityUCHash(int id, int version, BideAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.charge.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastBideAICapabilityUCEffects(
      SortedDictionary<int, List<IBideAICapabilityUCEffectObserver>> observers) {
    foreach (var effect in effectsBideAICapabilityUCDeleteEffect) {
      if (observers.TryGetValue(0, out List<IBideAICapabilityUCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnBideAICapabilityUCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IBideAICapabilityUCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnBideAICapabilityUCEffect(effect);
        }
        observersForBideAICapabilityUC.Remove(effect.id);
      }
    }
    effectsBideAICapabilityUCDeleteEffect.Clear();


    foreach (var effect in effectsBideAICapabilityUCSetChargeEffect) {
      if (observers.TryGetValue(0, out List<IBideAICapabilityUCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnBideAICapabilityUCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IBideAICapabilityUCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnBideAICapabilityUCEffect(effect);
        }
      }
    }
    effectsBideAICapabilityUCSetChargeEffect.Clear();

    foreach (var effect in effectsBideAICapabilityUCCreateEffect) {
      if (observers.TryGetValue(0, out List<IBideAICapabilityUCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnBideAICapabilityUCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IBideAICapabilityUCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnBideAICapabilityUCEffect(effect);
        }
      }
    }
    effectsBideAICapabilityUCCreateEffect.Clear();
  }

  public void EffectBideAICapabilityUCSetCharge(int id, int newValue) {
    CheckUnlocked();
    CheckHasBideAICapabilityUC(id);
    var effect = new BideAICapabilityUCSetChargeEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsBideAICapabilityUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.charge;
      oldIncarnationAndVersion.incarnation.charge = newValue;

    } else {
      var newIncarnation =
          new BideAICapabilityUCIncarnation(
              newValue);
      rootIncarnation.incarnationsBideAICapabilityUC[id] =
          new VersionAndIncarnation<BideAICapabilityUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsBideAICapabilityUCSetChargeEffect.Add(effect);
  }
  public FireImpulseIncarnation GetFireImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsFireImpulse[id].incarnation;
  }
  public bool FireImpulseExists(int id) {
    return rootIncarnation.incarnationsFireImpulse.ContainsKey(id);
  }
  public FireImpulse GetFireImpulse(int id) {
    return new FireImpulse(this, id);
  }
  public List<FireImpulse> AllFireImpulse() {
    List<FireImpulse> result = new List<FireImpulse>(rootIncarnation.incarnationsFireImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsFireImpulse.Keys) {
      result.Add(new FireImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<FireImpulse> EnumAllFireImpulse() {
    foreach (var id in rootIncarnation.incarnationsFireImpulse.Keys) {
      yield return GetFireImpulse(id);
    }
  }
  public void CheckHasFireImpulse(FireImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasFireImpulse(thing.id);
  }
  public void CheckHasFireImpulse(int id) {
    if (!rootIncarnation.incarnationsFireImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid FireImpulse: " + id);
    }
  }
  public void AddFireImpulseObserver(int id, IFireImpulseEffectObserver observer) {
    List<IFireImpulseEffectObserver> obsies;
    if (!observersForFireImpulse.TryGetValue(id, out obsies)) {
      obsies = new List<IFireImpulseEffectObserver>();
    }
    obsies.Add(observer);
    observersForFireImpulse[id] = obsies;
  }

  public void RemoveFireImpulseObserver(int id, IFireImpulseEffectObserver observer) {
    if (observersForFireImpulse.ContainsKey(id)) {
      var list = observersForFireImpulse[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForFireImpulse.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public FireImpulse EffectFireImpulseCreate(
      int weight,
      Unit targetUnit) {
    CheckUnlocked();
    CheckHasUnit(targetUnit);

    var id = NewId();
    var incarnation =
        new FireImpulseIncarnation(
            weight,
            targetUnit.id
            );
    EffectInternalCreateFireImpulse(id, rootIncarnation.version, incarnation);
    return new FireImpulse(this, id);
  }
  public void EffectInternalCreateFireImpulse(
      int id,
      int incarnationVersion,
      FireImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new FireImpulseCreateEffect(id);
    rootIncarnation.incarnationsFireImpulse.Add(
        id,
        new VersionAndIncarnation<FireImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    effectsFireImpulseCreateEffect.Add(effect);
  }

  public void EffectFireImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new FireImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsFireImpulse[id];

    rootIncarnation.incarnationsFireImpulse.Remove(id);
    effectsFireImpulseDeleteEffect.Add(effect);
  }

     
  public int GetFireImpulseHash(int id, int version, FireImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.targetUnit.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastFireImpulseEffects(
      SortedDictionary<int, List<IFireImpulseEffectObserver>> observers) {
    foreach (var effect in effectsFireImpulseDeleteEffect) {
      if (observers.TryGetValue(0, out List<IFireImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnFireImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IFireImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnFireImpulseEffect(effect);
        }
        observersForFireImpulse.Remove(effect.id);
      }
    }
    effectsFireImpulseDeleteEffect.Clear();


    foreach (var effect in effectsFireImpulseCreateEffect) {
      if (observers.TryGetValue(0, out List<IFireImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnFireImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IFireImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnFireImpulseEffect(effect);
        }
      }
    }
    effectsFireImpulseCreateEffect.Clear();
  }
  public CounterImpulseIncarnation GetCounterImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCounterImpulse[id].incarnation;
  }
  public bool CounterImpulseExists(int id) {
    return rootIncarnation.incarnationsCounterImpulse.ContainsKey(id);
  }
  public CounterImpulse GetCounterImpulse(int id) {
    return new CounterImpulse(this, id);
  }
  public List<CounterImpulse> AllCounterImpulse() {
    List<CounterImpulse> result = new List<CounterImpulse>(rootIncarnation.incarnationsCounterImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsCounterImpulse.Keys) {
      result.Add(new CounterImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<CounterImpulse> EnumAllCounterImpulse() {
    foreach (var id in rootIncarnation.incarnationsCounterImpulse.Keys) {
      yield return GetCounterImpulse(id);
    }
  }
  public void CheckHasCounterImpulse(CounterImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCounterImpulse(thing.id);
  }
  public void CheckHasCounterImpulse(int id) {
    if (!rootIncarnation.incarnationsCounterImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid CounterImpulse: " + id);
    }
  }
  public void AddCounterImpulseObserver(int id, ICounterImpulseEffectObserver observer) {
    List<ICounterImpulseEffectObserver> obsies;
    if (!observersForCounterImpulse.TryGetValue(id, out obsies)) {
      obsies = new List<ICounterImpulseEffectObserver>();
    }
    obsies.Add(observer);
    observersForCounterImpulse[id] = obsies;
  }

  public void RemoveCounterImpulseObserver(int id, ICounterImpulseEffectObserver observer) {
    if (observersForCounterImpulse.ContainsKey(id)) {
      var list = observersForCounterImpulse[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForCounterImpulse.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public CounterImpulse EffectCounterImpulseCreate(
      int weight) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new CounterImpulseIncarnation(
            weight
            );
    EffectInternalCreateCounterImpulse(id, rootIncarnation.version, incarnation);
    return new CounterImpulse(this, id);
  }
  public void EffectInternalCreateCounterImpulse(
      int id,
      int incarnationVersion,
      CounterImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new CounterImpulseCreateEffect(id);
    rootIncarnation.incarnationsCounterImpulse.Add(
        id,
        new VersionAndIncarnation<CounterImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    effectsCounterImpulseCreateEffect.Add(effect);
  }

  public void EffectCounterImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new CounterImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCounterImpulse[id];

    rootIncarnation.incarnationsCounterImpulse.Remove(id);
    effectsCounterImpulseDeleteEffect.Add(effect);
  }

     
  public int GetCounterImpulseHash(int id, int version, CounterImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastCounterImpulseEffects(
      SortedDictionary<int, List<ICounterImpulseEffectObserver>> observers) {
    foreach (var effect in effectsCounterImpulseDeleteEffect) {
      if (observers.TryGetValue(0, out List<ICounterImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCounterImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICounterImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCounterImpulseEffect(effect);
        }
        observersForCounterImpulse.Remove(effect.id);
      }
    }
    effectsCounterImpulseDeleteEffect.Clear();


    foreach (var effect in effectsCounterImpulseCreateEffect) {
      if (observers.TryGetValue(0, out List<ICounterImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCounterImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICounterImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCounterImpulseEffect(effect);
        }
      }
    }
    effectsCounterImpulseCreateEffect.Clear();
  }
  public DefendImpulseIncarnation GetDefendImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsDefendImpulse[id].incarnation;
  }
  public bool DefendImpulseExists(int id) {
    return rootIncarnation.incarnationsDefendImpulse.ContainsKey(id);
  }
  public DefendImpulse GetDefendImpulse(int id) {
    return new DefendImpulse(this, id);
  }
  public List<DefendImpulse> AllDefendImpulse() {
    List<DefendImpulse> result = new List<DefendImpulse>(rootIncarnation.incarnationsDefendImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsDefendImpulse.Keys) {
      result.Add(new DefendImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<DefendImpulse> EnumAllDefendImpulse() {
    foreach (var id in rootIncarnation.incarnationsDefendImpulse.Keys) {
      yield return GetDefendImpulse(id);
    }
  }
  public void CheckHasDefendImpulse(DefendImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasDefendImpulse(thing.id);
  }
  public void CheckHasDefendImpulse(int id) {
    if (!rootIncarnation.incarnationsDefendImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid DefendImpulse: " + id);
    }
  }
  public void AddDefendImpulseObserver(int id, IDefendImpulseEffectObserver observer) {
    List<IDefendImpulseEffectObserver> obsies;
    if (!observersForDefendImpulse.TryGetValue(id, out obsies)) {
      obsies = new List<IDefendImpulseEffectObserver>();
    }
    obsies.Add(observer);
    observersForDefendImpulse[id] = obsies;
  }

  public void RemoveDefendImpulseObserver(int id, IDefendImpulseEffectObserver observer) {
    if (observersForDefendImpulse.ContainsKey(id)) {
      var list = observersForDefendImpulse[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForDefendImpulse.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public DefendImpulse EffectDefendImpulseCreate(
      int weight) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new DefendImpulseIncarnation(
            weight
            );
    EffectInternalCreateDefendImpulse(id, rootIncarnation.version, incarnation);
    return new DefendImpulse(this, id);
  }
  public void EffectInternalCreateDefendImpulse(
      int id,
      int incarnationVersion,
      DefendImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new DefendImpulseCreateEffect(id);
    rootIncarnation.incarnationsDefendImpulse.Add(
        id,
        new VersionAndIncarnation<DefendImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    effectsDefendImpulseCreateEffect.Add(effect);
  }

  public void EffectDefendImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new DefendImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsDefendImpulse[id];

    rootIncarnation.incarnationsDefendImpulse.Remove(id);
    effectsDefendImpulseDeleteEffect.Add(effect);
  }

     
  public int GetDefendImpulseHash(int id, int version, DefendImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastDefendImpulseEffects(
      SortedDictionary<int, List<IDefendImpulseEffectObserver>> observers) {
    foreach (var effect in effectsDefendImpulseDeleteEffect) {
      if (observers.TryGetValue(0, out List<IDefendImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnDefendImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IDefendImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnDefendImpulseEffect(effect);
        }
        observersForDefendImpulse.Remove(effect.id);
      }
    }
    effectsDefendImpulseDeleteEffect.Clear();


    foreach (var effect in effectsDefendImpulseCreateEffect) {
      if (observers.TryGetValue(0, out List<IDefendImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnDefendImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IDefendImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnDefendImpulseEffect(effect);
        }
      }
    }
    effectsDefendImpulseCreateEffect.Clear();
  }
  public AttackImpulseIncarnation GetAttackImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsAttackImpulse[id].incarnation;
  }
  public bool AttackImpulseExists(int id) {
    return rootIncarnation.incarnationsAttackImpulse.ContainsKey(id);
  }
  public AttackImpulse GetAttackImpulse(int id) {
    return new AttackImpulse(this, id);
  }
  public List<AttackImpulse> AllAttackImpulse() {
    List<AttackImpulse> result = new List<AttackImpulse>(rootIncarnation.incarnationsAttackImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsAttackImpulse.Keys) {
      result.Add(new AttackImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<AttackImpulse> EnumAllAttackImpulse() {
    foreach (var id in rootIncarnation.incarnationsAttackImpulse.Keys) {
      yield return GetAttackImpulse(id);
    }
  }
  public void CheckHasAttackImpulse(AttackImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasAttackImpulse(thing.id);
  }
  public void CheckHasAttackImpulse(int id) {
    if (!rootIncarnation.incarnationsAttackImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid AttackImpulse: " + id);
    }
  }
  public void AddAttackImpulseObserver(int id, IAttackImpulseEffectObserver observer) {
    List<IAttackImpulseEffectObserver> obsies;
    if (!observersForAttackImpulse.TryGetValue(id, out obsies)) {
      obsies = new List<IAttackImpulseEffectObserver>();
    }
    obsies.Add(observer);
    observersForAttackImpulse[id] = obsies;
  }

  public void RemoveAttackImpulseObserver(int id, IAttackImpulseEffectObserver observer) {
    if (observersForAttackImpulse.ContainsKey(id)) {
      var list = observersForAttackImpulse[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForAttackImpulse.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public AttackImpulse EffectAttackImpulseCreate(
      int weight,
      Unit targetUnit) {
    CheckUnlocked();
    CheckHasUnit(targetUnit);

    var id = NewId();
    var incarnation =
        new AttackImpulseIncarnation(
            weight,
            targetUnit.id
            );
    EffectInternalCreateAttackImpulse(id, rootIncarnation.version, incarnation);
    return new AttackImpulse(this, id);
  }
  public void EffectInternalCreateAttackImpulse(
      int id,
      int incarnationVersion,
      AttackImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new AttackImpulseCreateEffect(id);
    rootIncarnation.incarnationsAttackImpulse.Add(
        id,
        new VersionAndIncarnation<AttackImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    effectsAttackImpulseCreateEffect.Add(effect);
  }

  public void EffectAttackImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new AttackImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsAttackImpulse[id];

    rootIncarnation.incarnationsAttackImpulse.Remove(id);
    effectsAttackImpulseDeleteEffect.Add(effect);
  }

     
  public int GetAttackImpulseHash(int id, int version, AttackImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.targetUnit.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastAttackImpulseEffects(
      SortedDictionary<int, List<IAttackImpulseEffectObserver>> observers) {
    foreach (var effect in effectsAttackImpulseDeleteEffect) {
      if (observers.TryGetValue(0, out List<IAttackImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnAttackImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IAttackImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnAttackImpulseEffect(effect);
        }
        observersForAttackImpulse.Remove(effect.id);
      }
    }
    effectsAttackImpulseDeleteEffect.Clear();


    foreach (var effect in effectsAttackImpulseCreateEffect) {
      if (observers.TryGetValue(0, out List<IAttackImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnAttackImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IAttackImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnAttackImpulseEffect(effect);
        }
      }
    }
    effectsAttackImpulseCreateEffect.Clear();
  }
  public PursueImpulseIncarnation GetPursueImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsPursueImpulse[id].incarnation;
  }
  public bool PursueImpulseExists(int id) {
    return rootIncarnation.incarnationsPursueImpulse.ContainsKey(id);
  }
  public PursueImpulse GetPursueImpulse(int id) {
    return new PursueImpulse(this, id);
  }
  public List<PursueImpulse> AllPursueImpulse() {
    List<PursueImpulse> result = new List<PursueImpulse>(rootIncarnation.incarnationsPursueImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsPursueImpulse.Keys) {
      result.Add(new PursueImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<PursueImpulse> EnumAllPursueImpulse() {
    foreach (var id in rootIncarnation.incarnationsPursueImpulse.Keys) {
      yield return GetPursueImpulse(id);
    }
  }
  public void CheckHasPursueImpulse(PursueImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasPursueImpulse(thing.id);
  }
  public void CheckHasPursueImpulse(int id) {
    if (!rootIncarnation.incarnationsPursueImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid PursueImpulse: " + id);
    }
  }
  public void AddPursueImpulseObserver(int id, IPursueImpulseEffectObserver observer) {
    List<IPursueImpulseEffectObserver> obsies;
    if (!observersForPursueImpulse.TryGetValue(id, out obsies)) {
      obsies = new List<IPursueImpulseEffectObserver>();
    }
    obsies.Add(observer);
    observersForPursueImpulse[id] = obsies;
  }

  public void RemovePursueImpulseObserver(int id, IPursueImpulseEffectObserver observer) {
    if (observersForPursueImpulse.ContainsKey(id)) {
      var list = observersForPursueImpulse[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForPursueImpulse.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public PursueImpulse EffectPursueImpulseCreate(
      int weight) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new PursueImpulseIncarnation(
            weight
            );
    EffectInternalCreatePursueImpulse(id, rootIncarnation.version, incarnation);
    return new PursueImpulse(this, id);
  }
  public void EffectInternalCreatePursueImpulse(
      int id,
      int incarnationVersion,
      PursueImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new PursueImpulseCreateEffect(id);
    rootIncarnation.incarnationsPursueImpulse.Add(
        id,
        new VersionAndIncarnation<PursueImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    effectsPursueImpulseCreateEffect.Add(effect);
  }

  public void EffectPursueImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new PursueImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsPursueImpulse[id];

    rootIncarnation.incarnationsPursueImpulse.Remove(id);
    effectsPursueImpulseDeleteEffect.Add(effect);
  }

     
  public int GetPursueImpulseHash(int id, int version, PursueImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastPursueImpulseEffects(
      SortedDictionary<int, List<IPursueImpulseEffectObserver>> observers) {
    foreach (var effect in effectsPursueImpulseDeleteEffect) {
      if (observers.TryGetValue(0, out List<IPursueImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnPursueImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IPursueImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnPursueImpulseEffect(effect);
        }
        observersForPursueImpulse.Remove(effect.id);
      }
    }
    effectsPursueImpulseDeleteEffect.Clear();


    foreach (var effect in effectsPursueImpulseCreateEffect) {
      if (observers.TryGetValue(0, out List<IPursueImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnPursueImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IPursueImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnPursueImpulseEffect(effect);
        }
      }
    }
    effectsPursueImpulseCreateEffect.Clear();
  }
  public KillDirectiveIncarnation GetKillDirectiveIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsKillDirective[id].incarnation;
  }
  public bool KillDirectiveExists(int id) {
    return rootIncarnation.incarnationsKillDirective.ContainsKey(id);
  }
  public KillDirective GetKillDirective(int id) {
    return new KillDirective(this, id);
  }
  public List<KillDirective> AllKillDirective() {
    List<KillDirective> result = new List<KillDirective>(rootIncarnation.incarnationsKillDirective.Count);
    foreach (var id in rootIncarnation.incarnationsKillDirective.Keys) {
      result.Add(new KillDirective(this, id));
    }
    return result;
  }
  public IEnumerator<KillDirective> EnumAllKillDirective() {
    foreach (var id in rootIncarnation.incarnationsKillDirective.Keys) {
      yield return GetKillDirective(id);
    }
  }
  public void CheckHasKillDirective(KillDirective thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasKillDirective(thing.id);
  }
  public void CheckHasKillDirective(int id) {
    if (!rootIncarnation.incarnationsKillDirective.ContainsKey(id)) {
      throw new System.Exception("Invalid KillDirective: " + id);
    }
  }
  public void AddKillDirectiveObserver(int id, IKillDirectiveEffectObserver observer) {
    List<IKillDirectiveEffectObserver> obsies;
    if (!observersForKillDirective.TryGetValue(id, out obsies)) {
      obsies = new List<IKillDirectiveEffectObserver>();
    }
    obsies.Add(observer);
    observersForKillDirective[id] = obsies;
  }

  public void RemoveKillDirectiveObserver(int id, IKillDirectiveEffectObserver observer) {
    if (observersForKillDirective.ContainsKey(id)) {
      var list = observersForKillDirective[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForKillDirective.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public KillDirective EffectKillDirectiveCreate(
      Unit targetUnit,
      LocationMutList pathToLastSeenLocation) {
    CheckUnlocked();
    CheckHasUnit(targetUnit);
    CheckHasLocationMutList(pathToLastSeenLocation);

    var id = NewId();
    var incarnation =
        new KillDirectiveIncarnation(
            targetUnit.id,
            pathToLastSeenLocation.id
            );
    EffectInternalCreateKillDirective(id, rootIncarnation.version, incarnation);
    return new KillDirective(this, id);
  }
  public void EffectInternalCreateKillDirective(
      int id,
      int incarnationVersion,
      KillDirectiveIncarnation incarnation) {
    CheckUnlocked();
    var effect = new KillDirectiveCreateEffect(id);
    rootIncarnation.incarnationsKillDirective.Add(
        id,
        new VersionAndIncarnation<KillDirectiveIncarnation>(
            incarnationVersion,
            incarnation));
    effectsKillDirectiveCreateEffect.Add(effect);
  }

  public void EffectKillDirectiveDelete(int id) {
    CheckUnlocked();
    var effect = new KillDirectiveDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsKillDirective[id];

    rootIncarnation.incarnationsKillDirective.Remove(id);
    effectsKillDirectiveDeleteEffect.Add(effect);
  }

     
  public int GetKillDirectiveHash(int id, int version, KillDirectiveIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.targetUnit.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.pathToLastSeenLocation.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastKillDirectiveEffects(
      SortedDictionary<int, List<IKillDirectiveEffectObserver>> observers) {
    foreach (var effect in effectsKillDirectiveDeleteEffect) {
      if (observers.TryGetValue(0, out List<IKillDirectiveEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnKillDirectiveEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IKillDirectiveEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnKillDirectiveEffect(effect);
        }
        observersForKillDirective.Remove(effect.id);
      }
    }
    effectsKillDirectiveDeleteEffect.Clear();


    foreach (var effect in effectsKillDirectiveCreateEffect) {
      if (observers.TryGetValue(0, out List<IKillDirectiveEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnKillDirectiveEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IKillDirectiveEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnKillDirectiveEffect(effect);
        }
      }
    }
    effectsKillDirectiveCreateEffect.Clear();
  }
  public AttackAICapabilityUCIncarnation GetAttackAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsAttackAICapabilityUC[id].incarnation;
  }
  public bool AttackAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id);
  }
  public AttackAICapabilityUC GetAttackAICapabilityUC(int id) {
    return new AttackAICapabilityUC(this, id);
  }
  public List<AttackAICapabilityUC> AllAttackAICapabilityUC() {
    List<AttackAICapabilityUC> result = new List<AttackAICapabilityUC>(rootIncarnation.incarnationsAttackAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsAttackAICapabilityUC.Keys) {
      result.Add(new AttackAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<AttackAICapabilityUC> EnumAllAttackAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsAttackAICapabilityUC.Keys) {
      yield return GetAttackAICapabilityUC(id);
    }
  }
  public void CheckHasAttackAICapabilityUC(AttackAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasAttackAICapabilityUC(thing.id);
  }
  public void CheckHasAttackAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid AttackAICapabilityUC: " + id);
    }
  }
  public void AddAttackAICapabilityUCObserver(int id, IAttackAICapabilityUCEffectObserver observer) {
    List<IAttackAICapabilityUCEffectObserver> obsies;
    if (!observersForAttackAICapabilityUC.TryGetValue(id, out obsies)) {
      obsies = new List<IAttackAICapabilityUCEffectObserver>();
    }
    obsies.Add(observer);
    observersForAttackAICapabilityUC[id] = obsies;
  }

  public void RemoveAttackAICapabilityUCObserver(int id, IAttackAICapabilityUCEffectObserver observer) {
    if (observersForAttackAICapabilityUC.ContainsKey(id)) {
      var list = observersForAttackAICapabilityUC[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForAttackAICapabilityUC.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public AttackAICapabilityUC EffectAttackAICapabilityUCCreate(
      KillDirective killDirective) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new AttackAICapabilityUCIncarnation(
            killDirective.id
            );
    EffectInternalCreateAttackAICapabilityUC(id, rootIncarnation.version, incarnation);
    return new AttackAICapabilityUC(this, id);
  }
  public void EffectInternalCreateAttackAICapabilityUC(
      int id,
      int incarnationVersion,
      AttackAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new AttackAICapabilityUCCreateEffect(id);
    rootIncarnation.incarnationsAttackAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<AttackAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    effectsAttackAICapabilityUCCreateEffect.Add(effect);
  }

  public void EffectAttackAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = new AttackAICapabilityUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsAttackAICapabilityUC[id];

    rootIncarnation.incarnationsAttackAICapabilityUC.Remove(id);
    effectsAttackAICapabilityUCDeleteEffect.Add(effect);
  }

     
  public int GetAttackAICapabilityUCHash(int id, int version, AttackAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    if (!object.ReferenceEquals(incarnation.killDirective, null)) {
      result += id * version * 1 * incarnation.killDirective.GetDeterministicHashCode();
    }
    return result;
  }
     
  public void BroadcastAttackAICapabilityUCEffects(
      SortedDictionary<int, List<IAttackAICapabilityUCEffectObserver>> observers) {
    foreach (var effect in effectsAttackAICapabilityUCDeleteEffect) {
      if (observers.TryGetValue(0, out List<IAttackAICapabilityUCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnAttackAICapabilityUCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IAttackAICapabilityUCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnAttackAICapabilityUCEffect(effect);
        }
        observersForAttackAICapabilityUC.Remove(effect.id);
      }
    }
    effectsAttackAICapabilityUCDeleteEffect.Clear();


    foreach (var effect in effectsAttackAICapabilityUCSetKillDirectiveEffect) {
      if (observers.TryGetValue(0, out List<IAttackAICapabilityUCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnAttackAICapabilityUCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IAttackAICapabilityUCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnAttackAICapabilityUCEffect(effect);
        }
      }
    }
    effectsAttackAICapabilityUCSetKillDirectiveEffect.Clear();

    foreach (var effect in effectsAttackAICapabilityUCCreateEffect) {
      if (observers.TryGetValue(0, out List<IAttackAICapabilityUCEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnAttackAICapabilityUCEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IAttackAICapabilityUCEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnAttackAICapabilityUCEffect(effect);
        }
      }
    }
    effectsAttackAICapabilityUCCreateEffect.Clear();
  }

  public void EffectAttackAICapabilityUCSetKillDirective(int id, KillDirective newValue) {
    CheckUnlocked();
    CheckHasAttackAICapabilityUC(id);
    var effect = new AttackAICapabilityUCSetKillDirectiveEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsAttackAICapabilityUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldId = oldIncarnationAndVersion.incarnation.killDirective;
      oldIncarnationAndVersion.incarnation.killDirective = newValue.id;

    } else {
      var newIncarnation =
          new AttackAICapabilityUCIncarnation(
              newValue.id);
      rootIncarnation.incarnationsAttackAICapabilityUC[id] =
          new VersionAndIncarnation<AttackAICapabilityUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsAttackAICapabilityUCSetKillDirectiveEffect.Add(effect);
  }
  public MoveImpulseIncarnation GetMoveImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsMoveImpulse[id].incarnation;
  }
  public bool MoveImpulseExists(int id) {
    return rootIncarnation.incarnationsMoveImpulse.ContainsKey(id);
  }
  public MoveImpulse GetMoveImpulse(int id) {
    return new MoveImpulse(this, id);
  }
  public List<MoveImpulse> AllMoveImpulse() {
    List<MoveImpulse> result = new List<MoveImpulse>(rootIncarnation.incarnationsMoveImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsMoveImpulse.Keys) {
      result.Add(new MoveImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<MoveImpulse> EnumAllMoveImpulse() {
    foreach (var id in rootIncarnation.incarnationsMoveImpulse.Keys) {
      yield return GetMoveImpulse(id);
    }
  }
  public void CheckHasMoveImpulse(MoveImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasMoveImpulse(thing.id);
  }
  public void CheckHasMoveImpulse(int id) {
    if (!rootIncarnation.incarnationsMoveImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid MoveImpulse: " + id);
    }
  }
  public void AddMoveImpulseObserver(int id, IMoveImpulseEffectObserver observer) {
    List<IMoveImpulseEffectObserver> obsies;
    if (!observersForMoveImpulse.TryGetValue(id, out obsies)) {
      obsies = new List<IMoveImpulseEffectObserver>();
    }
    obsies.Add(observer);
    observersForMoveImpulse[id] = obsies;
  }

  public void RemoveMoveImpulseObserver(int id, IMoveImpulseEffectObserver observer) {
    if (observersForMoveImpulse.ContainsKey(id)) {
      var list = observersForMoveImpulse[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForMoveImpulse.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public MoveImpulse EffectMoveImpulseCreate(
      int weight,
      Location stepLocation) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new MoveImpulseIncarnation(
            weight,
            stepLocation
            );
    EffectInternalCreateMoveImpulse(id, rootIncarnation.version, incarnation);
    return new MoveImpulse(this, id);
  }
  public void EffectInternalCreateMoveImpulse(
      int id,
      int incarnationVersion,
      MoveImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new MoveImpulseCreateEffect(id);
    rootIncarnation.incarnationsMoveImpulse.Add(
        id,
        new VersionAndIncarnation<MoveImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    effectsMoveImpulseCreateEffect.Add(effect);
  }

  public void EffectMoveImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new MoveImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsMoveImpulse[id];

    rootIncarnation.incarnationsMoveImpulse.Remove(id);
    effectsMoveImpulseDeleteEffect.Add(effect);
  }

     
  public int GetMoveImpulseHash(int id, int version, MoveImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.stepLocation.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastMoveImpulseEffects(
      SortedDictionary<int, List<IMoveImpulseEffectObserver>> observers) {
    foreach (var effect in effectsMoveImpulseDeleteEffect) {
      if (observers.TryGetValue(0, out List<IMoveImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnMoveImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IMoveImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnMoveImpulseEffect(effect);
        }
        observersForMoveImpulse.Remove(effect.id);
      }
    }
    effectsMoveImpulseDeleteEffect.Clear();


    foreach (var effect in effectsMoveImpulseCreateEffect) {
      if (observers.TryGetValue(0, out List<IMoveImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnMoveImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IMoveImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnMoveImpulseEffect(effect);
        }
      }
    }
    effectsMoveImpulseCreateEffect.Clear();
  }
  public UnitIncarnation GetUnitIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsUnit[id].incarnation;
  }
  public bool UnitExists(int id) {
    return rootIncarnation.incarnationsUnit.ContainsKey(id);
  }
  public Unit GetUnit(int id) {
    return new Unit(this, id);
  }
  public List<Unit> AllUnit() {
    List<Unit> result = new List<Unit>(rootIncarnation.incarnationsUnit.Count);
    foreach (var id in rootIncarnation.incarnationsUnit.Keys) {
      result.Add(new Unit(this, id));
    }
    return result;
  }
  public IEnumerator<Unit> EnumAllUnit() {
    foreach (var id in rootIncarnation.incarnationsUnit.Keys) {
      yield return GetUnit(id);
    }
  }
  public void CheckHasUnit(Unit thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasUnit(thing.id);
  }
  public void CheckHasUnit(int id) {
    if (!rootIncarnation.incarnationsUnit.ContainsKey(id)) {
      throw new System.Exception("Invalid Unit: " + id);
    }
  }
  public void AddUnitObserver(int id, IUnitEffectObserver observer) {
    List<IUnitEffectObserver> obsies;
    if (!observersForUnit.TryGetValue(id, out obsies)) {
      obsies = new List<IUnitEffectObserver>();
    }
    obsies.Add(observer);
    observersForUnit[id] = obsies;
  }

  public void RemoveUnitObserver(int id, IUnitEffectObserver observer) {
    if (observersForUnit.ContainsKey(id)) {
      var list = observersForUnit[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForUnit.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public Unit EffectUnitCreate(
      IUnitEventMutList events,
      bool alive,
      int lifeEndTime,
      Location location,
      string classId,
      int hp,
      int maxHp,
      int mp,
      int maxMp,
      int inertia,
      int nextActionTime,
      IUnitComponentMutBunch components,
      bool good,
      int strength) {
    CheckUnlocked();
    CheckHasIUnitEventMutList(events);
    CheckHasIUnitComponentMutBunch(components);

    var id = NewId();
    var incarnation =
        new UnitIncarnation(
            events.id,
            alive,
            lifeEndTime,
            location,
            classId,
            hp,
            maxHp,
            mp,
            maxMp,
            inertia,
            nextActionTime,
            components.id,
            good,
            strength
            );
    EffectInternalCreateUnit(id, rootIncarnation.version, incarnation);
    return new Unit(this, id);
  }
  public void EffectInternalCreateUnit(
      int id,
      int incarnationVersion,
      UnitIncarnation incarnation) {
    CheckUnlocked();
    var effect = new UnitCreateEffect(id);
    rootIncarnation.incarnationsUnit.Add(
        id,
        new VersionAndIncarnation<UnitIncarnation>(
            incarnationVersion,
            incarnation));
    effectsUnitCreateEffect.Add(effect);
  }

  public void EffectUnitDelete(int id) {
    CheckUnlocked();
    var effect = new UnitDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsUnit[id];

    rootIncarnation.incarnationsUnit.Remove(id);
    effectsUnitDeleteEffect.Add(effect);
  }

     
  public int GetUnitHash(int id, int version, UnitIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.events.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.alive.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.lifeEndTime.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.location.GetDeterministicHashCode();
    result += id * version * 5 * incarnation.classId.GetDeterministicHashCode();
    result += id * version * 6 * incarnation.hp.GetDeterministicHashCode();
    result += id * version * 7 * incarnation.maxHp.GetDeterministicHashCode();
    result += id * version * 8 * incarnation.mp.GetDeterministicHashCode();
    result += id * version * 9 * incarnation.maxMp.GetDeterministicHashCode();
    result += id * version * 10 * incarnation.inertia.GetDeterministicHashCode();
    result += id * version * 11 * incarnation.nextActionTime.GetDeterministicHashCode();
    result += id * version * 12 * incarnation.components.GetDeterministicHashCode();
    result += id * version * 13 * incarnation.good.GetDeterministicHashCode();
    result += id * version * 14 * incarnation.strength.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastUnitEffects(
      SortedDictionary<int, List<IUnitEffectObserver>> observers) {
    foreach (var effect in effectsUnitDeleteEffect) {
      if (observers.TryGetValue(0, out List<IUnitEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnUnitEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IUnitEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnUnitEffect(effect);
        }
        observersForUnit.Remove(effect.id);
      }
    }
    effectsUnitDeleteEffect.Clear();


    foreach (var effect in effectsUnitSetAliveEffect) {
      if (observers.TryGetValue(0, out List<IUnitEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnUnitEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IUnitEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnUnitEffect(effect);
        }
      }
    }
    effectsUnitSetAliveEffect.Clear();

    foreach (var effect in effectsUnitSetLifeEndTimeEffect) {
      if (observers.TryGetValue(0, out List<IUnitEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnUnitEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IUnitEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnUnitEffect(effect);
        }
      }
    }
    effectsUnitSetLifeEndTimeEffect.Clear();

    foreach (var effect in effectsUnitSetLocationEffect) {
      if (observers.TryGetValue(0, out List<IUnitEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnUnitEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IUnitEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnUnitEffect(effect);
        }
      }
    }
    effectsUnitSetLocationEffect.Clear();

    foreach (var effect in effectsUnitSetHpEffect) {
      if (observers.TryGetValue(0, out List<IUnitEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnUnitEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IUnitEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnUnitEffect(effect);
        }
      }
    }
    effectsUnitSetHpEffect.Clear();

    foreach (var effect in effectsUnitSetMpEffect) {
      if (observers.TryGetValue(0, out List<IUnitEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnUnitEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IUnitEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnUnitEffect(effect);
        }
      }
    }
    effectsUnitSetMpEffect.Clear();

    foreach (var effect in effectsUnitSetNextActionTimeEffect) {
      if (observers.TryGetValue(0, out List<IUnitEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnUnitEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IUnitEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnUnitEffect(effect);
        }
      }
    }
    effectsUnitSetNextActionTimeEffect.Clear();

    foreach (var effect in effectsUnitCreateEffect) {
      if (observers.TryGetValue(0, out List<IUnitEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnUnitEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IUnitEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnUnitEffect(effect);
        }
      }
    }
    effectsUnitCreateEffect.Clear();
  }

  public void EffectUnitSetAlive(int id, bool newValue) {
    CheckUnlocked();
    CheckHasUnit(id);
    var effect = new UnitSetAliveEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsUnit[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.alive;
      oldIncarnationAndVersion.incarnation.alive = newValue;

    } else {
      var newIncarnation =
          new UnitIncarnation(
              oldIncarnationAndVersion.incarnation.events,
              newValue,
              oldIncarnationAndVersion.incarnation.lifeEndTime,
              oldIncarnationAndVersion.incarnation.location,
              oldIncarnationAndVersion.incarnation.classId,
              oldIncarnationAndVersion.incarnation.hp,
              oldIncarnationAndVersion.incarnation.maxHp,
              oldIncarnationAndVersion.incarnation.mp,
              oldIncarnationAndVersion.incarnation.maxMp,
              oldIncarnationAndVersion.incarnation.inertia,
              oldIncarnationAndVersion.incarnation.nextActionTime,
              oldIncarnationAndVersion.incarnation.components,
              oldIncarnationAndVersion.incarnation.good,
              oldIncarnationAndVersion.incarnation.strength);
      rootIncarnation.incarnationsUnit[id] =
          new VersionAndIncarnation<UnitIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsUnitSetAliveEffect.Add(effect);
  }

  public void EffectUnitSetLifeEndTime(int id, int newValue) {
    CheckUnlocked();
    CheckHasUnit(id);
    var effect = new UnitSetLifeEndTimeEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsUnit[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.lifeEndTime;
      oldIncarnationAndVersion.incarnation.lifeEndTime = newValue;

    } else {
      var newIncarnation =
          new UnitIncarnation(
              oldIncarnationAndVersion.incarnation.events,
              oldIncarnationAndVersion.incarnation.alive,
              newValue,
              oldIncarnationAndVersion.incarnation.location,
              oldIncarnationAndVersion.incarnation.classId,
              oldIncarnationAndVersion.incarnation.hp,
              oldIncarnationAndVersion.incarnation.maxHp,
              oldIncarnationAndVersion.incarnation.mp,
              oldIncarnationAndVersion.incarnation.maxMp,
              oldIncarnationAndVersion.incarnation.inertia,
              oldIncarnationAndVersion.incarnation.nextActionTime,
              oldIncarnationAndVersion.incarnation.components,
              oldIncarnationAndVersion.incarnation.good,
              oldIncarnationAndVersion.incarnation.strength);
      rootIncarnation.incarnationsUnit[id] =
          new VersionAndIncarnation<UnitIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsUnitSetLifeEndTimeEffect.Add(effect);
  }

  public void EffectUnitSetLocation(int id, Location newValue) {
    CheckUnlocked();
    CheckHasUnit(id);
    var effect = new UnitSetLocationEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsUnit[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.location;
      oldIncarnationAndVersion.incarnation.location = newValue;

    } else {
      var newIncarnation =
          new UnitIncarnation(
              oldIncarnationAndVersion.incarnation.events,
              oldIncarnationAndVersion.incarnation.alive,
              oldIncarnationAndVersion.incarnation.lifeEndTime,
              newValue,
              oldIncarnationAndVersion.incarnation.classId,
              oldIncarnationAndVersion.incarnation.hp,
              oldIncarnationAndVersion.incarnation.maxHp,
              oldIncarnationAndVersion.incarnation.mp,
              oldIncarnationAndVersion.incarnation.maxMp,
              oldIncarnationAndVersion.incarnation.inertia,
              oldIncarnationAndVersion.incarnation.nextActionTime,
              oldIncarnationAndVersion.incarnation.components,
              oldIncarnationAndVersion.incarnation.good,
              oldIncarnationAndVersion.incarnation.strength);
      rootIncarnation.incarnationsUnit[id] =
          new VersionAndIncarnation<UnitIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsUnitSetLocationEffect.Add(effect);
  }

  public void EffectUnitSetHp(int id, int newValue) {
    CheckUnlocked();
    CheckHasUnit(id);
    var effect = new UnitSetHpEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsUnit[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.hp;
      oldIncarnationAndVersion.incarnation.hp = newValue;

    } else {
      var newIncarnation =
          new UnitIncarnation(
              oldIncarnationAndVersion.incarnation.events,
              oldIncarnationAndVersion.incarnation.alive,
              oldIncarnationAndVersion.incarnation.lifeEndTime,
              oldIncarnationAndVersion.incarnation.location,
              oldIncarnationAndVersion.incarnation.classId,
              newValue,
              oldIncarnationAndVersion.incarnation.maxHp,
              oldIncarnationAndVersion.incarnation.mp,
              oldIncarnationAndVersion.incarnation.maxMp,
              oldIncarnationAndVersion.incarnation.inertia,
              oldIncarnationAndVersion.incarnation.nextActionTime,
              oldIncarnationAndVersion.incarnation.components,
              oldIncarnationAndVersion.incarnation.good,
              oldIncarnationAndVersion.incarnation.strength);
      rootIncarnation.incarnationsUnit[id] =
          new VersionAndIncarnation<UnitIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsUnitSetHpEffect.Add(effect);
  }

  public void EffectUnitSetMp(int id, int newValue) {
    CheckUnlocked();
    CheckHasUnit(id);
    var effect = new UnitSetMpEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsUnit[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.mp;
      oldIncarnationAndVersion.incarnation.mp = newValue;

    } else {
      var newIncarnation =
          new UnitIncarnation(
              oldIncarnationAndVersion.incarnation.events,
              oldIncarnationAndVersion.incarnation.alive,
              oldIncarnationAndVersion.incarnation.lifeEndTime,
              oldIncarnationAndVersion.incarnation.location,
              oldIncarnationAndVersion.incarnation.classId,
              oldIncarnationAndVersion.incarnation.hp,
              oldIncarnationAndVersion.incarnation.maxHp,
              newValue,
              oldIncarnationAndVersion.incarnation.maxMp,
              oldIncarnationAndVersion.incarnation.inertia,
              oldIncarnationAndVersion.incarnation.nextActionTime,
              oldIncarnationAndVersion.incarnation.components,
              oldIncarnationAndVersion.incarnation.good,
              oldIncarnationAndVersion.incarnation.strength);
      rootIncarnation.incarnationsUnit[id] =
          new VersionAndIncarnation<UnitIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsUnitSetMpEffect.Add(effect);
  }

  public void EffectUnitSetNextActionTime(int id, int newValue) {
    CheckUnlocked();
    CheckHasUnit(id);
    var effect = new UnitSetNextActionTimeEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsUnit[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.nextActionTime;
      oldIncarnationAndVersion.incarnation.nextActionTime = newValue;

    } else {
      var newIncarnation =
          new UnitIncarnation(
              oldIncarnationAndVersion.incarnation.events,
              oldIncarnationAndVersion.incarnation.alive,
              oldIncarnationAndVersion.incarnation.lifeEndTime,
              oldIncarnationAndVersion.incarnation.location,
              oldIncarnationAndVersion.incarnation.classId,
              oldIncarnationAndVersion.incarnation.hp,
              oldIncarnationAndVersion.incarnation.maxHp,
              oldIncarnationAndVersion.incarnation.mp,
              oldIncarnationAndVersion.incarnation.maxMp,
              oldIncarnationAndVersion.incarnation.inertia,
              newValue,
              oldIncarnationAndVersion.incarnation.components,
              oldIncarnationAndVersion.incarnation.good,
              oldIncarnationAndVersion.incarnation.strength);
      rootIncarnation.incarnationsUnit[id] =
          new VersionAndIncarnation<UnitIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsUnitSetNextActionTimeEffect.Add(effect);
  }
  public IUnitComponentMutBunchIncarnation GetIUnitComponentMutBunchIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsIUnitComponentMutBunch[id].incarnation;
  }
  public bool IUnitComponentMutBunchExists(int id) {
    return rootIncarnation.incarnationsIUnitComponentMutBunch.ContainsKey(id);
  }
  public IUnitComponentMutBunch GetIUnitComponentMutBunch(int id) {
    return new IUnitComponentMutBunch(this, id);
  }
  public List<IUnitComponentMutBunch> AllIUnitComponentMutBunch() {
    List<IUnitComponentMutBunch> result = new List<IUnitComponentMutBunch>(rootIncarnation.incarnationsIUnitComponentMutBunch.Count);
    foreach (var id in rootIncarnation.incarnationsIUnitComponentMutBunch.Keys) {
      result.Add(new IUnitComponentMutBunch(this, id));
    }
    return result;
  }
  public IEnumerator<IUnitComponentMutBunch> EnumAllIUnitComponentMutBunch() {
    foreach (var id in rootIncarnation.incarnationsIUnitComponentMutBunch.Keys) {
      yield return GetIUnitComponentMutBunch(id);
    }
  }
  public void CheckHasIUnitComponentMutBunch(IUnitComponentMutBunch thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasIUnitComponentMutBunch(thing.id);
  }
  public void CheckHasIUnitComponentMutBunch(int id) {
    if (!rootIncarnation.incarnationsIUnitComponentMutBunch.ContainsKey(id)) {
      throw new System.Exception("Invalid IUnitComponentMutBunch: " + id);
    }
  }
  public void AddIUnitComponentMutBunchObserver(int id, IIUnitComponentMutBunchEffectObserver observer) {
    List<IIUnitComponentMutBunchEffectObserver> obsies;
    if (!observersForIUnitComponentMutBunch.TryGetValue(id, out obsies)) {
      obsies = new List<IIUnitComponentMutBunchEffectObserver>();
    }
    obsies.Add(observer);
    observersForIUnitComponentMutBunch[id] = obsies;
  }

  public void RemoveIUnitComponentMutBunchObserver(int id, IIUnitComponentMutBunchEffectObserver observer) {
    if (observersForIUnitComponentMutBunch.ContainsKey(id)) {
      var list = observersForIUnitComponentMutBunch[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForIUnitComponentMutBunch.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public IUnitComponentMutBunch EffectIUnitComponentMutBunchCreate(
      ArmorMutSet membersArmorMutSet,
      InertiaRingMutSet membersInertiaRingMutSet,
      GlaiveMutSet membersGlaiveMutSet,
      ManaPotionMutSet membersManaPotionMutSet,
      HealthPotionMutSet membersHealthPotionMutSet,
      WanderAICapabilityUCMutSet membersWanderAICapabilityUCMutSet,
      TimeCloneAICapabilityUCMutSet membersTimeCloneAICapabilityUCMutSet,
      AttackAICapabilityUCMutSet membersAttackAICapabilityUCMutSet,
      CounteringUCMutSet membersCounteringUCMutSet,
      ShieldingUCMutSet membersShieldingUCMutSet,
      BideAICapabilityUCMutSet membersBideAICapabilityUCMutSet) {
    CheckUnlocked();
    CheckHasArmorMutSet(membersArmorMutSet);
    CheckHasInertiaRingMutSet(membersInertiaRingMutSet);
    CheckHasGlaiveMutSet(membersGlaiveMutSet);
    CheckHasManaPotionMutSet(membersManaPotionMutSet);
    CheckHasHealthPotionMutSet(membersHealthPotionMutSet);
    CheckHasWanderAICapabilityUCMutSet(membersWanderAICapabilityUCMutSet);
    CheckHasTimeCloneAICapabilityUCMutSet(membersTimeCloneAICapabilityUCMutSet);
    CheckHasAttackAICapabilityUCMutSet(membersAttackAICapabilityUCMutSet);
    CheckHasCounteringUCMutSet(membersCounteringUCMutSet);
    CheckHasShieldingUCMutSet(membersShieldingUCMutSet);
    CheckHasBideAICapabilityUCMutSet(membersBideAICapabilityUCMutSet);

    var id = NewId();
    var incarnation =
        new IUnitComponentMutBunchIncarnation(
            membersArmorMutSet.id,
            membersInertiaRingMutSet.id,
            membersGlaiveMutSet.id,
            membersManaPotionMutSet.id,
            membersHealthPotionMutSet.id,
            membersWanderAICapabilityUCMutSet.id,
            membersTimeCloneAICapabilityUCMutSet.id,
            membersAttackAICapabilityUCMutSet.id,
            membersCounteringUCMutSet.id,
            membersShieldingUCMutSet.id,
            membersBideAICapabilityUCMutSet.id
            );
    EffectInternalCreateIUnitComponentMutBunch(id, rootIncarnation.version, incarnation);
    return new IUnitComponentMutBunch(this, id);
  }
  public void EffectInternalCreateIUnitComponentMutBunch(
      int id,
      int incarnationVersion,
      IUnitComponentMutBunchIncarnation incarnation) {
    CheckUnlocked();
    var effect = new IUnitComponentMutBunchCreateEffect(id);
    rootIncarnation.incarnationsIUnitComponentMutBunch.Add(
        id,
        new VersionAndIncarnation<IUnitComponentMutBunchIncarnation>(
            incarnationVersion,
            incarnation));
    effectsIUnitComponentMutBunchCreateEffect.Add(effect);
  }

  public void EffectIUnitComponentMutBunchDelete(int id) {
    CheckUnlocked();
    var effect = new IUnitComponentMutBunchDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsIUnitComponentMutBunch[id];

    rootIncarnation.incarnationsIUnitComponentMutBunch.Remove(id);
    effectsIUnitComponentMutBunchDeleteEffect.Add(effect);
  }

     
  public int GetIUnitComponentMutBunchHash(int id, int version, IUnitComponentMutBunchIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.membersArmorMutSet.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.membersInertiaRingMutSet.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.membersGlaiveMutSet.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.membersManaPotionMutSet.GetDeterministicHashCode();
    result += id * version * 5 * incarnation.membersHealthPotionMutSet.GetDeterministicHashCode();
    result += id * version * 6 * incarnation.membersWanderAICapabilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 7 * incarnation.membersTimeCloneAICapabilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 8 * incarnation.membersAttackAICapabilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 9 * incarnation.membersCounteringUCMutSet.GetDeterministicHashCode();
    result += id * version * 10 * incarnation.membersShieldingUCMutSet.GetDeterministicHashCode();
    result += id * version * 11 * incarnation.membersBideAICapabilityUCMutSet.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastIUnitComponentMutBunchEffects(
      SortedDictionary<int, List<IIUnitComponentMutBunchEffectObserver>> observers) {
    foreach (var effect in effectsIUnitComponentMutBunchDeleteEffect) {
      if (observers.TryGetValue(0, out List<IIUnitComponentMutBunchEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnIUnitComponentMutBunchEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IIUnitComponentMutBunchEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnIUnitComponentMutBunchEffect(effect);
        }
        observersForIUnitComponentMutBunch.Remove(effect.id);
      }
    }
    effectsIUnitComponentMutBunchDeleteEffect.Clear();


    foreach (var effect in effectsIUnitComponentMutBunchCreateEffect) {
      if (observers.TryGetValue(0, out List<IIUnitComponentMutBunchEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnIUnitComponentMutBunchEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IIUnitComponentMutBunchEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnIUnitComponentMutBunchEffect(effect);
        }
      }
    }
    effectsIUnitComponentMutBunchCreateEffect.Clear();
  }
  public NoImpulseIncarnation GetNoImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsNoImpulse[id].incarnation;
  }
  public bool NoImpulseExists(int id) {
    return rootIncarnation.incarnationsNoImpulse.ContainsKey(id);
  }
  public NoImpulse GetNoImpulse(int id) {
    return new NoImpulse(this, id);
  }
  public List<NoImpulse> AllNoImpulse() {
    List<NoImpulse> result = new List<NoImpulse>(rootIncarnation.incarnationsNoImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsNoImpulse.Keys) {
      result.Add(new NoImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<NoImpulse> EnumAllNoImpulse() {
    foreach (var id in rootIncarnation.incarnationsNoImpulse.Keys) {
      yield return GetNoImpulse(id);
    }
  }
  public void CheckHasNoImpulse(NoImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasNoImpulse(thing.id);
  }
  public void CheckHasNoImpulse(int id) {
    if (!rootIncarnation.incarnationsNoImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid NoImpulse: " + id);
    }
  }
  public void AddNoImpulseObserver(int id, INoImpulseEffectObserver observer) {
    List<INoImpulseEffectObserver> obsies;
    if (!observersForNoImpulse.TryGetValue(id, out obsies)) {
      obsies = new List<INoImpulseEffectObserver>();
    }
    obsies.Add(observer);
    observersForNoImpulse[id] = obsies;
  }

  public void RemoveNoImpulseObserver(int id, INoImpulseEffectObserver observer) {
    if (observersForNoImpulse.ContainsKey(id)) {
      var list = observersForNoImpulse[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForNoImpulse.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public NoImpulse EffectNoImpulseCreate(
) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new NoImpulseIncarnation(

            );
    EffectInternalCreateNoImpulse(id, rootIncarnation.version, incarnation);
    return new NoImpulse(this, id);
  }
  public void EffectInternalCreateNoImpulse(
      int id,
      int incarnationVersion,
      NoImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new NoImpulseCreateEffect(id);
    rootIncarnation.incarnationsNoImpulse.Add(
        id,
        new VersionAndIncarnation<NoImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    effectsNoImpulseCreateEffect.Add(effect);
  }

  public void EffectNoImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new NoImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsNoImpulse[id];

    rootIncarnation.incarnationsNoImpulse.Remove(id);
    effectsNoImpulseDeleteEffect.Add(effect);
  }

     
  public int GetNoImpulseHash(int id, int version, NoImpulseIncarnation incarnation) {
    int result = id * version;
    return result;
  }
     
  public void BroadcastNoImpulseEffects(
      SortedDictionary<int, List<INoImpulseEffectObserver>> observers) {
    foreach (var effect in effectsNoImpulseDeleteEffect) {
      if (observers.TryGetValue(0, out List<INoImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnNoImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<INoImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnNoImpulseEffect(effect);
        }
        observersForNoImpulse.Remove(effect.id);
      }
    }
    effectsNoImpulseDeleteEffect.Clear();


    foreach (var effect in effectsNoImpulseCreateEffect) {
      if (observers.TryGetValue(0, out List<INoImpulseEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnNoImpulseEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<INoImpulseEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnNoImpulseEffect(effect);
        }
      }
    }
    effectsNoImpulseCreateEffect.Clear();
  }
  public ExecutionStateIncarnation GetExecutionStateIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsExecutionState[id].incarnation;
  }
  public bool ExecutionStateExists(int id) {
    return rootIncarnation.incarnationsExecutionState.ContainsKey(id);
  }
  public ExecutionState GetExecutionState(int id) {
    return new ExecutionState(this, id);
  }
  public List<ExecutionState> AllExecutionState() {
    List<ExecutionState> result = new List<ExecutionState>(rootIncarnation.incarnationsExecutionState.Count);
    foreach (var id in rootIncarnation.incarnationsExecutionState.Keys) {
      result.Add(new ExecutionState(this, id));
    }
    return result;
  }
  public IEnumerator<ExecutionState> EnumAllExecutionState() {
    foreach (var id in rootIncarnation.incarnationsExecutionState.Keys) {
      yield return GetExecutionState(id);
    }
  }
  public void CheckHasExecutionState(ExecutionState thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasExecutionState(thing.id);
  }
  public void CheckHasExecutionState(int id) {
    if (!rootIncarnation.incarnationsExecutionState.ContainsKey(id)) {
      throw new System.Exception("Invalid ExecutionState: " + id);
    }
  }
  public void AddExecutionStateObserver(int id, IExecutionStateEffectObserver observer) {
    List<IExecutionStateEffectObserver> obsies;
    if (!observersForExecutionState.TryGetValue(id, out obsies)) {
      obsies = new List<IExecutionStateEffectObserver>();
    }
    obsies.Add(observer);
    observersForExecutionState[id] = obsies;
  }

  public void RemoveExecutionStateObserver(int id, IExecutionStateEffectObserver observer) {
    if (observersForExecutionState.ContainsKey(id)) {
      var list = observersForExecutionState[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForExecutionState.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public ExecutionState EffectExecutionStateCreate(
      Unit actingUnit,
      bool actingUnitDidAction,
      IPreActingUCWeakMutBunch remainingPreActingUnitComponents,
      IPostActingUCWeakMutBunch remainingPostActingUnitComponents) {
    CheckUnlocked();

    var id = NewId();
    var incarnation =
        new ExecutionStateIncarnation(
            actingUnit.id,
            actingUnitDidAction,
            remainingPreActingUnitComponents.id,
            remainingPostActingUnitComponents.id
            );
    EffectInternalCreateExecutionState(id, rootIncarnation.version, incarnation);
    return new ExecutionState(this, id);
  }
  public void EffectInternalCreateExecutionState(
      int id,
      int incarnationVersion,
      ExecutionStateIncarnation incarnation) {
    CheckUnlocked();
    var effect = new ExecutionStateCreateEffect(id);
    rootIncarnation.incarnationsExecutionState.Add(
        id,
        new VersionAndIncarnation<ExecutionStateIncarnation>(
            incarnationVersion,
            incarnation));
    effectsExecutionStateCreateEffect.Add(effect);
  }

  public void EffectExecutionStateDelete(int id) {
    CheckUnlocked();
    var effect = new ExecutionStateDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsExecutionState[id];

    rootIncarnation.incarnationsExecutionState.Remove(id);
    effectsExecutionStateDeleteEffect.Add(effect);
  }

     
  public int GetExecutionStateHash(int id, int version, ExecutionStateIncarnation incarnation) {
    int result = id * version;
    if (!object.ReferenceEquals(incarnation.actingUnit, null)) {
      result += id * version * 1 * incarnation.actingUnit.GetDeterministicHashCode();
    }
    result += id * version * 2 * incarnation.actingUnitDidAction.GetDeterministicHashCode();
    if (!object.ReferenceEquals(incarnation.remainingPreActingUnitComponents, null)) {
      result += id * version * 3 * incarnation.remainingPreActingUnitComponents.GetDeterministicHashCode();
    }
    if (!object.ReferenceEquals(incarnation.remainingPostActingUnitComponents, null)) {
      result += id * version * 4 * incarnation.remainingPostActingUnitComponents.GetDeterministicHashCode();
    }
    return result;
  }
     
  public void BroadcastExecutionStateEffects(
      SortedDictionary<int, List<IExecutionStateEffectObserver>> observers) {
    foreach (var effect in effectsExecutionStateDeleteEffect) {
      if (observers.TryGetValue(0, out List<IExecutionStateEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnExecutionStateEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IExecutionStateEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnExecutionStateEffect(effect);
        }
        observersForExecutionState.Remove(effect.id);
      }
    }
    effectsExecutionStateDeleteEffect.Clear();


    foreach (var effect in effectsExecutionStateSetActingUnitEffect) {
      if (observers.TryGetValue(0, out List<IExecutionStateEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnExecutionStateEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IExecutionStateEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnExecutionStateEffect(effect);
        }
      }
    }
    effectsExecutionStateSetActingUnitEffect.Clear();

    foreach (var effect in effectsExecutionStateSetActingUnitDidActionEffect) {
      if (observers.TryGetValue(0, out List<IExecutionStateEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnExecutionStateEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IExecutionStateEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnExecutionStateEffect(effect);
        }
      }
    }
    effectsExecutionStateSetActingUnitDidActionEffect.Clear();

    foreach (var effect in effectsExecutionStateSetRemainingPreActingUnitComponentsEffect) {
      if (observers.TryGetValue(0, out List<IExecutionStateEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnExecutionStateEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IExecutionStateEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnExecutionStateEffect(effect);
        }
      }
    }
    effectsExecutionStateSetRemainingPreActingUnitComponentsEffect.Clear();

    foreach (var effect in effectsExecutionStateSetRemainingPostActingUnitComponentsEffect) {
      if (observers.TryGetValue(0, out List<IExecutionStateEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnExecutionStateEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IExecutionStateEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnExecutionStateEffect(effect);
        }
      }
    }
    effectsExecutionStateSetRemainingPostActingUnitComponentsEffect.Clear();

    foreach (var effect in effectsExecutionStateCreateEffect) {
      if (observers.TryGetValue(0, out List<IExecutionStateEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnExecutionStateEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IExecutionStateEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnExecutionStateEffect(effect);
        }
      }
    }
    effectsExecutionStateCreateEffect.Clear();
  }

  public void EffectExecutionStateSetActingUnit(int id, Unit newValue) {
    CheckUnlocked();
    CheckHasExecutionState(id);
    var effect = new ExecutionStateSetActingUnitEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsExecutionState[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldId = oldIncarnationAndVersion.incarnation.actingUnit;
      oldIncarnationAndVersion.incarnation.actingUnit = newValue.id;

    } else {
      var newIncarnation =
          new ExecutionStateIncarnation(
              newValue.id,
              oldIncarnationAndVersion.incarnation.actingUnitDidAction,
              oldIncarnationAndVersion.incarnation.remainingPreActingUnitComponents,
              oldIncarnationAndVersion.incarnation.remainingPostActingUnitComponents);
      rootIncarnation.incarnationsExecutionState[id] =
          new VersionAndIncarnation<ExecutionStateIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsExecutionStateSetActingUnitEffect.Add(effect);
  }

  public void EffectExecutionStateSetActingUnitDidAction(int id, bool newValue) {
    CheckUnlocked();
    CheckHasExecutionState(id);
    var effect = new ExecutionStateSetActingUnitDidActionEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsExecutionState[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.actingUnitDidAction;
      oldIncarnationAndVersion.incarnation.actingUnitDidAction = newValue;

    } else {
      var newIncarnation =
          new ExecutionStateIncarnation(
              oldIncarnationAndVersion.incarnation.actingUnit,
              newValue,
              oldIncarnationAndVersion.incarnation.remainingPreActingUnitComponents,
              oldIncarnationAndVersion.incarnation.remainingPostActingUnitComponents);
      rootIncarnation.incarnationsExecutionState[id] =
          new VersionAndIncarnation<ExecutionStateIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsExecutionStateSetActingUnitDidActionEffect.Add(effect);
  }

  public void EffectExecutionStateSetRemainingPreActingUnitComponents(int id, IPreActingUCWeakMutBunch newValue) {
    CheckUnlocked();
    CheckHasExecutionState(id);
    var effect = new ExecutionStateSetRemainingPreActingUnitComponentsEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsExecutionState[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldId = oldIncarnationAndVersion.incarnation.remainingPreActingUnitComponents;
      oldIncarnationAndVersion.incarnation.remainingPreActingUnitComponents = newValue.id;

    } else {
      var newIncarnation =
          new ExecutionStateIncarnation(
              oldIncarnationAndVersion.incarnation.actingUnit,
              oldIncarnationAndVersion.incarnation.actingUnitDidAction,
              newValue.id,
              oldIncarnationAndVersion.incarnation.remainingPostActingUnitComponents);
      rootIncarnation.incarnationsExecutionState[id] =
          new VersionAndIncarnation<ExecutionStateIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsExecutionStateSetRemainingPreActingUnitComponentsEffect.Add(effect);
  }

  public void EffectExecutionStateSetRemainingPostActingUnitComponents(int id, IPostActingUCWeakMutBunch newValue) {
    CheckUnlocked();
    CheckHasExecutionState(id);
    var effect = new ExecutionStateSetRemainingPostActingUnitComponentsEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsExecutionState[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldId = oldIncarnationAndVersion.incarnation.remainingPostActingUnitComponents;
      oldIncarnationAndVersion.incarnation.remainingPostActingUnitComponents = newValue.id;

    } else {
      var newIncarnation =
          new ExecutionStateIncarnation(
              oldIncarnationAndVersion.incarnation.actingUnit,
              oldIncarnationAndVersion.incarnation.actingUnitDidAction,
              oldIncarnationAndVersion.incarnation.remainingPreActingUnitComponents,
              newValue.id);
      rootIncarnation.incarnationsExecutionState[id] =
          new VersionAndIncarnation<ExecutionStateIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsExecutionStateSetRemainingPostActingUnitComponentsEffect.Add(effect);
  }
  public IPostActingUCWeakMutBunchIncarnation GetIPostActingUCWeakMutBunchIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsIPostActingUCWeakMutBunch[id].incarnation;
  }
  public bool IPostActingUCWeakMutBunchExists(int id) {
    return rootIncarnation.incarnationsIPostActingUCWeakMutBunch.ContainsKey(id);
  }
  public IPostActingUCWeakMutBunch GetIPostActingUCWeakMutBunch(int id) {
    return new IPostActingUCWeakMutBunch(this, id);
  }
  public List<IPostActingUCWeakMutBunch> AllIPostActingUCWeakMutBunch() {
    List<IPostActingUCWeakMutBunch> result = new List<IPostActingUCWeakMutBunch>(rootIncarnation.incarnationsIPostActingUCWeakMutBunch.Count);
    foreach (var id in rootIncarnation.incarnationsIPostActingUCWeakMutBunch.Keys) {
      result.Add(new IPostActingUCWeakMutBunch(this, id));
    }
    return result;
  }
  public IEnumerator<IPostActingUCWeakMutBunch> EnumAllIPostActingUCWeakMutBunch() {
    foreach (var id in rootIncarnation.incarnationsIPostActingUCWeakMutBunch.Keys) {
      yield return GetIPostActingUCWeakMutBunch(id);
    }
  }
  public void CheckHasIPostActingUCWeakMutBunch(IPostActingUCWeakMutBunch thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasIPostActingUCWeakMutBunch(thing.id);
  }
  public void CheckHasIPostActingUCWeakMutBunch(int id) {
    if (!rootIncarnation.incarnationsIPostActingUCWeakMutBunch.ContainsKey(id)) {
      throw new System.Exception("Invalid IPostActingUCWeakMutBunch: " + id);
    }
  }
  public void AddIPostActingUCWeakMutBunchObserver(int id, IIPostActingUCWeakMutBunchEffectObserver observer) {
    List<IIPostActingUCWeakMutBunchEffectObserver> obsies;
    if (!observersForIPostActingUCWeakMutBunch.TryGetValue(id, out obsies)) {
      obsies = new List<IIPostActingUCWeakMutBunchEffectObserver>();
    }
    obsies.Add(observer);
    observersForIPostActingUCWeakMutBunch[id] = obsies;
  }

  public void RemoveIPostActingUCWeakMutBunchObserver(int id, IIPostActingUCWeakMutBunchEffectObserver observer) {
    if (observersForIPostActingUCWeakMutBunch.ContainsKey(id)) {
      var list = observersForIPostActingUCWeakMutBunch[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForIPostActingUCWeakMutBunch.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public IPostActingUCWeakMutBunch EffectIPostActingUCWeakMutBunchCreate(
      TimeCloneAICapabilityUCWeakMutSet membersTimeCloneAICapabilityUCWeakMutSet) {
    CheckUnlocked();
    CheckHasTimeCloneAICapabilityUCWeakMutSet(membersTimeCloneAICapabilityUCWeakMutSet);

    var id = NewId();
    var incarnation =
        new IPostActingUCWeakMutBunchIncarnation(
            membersTimeCloneAICapabilityUCWeakMutSet.id
            );
    EffectInternalCreateIPostActingUCWeakMutBunch(id, rootIncarnation.version, incarnation);
    return new IPostActingUCWeakMutBunch(this, id);
  }
  public void EffectInternalCreateIPostActingUCWeakMutBunch(
      int id,
      int incarnationVersion,
      IPostActingUCWeakMutBunchIncarnation incarnation) {
    CheckUnlocked();
    var effect = new IPostActingUCWeakMutBunchCreateEffect(id);
    rootIncarnation.incarnationsIPostActingUCWeakMutBunch.Add(
        id,
        new VersionAndIncarnation<IPostActingUCWeakMutBunchIncarnation>(
            incarnationVersion,
            incarnation));
    effectsIPostActingUCWeakMutBunchCreateEffect.Add(effect);
  }

  public void EffectIPostActingUCWeakMutBunchDelete(int id) {
    CheckUnlocked();
    var effect = new IPostActingUCWeakMutBunchDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsIPostActingUCWeakMutBunch[id];

    rootIncarnation.incarnationsIPostActingUCWeakMutBunch.Remove(id);
    effectsIPostActingUCWeakMutBunchDeleteEffect.Add(effect);
  }

     
  public int GetIPostActingUCWeakMutBunchHash(int id, int version, IPostActingUCWeakMutBunchIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.membersTimeCloneAICapabilityUCWeakMutSet.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastIPostActingUCWeakMutBunchEffects(
      SortedDictionary<int, List<IIPostActingUCWeakMutBunchEffectObserver>> observers) {
    foreach (var effect in effectsIPostActingUCWeakMutBunchDeleteEffect) {
      if (observers.TryGetValue(0, out List<IIPostActingUCWeakMutBunchEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnIPostActingUCWeakMutBunchEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IIPostActingUCWeakMutBunchEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnIPostActingUCWeakMutBunchEffect(effect);
        }
        observersForIPostActingUCWeakMutBunch.Remove(effect.id);
      }
    }
    effectsIPostActingUCWeakMutBunchDeleteEffect.Clear();


    foreach (var effect in effectsIPostActingUCWeakMutBunchCreateEffect) {
      if (observers.TryGetValue(0, out List<IIPostActingUCWeakMutBunchEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnIPostActingUCWeakMutBunchEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IIPostActingUCWeakMutBunchEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnIPostActingUCWeakMutBunchEffect(effect);
        }
      }
    }
    effectsIPostActingUCWeakMutBunchCreateEffect.Clear();
  }
  public IPreActingUCWeakMutBunchIncarnation GetIPreActingUCWeakMutBunchIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsIPreActingUCWeakMutBunch[id].incarnation;
  }
  public bool IPreActingUCWeakMutBunchExists(int id) {
    return rootIncarnation.incarnationsIPreActingUCWeakMutBunch.ContainsKey(id);
  }
  public IPreActingUCWeakMutBunch GetIPreActingUCWeakMutBunch(int id) {
    return new IPreActingUCWeakMutBunch(this, id);
  }
  public List<IPreActingUCWeakMutBunch> AllIPreActingUCWeakMutBunch() {
    List<IPreActingUCWeakMutBunch> result = new List<IPreActingUCWeakMutBunch>(rootIncarnation.incarnationsIPreActingUCWeakMutBunch.Count);
    foreach (var id in rootIncarnation.incarnationsIPreActingUCWeakMutBunch.Keys) {
      result.Add(new IPreActingUCWeakMutBunch(this, id));
    }
    return result;
  }
  public IEnumerator<IPreActingUCWeakMutBunch> EnumAllIPreActingUCWeakMutBunch() {
    foreach (var id in rootIncarnation.incarnationsIPreActingUCWeakMutBunch.Keys) {
      yield return GetIPreActingUCWeakMutBunch(id);
    }
  }
  public void CheckHasIPreActingUCWeakMutBunch(IPreActingUCWeakMutBunch thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasIPreActingUCWeakMutBunch(thing.id);
  }
  public void CheckHasIPreActingUCWeakMutBunch(int id) {
    if (!rootIncarnation.incarnationsIPreActingUCWeakMutBunch.ContainsKey(id)) {
      throw new System.Exception("Invalid IPreActingUCWeakMutBunch: " + id);
    }
  }
  public void AddIPreActingUCWeakMutBunchObserver(int id, IIPreActingUCWeakMutBunchEffectObserver observer) {
    List<IIPreActingUCWeakMutBunchEffectObserver> obsies;
    if (!observersForIPreActingUCWeakMutBunch.TryGetValue(id, out obsies)) {
      obsies = new List<IIPreActingUCWeakMutBunchEffectObserver>();
    }
    obsies.Add(observer);
    observersForIPreActingUCWeakMutBunch[id] = obsies;
  }

  public void RemoveIPreActingUCWeakMutBunchObserver(int id, IIPreActingUCWeakMutBunchEffectObserver observer) {
    if (observersForIPreActingUCWeakMutBunch.ContainsKey(id)) {
      var list = observersForIPreActingUCWeakMutBunch[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForIPreActingUCWeakMutBunch.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public IPreActingUCWeakMutBunch EffectIPreActingUCWeakMutBunchCreate(
      CounteringUCWeakMutSet membersCounteringUCWeakMutSet,
      ShieldingUCWeakMutSet membersShieldingUCWeakMutSet,
      AttackAICapabilityUCWeakMutSet membersAttackAICapabilityUCWeakMutSet) {
    CheckUnlocked();
    CheckHasCounteringUCWeakMutSet(membersCounteringUCWeakMutSet);
    CheckHasShieldingUCWeakMutSet(membersShieldingUCWeakMutSet);
    CheckHasAttackAICapabilityUCWeakMutSet(membersAttackAICapabilityUCWeakMutSet);

    var id = NewId();
    var incarnation =
        new IPreActingUCWeakMutBunchIncarnation(
            membersCounteringUCWeakMutSet.id,
            membersShieldingUCWeakMutSet.id,
            membersAttackAICapabilityUCWeakMutSet.id
            );
    EffectInternalCreateIPreActingUCWeakMutBunch(id, rootIncarnation.version, incarnation);
    return new IPreActingUCWeakMutBunch(this, id);
  }
  public void EffectInternalCreateIPreActingUCWeakMutBunch(
      int id,
      int incarnationVersion,
      IPreActingUCWeakMutBunchIncarnation incarnation) {
    CheckUnlocked();
    var effect = new IPreActingUCWeakMutBunchCreateEffect(id);
    rootIncarnation.incarnationsIPreActingUCWeakMutBunch.Add(
        id,
        new VersionAndIncarnation<IPreActingUCWeakMutBunchIncarnation>(
            incarnationVersion,
            incarnation));
    effectsIPreActingUCWeakMutBunchCreateEffect.Add(effect);
  }

  public void EffectIPreActingUCWeakMutBunchDelete(int id) {
    CheckUnlocked();
    var effect = new IPreActingUCWeakMutBunchDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsIPreActingUCWeakMutBunch[id];

    rootIncarnation.incarnationsIPreActingUCWeakMutBunch.Remove(id);
    effectsIPreActingUCWeakMutBunchDeleteEffect.Add(effect);
  }

     
  public int GetIPreActingUCWeakMutBunchHash(int id, int version, IPreActingUCWeakMutBunchIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.membersCounteringUCWeakMutSet.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.membersShieldingUCWeakMutSet.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.membersAttackAICapabilityUCWeakMutSet.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastIPreActingUCWeakMutBunchEffects(
      SortedDictionary<int, List<IIPreActingUCWeakMutBunchEffectObserver>> observers) {
    foreach (var effect in effectsIPreActingUCWeakMutBunchDeleteEffect) {
      if (observers.TryGetValue(0, out List<IIPreActingUCWeakMutBunchEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnIPreActingUCWeakMutBunchEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IIPreActingUCWeakMutBunchEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnIPreActingUCWeakMutBunchEffect(effect);
        }
        observersForIPreActingUCWeakMutBunch.Remove(effect.id);
      }
    }
    effectsIPreActingUCWeakMutBunchDeleteEffect.Clear();


    foreach (var effect in effectsIPreActingUCWeakMutBunchCreateEffect) {
      if (observers.TryGetValue(0, out List<IIPreActingUCWeakMutBunchEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnIPreActingUCWeakMutBunchEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IIPreActingUCWeakMutBunchEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnIPreActingUCWeakMutBunchEffect(effect);
        }
      }
    }
    effectsIPreActingUCWeakMutBunchCreateEffect.Clear();
  }
  public GameIncarnation GetGameIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsGame[id].incarnation;
  }
  public bool GameExists(int id) {
    return rootIncarnation.incarnationsGame.ContainsKey(id);
  }
  public Game GetGame(int id) {
    return new Game(this, id);
  }
  public List<Game> AllGame() {
    List<Game> result = new List<Game>(rootIncarnation.incarnationsGame.Count);
    foreach (var id in rootIncarnation.incarnationsGame.Keys) {
      result.Add(new Game(this, id));
    }
    return result;
  }
  public IEnumerator<Game> EnumAllGame() {
    foreach (var id in rootIncarnation.incarnationsGame.Keys) {
      yield return GetGame(id);
    }
  }
  public void CheckHasGame(Game thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasGame(thing.id);
  }
  public void CheckHasGame(int id) {
    if (!rootIncarnation.incarnationsGame.ContainsKey(id)) {
      throw new System.Exception("Invalid Game: " + id);
    }
  }
  public void AddGameObserver(int id, IGameEffectObserver observer) {
    List<IGameEffectObserver> obsies;
    if (!observersForGame.TryGetValue(id, out obsies)) {
      obsies = new List<IGameEffectObserver>();
    }
    obsies.Add(observer);
    observersForGame[id] = obsies;
  }

  public void RemoveGameObserver(int id, IGameEffectObserver observer) {
    if (observersForGame.ContainsKey(id)) {
      var list = observersForGame[id];
      list.Remove(observer);
      if (list.Count == 0) {
        observersForGame.Remove(id);
      }
    } else {
      throw new Exception("Couldnt find!");
    }
  }
  public Game EffectGameCreate(
      Rand rand,
      bool squareLevelsOnly,
      bool gauntletMode,
      LevelMutSet levels,
      Unit player,
      Level level,
      int time,
      ExecutionState executionState) {
    CheckUnlocked();
    CheckHasRand(rand);
    CheckHasLevelMutSet(levels);
    CheckHasExecutionState(executionState);

    var id = NewId();
    var incarnation =
        new GameIncarnation(
            rand.id,
            squareLevelsOnly,
            gauntletMode,
            levels.id,
            player.id,
            level.id,
            time,
            executionState.id
            );
    EffectInternalCreateGame(id, rootIncarnation.version, incarnation);
    return new Game(this, id);
  }
  public void EffectInternalCreateGame(
      int id,
      int incarnationVersion,
      GameIncarnation incarnation) {
    CheckUnlocked();
    var effect = new GameCreateEffect(id);
    rootIncarnation.incarnationsGame.Add(
        id,
        new VersionAndIncarnation<GameIncarnation>(
            incarnationVersion,
            incarnation));
    effectsGameCreateEffect.Add(effect);
  }

  public void EffectGameDelete(int id) {
    CheckUnlocked();
    var effect = new GameDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsGame[id];

    rootIncarnation.incarnationsGame.Remove(id);
    effectsGameDeleteEffect.Add(effect);
  }

     
  public int GetGameHash(int id, int version, GameIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.rand.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.squareLevelsOnly.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.gauntletMode.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.levels.GetDeterministicHashCode();
    if (!object.ReferenceEquals(incarnation.player, null)) {
      result += id * version * 5 * incarnation.player.GetDeterministicHashCode();
    }
    if (!object.ReferenceEquals(incarnation.level, null)) {
      result += id * version * 6 * incarnation.level.GetDeterministicHashCode();
    }
    result += id * version * 7 * incarnation.time.GetDeterministicHashCode();
    result += id * version * 8 * incarnation.executionState.GetDeterministicHashCode();
    return result;
  }
     
  public void BroadcastGameEffects(
      SortedDictionary<int, List<IGameEffectObserver>> observers) {
    foreach (var effect in effectsGameDeleteEffect) {
      if (observers.TryGetValue(0, out List<IGameEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnGameEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IGameEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnGameEffect(effect);
        }
        observersForGame.Remove(effect.id);
      }
    }
    effectsGameDeleteEffect.Clear();


    foreach (var effect in effectsGameSetPlayerEffect) {
      if (observers.TryGetValue(0, out List<IGameEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnGameEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IGameEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnGameEffect(effect);
        }
      }
    }
    effectsGameSetPlayerEffect.Clear();

    foreach (var effect in effectsGameSetLevelEffect) {
      if (observers.TryGetValue(0, out List<IGameEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnGameEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IGameEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnGameEffect(effect);
        }
      }
    }
    effectsGameSetLevelEffect.Clear();

    foreach (var effect in effectsGameSetTimeEffect) {
      if (observers.TryGetValue(0, out List<IGameEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnGameEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IGameEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnGameEffect(effect);
        }
      }
    }
    effectsGameSetTimeEffect.Clear();

    foreach (var effect in effectsGameCreateEffect) {
      if (observers.TryGetValue(0, out List<IGameEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnGameEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IGameEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnGameEffect(effect);
        }
      }
    }
    effectsGameCreateEffect.Clear();
  }

  public void EffectGameSetPlayer(int id, Unit newValue) {
    CheckUnlocked();
    CheckHasGame(id);
    var effect = new GameSetPlayerEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldId = oldIncarnationAndVersion.incarnation.player;
      oldIncarnationAndVersion.incarnation.player = newValue.id;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.gauntletMode,
              oldIncarnationAndVersion.incarnation.levels,
              newValue.id,
              oldIncarnationAndVersion.incarnation.level,
              oldIncarnationAndVersion.incarnation.time,
              oldIncarnationAndVersion.incarnation.executionState);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsGameSetPlayerEffect.Add(effect);
  }

  public void EffectGameSetLevel(int id, Level newValue) {
    CheckUnlocked();
    CheckHasGame(id);
    var effect = new GameSetLevelEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldId = oldIncarnationAndVersion.incarnation.level;
      oldIncarnationAndVersion.incarnation.level = newValue.id;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.gauntletMode,
              oldIncarnationAndVersion.incarnation.levels,
              oldIncarnationAndVersion.incarnation.player,
              newValue.id,
              oldIncarnationAndVersion.incarnation.time,
              oldIncarnationAndVersion.incarnation.executionState);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsGameSetLevelEffect.Add(effect);
  }

  public void EffectGameSetTime(int id, int newValue) {
    CheckUnlocked();
    CheckHasGame(id);
    var effect = new GameSetTimeEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.time;
      oldIncarnationAndVersion.incarnation.time = newValue;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.gauntletMode,
              oldIncarnationAndVersion.incarnation.levels,
              oldIncarnationAndVersion.incarnation.player,
              oldIncarnationAndVersion.incarnation.level,
              newValue,
              oldIncarnationAndVersion.incarnation.executionState);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    effectsGameSetTimeEffect.Add(effect);
  }

  public ILevelController GetILevelController(int id) {
    if (rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(id)) {
      return new SquareCaveLevelControllerAsILevelController(new SquareCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsRidgeLevelController.ContainsKey(id)) {
      return new RidgeLevelControllerAsILevelController(new RidgeLevelController(this, id));
    }
    if (rootIncarnation.incarnationsGauntletLevelController.ContainsKey(id)) {
      return new GauntletLevelControllerAsILevelController(new GauntletLevelController(this, id));
    }
    if (rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(id)) {
      return new PreGauntletLevelControllerAsILevelController(new PreGauntletLevelController(this, id));
    }
    if (rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(id)) {
      return new RavashrikeLevelControllerAsILevelController(new RavashrikeLevelController(this, id));
    }
    if (rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(id)) {
      return new PentagonalCaveLevelControllerAsILevelController(new PentagonalCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsCliffLevelController.ContainsKey(id)) {
      return new CliffLevelControllerAsILevelController(new CliffLevelController(this, id));
    }
    throw new Exception("Unknown ILevelController: " + id);
  }
  public ILevelController GetILevelControllerOrNull(int id) {
    if (rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(id)) {
      return new SquareCaveLevelControllerAsILevelController(new SquareCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsRidgeLevelController.ContainsKey(id)) {
      return new RidgeLevelControllerAsILevelController(new RidgeLevelController(this, id));
    }
    if (rootIncarnation.incarnationsGauntletLevelController.ContainsKey(id)) {
      return new GauntletLevelControllerAsILevelController(new GauntletLevelController(this, id));
    }
    if (rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(id)) {
      return new PreGauntletLevelControllerAsILevelController(new PreGauntletLevelController(this, id));
    }
    if (rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(id)) {
      return new RavashrikeLevelControllerAsILevelController(new RavashrikeLevelController(this, id));
    }
    if (rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(id)) {
      return new PentagonalCaveLevelControllerAsILevelController(new PentagonalCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsCliffLevelController.ContainsKey(id)) {
      return new CliffLevelControllerAsILevelController(new CliffLevelController(this, id));
    }
    return NullILevelController.Null;
  }
  public bool ILevelControllerExists(int id) {
    return GetILevelControllerOrNull(id) != null;
  }
  public void CheckHasILevelController(ILevelController thing) {
    GetILevelController(thing.id);
  }
  public void CheckHasILevelController(int id) {
    GetILevelController(id);
  }

  public IUnwalkableTTC GetIUnwalkableTTC(int id) {
    if (rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      return new FallsTTCAsIUnwalkableTTC(new FallsTTC(this, id));
    }
    if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      return new MagmaTTCAsIUnwalkableTTC(new MagmaTTC(this, id));
    }
    throw new Exception("Unknown IUnwalkableTTC: " + id);
  }
  public IUnwalkableTTC GetIUnwalkableTTCOrNull(int id) {
    if (rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      return new FallsTTCAsIUnwalkableTTC(new FallsTTC(this, id));
    }
    if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      return new MagmaTTCAsIUnwalkableTTC(new MagmaTTC(this, id));
    }
    return NullIUnwalkableTTC.Null;
  }
  public bool IUnwalkableTTCExists(int id) {
    return GetIUnwalkableTTCOrNull(id) != null;
  }
  public void CheckHasIUnwalkableTTC(IUnwalkableTTC thing) {
    GetIUnwalkableTTC(thing.id);
  }
  public void CheckHasIUnwalkableTTC(int id) {
    GetIUnwalkableTTC(id);
  }

  public ITerrainTileComponent GetITerrainTileComponent(int id) {
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsITerrainTileComponent(new Armor(this, id));
    }
    if (rootIncarnation.incarnationsInertiaRing.ContainsKey(id)) {
      return new InertiaRingAsITerrainTileComponent(new InertiaRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsITerrainTileComponent(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsITerrainTileComponent(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsITerrainTileComponent(new HealthPotion(this, id));
    }
    if (rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(id)) {
      return new TimeAnchorTTCAsITerrainTileComponent(new TimeAnchorTTC(this, id));
    }
    if (rootIncarnation.incarnationsStaircaseTTC.ContainsKey(id)) {
      return new StaircaseTTCAsITerrainTileComponent(new StaircaseTTC(this, id));
    }
    if (rootIncarnation.incarnationsWallTTC.ContainsKey(id)) {
      return new WallTTCAsITerrainTileComponent(new WallTTC(this, id));
    }
    if (rootIncarnation.incarnationsBloodTTC.ContainsKey(id)) {
      return new BloodTTCAsITerrainTileComponent(new BloodTTC(this, id));
    }
    if (rootIncarnation.incarnationsRocksTTC.ContainsKey(id)) {
      return new RocksTTCAsITerrainTileComponent(new RocksTTC(this, id));
    }
    if (rootIncarnation.incarnationsDownstairsTTC.ContainsKey(id)) {
      return new DownstairsTTCAsITerrainTileComponent(new DownstairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsUpstairsTTC.ContainsKey(id)) {
      return new UpstairsTTCAsITerrainTileComponent(new UpstairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveTTC.ContainsKey(id)) {
      return new CaveTTCAsITerrainTileComponent(new CaveTTC(this, id));
    }
    if (rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      return new FallsTTCAsITerrainTileComponent(new FallsTTC(this, id));
    }
    if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      return new MagmaTTCAsITerrainTileComponent(new MagmaTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffTTC.ContainsKey(id)) {
      return new CliffTTCAsITerrainTileComponent(new CliffTTC(this, id));
    }
    if (rootIncarnation.incarnationsRavaNestTTC.ContainsKey(id)) {
      return new RavaNestTTCAsITerrainTileComponent(new RavaNestTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(id)) {
      return new CliffLandingTTCAsITerrainTileComponent(new CliffLandingTTC(this, id));
    }
    if (rootIncarnation.incarnationsStoneTTC.ContainsKey(id)) {
      return new StoneTTCAsITerrainTileComponent(new StoneTTC(this, id));
    }
    if (rootIncarnation.incarnationsGrassTTC.ContainsKey(id)) {
      return new GrassTTCAsITerrainTileComponent(new GrassTTC(this, id));
    }
    throw new Exception("Unknown ITerrainTileComponent: " + id);
  }
  public ITerrainTileComponent GetITerrainTileComponentOrNull(int id) {
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsITerrainTileComponent(new Armor(this, id));
    }
    if (rootIncarnation.incarnationsInertiaRing.ContainsKey(id)) {
      return new InertiaRingAsITerrainTileComponent(new InertiaRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsITerrainTileComponent(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsITerrainTileComponent(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsITerrainTileComponent(new HealthPotion(this, id));
    }
    if (rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(id)) {
      return new TimeAnchorTTCAsITerrainTileComponent(new TimeAnchorTTC(this, id));
    }
    if (rootIncarnation.incarnationsStaircaseTTC.ContainsKey(id)) {
      return new StaircaseTTCAsITerrainTileComponent(new StaircaseTTC(this, id));
    }
    if (rootIncarnation.incarnationsWallTTC.ContainsKey(id)) {
      return new WallTTCAsITerrainTileComponent(new WallTTC(this, id));
    }
    if (rootIncarnation.incarnationsBloodTTC.ContainsKey(id)) {
      return new BloodTTCAsITerrainTileComponent(new BloodTTC(this, id));
    }
    if (rootIncarnation.incarnationsRocksTTC.ContainsKey(id)) {
      return new RocksTTCAsITerrainTileComponent(new RocksTTC(this, id));
    }
    if (rootIncarnation.incarnationsDownstairsTTC.ContainsKey(id)) {
      return new DownstairsTTCAsITerrainTileComponent(new DownstairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsUpstairsTTC.ContainsKey(id)) {
      return new UpstairsTTCAsITerrainTileComponent(new UpstairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveTTC.ContainsKey(id)) {
      return new CaveTTCAsITerrainTileComponent(new CaveTTC(this, id));
    }
    if (rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      return new FallsTTCAsITerrainTileComponent(new FallsTTC(this, id));
    }
    if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      return new MagmaTTCAsITerrainTileComponent(new MagmaTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffTTC.ContainsKey(id)) {
      return new CliffTTCAsITerrainTileComponent(new CliffTTC(this, id));
    }
    if (rootIncarnation.incarnationsRavaNestTTC.ContainsKey(id)) {
      return new RavaNestTTCAsITerrainTileComponent(new RavaNestTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(id)) {
      return new CliffLandingTTCAsITerrainTileComponent(new CliffLandingTTC(this, id));
    }
    if (rootIncarnation.incarnationsStoneTTC.ContainsKey(id)) {
      return new StoneTTCAsITerrainTileComponent(new StoneTTC(this, id));
    }
    if (rootIncarnation.incarnationsGrassTTC.ContainsKey(id)) {
      return new GrassTTCAsITerrainTileComponent(new GrassTTC(this, id));
    }
    return NullITerrainTileComponent.Null;
  }
  public bool ITerrainTileComponentExists(int id) {
    return GetITerrainTileComponentOrNull(id) != null;
  }
  public void CheckHasITerrainTileComponent(ITerrainTileComponent thing) {
    GetITerrainTileComponent(thing.id);
  }
  public void CheckHasITerrainTileComponent(int id) {
    GetITerrainTileComponent(id);
  }

  public IDefenseItem GetIDefenseItem(int id) {
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIDefenseItem(new Armor(this, id));
    }
    throw new Exception("Unknown IDefenseItem: " + id);
  }
  public IDefenseItem GetIDefenseItemOrNull(int id) {
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIDefenseItem(new Armor(this, id));
    }
    return NullIDefenseItem.Null;
  }
  public bool IDefenseItemExists(int id) {
    return GetIDefenseItemOrNull(id) != null;
  }
  public void CheckHasIDefenseItem(IDefenseItem thing) {
    GetIDefenseItem(thing.id);
  }
  public void CheckHasIDefenseItem(int id) {
    GetIDefenseItem(id);
  }

  public IInertiaItem GetIInertiaItem(int id) {
    if (rootIncarnation.incarnationsInertiaRing.ContainsKey(id)) {
      return new InertiaRingAsIInertiaItem(new InertiaRing(this, id));
    }
    throw new Exception("Unknown IInertiaItem: " + id);
  }
  public IInertiaItem GetIInertiaItemOrNull(int id) {
    if (rootIncarnation.incarnationsInertiaRing.ContainsKey(id)) {
      return new InertiaRingAsIInertiaItem(new InertiaRing(this, id));
    }
    return NullIInertiaItem.Null;
  }
  public bool IInertiaItemExists(int id) {
    return GetIInertiaItemOrNull(id) != null;
  }
  public void CheckHasIInertiaItem(IInertiaItem thing) {
    GetIInertiaItem(thing.id);
  }
  public void CheckHasIInertiaItem(int id) {
    GetIInertiaItem(id);
  }

  public IOffenseItem GetIOffenseItem(int id) {
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIOffenseItem(new Glaive(this, id));
    }
    throw new Exception("Unknown IOffenseItem: " + id);
  }
  public IOffenseItem GetIOffenseItemOrNull(int id) {
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIOffenseItem(new Glaive(this, id));
    }
    return NullIOffenseItem.Null;
  }
  public bool IOffenseItemExists(int id) {
    return GetIOffenseItemOrNull(id) != null;
  }
  public void CheckHasIOffenseItem(IOffenseItem thing) {
    GetIOffenseItem(thing.id);
  }
  public void CheckHasIOffenseItem(int id) {
    GetIOffenseItem(id);
  }

  public IUsableItem GetIUsableItem(int id) {
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIUsableItem(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIUsableItem(new HealthPotion(this, id));
    }
    throw new Exception("Unknown IUsableItem: " + id);
  }
  public IUsableItem GetIUsableItemOrNull(int id) {
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIUsableItem(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIUsableItem(new HealthPotion(this, id));
    }
    return NullIUsableItem.Null;
  }
  public bool IUsableItemExists(int id) {
    return GetIUsableItemOrNull(id) != null;
  }
  public void CheckHasIUsableItem(IUsableItem thing) {
    GetIUsableItem(thing.id);
  }
  public void CheckHasIUsableItem(int id) {
    GetIUsableItem(id);
  }

  public IItem GetIItem(int id) {
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIItem(new Armor(this, id));
    }
    if (rootIncarnation.incarnationsInertiaRing.ContainsKey(id)) {
      return new InertiaRingAsIItem(new InertiaRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIItem(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIItem(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIItem(new HealthPotion(this, id));
    }
    throw new Exception("Unknown IItem: " + id);
  }
  public IItem GetIItemOrNull(int id) {
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIItem(new Armor(this, id));
    }
    if (rootIncarnation.incarnationsInertiaRing.ContainsKey(id)) {
      return new InertiaRingAsIItem(new InertiaRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIItem(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIItem(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIItem(new HealthPotion(this, id));
    }
    return NullIItem.Null;
  }
  public bool IItemExists(int id) {
    return GetIItemOrNull(id) != null;
  }
  public void CheckHasIItem(IItem thing) {
    GetIItem(thing.id);
  }
  public void CheckHasIItem(int id) {
    GetIItem(id);
  }

  public IImpulsePostReactor GetIImpulsePostReactor(int id) {
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIImpulsePostReactor(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIImpulsePostReactor(new AttackAICapabilityUC(this, id));
    }
    throw new Exception("Unknown IImpulsePostReactor: " + id);
  }
  public IImpulsePostReactor GetIImpulsePostReactorOrNull(int id) {
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIImpulsePostReactor(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIImpulsePostReactor(new AttackAICapabilityUC(this, id));
    }
    return NullIImpulsePostReactor.Null;
  }
  public bool IImpulsePostReactorExists(int id) {
    return GetIImpulsePostReactorOrNull(id) != null;
  }
  public void CheckHasIImpulsePostReactor(IImpulsePostReactor thing) {
    GetIImpulsePostReactor(thing.id);
  }
  public void CheckHasIImpulsePostReactor(int id) {
    GetIImpulsePostReactor(id);
  }

  public IImpulsePreReactor GetIImpulsePreReactor(int id) {
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIImpulsePreReactor(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIImpulsePreReactor(new AttackAICapabilityUC(this, id));
    }
    throw new Exception("Unknown IImpulsePreReactor: " + id);
  }
  public IImpulsePreReactor GetIImpulsePreReactorOrNull(int id) {
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIImpulsePreReactor(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIImpulsePreReactor(new AttackAICapabilityUC(this, id));
    }
    return NullIImpulsePreReactor.Null;
  }
  public bool IImpulsePreReactorExists(int id) {
    return GetIImpulsePreReactorOrNull(id) != null;
  }
  public void CheckHasIImpulsePreReactor(IImpulsePreReactor thing) {
    GetIImpulsePreReactor(thing.id);
  }
  public void CheckHasIImpulsePreReactor(int id) {
    GetIImpulsePreReactor(id);
  }

  public IAICapabilityUC GetIAICapabilityUC(int id) {
    if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      return new WanderAICapabilityUCAsIAICapabilityUC(new WanderAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIAICapabilityUC(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIAICapabilityUC(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIAICapabilityUC(new AttackAICapabilityUC(this, id));
    }
    throw new Exception("Unknown IAICapabilityUC: " + id);
  }
  public IAICapabilityUC GetIAICapabilityUCOrNull(int id) {
    if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      return new WanderAICapabilityUCAsIAICapabilityUC(new WanderAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIAICapabilityUC(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIAICapabilityUC(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIAICapabilityUC(new AttackAICapabilityUC(this, id));
    }
    return NullIAICapabilityUC.Null;
  }
  public bool IAICapabilityUCExists(int id) {
    return GetIAICapabilityUCOrNull(id) != null;
  }
  public void CheckHasIAICapabilityUC(IAICapabilityUC thing) {
    GetIAICapabilityUC(thing.id);
  }
  public void CheckHasIAICapabilityUC(int id) {
    GetIAICapabilityUC(id);
  }

  public IPostActingUC GetIPostActingUC(int id) {
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIPostActingUC(new TimeCloneAICapabilityUC(this, id));
    }
    throw new Exception("Unknown IPostActingUC: " + id);
  }
  public IPostActingUC GetIPostActingUCOrNull(int id) {
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIPostActingUC(new TimeCloneAICapabilityUC(this, id));
    }
    return NullIPostActingUC.Null;
  }
  public bool IPostActingUCExists(int id) {
    return GetIPostActingUCOrNull(id) != null;
  }
  public void CheckHasIPostActingUC(IPostActingUC thing) {
    GetIPostActingUC(thing.id);
  }
  public void CheckHasIPostActingUC(int id) {
    GetIPostActingUC(id);
  }

  public IPreActingUC GetIPreActingUC(int id) {
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIPreActingUC(new CounteringUC(this, id));
    }
    if (rootIncarnation.incarnationsShieldingUC.ContainsKey(id)) {
      return new ShieldingUCAsIPreActingUC(new ShieldingUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIPreActingUC(new AttackAICapabilityUC(this, id));
    }
    throw new Exception("Unknown IPreActingUC: " + id);
  }
  public IPreActingUC GetIPreActingUCOrNull(int id) {
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIPreActingUC(new CounteringUC(this, id));
    }
    if (rootIncarnation.incarnationsShieldingUC.ContainsKey(id)) {
      return new ShieldingUCAsIPreActingUC(new ShieldingUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIPreActingUC(new AttackAICapabilityUC(this, id));
    }
    return NullIPreActingUC.Null;
  }
  public bool IPreActingUCExists(int id) {
    return GetIPreActingUCOrNull(id) != null;
  }
  public void CheckHasIPreActingUC(IPreActingUC thing) {
    GetIPreActingUC(thing.id);
  }
  public void CheckHasIPreActingUC(int id) {
    GetIPreActingUC(id);
  }

  public IReactingToAttacksUC GetIReactingToAttacksUC(int id) {
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIReactingToAttacksUC(new CounteringUC(this, id));
    }
    throw new Exception("Unknown IReactingToAttacksUC: " + id);
  }
  public IReactingToAttacksUC GetIReactingToAttacksUCOrNull(int id) {
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIReactingToAttacksUC(new CounteringUC(this, id));
    }
    return NullIReactingToAttacksUC.Null;
  }
  public bool IReactingToAttacksUCExists(int id) {
    return GetIReactingToAttacksUCOrNull(id) != null;
  }
  public void CheckHasIReactingToAttacksUC(IReactingToAttacksUC thing) {
    GetIReactingToAttacksUC(thing.id);
  }
  public void CheckHasIReactingToAttacksUC(int id) {
    GetIReactingToAttacksUC(id);
  }

  public IDefenseUC GetIDefenseUC(int id) {
    if (rootIncarnation.incarnationsShieldingUC.ContainsKey(id)) {
      return new ShieldingUCAsIDefenseUC(new ShieldingUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIDefenseUC(new BideAICapabilityUC(this, id));
    }
    throw new Exception("Unknown IDefenseUC: " + id);
  }
  public IDefenseUC GetIDefenseUCOrNull(int id) {
    if (rootIncarnation.incarnationsShieldingUC.ContainsKey(id)) {
      return new ShieldingUCAsIDefenseUC(new ShieldingUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIDefenseUC(new BideAICapabilityUC(this, id));
    }
    return NullIDefenseUC.Null;
  }
  public bool IDefenseUCExists(int id) {
    return GetIDefenseUCOrNull(id) != null;
  }
  public void CheckHasIDefenseUC(IDefenseUC thing) {
    GetIDefenseUC(thing.id);
  }
  public void CheckHasIDefenseUC(int id) {
    GetIDefenseUC(id);
  }

  public IUnitComponent GetIUnitComponent(int id) {
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIUnitComponent(new Armor(this, id));
    }
    if (rootIncarnation.incarnationsInertiaRing.ContainsKey(id)) {
      return new InertiaRingAsIUnitComponent(new InertiaRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIUnitComponent(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIUnitComponent(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIUnitComponent(new HealthPotion(this, id));
    }
    if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      return new WanderAICapabilityUCAsIUnitComponent(new WanderAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIUnitComponent(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIUnitComponent(new AttackAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIUnitComponent(new CounteringUC(this, id));
    }
    if (rootIncarnation.incarnationsShieldingUC.ContainsKey(id)) {
      return new ShieldingUCAsIUnitComponent(new ShieldingUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIUnitComponent(new BideAICapabilityUC(this, id));
    }
    throw new Exception("Unknown IUnitComponent: " + id);
  }
  public IUnitComponent GetIUnitComponentOrNull(int id) {
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIUnitComponent(new Armor(this, id));
    }
    if (rootIncarnation.incarnationsInertiaRing.ContainsKey(id)) {
      return new InertiaRingAsIUnitComponent(new InertiaRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIUnitComponent(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIUnitComponent(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIUnitComponent(new HealthPotion(this, id));
    }
    if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      return new WanderAICapabilityUCAsIUnitComponent(new WanderAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIUnitComponent(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIUnitComponent(new AttackAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIUnitComponent(new CounteringUC(this, id));
    }
    if (rootIncarnation.incarnationsShieldingUC.ContainsKey(id)) {
      return new ShieldingUCAsIUnitComponent(new ShieldingUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIUnitComponent(new BideAICapabilityUC(this, id));
    }
    return NullIUnitComponent.Null;
  }
  public bool IUnitComponentExists(int id) {
    return GetIUnitComponentOrNull(id) != null;
  }
  public void CheckHasIUnitComponent(IUnitComponent thing) {
    GetIUnitComponent(thing.id);
  }
  public void CheckHasIUnitComponent(int id) {
    GetIUnitComponent(id);
  }

  public IImpulse GetIImpulse(int id) {
    if (rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(id)) {
      return new EvaporateImpulseAsIImpulse(new EvaporateImpulse(this, id));
    }
    if (rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(id)) {
      return new UnleashBideImpulseAsIImpulse(new UnleashBideImpulse(this, id));
    }
    if (rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(id)) {
      return new ContinueBidingImpulseAsIImpulse(new ContinueBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(id)) {
      return new StartBidingImpulseAsIImpulse(new StartBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsFireImpulse.ContainsKey(id)) {
      return new FireImpulseAsIImpulse(new FireImpulse(this, id));
    }
    if (rootIncarnation.incarnationsCounterImpulse.ContainsKey(id)) {
      return new CounterImpulseAsIImpulse(new CounterImpulse(this, id));
    }
    if (rootIncarnation.incarnationsDefendImpulse.ContainsKey(id)) {
      return new DefendImpulseAsIImpulse(new DefendImpulse(this, id));
    }
    if (rootIncarnation.incarnationsAttackImpulse.ContainsKey(id)) {
      return new AttackImpulseAsIImpulse(new AttackImpulse(this, id));
    }
    if (rootIncarnation.incarnationsPursueImpulse.ContainsKey(id)) {
      return new PursueImpulseAsIImpulse(new PursueImpulse(this, id));
    }
    if (rootIncarnation.incarnationsMoveImpulse.ContainsKey(id)) {
      return new MoveImpulseAsIImpulse(new MoveImpulse(this, id));
    }
    if (rootIncarnation.incarnationsNoImpulse.ContainsKey(id)) {
      return new NoImpulseAsIImpulse(new NoImpulse(this, id));
    }
    throw new Exception("Unknown IImpulse: " + id);
  }
  public IImpulse GetIImpulseOrNull(int id) {
    if (rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(id)) {
      return new EvaporateImpulseAsIImpulse(new EvaporateImpulse(this, id));
    }
    if (rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(id)) {
      return new UnleashBideImpulseAsIImpulse(new UnleashBideImpulse(this, id));
    }
    if (rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(id)) {
      return new ContinueBidingImpulseAsIImpulse(new ContinueBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(id)) {
      return new StartBidingImpulseAsIImpulse(new StartBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsFireImpulse.ContainsKey(id)) {
      return new FireImpulseAsIImpulse(new FireImpulse(this, id));
    }
    if (rootIncarnation.incarnationsCounterImpulse.ContainsKey(id)) {
      return new CounterImpulseAsIImpulse(new CounterImpulse(this, id));
    }
    if (rootIncarnation.incarnationsDefendImpulse.ContainsKey(id)) {
      return new DefendImpulseAsIImpulse(new DefendImpulse(this, id));
    }
    if (rootIncarnation.incarnationsAttackImpulse.ContainsKey(id)) {
      return new AttackImpulseAsIImpulse(new AttackImpulse(this, id));
    }
    if (rootIncarnation.incarnationsPursueImpulse.ContainsKey(id)) {
      return new PursueImpulseAsIImpulse(new PursueImpulse(this, id));
    }
    if (rootIncarnation.incarnationsMoveImpulse.ContainsKey(id)) {
      return new MoveImpulseAsIImpulse(new MoveImpulse(this, id));
    }
    if (rootIncarnation.incarnationsNoImpulse.ContainsKey(id)) {
      return new NoImpulseAsIImpulse(new NoImpulse(this, id));
    }
    return NullIImpulse.Null;
  }
  public bool IImpulseExists(int id) {
    return GetIImpulseOrNull(id) != null;
  }
  public void CheckHasIImpulse(IImpulse thing) {
    GetIImpulse(thing.id);
  }
  public void CheckHasIImpulse(int id) {
    GetIImpulse(id);
  }

  public IDestructible GetIDestructible(int id) {
    if (rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(id)) {
      return new TimeAnchorTTCAsIDestructible(new TimeAnchorTTC(this, id));
    }
    if (rootIncarnation.incarnationsStaircaseTTC.ContainsKey(id)) {
      return new StaircaseTTCAsIDestructible(new StaircaseTTC(this, id));
    }
    if (rootIncarnation.incarnationsWallTTC.ContainsKey(id)) {
      return new WallTTCAsIDestructible(new WallTTC(this, id));
    }
    if (rootIncarnation.incarnationsBloodTTC.ContainsKey(id)) {
      return new BloodTTCAsIDestructible(new BloodTTC(this, id));
    }
    if (rootIncarnation.incarnationsRocksTTC.ContainsKey(id)) {
      return new RocksTTCAsIDestructible(new RocksTTC(this, id));
    }
    if (rootIncarnation.incarnationsDownstairsTTC.ContainsKey(id)) {
      return new DownstairsTTCAsIDestructible(new DownstairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsUpstairsTTC.ContainsKey(id)) {
      return new UpstairsTTCAsIDestructible(new UpstairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveTTC.ContainsKey(id)) {
      return new CaveTTCAsIDestructible(new CaveTTC(this, id));
    }
    if (rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      return new FallsTTCAsIDestructible(new FallsTTC(this, id));
    }
    if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      return new MagmaTTCAsIDestructible(new MagmaTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffTTC.ContainsKey(id)) {
      return new CliffTTCAsIDestructible(new CliffTTC(this, id));
    }
    if (rootIncarnation.incarnationsRavaNestTTC.ContainsKey(id)) {
      return new RavaNestTTCAsIDestructible(new RavaNestTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(id)) {
      return new CliffLandingTTCAsIDestructible(new CliffLandingTTC(this, id));
    }
    if (rootIncarnation.incarnationsStoneTTC.ContainsKey(id)) {
      return new StoneTTCAsIDestructible(new StoneTTC(this, id));
    }
    if (rootIncarnation.incarnationsGrassTTC.ContainsKey(id)) {
      return new GrassTTCAsIDestructible(new GrassTTC(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIDestructible(new Armor(this, id));
    }
    if (rootIncarnation.incarnationsInertiaRing.ContainsKey(id)) {
      return new InertiaRingAsIDestructible(new InertiaRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIDestructible(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIDestructible(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIDestructible(new HealthPotion(this, id));
    }
    if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      return new WanderAICapabilityUCAsIDestructible(new WanderAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIDestructible(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIDestructible(new AttackAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIDestructible(new CounteringUC(this, id));
    }
    if (rootIncarnation.incarnationsShieldingUC.ContainsKey(id)) {
      return new ShieldingUCAsIDestructible(new ShieldingUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIDestructible(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(id)) {
      return new EvaporateImpulseAsIDestructible(new EvaporateImpulse(this, id));
    }
    if (rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(id)) {
      return new UnleashBideImpulseAsIDestructible(new UnleashBideImpulse(this, id));
    }
    if (rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(id)) {
      return new ContinueBidingImpulseAsIDestructible(new ContinueBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(id)) {
      return new StartBidingImpulseAsIDestructible(new StartBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsFireImpulse.ContainsKey(id)) {
      return new FireImpulseAsIDestructible(new FireImpulse(this, id));
    }
    if (rootIncarnation.incarnationsCounterImpulse.ContainsKey(id)) {
      return new CounterImpulseAsIDestructible(new CounterImpulse(this, id));
    }
    if (rootIncarnation.incarnationsDefendImpulse.ContainsKey(id)) {
      return new DefendImpulseAsIDestructible(new DefendImpulse(this, id));
    }
    if (rootIncarnation.incarnationsAttackImpulse.ContainsKey(id)) {
      return new AttackImpulseAsIDestructible(new AttackImpulse(this, id));
    }
    if (rootIncarnation.incarnationsPursueImpulse.ContainsKey(id)) {
      return new PursueImpulseAsIDestructible(new PursueImpulse(this, id));
    }
    if (rootIncarnation.incarnationsMoveImpulse.ContainsKey(id)) {
      return new MoveImpulseAsIDestructible(new MoveImpulse(this, id));
    }
    if (rootIncarnation.incarnationsNoImpulse.ContainsKey(id)) {
      return new NoImpulseAsIDestructible(new NoImpulse(this, id));
    }
    if (rootIncarnation.incarnationsUnit.ContainsKey(id)) {
      return new UnitAsIDestructible(new Unit(this, id));
    }
    throw new Exception("Unknown IDestructible: " + id);
  }
  public IDestructible GetIDestructibleOrNull(int id) {
    if (rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(id)) {
      return new TimeAnchorTTCAsIDestructible(new TimeAnchorTTC(this, id));
    }
    if (rootIncarnation.incarnationsStaircaseTTC.ContainsKey(id)) {
      return new StaircaseTTCAsIDestructible(new StaircaseTTC(this, id));
    }
    if (rootIncarnation.incarnationsWallTTC.ContainsKey(id)) {
      return new WallTTCAsIDestructible(new WallTTC(this, id));
    }
    if (rootIncarnation.incarnationsBloodTTC.ContainsKey(id)) {
      return new BloodTTCAsIDestructible(new BloodTTC(this, id));
    }
    if (rootIncarnation.incarnationsRocksTTC.ContainsKey(id)) {
      return new RocksTTCAsIDestructible(new RocksTTC(this, id));
    }
    if (rootIncarnation.incarnationsDownstairsTTC.ContainsKey(id)) {
      return new DownstairsTTCAsIDestructible(new DownstairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsUpstairsTTC.ContainsKey(id)) {
      return new UpstairsTTCAsIDestructible(new UpstairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveTTC.ContainsKey(id)) {
      return new CaveTTCAsIDestructible(new CaveTTC(this, id));
    }
    if (rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      return new FallsTTCAsIDestructible(new FallsTTC(this, id));
    }
    if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      return new MagmaTTCAsIDestructible(new MagmaTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffTTC.ContainsKey(id)) {
      return new CliffTTCAsIDestructible(new CliffTTC(this, id));
    }
    if (rootIncarnation.incarnationsRavaNestTTC.ContainsKey(id)) {
      return new RavaNestTTCAsIDestructible(new RavaNestTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(id)) {
      return new CliffLandingTTCAsIDestructible(new CliffLandingTTC(this, id));
    }
    if (rootIncarnation.incarnationsStoneTTC.ContainsKey(id)) {
      return new StoneTTCAsIDestructible(new StoneTTC(this, id));
    }
    if (rootIncarnation.incarnationsGrassTTC.ContainsKey(id)) {
      return new GrassTTCAsIDestructible(new GrassTTC(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIDestructible(new Armor(this, id));
    }
    if (rootIncarnation.incarnationsInertiaRing.ContainsKey(id)) {
      return new InertiaRingAsIDestructible(new InertiaRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIDestructible(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIDestructible(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIDestructible(new HealthPotion(this, id));
    }
    if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      return new WanderAICapabilityUCAsIDestructible(new WanderAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIDestructible(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIDestructible(new AttackAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIDestructible(new CounteringUC(this, id));
    }
    if (rootIncarnation.incarnationsShieldingUC.ContainsKey(id)) {
      return new ShieldingUCAsIDestructible(new ShieldingUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIDestructible(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(id)) {
      return new EvaporateImpulseAsIDestructible(new EvaporateImpulse(this, id));
    }
    if (rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(id)) {
      return new UnleashBideImpulseAsIDestructible(new UnleashBideImpulse(this, id));
    }
    if (rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(id)) {
      return new ContinueBidingImpulseAsIDestructible(new ContinueBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(id)) {
      return new StartBidingImpulseAsIDestructible(new StartBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsFireImpulse.ContainsKey(id)) {
      return new FireImpulseAsIDestructible(new FireImpulse(this, id));
    }
    if (rootIncarnation.incarnationsCounterImpulse.ContainsKey(id)) {
      return new CounterImpulseAsIDestructible(new CounterImpulse(this, id));
    }
    if (rootIncarnation.incarnationsDefendImpulse.ContainsKey(id)) {
      return new DefendImpulseAsIDestructible(new DefendImpulse(this, id));
    }
    if (rootIncarnation.incarnationsAttackImpulse.ContainsKey(id)) {
      return new AttackImpulseAsIDestructible(new AttackImpulse(this, id));
    }
    if (rootIncarnation.incarnationsPursueImpulse.ContainsKey(id)) {
      return new PursueImpulseAsIDestructible(new PursueImpulse(this, id));
    }
    if (rootIncarnation.incarnationsMoveImpulse.ContainsKey(id)) {
      return new MoveImpulseAsIDestructible(new MoveImpulse(this, id));
    }
    if (rootIncarnation.incarnationsNoImpulse.ContainsKey(id)) {
      return new NoImpulseAsIDestructible(new NoImpulse(this, id));
    }
    if (rootIncarnation.incarnationsUnit.ContainsKey(id)) {
      return new UnitAsIDestructible(new Unit(this, id));
    }
    return NullIDestructible.Null;
  }
  public bool IDestructibleExists(int id) {
    return GetIDestructibleOrNull(id) != null;
  }
  public void CheckHasIDestructible(IDestructible thing) {
    GetIDestructible(thing.id);
  }
  public void CheckHasIDestructible(int id) {
    GetIDestructible(id);
  }

    public int GetIUnitEventMutListHash(int id, int version, IUnitEventMutListIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.list) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public IUnitEventMutListIncarnation GetIUnitEventMutListIncarnation(int id) {
      return rootIncarnation.incarnationsIUnitEventMutList[id].incarnation;
    }
    public IUnitEventMutList GetIUnitEventMutList(int id) {
      return new IUnitEventMutList(this, id);
    }
    public List<IUnitEventMutList> AllIUnitEventMutList() {
      List<IUnitEventMutList> result = new List<IUnitEventMutList>(rootIncarnation.incarnationsIUnitEventMutList.Count);
      foreach (var id in rootIncarnation.incarnationsIUnitEventMutList.Keys) {
        result.Add(new IUnitEventMutList(this, id));
      }
      return result;
    }
    public bool IUnitEventMutListExists(int id) {
      return rootIncarnation.incarnationsIUnitEventMutList.ContainsKey(id);
    }
    public void CheckHasIUnitEventMutList(IUnitEventMutList thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasIUnitEventMutList(thing.id);
    }
    public void CheckHasIUnitEventMutList(int id) {
      if (!rootIncarnation.incarnationsIUnitEventMutList.ContainsKey(id)) {
        throw new System.Exception("Invalid IUnitEventMutList}: " + id);
      }
    }
    public IUnitEventMutList EffectIUnitEventMutListCreate() {
      CheckUnlocked();
      var id = NewId();
      EffectInternalCreateIUnitEventMutList(id, rootIncarnation.version, new IUnitEventMutListIncarnation(new List<IUnitEvent>()));
      return new IUnitEventMutList(this, id);
    }
    public IUnitEventMutList EffectIUnitEventMutListCreate(IEnumerable<IUnitEvent> elements) {
      var id = NewId();
      var incarnation = new IUnitEventMutListIncarnation(new List<IUnitEvent>(elements));
      EffectInternalCreateIUnitEventMutList(id, rootIncarnation.version, incarnation);
      return new IUnitEventMutList(this, id);
    }
    public void EffectInternalCreateIUnitEventMutList(int id, int incarnationVersion, IUnitEventMutListIncarnation incarnation) {
      var effect = new IUnitEventMutListCreateEffect(id);
      rootIncarnation.incarnationsIUnitEventMutList
          .Add(
              id,
              new VersionAndIncarnation<IUnitEventMutListIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsIUnitEventMutListCreateEffect.Add(effect);
    }
    public void EffectIUnitEventMutListDelete(int id) {
      CheckUnlocked();
      var effect = new IUnitEventMutListDeleteEffect(id);
      effectsIUnitEventMutListDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsIUnitEventMutList[id];
      rootIncarnation.incarnationsIUnitEventMutList.Remove(id);
    }
    public void EffectIUnitEventMutListAdd(int listId, IUnitEvent element) {
      CheckUnlocked();
      CheckHasIUnitEventMutList(listId);

    
      var effect = new IUnitEventMutListAddEffect(listId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsIUnitEventMutList[listId];
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.list.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.list;
        var newMap = new List<IUnitEvent>(oldMap);
        newMap.Add(element);
        var newIncarnation = new IUnitEventMutListIncarnation(newMap);
        rootIncarnation.incarnationsIUnitEventMutList[listId] =
            new VersionAndIncarnation<IUnitEventMutListIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsIUnitEventMutListAddEffect.Add(effect);
    }
    public void EffectIUnitEventMutListRemoveAt(int listId, int index) {
      CheckUnlocked();
      CheckHasIUnitEventMutList(listId);

      var effect = new IUnitEventMutListRemoveEffect(listId, index);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsIUnitEventMutList[listId];
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        var oldElement = oldIncarnationAndVersion.incarnation.list[index];
        oldIncarnationAndVersion.incarnation.list.RemoveAt(index);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.list;
        var newMap = new List<IUnitEvent>(oldMap);
        newMap.RemoveAt(index);
        var newIncarnation = new IUnitEventMutListIncarnation(newMap);
        rootIncarnation.incarnationsIUnitEventMutList[listId] =
            new VersionAndIncarnation<IUnitEventMutListIncarnation>(
                rootIncarnation.version, newIncarnation);

      }
      effectsIUnitEventMutListRemoveEffect.Add(effect);
    }
       
    public void AddIUnitEventMutListObserver(int id, IIUnitEventMutListEffectObserver observer) {
      List<IIUnitEventMutListEffectObserver> obsies;
      if (!observersForIUnitEventMutList.TryGetValue(id, out obsies)) {
        obsies = new List<IIUnitEventMutListEffectObserver>();
      }
      obsies.Add(observer);
      observersForIUnitEventMutList[id] = obsies;
    }

    public void RemoveIUnitEventMutListObserver(int id, IIUnitEventMutListEffectObserver observer) {
      if (observersForIUnitEventMutList.ContainsKey(id)) {
        var list = observersForIUnitEventMutList[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForIUnitEventMutList.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }

  public void BroadcastIUnitEventMutListEffects(
      SortedDictionary<int, List<IIUnitEventMutListEffectObserver>> observers) {
    foreach (var effect in effectsIUnitEventMutListDeleteEffect) {
      if (observers.TryGetValue(0, out List<IIUnitEventMutListEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnIUnitEventMutListEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IIUnitEventMutListEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnIUnitEventMutListEffect(effect);
        }
        observersForIUnitEventMutList.Remove(effect.id);
      }
    }
    effectsIUnitEventMutListDeleteEffect.Clear();

    foreach (var effect in effectsIUnitEventMutListAddEffect) {
      if (observers.TryGetValue(0, out List<IIUnitEventMutListEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnIUnitEventMutListEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IIUnitEventMutListEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnIUnitEventMutListEffect(effect);
        }
      }
    }
    effectsIUnitEventMutListAddEffect.Clear();

    foreach (var effect in effectsIUnitEventMutListRemoveEffect) {
      if (observers.TryGetValue(0, out List<IIUnitEventMutListEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnIUnitEventMutListEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IIUnitEventMutListEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnIUnitEventMutListEffect(effect);
        }
      }
    }
    effectsIUnitEventMutListRemoveEffect.Clear();

    foreach (var effect in effectsIUnitEventMutListCreateEffect) {
      if (observers.TryGetValue(0, out List<IIUnitEventMutListEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnIUnitEventMutListEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IIUnitEventMutListEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnIUnitEventMutListEffect(effect);
        }
      }
    }
    effectsIUnitEventMutListCreateEffect.Clear();

  }

    public int GetLocationMutListHash(int id, int version, LocationMutListIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.list) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public LocationMutListIncarnation GetLocationMutListIncarnation(int id) {
      return rootIncarnation.incarnationsLocationMutList[id].incarnation;
    }
    public LocationMutList GetLocationMutList(int id) {
      return new LocationMutList(this, id);
    }
    public List<LocationMutList> AllLocationMutList() {
      List<LocationMutList> result = new List<LocationMutList>(rootIncarnation.incarnationsLocationMutList.Count);
      foreach (var id in rootIncarnation.incarnationsLocationMutList.Keys) {
        result.Add(new LocationMutList(this, id));
      }
      return result;
    }
    public bool LocationMutListExists(int id) {
      return rootIncarnation.incarnationsLocationMutList.ContainsKey(id);
    }
    public void CheckHasLocationMutList(LocationMutList thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasLocationMutList(thing.id);
    }
    public void CheckHasLocationMutList(int id) {
      if (!rootIncarnation.incarnationsLocationMutList.ContainsKey(id)) {
        throw new System.Exception("Invalid LocationMutList}: " + id);
      }
    }
    public LocationMutList EffectLocationMutListCreate() {
      CheckUnlocked();
      var id = NewId();
      EffectInternalCreateLocationMutList(id, rootIncarnation.version, new LocationMutListIncarnation(new List<Location>()));
      return new LocationMutList(this, id);
    }
    public LocationMutList EffectLocationMutListCreate(IEnumerable<Location> elements) {
      var id = NewId();
      var incarnation = new LocationMutListIncarnation(new List<Location>(elements));
      EffectInternalCreateLocationMutList(id, rootIncarnation.version, incarnation);
      return new LocationMutList(this, id);
    }
    public void EffectInternalCreateLocationMutList(int id, int incarnationVersion, LocationMutListIncarnation incarnation) {
      var effect = new LocationMutListCreateEffect(id);
      rootIncarnation.incarnationsLocationMutList
          .Add(
              id,
              new VersionAndIncarnation<LocationMutListIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsLocationMutListCreateEffect.Add(effect);
    }
    public void EffectLocationMutListDelete(int id) {
      CheckUnlocked();
      var effect = new LocationMutListDeleteEffect(id);
      effectsLocationMutListDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsLocationMutList[id];
      rootIncarnation.incarnationsLocationMutList.Remove(id);
    }
    public void EffectLocationMutListAdd(int listId, Location element) {
      CheckUnlocked();
      CheckHasLocationMutList(listId);

    
      var effect = new LocationMutListAddEffect(listId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsLocationMutList[listId];
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.list.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.list;
        var newMap = new List<Location>(oldMap);
        newMap.Add(element);
        var newIncarnation = new LocationMutListIncarnation(newMap);
        rootIncarnation.incarnationsLocationMutList[listId] =
            new VersionAndIncarnation<LocationMutListIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsLocationMutListAddEffect.Add(effect);
    }
    public void EffectLocationMutListRemoveAt(int listId, int index) {
      CheckUnlocked();
      CheckHasLocationMutList(listId);

      var effect = new LocationMutListRemoveEffect(listId, index);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsLocationMutList[listId];
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        var oldElement = oldIncarnationAndVersion.incarnation.list[index];
        oldIncarnationAndVersion.incarnation.list.RemoveAt(index);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.list;
        var newMap = new List<Location>(oldMap);
        newMap.RemoveAt(index);
        var newIncarnation = new LocationMutListIncarnation(newMap);
        rootIncarnation.incarnationsLocationMutList[listId] =
            new VersionAndIncarnation<LocationMutListIncarnation>(
                rootIncarnation.version, newIncarnation);

      }
      effectsLocationMutListRemoveEffect.Add(effect);
    }
       
    public void AddLocationMutListObserver(int id, ILocationMutListEffectObserver observer) {
      List<ILocationMutListEffectObserver> obsies;
      if (!observersForLocationMutList.TryGetValue(id, out obsies)) {
        obsies = new List<ILocationMutListEffectObserver>();
      }
      obsies.Add(observer);
      observersForLocationMutList[id] = obsies;
    }

    public void RemoveLocationMutListObserver(int id, ILocationMutListEffectObserver observer) {
      if (observersForLocationMutList.ContainsKey(id)) {
        var list = observersForLocationMutList[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForLocationMutList.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }

  public void BroadcastLocationMutListEffects(
      SortedDictionary<int, List<ILocationMutListEffectObserver>> observers) {
    foreach (var effect in effectsLocationMutListDeleteEffect) {
      if (observers.TryGetValue(0, out List<ILocationMutListEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnLocationMutListEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ILocationMutListEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnLocationMutListEffect(effect);
        }
        observersForLocationMutList.Remove(effect.id);
      }
    }
    effectsLocationMutListDeleteEffect.Clear();

    foreach (var effect in effectsLocationMutListAddEffect) {
      if (observers.TryGetValue(0, out List<ILocationMutListEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnLocationMutListEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ILocationMutListEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnLocationMutListEffect(effect);
        }
      }
    }
    effectsLocationMutListAddEffect.Clear();

    foreach (var effect in effectsLocationMutListRemoveEffect) {
      if (observers.TryGetValue(0, out List<ILocationMutListEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnLocationMutListEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ILocationMutListEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnLocationMutListEffect(effect);
        }
      }
    }
    effectsLocationMutListRemoveEffect.Clear();

    foreach (var effect in effectsLocationMutListCreateEffect) {
      if (observers.TryGetValue(0, out List<ILocationMutListEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnLocationMutListEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ILocationMutListEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnLocationMutListEffect(effect);
        }
      }
    }
    effectsLocationMutListCreateEffect.Clear();

  }

    public int GetIRequestMutListHash(int id, int version, IRequestMutListIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.list) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public IRequestMutListIncarnation GetIRequestMutListIncarnation(int id) {
      return rootIncarnation.incarnationsIRequestMutList[id].incarnation;
    }
    public IRequestMutList GetIRequestMutList(int id) {
      return new IRequestMutList(this, id);
    }
    public List<IRequestMutList> AllIRequestMutList() {
      List<IRequestMutList> result = new List<IRequestMutList>(rootIncarnation.incarnationsIRequestMutList.Count);
      foreach (var id in rootIncarnation.incarnationsIRequestMutList.Keys) {
        result.Add(new IRequestMutList(this, id));
      }
      return result;
    }
    public bool IRequestMutListExists(int id) {
      return rootIncarnation.incarnationsIRequestMutList.ContainsKey(id);
    }
    public void CheckHasIRequestMutList(IRequestMutList thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasIRequestMutList(thing.id);
    }
    public void CheckHasIRequestMutList(int id) {
      if (!rootIncarnation.incarnationsIRequestMutList.ContainsKey(id)) {
        throw new System.Exception("Invalid IRequestMutList}: " + id);
      }
    }
    public IRequestMutList EffectIRequestMutListCreate() {
      CheckUnlocked();
      var id = NewId();
      EffectInternalCreateIRequestMutList(id, rootIncarnation.version, new IRequestMutListIncarnation(new List<IRequest>()));
      return new IRequestMutList(this, id);
    }
    public IRequestMutList EffectIRequestMutListCreate(IEnumerable<IRequest> elements) {
      var id = NewId();
      var incarnation = new IRequestMutListIncarnation(new List<IRequest>(elements));
      EffectInternalCreateIRequestMutList(id, rootIncarnation.version, incarnation);
      return new IRequestMutList(this, id);
    }
    public void EffectInternalCreateIRequestMutList(int id, int incarnationVersion, IRequestMutListIncarnation incarnation) {
      var effect = new IRequestMutListCreateEffect(id);
      rootIncarnation.incarnationsIRequestMutList
          .Add(
              id,
              new VersionAndIncarnation<IRequestMutListIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsIRequestMutListCreateEffect.Add(effect);
    }
    public void EffectIRequestMutListDelete(int id) {
      CheckUnlocked();
      var effect = new IRequestMutListDeleteEffect(id);
      effectsIRequestMutListDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsIRequestMutList[id];
      rootIncarnation.incarnationsIRequestMutList.Remove(id);
    }
    public void EffectIRequestMutListAdd(int listId, IRequest element) {
      CheckUnlocked();
      CheckHasIRequestMutList(listId);

    
      var effect = new IRequestMutListAddEffect(listId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsIRequestMutList[listId];
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.list.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.list;
        var newMap = new List<IRequest>(oldMap);
        newMap.Add(element);
        var newIncarnation = new IRequestMutListIncarnation(newMap);
        rootIncarnation.incarnationsIRequestMutList[listId] =
            new VersionAndIncarnation<IRequestMutListIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsIRequestMutListAddEffect.Add(effect);
    }
    public void EffectIRequestMutListRemoveAt(int listId, int index) {
      CheckUnlocked();
      CheckHasIRequestMutList(listId);

      var effect = new IRequestMutListRemoveEffect(listId, index);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsIRequestMutList[listId];
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        var oldElement = oldIncarnationAndVersion.incarnation.list[index];
        oldIncarnationAndVersion.incarnation.list.RemoveAt(index);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.list;
        var newMap = new List<IRequest>(oldMap);
        newMap.RemoveAt(index);
        var newIncarnation = new IRequestMutListIncarnation(newMap);
        rootIncarnation.incarnationsIRequestMutList[listId] =
            new VersionAndIncarnation<IRequestMutListIncarnation>(
                rootIncarnation.version, newIncarnation);

      }
      effectsIRequestMutListRemoveEffect.Add(effect);
    }
       
    public void AddIRequestMutListObserver(int id, IIRequestMutListEffectObserver observer) {
      List<IIRequestMutListEffectObserver> obsies;
      if (!observersForIRequestMutList.TryGetValue(id, out obsies)) {
        obsies = new List<IIRequestMutListEffectObserver>();
      }
      obsies.Add(observer);
      observersForIRequestMutList[id] = obsies;
    }

    public void RemoveIRequestMutListObserver(int id, IIRequestMutListEffectObserver observer) {
      if (observersForIRequestMutList.ContainsKey(id)) {
        var list = observersForIRequestMutList[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForIRequestMutList.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }

  public void BroadcastIRequestMutListEffects(
      SortedDictionary<int, List<IIRequestMutListEffectObserver>> observers) {
    foreach (var effect in effectsIRequestMutListDeleteEffect) {
      if (observers.TryGetValue(0, out List<IIRequestMutListEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnIRequestMutListEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IIRequestMutListEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnIRequestMutListEffect(effect);
        }
        observersForIRequestMutList.Remove(effect.id);
      }
    }
    effectsIRequestMutListDeleteEffect.Clear();

    foreach (var effect in effectsIRequestMutListAddEffect) {
      if (observers.TryGetValue(0, out List<IIRequestMutListEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnIRequestMutListEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IIRequestMutListEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnIRequestMutListEffect(effect);
        }
      }
    }
    effectsIRequestMutListAddEffect.Clear();

    foreach (var effect in effectsIRequestMutListRemoveEffect) {
      if (observers.TryGetValue(0, out List<IIRequestMutListEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnIRequestMutListEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IIRequestMutListEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnIRequestMutListEffect(effect);
        }
      }
    }
    effectsIRequestMutListRemoveEffect.Clear();

    foreach (var effect in effectsIRequestMutListCreateEffect) {
      if (observers.TryGetValue(0, out List<IIRequestMutListEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnIRequestMutListEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IIRequestMutListEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnIRequestMutListEffect(effect);
        }
      }
    }
    effectsIRequestMutListCreateEffect.Clear();

  }

    public int GetLevelMutSetHash(int id, int version, LevelMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public LevelMutSetIncarnation GetLevelMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsLevelMutSet[id].incarnation;
    }
    public LevelMutSet GetLevelMutSet(int id) {
      return new LevelMutSet(this, id);
    }
    public List<LevelMutSet> AllLevelMutSet() {
      List<LevelMutSet> result = new List<LevelMutSet>(rootIncarnation.incarnationsLevelMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsLevelMutSet.Keys) {
        result.Add(new LevelMutSet(this, id));
      }
      return result;
    }
    public bool LevelMutSetExists(int id) {
      return rootIncarnation.incarnationsLevelMutSet.ContainsKey(id);
    }
    public void CheckHasLevelMutSet(LevelMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasLevelMutSet(thing.id);
    }
    public void CheckHasLevelMutSet(int id) {
      if (!rootIncarnation.incarnationsLevelMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid LevelMutSet}: " + id);
      }
    }
    public LevelMutSet EffectLevelMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new LevelMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateLevelMutSet(id, rootIncarnation.version, incarnation);
      return new LevelMutSet(this, id);
    }
    public void EffectInternalCreateLevelMutSet(int id, int incarnationVersion, LevelMutSetIncarnation incarnation) {
      var effect = new LevelMutSetCreateEffect(id);
      rootIncarnation.incarnationsLevelMutSet
          .Add(
              id,
              new VersionAndIncarnation<LevelMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsLevelMutSetCreateEffect.Add(effect);
    }
    public void EffectLevelMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new LevelMutSetDeleteEffect(id);
      effectsLevelMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsLevelMutSet[id];
      rootIncarnation.incarnationsLevelMutSet.Remove(id);
    }

       
    public void EffectLevelMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasLevelMutSet(setId);
      CheckHasLevel(elementId);

      var effect = new LevelMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsLevelMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new LevelMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLevelMutSet[setId] =
            new VersionAndIncarnation<LevelMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsLevelMutSetAddEffect.Add(effect);
    }
    public void EffectLevelMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasLevelMutSet(setId);
      CheckHasLevel(elementId);

      var effect = new LevelMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsLevelMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new LevelMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLevelMutSet[setId] =
            new VersionAndIncarnation<LevelMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsLevelMutSetRemoveEffect.Add(effect);
    }

       
    public void AddLevelMutSetObserver(int id, ILevelMutSetEffectObserver observer) {
      List<ILevelMutSetEffectObserver> obsies;
      if (!observersForLevelMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<ILevelMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForLevelMutSet[id] = obsies;
    }

    public void RemoveLevelMutSetObserver(int id, ILevelMutSetEffectObserver observer) {
      if (observersForLevelMutSet.ContainsKey(id)) {
        var list = observersForLevelMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForLevelMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastLevelMutSetEffects(
      SortedDictionary<int, List<ILevelMutSetEffectObserver>> observers) {
    foreach (var effect in effectsLevelMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<ILevelMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnLevelMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ILevelMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnLevelMutSetEffect(effect);
        }
        observersForLevelMutSet.Remove(effect.id);
      }
    }
    effectsLevelMutSetDeleteEffect.Clear();

    foreach (var effect in effectsLevelMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<ILevelMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnLevelMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ILevelMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnLevelMutSetEffect(effect);
        }
      }
    }
    effectsLevelMutSetAddEffect.Clear();

    foreach (var effect in effectsLevelMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<ILevelMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnLevelMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ILevelMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnLevelMutSetEffect(effect);
        }
      }
    }
    effectsLevelMutSetRemoveEffect.Clear();

    foreach (var effect in effectsLevelMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<ILevelMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnLevelMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ILevelMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnLevelMutSetEffect(effect);
        }
      }
    }
    effectsLevelMutSetCreateEffect.Clear();

  }

    public int GetCounteringUCWeakMutSetHash(int id, int version, CounteringUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CounteringUCWeakMutSetIncarnation GetCounteringUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsCounteringUCWeakMutSet[id].incarnation;
    }
    public CounteringUCWeakMutSet GetCounteringUCWeakMutSet(int id) {
      return new CounteringUCWeakMutSet(this, id);
    }
    public List<CounteringUCWeakMutSet> AllCounteringUCWeakMutSet() {
      List<CounteringUCWeakMutSet> result = new List<CounteringUCWeakMutSet>(rootIncarnation.incarnationsCounteringUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsCounteringUCWeakMutSet.Keys) {
        result.Add(new CounteringUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool CounteringUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsCounteringUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasCounteringUCWeakMutSet(CounteringUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCounteringUCWeakMutSet(thing.id);
    }
    public void CheckHasCounteringUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsCounteringUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid CounteringUCWeakMutSet}: " + id);
      }
    }
    public CounteringUCWeakMutSet EffectCounteringUCWeakMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new CounteringUCWeakMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateCounteringUCWeakMutSet(id, rootIncarnation.version, incarnation);
      return new CounteringUCWeakMutSet(this, id);
    }
    public void EffectInternalCreateCounteringUCWeakMutSet(int id, int incarnationVersion, CounteringUCWeakMutSetIncarnation incarnation) {
      var effect = new CounteringUCWeakMutSetCreateEffect(id);
      rootIncarnation.incarnationsCounteringUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<CounteringUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsCounteringUCWeakMutSetCreateEffect.Add(effect);
    }
    public void EffectCounteringUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new CounteringUCWeakMutSetDeleteEffect(id);
      effectsCounteringUCWeakMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsCounteringUCWeakMutSet[id];
      rootIncarnation.incarnationsCounteringUCWeakMutSet.Remove(id);
    }

       
    public void EffectCounteringUCWeakMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasCounteringUCWeakMutSet(setId);
      CheckHasCounteringUC(elementId);

      var effect = new CounteringUCWeakMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCounteringUCWeakMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new CounteringUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCounteringUCWeakMutSet[setId] =
            new VersionAndIncarnation<CounteringUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsCounteringUCWeakMutSetAddEffect.Add(effect);
    }
    public void EffectCounteringUCWeakMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasCounteringUCWeakMutSet(setId);
      CheckHasCounteringUC(elementId);

      var effect = new CounteringUCWeakMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCounteringUCWeakMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new CounteringUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCounteringUCWeakMutSet[setId] =
            new VersionAndIncarnation<CounteringUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsCounteringUCWeakMutSetRemoveEffect.Add(effect);
    }

       
    public void AddCounteringUCWeakMutSetObserver(int id, ICounteringUCWeakMutSetEffectObserver observer) {
      List<ICounteringUCWeakMutSetEffectObserver> obsies;
      if (!observersForCounteringUCWeakMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<ICounteringUCWeakMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForCounteringUCWeakMutSet[id] = obsies;
    }

    public void RemoveCounteringUCWeakMutSetObserver(int id, ICounteringUCWeakMutSetEffectObserver observer) {
      if (observersForCounteringUCWeakMutSet.ContainsKey(id)) {
        var list = observersForCounteringUCWeakMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForCounteringUCWeakMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastCounteringUCWeakMutSetEffects(
      SortedDictionary<int, List<ICounteringUCWeakMutSetEffectObserver>> observers) {
    foreach (var effect in effectsCounteringUCWeakMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<ICounteringUCWeakMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCounteringUCWeakMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICounteringUCWeakMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCounteringUCWeakMutSetEffect(effect);
        }
        observersForCounteringUCWeakMutSet.Remove(effect.id);
      }
    }
    effectsCounteringUCWeakMutSetDeleteEffect.Clear();

    foreach (var effect in effectsCounteringUCWeakMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<ICounteringUCWeakMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCounteringUCWeakMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICounteringUCWeakMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCounteringUCWeakMutSetEffect(effect);
        }
      }
    }
    effectsCounteringUCWeakMutSetAddEffect.Clear();

    foreach (var effect in effectsCounteringUCWeakMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<ICounteringUCWeakMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCounteringUCWeakMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICounteringUCWeakMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCounteringUCWeakMutSetEffect(effect);
        }
      }
    }
    effectsCounteringUCWeakMutSetRemoveEffect.Clear();

    foreach (var effect in effectsCounteringUCWeakMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<ICounteringUCWeakMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCounteringUCWeakMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICounteringUCWeakMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCounteringUCWeakMutSetEffect(effect);
        }
      }
    }
    effectsCounteringUCWeakMutSetCreateEffect.Clear();

  }

    public int GetShieldingUCWeakMutSetHash(int id, int version, ShieldingUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ShieldingUCWeakMutSetIncarnation GetShieldingUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsShieldingUCWeakMutSet[id].incarnation;
    }
    public ShieldingUCWeakMutSet GetShieldingUCWeakMutSet(int id) {
      return new ShieldingUCWeakMutSet(this, id);
    }
    public List<ShieldingUCWeakMutSet> AllShieldingUCWeakMutSet() {
      List<ShieldingUCWeakMutSet> result = new List<ShieldingUCWeakMutSet>(rootIncarnation.incarnationsShieldingUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsShieldingUCWeakMutSet.Keys) {
        result.Add(new ShieldingUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool ShieldingUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsShieldingUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasShieldingUCWeakMutSet(ShieldingUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasShieldingUCWeakMutSet(thing.id);
    }
    public void CheckHasShieldingUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsShieldingUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ShieldingUCWeakMutSet}: " + id);
      }
    }
    public ShieldingUCWeakMutSet EffectShieldingUCWeakMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new ShieldingUCWeakMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateShieldingUCWeakMutSet(id, rootIncarnation.version, incarnation);
      return new ShieldingUCWeakMutSet(this, id);
    }
    public void EffectInternalCreateShieldingUCWeakMutSet(int id, int incarnationVersion, ShieldingUCWeakMutSetIncarnation incarnation) {
      var effect = new ShieldingUCWeakMutSetCreateEffect(id);
      rootIncarnation.incarnationsShieldingUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<ShieldingUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsShieldingUCWeakMutSetCreateEffect.Add(effect);
    }
    public void EffectShieldingUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new ShieldingUCWeakMutSetDeleteEffect(id);
      effectsShieldingUCWeakMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsShieldingUCWeakMutSet[id];
      rootIncarnation.incarnationsShieldingUCWeakMutSet.Remove(id);
    }

       
    public void EffectShieldingUCWeakMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasShieldingUCWeakMutSet(setId);
      CheckHasShieldingUC(elementId);

      var effect = new ShieldingUCWeakMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsShieldingUCWeakMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new ShieldingUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsShieldingUCWeakMutSet[setId] =
            new VersionAndIncarnation<ShieldingUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsShieldingUCWeakMutSetAddEffect.Add(effect);
    }
    public void EffectShieldingUCWeakMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasShieldingUCWeakMutSet(setId);
      CheckHasShieldingUC(elementId);

      var effect = new ShieldingUCWeakMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsShieldingUCWeakMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ShieldingUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsShieldingUCWeakMutSet[setId] =
            new VersionAndIncarnation<ShieldingUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsShieldingUCWeakMutSetRemoveEffect.Add(effect);
    }

       
    public void AddShieldingUCWeakMutSetObserver(int id, IShieldingUCWeakMutSetEffectObserver observer) {
      List<IShieldingUCWeakMutSetEffectObserver> obsies;
      if (!observersForShieldingUCWeakMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IShieldingUCWeakMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForShieldingUCWeakMutSet[id] = obsies;
    }

    public void RemoveShieldingUCWeakMutSetObserver(int id, IShieldingUCWeakMutSetEffectObserver observer) {
      if (observersForShieldingUCWeakMutSet.ContainsKey(id)) {
        var list = observersForShieldingUCWeakMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForShieldingUCWeakMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastShieldingUCWeakMutSetEffects(
      SortedDictionary<int, List<IShieldingUCWeakMutSetEffectObserver>> observers) {
    foreach (var effect in effectsShieldingUCWeakMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IShieldingUCWeakMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnShieldingUCWeakMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IShieldingUCWeakMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnShieldingUCWeakMutSetEffect(effect);
        }
        observersForShieldingUCWeakMutSet.Remove(effect.id);
      }
    }
    effectsShieldingUCWeakMutSetDeleteEffect.Clear();

    foreach (var effect in effectsShieldingUCWeakMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IShieldingUCWeakMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnShieldingUCWeakMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IShieldingUCWeakMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnShieldingUCWeakMutSetEffect(effect);
        }
      }
    }
    effectsShieldingUCWeakMutSetAddEffect.Clear();

    foreach (var effect in effectsShieldingUCWeakMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IShieldingUCWeakMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnShieldingUCWeakMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IShieldingUCWeakMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnShieldingUCWeakMutSetEffect(effect);
        }
      }
    }
    effectsShieldingUCWeakMutSetRemoveEffect.Clear();

    foreach (var effect in effectsShieldingUCWeakMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IShieldingUCWeakMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnShieldingUCWeakMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IShieldingUCWeakMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnShieldingUCWeakMutSetEffect(effect);
        }
      }
    }
    effectsShieldingUCWeakMutSetCreateEffect.Clear();

  }

    public int GetAttackAICapabilityUCWeakMutSetHash(int id, int version, AttackAICapabilityUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public AttackAICapabilityUCWeakMutSetIncarnation GetAttackAICapabilityUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[id].incarnation;
    }
    public AttackAICapabilityUCWeakMutSet GetAttackAICapabilityUCWeakMutSet(int id) {
      return new AttackAICapabilityUCWeakMutSet(this, id);
    }
    public List<AttackAICapabilityUCWeakMutSet> AllAttackAICapabilityUCWeakMutSet() {
      List<AttackAICapabilityUCWeakMutSet> result = new List<AttackAICapabilityUCWeakMutSet>(rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.Keys) {
        result.Add(new AttackAICapabilityUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool AttackAICapabilityUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasAttackAICapabilityUCWeakMutSet(AttackAICapabilityUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasAttackAICapabilityUCWeakMutSet(thing.id);
    }
    public void CheckHasAttackAICapabilityUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid AttackAICapabilityUCWeakMutSet}: " + id);
      }
    }
    public AttackAICapabilityUCWeakMutSet EffectAttackAICapabilityUCWeakMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new AttackAICapabilityUCWeakMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateAttackAICapabilityUCWeakMutSet(id, rootIncarnation.version, incarnation);
      return new AttackAICapabilityUCWeakMutSet(this, id);
    }
    public void EffectInternalCreateAttackAICapabilityUCWeakMutSet(int id, int incarnationVersion, AttackAICapabilityUCWeakMutSetIncarnation incarnation) {
      var effect = new AttackAICapabilityUCWeakMutSetCreateEffect(id);
      rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<AttackAICapabilityUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsAttackAICapabilityUCWeakMutSetCreateEffect.Add(effect);
    }
    public void EffectAttackAICapabilityUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new AttackAICapabilityUCWeakMutSetDeleteEffect(id);
      effectsAttackAICapabilityUCWeakMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[id];
      rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.Remove(id);
    }

       
    public void EffectAttackAICapabilityUCWeakMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasAttackAICapabilityUCWeakMutSet(setId);
      CheckHasAttackAICapabilityUC(elementId);

      var effect = new AttackAICapabilityUCWeakMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new AttackAICapabilityUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[setId] =
            new VersionAndIncarnation<AttackAICapabilityUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsAttackAICapabilityUCWeakMutSetAddEffect.Add(effect);
    }
    public void EffectAttackAICapabilityUCWeakMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasAttackAICapabilityUCWeakMutSet(setId);
      CheckHasAttackAICapabilityUC(elementId);

      var effect = new AttackAICapabilityUCWeakMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new AttackAICapabilityUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[setId] =
            new VersionAndIncarnation<AttackAICapabilityUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsAttackAICapabilityUCWeakMutSetRemoveEffect.Add(effect);
    }

       
    public void AddAttackAICapabilityUCWeakMutSetObserver(int id, IAttackAICapabilityUCWeakMutSetEffectObserver observer) {
      List<IAttackAICapabilityUCWeakMutSetEffectObserver> obsies;
      if (!observersForAttackAICapabilityUCWeakMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IAttackAICapabilityUCWeakMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForAttackAICapabilityUCWeakMutSet[id] = obsies;
    }

    public void RemoveAttackAICapabilityUCWeakMutSetObserver(int id, IAttackAICapabilityUCWeakMutSetEffectObserver observer) {
      if (observersForAttackAICapabilityUCWeakMutSet.ContainsKey(id)) {
        var list = observersForAttackAICapabilityUCWeakMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForAttackAICapabilityUCWeakMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastAttackAICapabilityUCWeakMutSetEffects(
      SortedDictionary<int, List<IAttackAICapabilityUCWeakMutSetEffectObserver>> observers) {
    foreach (var effect in effectsAttackAICapabilityUCWeakMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IAttackAICapabilityUCWeakMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnAttackAICapabilityUCWeakMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IAttackAICapabilityUCWeakMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnAttackAICapabilityUCWeakMutSetEffect(effect);
        }
        observersForAttackAICapabilityUCWeakMutSet.Remove(effect.id);
      }
    }
    effectsAttackAICapabilityUCWeakMutSetDeleteEffect.Clear();

    foreach (var effect in effectsAttackAICapabilityUCWeakMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IAttackAICapabilityUCWeakMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnAttackAICapabilityUCWeakMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IAttackAICapabilityUCWeakMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnAttackAICapabilityUCWeakMutSetEffect(effect);
        }
      }
    }
    effectsAttackAICapabilityUCWeakMutSetAddEffect.Clear();

    foreach (var effect in effectsAttackAICapabilityUCWeakMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IAttackAICapabilityUCWeakMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnAttackAICapabilityUCWeakMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IAttackAICapabilityUCWeakMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnAttackAICapabilityUCWeakMutSetEffect(effect);
        }
      }
    }
    effectsAttackAICapabilityUCWeakMutSetRemoveEffect.Clear();

    foreach (var effect in effectsAttackAICapabilityUCWeakMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IAttackAICapabilityUCWeakMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnAttackAICapabilityUCWeakMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IAttackAICapabilityUCWeakMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnAttackAICapabilityUCWeakMutSetEffect(effect);
        }
      }
    }
    effectsAttackAICapabilityUCWeakMutSetCreateEffect.Clear();

  }

    public int GetTimeCloneAICapabilityUCWeakMutSetHash(int id, int version, TimeCloneAICapabilityUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public TimeCloneAICapabilityUCWeakMutSetIncarnation GetTimeCloneAICapabilityUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[id].incarnation;
    }
    public TimeCloneAICapabilityUCWeakMutSet GetTimeCloneAICapabilityUCWeakMutSet(int id) {
      return new TimeCloneAICapabilityUCWeakMutSet(this, id);
    }
    public List<TimeCloneAICapabilityUCWeakMutSet> AllTimeCloneAICapabilityUCWeakMutSet() {
      List<TimeCloneAICapabilityUCWeakMutSet> result = new List<TimeCloneAICapabilityUCWeakMutSet>(rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.Keys) {
        result.Add(new TimeCloneAICapabilityUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool TimeCloneAICapabilityUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasTimeCloneAICapabilityUCWeakMutSet(TimeCloneAICapabilityUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasTimeCloneAICapabilityUCWeakMutSet(thing.id);
    }
    public void CheckHasTimeCloneAICapabilityUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid TimeCloneAICapabilityUCWeakMutSet}: " + id);
      }
    }
    public TimeCloneAICapabilityUCWeakMutSet EffectTimeCloneAICapabilityUCWeakMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new TimeCloneAICapabilityUCWeakMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateTimeCloneAICapabilityUCWeakMutSet(id, rootIncarnation.version, incarnation);
      return new TimeCloneAICapabilityUCWeakMutSet(this, id);
    }
    public void EffectInternalCreateTimeCloneAICapabilityUCWeakMutSet(int id, int incarnationVersion, TimeCloneAICapabilityUCWeakMutSetIncarnation incarnation) {
      var effect = new TimeCloneAICapabilityUCWeakMutSetCreateEffect(id);
      rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<TimeCloneAICapabilityUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsTimeCloneAICapabilityUCWeakMutSetCreateEffect.Add(effect);
    }
    public void EffectTimeCloneAICapabilityUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new TimeCloneAICapabilityUCWeakMutSetDeleteEffect(id);
      effectsTimeCloneAICapabilityUCWeakMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[id];
      rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.Remove(id);
    }

       
    public void EffectTimeCloneAICapabilityUCWeakMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasTimeCloneAICapabilityUCWeakMutSet(setId);
      CheckHasTimeCloneAICapabilityUC(elementId);

      var effect = new TimeCloneAICapabilityUCWeakMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new TimeCloneAICapabilityUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[setId] =
            new VersionAndIncarnation<TimeCloneAICapabilityUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsTimeCloneAICapabilityUCWeakMutSetAddEffect.Add(effect);
    }
    public void EffectTimeCloneAICapabilityUCWeakMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasTimeCloneAICapabilityUCWeakMutSet(setId);
      CheckHasTimeCloneAICapabilityUC(elementId);

      var effect = new TimeCloneAICapabilityUCWeakMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new TimeCloneAICapabilityUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[setId] =
            new VersionAndIncarnation<TimeCloneAICapabilityUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsTimeCloneAICapabilityUCWeakMutSetRemoveEffect.Add(effect);
    }

       
    public void AddTimeCloneAICapabilityUCWeakMutSetObserver(int id, ITimeCloneAICapabilityUCWeakMutSetEffectObserver observer) {
      List<ITimeCloneAICapabilityUCWeakMutSetEffectObserver> obsies;
      if (!observersForTimeCloneAICapabilityUCWeakMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<ITimeCloneAICapabilityUCWeakMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForTimeCloneAICapabilityUCWeakMutSet[id] = obsies;
    }

    public void RemoveTimeCloneAICapabilityUCWeakMutSetObserver(int id, ITimeCloneAICapabilityUCWeakMutSetEffectObserver observer) {
      if (observersForTimeCloneAICapabilityUCWeakMutSet.ContainsKey(id)) {
        var list = observersForTimeCloneAICapabilityUCWeakMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForTimeCloneAICapabilityUCWeakMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastTimeCloneAICapabilityUCWeakMutSetEffects(
      SortedDictionary<int, List<ITimeCloneAICapabilityUCWeakMutSetEffectObserver>> observers) {
    foreach (var effect in effectsTimeCloneAICapabilityUCWeakMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<ITimeCloneAICapabilityUCWeakMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTimeCloneAICapabilityUCWeakMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITimeCloneAICapabilityUCWeakMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTimeCloneAICapabilityUCWeakMutSetEffect(effect);
        }
        observersForTimeCloneAICapabilityUCWeakMutSet.Remove(effect.id);
      }
    }
    effectsTimeCloneAICapabilityUCWeakMutSetDeleteEffect.Clear();

    foreach (var effect in effectsTimeCloneAICapabilityUCWeakMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<ITimeCloneAICapabilityUCWeakMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTimeCloneAICapabilityUCWeakMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITimeCloneAICapabilityUCWeakMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTimeCloneAICapabilityUCWeakMutSetEffect(effect);
        }
      }
    }
    effectsTimeCloneAICapabilityUCWeakMutSetAddEffect.Clear();

    foreach (var effect in effectsTimeCloneAICapabilityUCWeakMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<ITimeCloneAICapabilityUCWeakMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTimeCloneAICapabilityUCWeakMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITimeCloneAICapabilityUCWeakMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTimeCloneAICapabilityUCWeakMutSetEffect(effect);
        }
      }
    }
    effectsTimeCloneAICapabilityUCWeakMutSetRemoveEffect.Clear();

    foreach (var effect in effectsTimeCloneAICapabilityUCWeakMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<ITimeCloneAICapabilityUCWeakMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTimeCloneAICapabilityUCWeakMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITimeCloneAICapabilityUCWeakMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTimeCloneAICapabilityUCWeakMutSetEffect(effect);
        }
      }
    }
    effectsTimeCloneAICapabilityUCWeakMutSetCreateEffect.Clear();

  }

    public int GetArmorMutSetHash(int id, int version, ArmorMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ArmorMutSetIncarnation GetArmorMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsArmorMutSet[id].incarnation;
    }
    public ArmorMutSet GetArmorMutSet(int id) {
      return new ArmorMutSet(this, id);
    }
    public List<ArmorMutSet> AllArmorMutSet() {
      List<ArmorMutSet> result = new List<ArmorMutSet>(rootIncarnation.incarnationsArmorMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsArmorMutSet.Keys) {
        result.Add(new ArmorMutSet(this, id));
      }
      return result;
    }
    public bool ArmorMutSetExists(int id) {
      return rootIncarnation.incarnationsArmorMutSet.ContainsKey(id);
    }
    public void CheckHasArmorMutSet(ArmorMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasArmorMutSet(thing.id);
    }
    public void CheckHasArmorMutSet(int id) {
      if (!rootIncarnation.incarnationsArmorMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ArmorMutSet}: " + id);
      }
    }
    public ArmorMutSet EffectArmorMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new ArmorMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateArmorMutSet(id, rootIncarnation.version, incarnation);
      return new ArmorMutSet(this, id);
    }
    public void EffectInternalCreateArmorMutSet(int id, int incarnationVersion, ArmorMutSetIncarnation incarnation) {
      var effect = new ArmorMutSetCreateEffect(id);
      rootIncarnation.incarnationsArmorMutSet
          .Add(
              id,
              new VersionAndIncarnation<ArmorMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsArmorMutSetCreateEffect.Add(effect);
    }
    public void EffectArmorMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new ArmorMutSetDeleteEffect(id);
      effectsArmorMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsArmorMutSet[id];
      rootIncarnation.incarnationsArmorMutSet.Remove(id);
    }

       
    public void EffectArmorMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasArmorMutSet(setId);
      CheckHasArmor(elementId);

      var effect = new ArmorMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsArmorMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new ArmorMutSetIncarnation(newMap);
        rootIncarnation.incarnationsArmorMutSet[setId] =
            new VersionAndIncarnation<ArmorMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsArmorMutSetAddEffect.Add(effect);
    }
    public void EffectArmorMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasArmorMutSet(setId);
      CheckHasArmor(elementId);

      var effect = new ArmorMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsArmorMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ArmorMutSetIncarnation(newMap);
        rootIncarnation.incarnationsArmorMutSet[setId] =
            new VersionAndIncarnation<ArmorMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsArmorMutSetRemoveEffect.Add(effect);
    }

       
    public void AddArmorMutSetObserver(int id, IArmorMutSetEffectObserver observer) {
      List<IArmorMutSetEffectObserver> obsies;
      if (!observersForArmorMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IArmorMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForArmorMutSet[id] = obsies;
    }

    public void RemoveArmorMutSetObserver(int id, IArmorMutSetEffectObserver observer) {
      if (observersForArmorMutSet.ContainsKey(id)) {
        var list = observersForArmorMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForArmorMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastArmorMutSetEffects(
      SortedDictionary<int, List<IArmorMutSetEffectObserver>> observers) {
    foreach (var effect in effectsArmorMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IArmorMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnArmorMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IArmorMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnArmorMutSetEffect(effect);
        }
        observersForArmorMutSet.Remove(effect.id);
      }
    }
    effectsArmorMutSetDeleteEffect.Clear();

    foreach (var effect in effectsArmorMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IArmorMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnArmorMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IArmorMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnArmorMutSetEffect(effect);
        }
      }
    }
    effectsArmorMutSetAddEffect.Clear();

    foreach (var effect in effectsArmorMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IArmorMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnArmorMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IArmorMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnArmorMutSetEffect(effect);
        }
      }
    }
    effectsArmorMutSetRemoveEffect.Clear();

    foreach (var effect in effectsArmorMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IArmorMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnArmorMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IArmorMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnArmorMutSetEffect(effect);
        }
      }
    }
    effectsArmorMutSetCreateEffect.Clear();

  }

    public int GetInertiaRingMutSetHash(int id, int version, InertiaRingMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public InertiaRingMutSetIncarnation GetInertiaRingMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsInertiaRingMutSet[id].incarnation;
    }
    public InertiaRingMutSet GetInertiaRingMutSet(int id) {
      return new InertiaRingMutSet(this, id);
    }
    public List<InertiaRingMutSet> AllInertiaRingMutSet() {
      List<InertiaRingMutSet> result = new List<InertiaRingMutSet>(rootIncarnation.incarnationsInertiaRingMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsInertiaRingMutSet.Keys) {
        result.Add(new InertiaRingMutSet(this, id));
      }
      return result;
    }
    public bool InertiaRingMutSetExists(int id) {
      return rootIncarnation.incarnationsInertiaRingMutSet.ContainsKey(id);
    }
    public void CheckHasInertiaRingMutSet(InertiaRingMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasInertiaRingMutSet(thing.id);
    }
    public void CheckHasInertiaRingMutSet(int id) {
      if (!rootIncarnation.incarnationsInertiaRingMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid InertiaRingMutSet}: " + id);
      }
    }
    public InertiaRingMutSet EffectInertiaRingMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new InertiaRingMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateInertiaRingMutSet(id, rootIncarnation.version, incarnation);
      return new InertiaRingMutSet(this, id);
    }
    public void EffectInternalCreateInertiaRingMutSet(int id, int incarnationVersion, InertiaRingMutSetIncarnation incarnation) {
      var effect = new InertiaRingMutSetCreateEffect(id);
      rootIncarnation.incarnationsInertiaRingMutSet
          .Add(
              id,
              new VersionAndIncarnation<InertiaRingMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsInertiaRingMutSetCreateEffect.Add(effect);
    }
    public void EffectInertiaRingMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new InertiaRingMutSetDeleteEffect(id);
      effectsInertiaRingMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsInertiaRingMutSet[id];
      rootIncarnation.incarnationsInertiaRingMutSet.Remove(id);
    }

       
    public void EffectInertiaRingMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasInertiaRingMutSet(setId);
      CheckHasInertiaRing(elementId);

      var effect = new InertiaRingMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsInertiaRingMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new InertiaRingMutSetIncarnation(newMap);
        rootIncarnation.incarnationsInertiaRingMutSet[setId] =
            new VersionAndIncarnation<InertiaRingMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsInertiaRingMutSetAddEffect.Add(effect);
    }
    public void EffectInertiaRingMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasInertiaRingMutSet(setId);
      CheckHasInertiaRing(elementId);

      var effect = new InertiaRingMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsInertiaRingMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new InertiaRingMutSetIncarnation(newMap);
        rootIncarnation.incarnationsInertiaRingMutSet[setId] =
            new VersionAndIncarnation<InertiaRingMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsInertiaRingMutSetRemoveEffect.Add(effect);
    }

       
    public void AddInertiaRingMutSetObserver(int id, IInertiaRingMutSetEffectObserver observer) {
      List<IInertiaRingMutSetEffectObserver> obsies;
      if (!observersForInertiaRingMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IInertiaRingMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForInertiaRingMutSet[id] = obsies;
    }

    public void RemoveInertiaRingMutSetObserver(int id, IInertiaRingMutSetEffectObserver observer) {
      if (observersForInertiaRingMutSet.ContainsKey(id)) {
        var list = observersForInertiaRingMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForInertiaRingMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastInertiaRingMutSetEffects(
      SortedDictionary<int, List<IInertiaRingMutSetEffectObserver>> observers) {
    foreach (var effect in effectsInertiaRingMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IInertiaRingMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnInertiaRingMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IInertiaRingMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnInertiaRingMutSetEffect(effect);
        }
        observersForInertiaRingMutSet.Remove(effect.id);
      }
    }
    effectsInertiaRingMutSetDeleteEffect.Clear();

    foreach (var effect in effectsInertiaRingMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IInertiaRingMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnInertiaRingMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IInertiaRingMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnInertiaRingMutSetEffect(effect);
        }
      }
    }
    effectsInertiaRingMutSetAddEffect.Clear();

    foreach (var effect in effectsInertiaRingMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IInertiaRingMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnInertiaRingMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IInertiaRingMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnInertiaRingMutSetEffect(effect);
        }
      }
    }
    effectsInertiaRingMutSetRemoveEffect.Clear();

    foreach (var effect in effectsInertiaRingMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IInertiaRingMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnInertiaRingMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IInertiaRingMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnInertiaRingMutSetEffect(effect);
        }
      }
    }
    effectsInertiaRingMutSetCreateEffect.Clear();

  }

    public int GetGlaiveMutSetHash(int id, int version, GlaiveMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public GlaiveMutSetIncarnation GetGlaiveMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsGlaiveMutSet[id].incarnation;
    }
    public GlaiveMutSet GetGlaiveMutSet(int id) {
      return new GlaiveMutSet(this, id);
    }
    public List<GlaiveMutSet> AllGlaiveMutSet() {
      List<GlaiveMutSet> result = new List<GlaiveMutSet>(rootIncarnation.incarnationsGlaiveMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsGlaiveMutSet.Keys) {
        result.Add(new GlaiveMutSet(this, id));
      }
      return result;
    }
    public bool GlaiveMutSetExists(int id) {
      return rootIncarnation.incarnationsGlaiveMutSet.ContainsKey(id);
    }
    public void CheckHasGlaiveMutSet(GlaiveMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasGlaiveMutSet(thing.id);
    }
    public void CheckHasGlaiveMutSet(int id) {
      if (!rootIncarnation.incarnationsGlaiveMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid GlaiveMutSet}: " + id);
      }
    }
    public GlaiveMutSet EffectGlaiveMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new GlaiveMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateGlaiveMutSet(id, rootIncarnation.version, incarnation);
      return new GlaiveMutSet(this, id);
    }
    public void EffectInternalCreateGlaiveMutSet(int id, int incarnationVersion, GlaiveMutSetIncarnation incarnation) {
      var effect = new GlaiveMutSetCreateEffect(id);
      rootIncarnation.incarnationsGlaiveMutSet
          .Add(
              id,
              new VersionAndIncarnation<GlaiveMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsGlaiveMutSetCreateEffect.Add(effect);
    }
    public void EffectGlaiveMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new GlaiveMutSetDeleteEffect(id);
      effectsGlaiveMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsGlaiveMutSet[id];
      rootIncarnation.incarnationsGlaiveMutSet.Remove(id);
    }

       
    public void EffectGlaiveMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasGlaiveMutSet(setId);
      CheckHasGlaive(elementId);

      var effect = new GlaiveMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsGlaiveMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new GlaiveMutSetIncarnation(newMap);
        rootIncarnation.incarnationsGlaiveMutSet[setId] =
            new VersionAndIncarnation<GlaiveMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsGlaiveMutSetAddEffect.Add(effect);
    }
    public void EffectGlaiveMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasGlaiveMutSet(setId);
      CheckHasGlaive(elementId);

      var effect = new GlaiveMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsGlaiveMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new GlaiveMutSetIncarnation(newMap);
        rootIncarnation.incarnationsGlaiveMutSet[setId] =
            new VersionAndIncarnation<GlaiveMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsGlaiveMutSetRemoveEffect.Add(effect);
    }

       
    public void AddGlaiveMutSetObserver(int id, IGlaiveMutSetEffectObserver observer) {
      List<IGlaiveMutSetEffectObserver> obsies;
      if (!observersForGlaiveMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IGlaiveMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForGlaiveMutSet[id] = obsies;
    }

    public void RemoveGlaiveMutSetObserver(int id, IGlaiveMutSetEffectObserver observer) {
      if (observersForGlaiveMutSet.ContainsKey(id)) {
        var list = observersForGlaiveMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForGlaiveMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastGlaiveMutSetEffects(
      SortedDictionary<int, List<IGlaiveMutSetEffectObserver>> observers) {
    foreach (var effect in effectsGlaiveMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IGlaiveMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnGlaiveMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IGlaiveMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnGlaiveMutSetEffect(effect);
        }
        observersForGlaiveMutSet.Remove(effect.id);
      }
    }
    effectsGlaiveMutSetDeleteEffect.Clear();

    foreach (var effect in effectsGlaiveMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IGlaiveMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnGlaiveMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IGlaiveMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnGlaiveMutSetEffect(effect);
        }
      }
    }
    effectsGlaiveMutSetAddEffect.Clear();

    foreach (var effect in effectsGlaiveMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IGlaiveMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnGlaiveMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IGlaiveMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnGlaiveMutSetEffect(effect);
        }
      }
    }
    effectsGlaiveMutSetRemoveEffect.Clear();

    foreach (var effect in effectsGlaiveMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IGlaiveMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnGlaiveMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IGlaiveMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnGlaiveMutSetEffect(effect);
        }
      }
    }
    effectsGlaiveMutSetCreateEffect.Clear();

  }

    public int GetManaPotionMutSetHash(int id, int version, ManaPotionMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ManaPotionMutSetIncarnation GetManaPotionMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsManaPotionMutSet[id].incarnation;
    }
    public ManaPotionMutSet GetManaPotionMutSet(int id) {
      return new ManaPotionMutSet(this, id);
    }
    public List<ManaPotionMutSet> AllManaPotionMutSet() {
      List<ManaPotionMutSet> result = new List<ManaPotionMutSet>(rootIncarnation.incarnationsManaPotionMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsManaPotionMutSet.Keys) {
        result.Add(new ManaPotionMutSet(this, id));
      }
      return result;
    }
    public bool ManaPotionMutSetExists(int id) {
      return rootIncarnation.incarnationsManaPotionMutSet.ContainsKey(id);
    }
    public void CheckHasManaPotionMutSet(ManaPotionMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasManaPotionMutSet(thing.id);
    }
    public void CheckHasManaPotionMutSet(int id) {
      if (!rootIncarnation.incarnationsManaPotionMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ManaPotionMutSet}: " + id);
      }
    }
    public ManaPotionMutSet EffectManaPotionMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new ManaPotionMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateManaPotionMutSet(id, rootIncarnation.version, incarnation);
      return new ManaPotionMutSet(this, id);
    }
    public void EffectInternalCreateManaPotionMutSet(int id, int incarnationVersion, ManaPotionMutSetIncarnation incarnation) {
      var effect = new ManaPotionMutSetCreateEffect(id);
      rootIncarnation.incarnationsManaPotionMutSet
          .Add(
              id,
              new VersionAndIncarnation<ManaPotionMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsManaPotionMutSetCreateEffect.Add(effect);
    }
    public void EffectManaPotionMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new ManaPotionMutSetDeleteEffect(id);
      effectsManaPotionMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsManaPotionMutSet[id];
      rootIncarnation.incarnationsManaPotionMutSet.Remove(id);
    }

       
    public void EffectManaPotionMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasManaPotionMutSet(setId);
      CheckHasManaPotion(elementId);

      var effect = new ManaPotionMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsManaPotionMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new ManaPotionMutSetIncarnation(newMap);
        rootIncarnation.incarnationsManaPotionMutSet[setId] =
            new VersionAndIncarnation<ManaPotionMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsManaPotionMutSetAddEffect.Add(effect);
    }
    public void EffectManaPotionMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasManaPotionMutSet(setId);
      CheckHasManaPotion(elementId);

      var effect = new ManaPotionMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsManaPotionMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ManaPotionMutSetIncarnation(newMap);
        rootIncarnation.incarnationsManaPotionMutSet[setId] =
            new VersionAndIncarnation<ManaPotionMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsManaPotionMutSetRemoveEffect.Add(effect);
    }

       
    public void AddManaPotionMutSetObserver(int id, IManaPotionMutSetEffectObserver observer) {
      List<IManaPotionMutSetEffectObserver> obsies;
      if (!observersForManaPotionMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IManaPotionMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForManaPotionMutSet[id] = obsies;
    }

    public void RemoveManaPotionMutSetObserver(int id, IManaPotionMutSetEffectObserver observer) {
      if (observersForManaPotionMutSet.ContainsKey(id)) {
        var list = observersForManaPotionMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForManaPotionMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastManaPotionMutSetEffects(
      SortedDictionary<int, List<IManaPotionMutSetEffectObserver>> observers) {
    foreach (var effect in effectsManaPotionMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IManaPotionMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnManaPotionMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IManaPotionMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnManaPotionMutSetEffect(effect);
        }
        observersForManaPotionMutSet.Remove(effect.id);
      }
    }
    effectsManaPotionMutSetDeleteEffect.Clear();

    foreach (var effect in effectsManaPotionMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IManaPotionMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnManaPotionMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IManaPotionMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnManaPotionMutSetEffect(effect);
        }
      }
    }
    effectsManaPotionMutSetAddEffect.Clear();

    foreach (var effect in effectsManaPotionMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IManaPotionMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnManaPotionMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IManaPotionMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnManaPotionMutSetEffect(effect);
        }
      }
    }
    effectsManaPotionMutSetRemoveEffect.Clear();

    foreach (var effect in effectsManaPotionMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IManaPotionMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnManaPotionMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IManaPotionMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnManaPotionMutSetEffect(effect);
        }
      }
    }
    effectsManaPotionMutSetCreateEffect.Clear();

  }

    public int GetHealthPotionMutSetHash(int id, int version, HealthPotionMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public HealthPotionMutSetIncarnation GetHealthPotionMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsHealthPotionMutSet[id].incarnation;
    }
    public HealthPotionMutSet GetHealthPotionMutSet(int id) {
      return new HealthPotionMutSet(this, id);
    }
    public List<HealthPotionMutSet> AllHealthPotionMutSet() {
      List<HealthPotionMutSet> result = new List<HealthPotionMutSet>(rootIncarnation.incarnationsHealthPotionMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsHealthPotionMutSet.Keys) {
        result.Add(new HealthPotionMutSet(this, id));
      }
      return result;
    }
    public bool HealthPotionMutSetExists(int id) {
      return rootIncarnation.incarnationsHealthPotionMutSet.ContainsKey(id);
    }
    public void CheckHasHealthPotionMutSet(HealthPotionMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasHealthPotionMutSet(thing.id);
    }
    public void CheckHasHealthPotionMutSet(int id) {
      if (!rootIncarnation.incarnationsHealthPotionMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid HealthPotionMutSet}: " + id);
      }
    }
    public HealthPotionMutSet EffectHealthPotionMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new HealthPotionMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateHealthPotionMutSet(id, rootIncarnation.version, incarnation);
      return new HealthPotionMutSet(this, id);
    }
    public void EffectInternalCreateHealthPotionMutSet(int id, int incarnationVersion, HealthPotionMutSetIncarnation incarnation) {
      var effect = new HealthPotionMutSetCreateEffect(id);
      rootIncarnation.incarnationsHealthPotionMutSet
          .Add(
              id,
              new VersionAndIncarnation<HealthPotionMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsHealthPotionMutSetCreateEffect.Add(effect);
    }
    public void EffectHealthPotionMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new HealthPotionMutSetDeleteEffect(id);
      effectsHealthPotionMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsHealthPotionMutSet[id];
      rootIncarnation.incarnationsHealthPotionMutSet.Remove(id);
    }

       
    public void EffectHealthPotionMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasHealthPotionMutSet(setId);
      CheckHasHealthPotion(elementId);

      var effect = new HealthPotionMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsHealthPotionMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new HealthPotionMutSetIncarnation(newMap);
        rootIncarnation.incarnationsHealthPotionMutSet[setId] =
            new VersionAndIncarnation<HealthPotionMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsHealthPotionMutSetAddEffect.Add(effect);
    }
    public void EffectHealthPotionMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasHealthPotionMutSet(setId);
      CheckHasHealthPotion(elementId);

      var effect = new HealthPotionMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsHealthPotionMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new HealthPotionMutSetIncarnation(newMap);
        rootIncarnation.incarnationsHealthPotionMutSet[setId] =
            new VersionAndIncarnation<HealthPotionMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsHealthPotionMutSetRemoveEffect.Add(effect);
    }

       
    public void AddHealthPotionMutSetObserver(int id, IHealthPotionMutSetEffectObserver observer) {
      List<IHealthPotionMutSetEffectObserver> obsies;
      if (!observersForHealthPotionMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IHealthPotionMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForHealthPotionMutSet[id] = obsies;
    }

    public void RemoveHealthPotionMutSetObserver(int id, IHealthPotionMutSetEffectObserver observer) {
      if (observersForHealthPotionMutSet.ContainsKey(id)) {
        var list = observersForHealthPotionMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForHealthPotionMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastHealthPotionMutSetEffects(
      SortedDictionary<int, List<IHealthPotionMutSetEffectObserver>> observers) {
    foreach (var effect in effectsHealthPotionMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IHealthPotionMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnHealthPotionMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IHealthPotionMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnHealthPotionMutSetEffect(effect);
        }
        observersForHealthPotionMutSet.Remove(effect.id);
      }
    }
    effectsHealthPotionMutSetDeleteEffect.Clear();

    foreach (var effect in effectsHealthPotionMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IHealthPotionMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnHealthPotionMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IHealthPotionMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnHealthPotionMutSetEffect(effect);
        }
      }
    }
    effectsHealthPotionMutSetAddEffect.Clear();

    foreach (var effect in effectsHealthPotionMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IHealthPotionMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnHealthPotionMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IHealthPotionMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnHealthPotionMutSetEffect(effect);
        }
      }
    }
    effectsHealthPotionMutSetRemoveEffect.Clear();

    foreach (var effect in effectsHealthPotionMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IHealthPotionMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnHealthPotionMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IHealthPotionMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnHealthPotionMutSetEffect(effect);
        }
      }
    }
    effectsHealthPotionMutSetCreateEffect.Clear();

  }

    public int GetWanderAICapabilityUCMutSetHash(int id, int version, WanderAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public WanderAICapabilityUCMutSetIncarnation GetWanderAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsWanderAICapabilityUCMutSet[id].incarnation;
    }
    public WanderAICapabilityUCMutSet GetWanderAICapabilityUCMutSet(int id) {
      return new WanderAICapabilityUCMutSet(this, id);
    }
    public List<WanderAICapabilityUCMutSet> AllWanderAICapabilityUCMutSet() {
      List<WanderAICapabilityUCMutSet> result = new List<WanderAICapabilityUCMutSet>(rootIncarnation.incarnationsWanderAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsWanderAICapabilityUCMutSet.Keys) {
        result.Add(new WanderAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool WanderAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsWanderAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasWanderAICapabilityUCMutSet(WanderAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasWanderAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasWanderAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsWanderAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid WanderAICapabilityUCMutSet}: " + id);
      }
    }
    public WanderAICapabilityUCMutSet EffectWanderAICapabilityUCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new WanderAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateWanderAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      return new WanderAICapabilityUCMutSet(this, id);
    }
    public void EffectInternalCreateWanderAICapabilityUCMutSet(int id, int incarnationVersion, WanderAICapabilityUCMutSetIncarnation incarnation) {
      var effect = new WanderAICapabilityUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsWanderAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<WanderAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsWanderAICapabilityUCMutSetCreateEffect.Add(effect);
    }
    public void EffectWanderAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new WanderAICapabilityUCMutSetDeleteEffect(id);
      effectsWanderAICapabilityUCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsWanderAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsWanderAICapabilityUCMutSet.Remove(id);
    }

       
    public void EffectWanderAICapabilityUCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasWanderAICapabilityUCMutSet(setId);
      CheckHasWanderAICapabilityUC(elementId);

      var effect = new WanderAICapabilityUCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsWanderAICapabilityUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new WanderAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsWanderAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<WanderAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsWanderAICapabilityUCMutSetAddEffect.Add(effect);
    }
    public void EffectWanderAICapabilityUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasWanderAICapabilityUCMutSet(setId);
      CheckHasWanderAICapabilityUC(elementId);

      var effect = new WanderAICapabilityUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsWanderAICapabilityUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new WanderAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsWanderAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<WanderAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsWanderAICapabilityUCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddWanderAICapabilityUCMutSetObserver(int id, IWanderAICapabilityUCMutSetEffectObserver observer) {
      List<IWanderAICapabilityUCMutSetEffectObserver> obsies;
      if (!observersForWanderAICapabilityUCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IWanderAICapabilityUCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForWanderAICapabilityUCMutSet[id] = obsies;
    }

    public void RemoveWanderAICapabilityUCMutSetObserver(int id, IWanderAICapabilityUCMutSetEffectObserver observer) {
      if (observersForWanderAICapabilityUCMutSet.ContainsKey(id)) {
        var list = observersForWanderAICapabilityUCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForWanderAICapabilityUCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastWanderAICapabilityUCMutSetEffects(
      SortedDictionary<int, List<IWanderAICapabilityUCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsWanderAICapabilityUCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IWanderAICapabilityUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnWanderAICapabilityUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IWanderAICapabilityUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnWanderAICapabilityUCMutSetEffect(effect);
        }
        observersForWanderAICapabilityUCMutSet.Remove(effect.id);
      }
    }
    effectsWanderAICapabilityUCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsWanderAICapabilityUCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IWanderAICapabilityUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnWanderAICapabilityUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IWanderAICapabilityUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnWanderAICapabilityUCMutSetEffect(effect);
        }
      }
    }
    effectsWanderAICapabilityUCMutSetAddEffect.Clear();

    foreach (var effect in effectsWanderAICapabilityUCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IWanderAICapabilityUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnWanderAICapabilityUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IWanderAICapabilityUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnWanderAICapabilityUCMutSetEffect(effect);
        }
      }
    }
    effectsWanderAICapabilityUCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsWanderAICapabilityUCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IWanderAICapabilityUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnWanderAICapabilityUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IWanderAICapabilityUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnWanderAICapabilityUCMutSetEffect(effect);
        }
      }
    }
    effectsWanderAICapabilityUCMutSetCreateEffect.Clear();

  }

    public int GetTimeCloneAICapabilityUCMutSetHash(int id, int version, TimeCloneAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public TimeCloneAICapabilityUCMutSetIncarnation GetTimeCloneAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[id].incarnation;
    }
    public TimeCloneAICapabilityUCMutSet GetTimeCloneAICapabilityUCMutSet(int id) {
      return new TimeCloneAICapabilityUCMutSet(this, id);
    }
    public List<TimeCloneAICapabilityUCMutSet> AllTimeCloneAICapabilityUCMutSet() {
      List<TimeCloneAICapabilityUCMutSet> result = new List<TimeCloneAICapabilityUCMutSet>(rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.Keys) {
        result.Add(new TimeCloneAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool TimeCloneAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasTimeCloneAICapabilityUCMutSet(TimeCloneAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasTimeCloneAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasTimeCloneAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid TimeCloneAICapabilityUCMutSet}: " + id);
      }
    }
    public TimeCloneAICapabilityUCMutSet EffectTimeCloneAICapabilityUCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new TimeCloneAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateTimeCloneAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      return new TimeCloneAICapabilityUCMutSet(this, id);
    }
    public void EffectInternalCreateTimeCloneAICapabilityUCMutSet(int id, int incarnationVersion, TimeCloneAICapabilityUCMutSetIncarnation incarnation) {
      var effect = new TimeCloneAICapabilityUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<TimeCloneAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsTimeCloneAICapabilityUCMutSetCreateEffect.Add(effect);
    }
    public void EffectTimeCloneAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new TimeCloneAICapabilityUCMutSetDeleteEffect(id);
      effectsTimeCloneAICapabilityUCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.Remove(id);
    }

       
    public void EffectTimeCloneAICapabilityUCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasTimeCloneAICapabilityUCMutSet(setId);
      CheckHasTimeCloneAICapabilityUC(elementId);

      var effect = new TimeCloneAICapabilityUCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new TimeCloneAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<TimeCloneAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsTimeCloneAICapabilityUCMutSetAddEffect.Add(effect);
    }
    public void EffectTimeCloneAICapabilityUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasTimeCloneAICapabilityUCMutSet(setId);
      CheckHasTimeCloneAICapabilityUC(elementId);

      var effect = new TimeCloneAICapabilityUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new TimeCloneAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<TimeCloneAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsTimeCloneAICapabilityUCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddTimeCloneAICapabilityUCMutSetObserver(int id, ITimeCloneAICapabilityUCMutSetEffectObserver observer) {
      List<ITimeCloneAICapabilityUCMutSetEffectObserver> obsies;
      if (!observersForTimeCloneAICapabilityUCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<ITimeCloneAICapabilityUCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForTimeCloneAICapabilityUCMutSet[id] = obsies;
    }

    public void RemoveTimeCloneAICapabilityUCMutSetObserver(int id, ITimeCloneAICapabilityUCMutSetEffectObserver observer) {
      if (observersForTimeCloneAICapabilityUCMutSet.ContainsKey(id)) {
        var list = observersForTimeCloneAICapabilityUCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForTimeCloneAICapabilityUCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastTimeCloneAICapabilityUCMutSetEffects(
      SortedDictionary<int, List<ITimeCloneAICapabilityUCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsTimeCloneAICapabilityUCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<ITimeCloneAICapabilityUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTimeCloneAICapabilityUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITimeCloneAICapabilityUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTimeCloneAICapabilityUCMutSetEffect(effect);
        }
        observersForTimeCloneAICapabilityUCMutSet.Remove(effect.id);
      }
    }
    effectsTimeCloneAICapabilityUCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsTimeCloneAICapabilityUCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<ITimeCloneAICapabilityUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTimeCloneAICapabilityUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITimeCloneAICapabilityUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTimeCloneAICapabilityUCMutSetEffect(effect);
        }
      }
    }
    effectsTimeCloneAICapabilityUCMutSetAddEffect.Clear();

    foreach (var effect in effectsTimeCloneAICapabilityUCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<ITimeCloneAICapabilityUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTimeCloneAICapabilityUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITimeCloneAICapabilityUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTimeCloneAICapabilityUCMutSetEffect(effect);
        }
      }
    }
    effectsTimeCloneAICapabilityUCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsTimeCloneAICapabilityUCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<ITimeCloneAICapabilityUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTimeCloneAICapabilityUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITimeCloneAICapabilityUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTimeCloneAICapabilityUCMutSetEffect(effect);
        }
      }
    }
    effectsTimeCloneAICapabilityUCMutSetCreateEffect.Clear();

  }

    public int GetAttackAICapabilityUCMutSetHash(int id, int version, AttackAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public AttackAICapabilityUCMutSetIncarnation GetAttackAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsAttackAICapabilityUCMutSet[id].incarnation;
    }
    public AttackAICapabilityUCMutSet GetAttackAICapabilityUCMutSet(int id) {
      return new AttackAICapabilityUCMutSet(this, id);
    }
    public List<AttackAICapabilityUCMutSet> AllAttackAICapabilityUCMutSet() {
      List<AttackAICapabilityUCMutSet> result = new List<AttackAICapabilityUCMutSet>(rootIncarnation.incarnationsAttackAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsAttackAICapabilityUCMutSet.Keys) {
        result.Add(new AttackAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool AttackAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsAttackAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasAttackAICapabilityUCMutSet(AttackAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasAttackAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasAttackAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsAttackAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid AttackAICapabilityUCMutSet}: " + id);
      }
    }
    public AttackAICapabilityUCMutSet EffectAttackAICapabilityUCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new AttackAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateAttackAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      return new AttackAICapabilityUCMutSet(this, id);
    }
    public void EffectInternalCreateAttackAICapabilityUCMutSet(int id, int incarnationVersion, AttackAICapabilityUCMutSetIncarnation incarnation) {
      var effect = new AttackAICapabilityUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsAttackAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<AttackAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsAttackAICapabilityUCMutSetCreateEffect.Add(effect);
    }
    public void EffectAttackAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new AttackAICapabilityUCMutSetDeleteEffect(id);
      effectsAttackAICapabilityUCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsAttackAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsAttackAICapabilityUCMutSet.Remove(id);
    }

       
    public void EffectAttackAICapabilityUCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasAttackAICapabilityUCMutSet(setId);
      CheckHasAttackAICapabilityUC(elementId);

      var effect = new AttackAICapabilityUCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsAttackAICapabilityUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new AttackAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsAttackAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<AttackAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsAttackAICapabilityUCMutSetAddEffect.Add(effect);
    }
    public void EffectAttackAICapabilityUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasAttackAICapabilityUCMutSet(setId);
      CheckHasAttackAICapabilityUC(elementId);

      var effect = new AttackAICapabilityUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsAttackAICapabilityUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new AttackAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsAttackAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<AttackAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsAttackAICapabilityUCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddAttackAICapabilityUCMutSetObserver(int id, IAttackAICapabilityUCMutSetEffectObserver observer) {
      List<IAttackAICapabilityUCMutSetEffectObserver> obsies;
      if (!observersForAttackAICapabilityUCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IAttackAICapabilityUCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForAttackAICapabilityUCMutSet[id] = obsies;
    }

    public void RemoveAttackAICapabilityUCMutSetObserver(int id, IAttackAICapabilityUCMutSetEffectObserver observer) {
      if (observersForAttackAICapabilityUCMutSet.ContainsKey(id)) {
        var list = observersForAttackAICapabilityUCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForAttackAICapabilityUCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastAttackAICapabilityUCMutSetEffects(
      SortedDictionary<int, List<IAttackAICapabilityUCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsAttackAICapabilityUCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IAttackAICapabilityUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnAttackAICapabilityUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IAttackAICapabilityUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnAttackAICapabilityUCMutSetEffect(effect);
        }
        observersForAttackAICapabilityUCMutSet.Remove(effect.id);
      }
    }
    effectsAttackAICapabilityUCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsAttackAICapabilityUCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IAttackAICapabilityUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnAttackAICapabilityUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IAttackAICapabilityUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnAttackAICapabilityUCMutSetEffect(effect);
        }
      }
    }
    effectsAttackAICapabilityUCMutSetAddEffect.Clear();

    foreach (var effect in effectsAttackAICapabilityUCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IAttackAICapabilityUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnAttackAICapabilityUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IAttackAICapabilityUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnAttackAICapabilityUCMutSetEffect(effect);
        }
      }
    }
    effectsAttackAICapabilityUCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsAttackAICapabilityUCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IAttackAICapabilityUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnAttackAICapabilityUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IAttackAICapabilityUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnAttackAICapabilityUCMutSetEffect(effect);
        }
      }
    }
    effectsAttackAICapabilityUCMutSetCreateEffect.Clear();

  }

    public int GetCounteringUCMutSetHash(int id, int version, CounteringUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CounteringUCMutSetIncarnation GetCounteringUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsCounteringUCMutSet[id].incarnation;
    }
    public CounteringUCMutSet GetCounteringUCMutSet(int id) {
      return new CounteringUCMutSet(this, id);
    }
    public List<CounteringUCMutSet> AllCounteringUCMutSet() {
      List<CounteringUCMutSet> result = new List<CounteringUCMutSet>(rootIncarnation.incarnationsCounteringUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsCounteringUCMutSet.Keys) {
        result.Add(new CounteringUCMutSet(this, id));
      }
      return result;
    }
    public bool CounteringUCMutSetExists(int id) {
      return rootIncarnation.incarnationsCounteringUCMutSet.ContainsKey(id);
    }
    public void CheckHasCounteringUCMutSet(CounteringUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCounteringUCMutSet(thing.id);
    }
    public void CheckHasCounteringUCMutSet(int id) {
      if (!rootIncarnation.incarnationsCounteringUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid CounteringUCMutSet}: " + id);
      }
    }
    public CounteringUCMutSet EffectCounteringUCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new CounteringUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateCounteringUCMutSet(id, rootIncarnation.version, incarnation);
      return new CounteringUCMutSet(this, id);
    }
    public void EffectInternalCreateCounteringUCMutSet(int id, int incarnationVersion, CounteringUCMutSetIncarnation incarnation) {
      var effect = new CounteringUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsCounteringUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<CounteringUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsCounteringUCMutSetCreateEffect.Add(effect);
    }
    public void EffectCounteringUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new CounteringUCMutSetDeleteEffect(id);
      effectsCounteringUCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsCounteringUCMutSet[id];
      rootIncarnation.incarnationsCounteringUCMutSet.Remove(id);
    }

       
    public void EffectCounteringUCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasCounteringUCMutSet(setId);
      CheckHasCounteringUC(elementId);

      var effect = new CounteringUCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCounteringUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new CounteringUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCounteringUCMutSet[setId] =
            new VersionAndIncarnation<CounteringUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsCounteringUCMutSetAddEffect.Add(effect);
    }
    public void EffectCounteringUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasCounteringUCMutSet(setId);
      CheckHasCounteringUC(elementId);

      var effect = new CounteringUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCounteringUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new CounteringUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCounteringUCMutSet[setId] =
            new VersionAndIncarnation<CounteringUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsCounteringUCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddCounteringUCMutSetObserver(int id, ICounteringUCMutSetEffectObserver observer) {
      List<ICounteringUCMutSetEffectObserver> obsies;
      if (!observersForCounteringUCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<ICounteringUCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForCounteringUCMutSet[id] = obsies;
    }

    public void RemoveCounteringUCMutSetObserver(int id, ICounteringUCMutSetEffectObserver observer) {
      if (observersForCounteringUCMutSet.ContainsKey(id)) {
        var list = observersForCounteringUCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForCounteringUCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastCounteringUCMutSetEffects(
      SortedDictionary<int, List<ICounteringUCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsCounteringUCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<ICounteringUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCounteringUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICounteringUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCounteringUCMutSetEffect(effect);
        }
        observersForCounteringUCMutSet.Remove(effect.id);
      }
    }
    effectsCounteringUCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsCounteringUCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<ICounteringUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCounteringUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICounteringUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCounteringUCMutSetEffect(effect);
        }
      }
    }
    effectsCounteringUCMutSetAddEffect.Clear();

    foreach (var effect in effectsCounteringUCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<ICounteringUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCounteringUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICounteringUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCounteringUCMutSetEffect(effect);
        }
      }
    }
    effectsCounteringUCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsCounteringUCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<ICounteringUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCounteringUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICounteringUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCounteringUCMutSetEffect(effect);
        }
      }
    }
    effectsCounteringUCMutSetCreateEffect.Clear();

  }

    public int GetShieldingUCMutSetHash(int id, int version, ShieldingUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ShieldingUCMutSetIncarnation GetShieldingUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsShieldingUCMutSet[id].incarnation;
    }
    public ShieldingUCMutSet GetShieldingUCMutSet(int id) {
      return new ShieldingUCMutSet(this, id);
    }
    public List<ShieldingUCMutSet> AllShieldingUCMutSet() {
      List<ShieldingUCMutSet> result = new List<ShieldingUCMutSet>(rootIncarnation.incarnationsShieldingUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsShieldingUCMutSet.Keys) {
        result.Add(new ShieldingUCMutSet(this, id));
      }
      return result;
    }
    public bool ShieldingUCMutSetExists(int id) {
      return rootIncarnation.incarnationsShieldingUCMutSet.ContainsKey(id);
    }
    public void CheckHasShieldingUCMutSet(ShieldingUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasShieldingUCMutSet(thing.id);
    }
    public void CheckHasShieldingUCMutSet(int id) {
      if (!rootIncarnation.incarnationsShieldingUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ShieldingUCMutSet}: " + id);
      }
    }
    public ShieldingUCMutSet EffectShieldingUCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new ShieldingUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateShieldingUCMutSet(id, rootIncarnation.version, incarnation);
      return new ShieldingUCMutSet(this, id);
    }
    public void EffectInternalCreateShieldingUCMutSet(int id, int incarnationVersion, ShieldingUCMutSetIncarnation incarnation) {
      var effect = new ShieldingUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsShieldingUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<ShieldingUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsShieldingUCMutSetCreateEffect.Add(effect);
    }
    public void EffectShieldingUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new ShieldingUCMutSetDeleteEffect(id);
      effectsShieldingUCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsShieldingUCMutSet[id];
      rootIncarnation.incarnationsShieldingUCMutSet.Remove(id);
    }

       
    public void EffectShieldingUCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasShieldingUCMutSet(setId);
      CheckHasShieldingUC(elementId);

      var effect = new ShieldingUCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsShieldingUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new ShieldingUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsShieldingUCMutSet[setId] =
            new VersionAndIncarnation<ShieldingUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsShieldingUCMutSetAddEffect.Add(effect);
    }
    public void EffectShieldingUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasShieldingUCMutSet(setId);
      CheckHasShieldingUC(elementId);

      var effect = new ShieldingUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsShieldingUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ShieldingUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsShieldingUCMutSet[setId] =
            new VersionAndIncarnation<ShieldingUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsShieldingUCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddShieldingUCMutSetObserver(int id, IShieldingUCMutSetEffectObserver observer) {
      List<IShieldingUCMutSetEffectObserver> obsies;
      if (!observersForShieldingUCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IShieldingUCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForShieldingUCMutSet[id] = obsies;
    }

    public void RemoveShieldingUCMutSetObserver(int id, IShieldingUCMutSetEffectObserver observer) {
      if (observersForShieldingUCMutSet.ContainsKey(id)) {
        var list = observersForShieldingUCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForShieldingUCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastShieldingUCMutSetEffects(
      SortedDictionary<int, List<IShieldingUCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsShieldingUCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IShieldingUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnShieldingUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IShieldingUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnShieldingUCMutSetEffect(effect);
        }
        observersForShieldingUCMutSet.Remove(effect.id);
      }
    }
    effectsShieldingUCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsShieldingUCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IShieldingUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnShieldingUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IShieldingUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnShieldingUCMutSetEffect(effect);
        }
      }
    }
    effectsShieldingUCMutSetAddEffect.Clear();

    foreach (var effect in effectsShieldingUCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IShieldingUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnShieldingUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IShieldingUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnShieldingUCMutSetEffect(effect);
        }
      }
    }
    effectsShieldingUCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsShieldingUCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IShieldingUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnShieldingUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IShieldingUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnShieldingUCMutSetEffect(effect);
        }
      }
    }
    effectsShieldingUCMutSetCreateEffect.Clear();

  }

    public int GetBideAICapabilityUCMutSetHash(int id, int version, BideAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BideAICapabilityUCMutSetIncarnation GetBideAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBideAICapabilityUCMutSet[id].incarnation;
    }
    public BideAICapabilityUCMutSet GetBideAICapabilityUCMutSet(int id) {
      return new BideAICapabilityUCMutSet(this, id);
    }
    public List<BideAICapabilityUCMutSet> AllBideAICapabilityUCMutSet() {
      List<BideAICapabilityUCMutSet> result = new List<BideAICapabilityUCMutSet>(rootIncarnation.incarnationsBideAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBideAICapabilityUCMutSet.Keys) {
        result.Add(new BideAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool BideAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsBideAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasBideAICapabilityUCMutSet(BideAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBideAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasBideAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsBideAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BideAICapabilityUCMutSet}: " + id);
      }
    }
    public BideAICapabilityUCMutSet EffectBideAICapabilityUCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new BideAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateBideAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      return new BideAICapabilityUCMutSet(this, id);
    }
    public void EffectInternalCreateBideAICapabilityUCMutSet(int id, int incarnationVersion, BideAICapabilityUCMutSetIncarnation incarnation) {
      var effect = new BideAICapabilityUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsBideAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<BideAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsBideAICapabilityUCMutSetCreateEffect.Add(effect);
    }
    public void EffectBideAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new BideAICapabilityUCMutSetDeleteEffect(id);
      effectsBideAICapabilityUCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsBideAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsBideAICapabilityUCMutSet.Remove(id);
    }

       
    public void EffectBideAICapabilityUCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasBideAICapabilityUCMutSet(setId);
      CheckHasBideAICapabilityUC(elementId);

      var effect = new BideAICapabilityUCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBideAICapabilityUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new BideAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBideAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<BideAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsBideAICapabilityUCMutSetAddEffect.Add(effect);
    }
    public void EffectBideAICapabilityUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasBideAICapabilityUCMutSet(setId);
      CheckHasBideAICapabilityUC(elementId);

      var effect = new BideAICapabilityUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBideAICapabilityUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BideAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBideAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<BideAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsBideAICapabilityUCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddBideAICapabilityUCMutSetObserver(int id, IBideAICapabilityUCMutSetEffectObserver observer) {
      List<IBideAICapabilityUCMutSetEffectObserver> obsies;
      if (!observersForBideAICapabilityUCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IBideAICapabilityUCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForBideAICapabilityUCMutSet[id] = obsies;
    }

    public void RemoveBideAICapabilityUCMutSetObserver(int id, IBideAICapabilityUCMutSetEffectObserver observer) {
      if (observersForBideAICapabilityUCMutSet.ContainsKey(id)) {
        var list = observersForBideAICapabilityUCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForBideAICapabilityUCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastBideAICapabilityUCMutSetEffects(
      SortedDictionary<int, List<IBideAICapabilityUCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsBideAICapabilityUCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IBideAICapabilityUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnBideAICapabilityUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IBideAICapabilityUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnBideAICapabilityUCMutSetEffect(effect);
        }
        observersForBideAICapabilityUCMutSet.Remove(effect.id);
      }
    }
    effectsBideAICapabilityUCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsBideAICapabilityUCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IBideAICapabilityUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnBideAICapabilityUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IBideAICapabilityUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnBideAICapabilityUCMutSetEffect(effect);
        }
      }
    }
    effectsBideAICapabilityUCMutSetAddEffect.Clear();

    foreach (var effect in effectsBideAICapabilityUCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IBideAICapabilityUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnBideAICapabilityUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IBideAICapabilityUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnBideAICapabilityUCMutSetEffect(effect);
        }
      }
    }
    effectsBideAICapabilityUCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsBideAICapabilityUCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IBideAICapabilityUCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnBideAICapabilityUCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IBideAICapabilityUCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnBideAICapabilityUCMutSetEffect(effect);
        }
      }
    }
    effectsBideAICapabilityUCMutSetCreateEffect.Clear();

  }

    public int GetTimeAnchorTTCMutSetHash(int id, int version, TimeAnchorTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public TimeAnchorTTCMutSetIncarnation GetTimeAnchorTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsTimeAnchorTTCMutSet[id].incarnation;
    }
    public TimeAnchorTTCMutSet GetTimeAnchorTTCMutSet(int id) {
      return new TimeAnchorTTCMutSet(this, id);
    }
    public List<TimeAnchorTTCMutSet> AllTimeAnchorTTCMutSet() {
      List<TimeAnchorTTCMutSet> result = new List<TimeAnchorTTCMutSet>(rootIncarnation.incarnationsTimeAnchorTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsTimeAnchorTTCMutSet.Keys) {
        result.Add(new TimeAnchorTTCMutSet(this, id));
      }
      return result;
    }
    public bool TimeAnchorTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsTimeAnchorTTCMutSet.ContainsKey(id);
    }
    public void CheckHasTimeAnchorTTCMutSet(TimeAnchorTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasTimeAnchorTTCMutSet(thing.id);
    }
    public void CheckHasTimeAnchorTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsTimeAnchorTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid TimeAnchorTTCMutSet}: " + id);
      }
    }
    public TimeAnchorTTCMutSet EffectTimeAnchorTTCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new TimeAnchorTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateTimeAnchorTTCMutSet(id, rootIncarnation.version, incarnation);
      return new TimeAnchorTTCMutSet(this, id);
    }
    public void EffectInternalCreateTimeAnchorTTCMutSet(int id, int incarnationVersion, TimeAnchorTTCMutSetIncarnation incarnation) {
      var effect = new TimeAnchorTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsTimeAnchorTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<TimeAnchorTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsTimeAnchorTTCMutSetCreateEffect.Add(effect);
    }
    public void EffectTimeAnchorTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new TimeAnchorTTCMutSetDeleteEffect(id);
      effectsTimeAnchorTTCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsTimeAnchorTTCMutSet[id];
      rootIncarnation.incarnationsTimeAnchorTTCMutSet.Remove(id);
    }

       
    public void EffectTimeAnchorTTCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasTimeAnchorTTCMutSet(setId);
      CheckHasTimeAnchorTTC(elementId);

      var effect = new TimeAnchorTTCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTimeAnchorTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new TimeAnchorTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTimeAnchorTTCMutSet[setId] =
            new VersionAndIncarnation<TimeAnchorTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsTimeAnchorTTCMutSetAddEffect.Add(effect);
    }
    public void EffectTimeAnchorTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasTimeAnchorTTCMutSet(setId);
      CheckHasTimeAnchorTTC(elementId);

      var effect = new TimeAnchorTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTimeAnchorTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new TimeAnchorTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTimeAnchorTTCMutSet[setId] =
            new VersionAndIncarnation<TimeAnchorTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsTimeAnchorTTCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddTimeAnchorTTCMutSetObserver(int id, ITimeAnchorTTCMutSetEffectObserver observer) {
      List<ITimeAnchorTTCMutSetEffectObserver> obsies;
      if (!observersForTimeAnchorTTCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<ITimeAnchorTTCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForTimeAnchorTTCMutSet[id] = obsies;
    }

    public void RemoveTimeAnchorTTCMutSetObserver(int id, ITimeAnchorTTCMutSetEffectObserver observer) {
      if (observersForTimeAnchorTTCMutSet.ContainsKey(id)) {
        var list = observersForTimeAnchorTTCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForTimeAnchorTTCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastTimeAnchorTTCMutSetEffects(
      SortedDictionary<int, List<ITimeAnchorTTCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsTimeAnchorTTCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<ITimeAnchorTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTimeAnchorTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITimeAnchorTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTimeAnchorTTCMutSetEffect(effect);
        }
        observersForTimeAnchorTTCMutSet.Remove(effect.id);
      }
    }
    effectsTimeAnchorTTCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsTimeAnchorTTCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<ITimeAnchorTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTimeAnchorTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITimeAnchorTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTimeAnchorTTCMutSetEffect(effect);
        }
      }
    }
    effectsTimeAnchorTTCMutSetAddEffect.Clear();

    foreach (var effect in effectsTimeAnchorTTCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<ITimeAnchorTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTimeAnchorTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITimeAnchorTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTimeAnchorTTCMutSetEffect(effect);
        }
      }
    }
    effectsTimeAnchorTTCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsTimeAnchorTTCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<ITimeAnchorTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTimeAnchorTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITimeAnchorTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTimeAnchorTTCMutSetEffect(effect);
        }
      }
    }
    effectsTimeAnchorTTCMutSetCreateEffect.Clear();

  }

    public int GetStaircaseTTCMutSetHash(int id, int version, StaircaseTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public StaircaseTTCMutSetIncarnation GetStaircaseTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsStaircaseTTCMutSet[id].incarnation;
    }
    public StaircaseTTCMutSet GetStaircaseTTCMutSet(int id) {
      return new StaircaseTTCMutSet(this, id);
    }
    public List<StaircaseTTCMutSet> AllStaircaseTTCMutSet() {
      List<StaircaseTTCMutSet> result = new List<StaircaseTTCMutSet>(rootIncarnation.incarnationsStaircaseTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsStaircaseTTCMutSet.Keys) {
        result.Add(new StaircaseTTCMutSet(this, id));
      }
      return result;
    }
    public bool StaircaseTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsStaircaseTTCMutSet.ContainsKey(id);
    }
    public void CheckHasStaircaseTTCMutSet(StaircaseTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasStaircaseTTCMutSet(thing.id);
    }
    public void CheckHasStaircaseTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsStaircaseTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid StaircaseTTCMutSet}: " + id);
      }
    }
    public StaircaseTTCMutSet EffectStaircaseTTCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new StaircaseTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateStaircaseTTCMutSet(id, rootIncarnation.version, incarnation);
      return new StaircaseTTCMutSet(this, id);
    }
    public void EffectInternalCreateStaircaseTTCMutSet(int id, int incarnationVersion, StaircaseTTCMutSetIncarnation incarnation) {
      var effect = new StaircaseTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsStaircaseTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<StaircaseTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsStaircaseTTCMutSetCreateEffect.Add(effect);
    }
    public void EffectStaircaseTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new StaircaseTTCMutSetDeleteEffect(id);
      effectsStaircaseTTCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsStaircaseTTCMutSet[id];
      rootIncarnation.incarnationsStaircaseTTCMutSet.Remove(id);
    }

       
    public void EffectStaircaseTTCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasStaircaseTTCMutSet(setId);
      CheckHasStaircaseTTC(elementId);

      var effect = new StaircaseTTCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsStaircaseTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new StaircaseTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsStaircaseTTCMutSet[setId] =
            new VersionAndIncarnation<StaircaseTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsStaircaseTTCMutSetAddEffect.Add(effect);
    }
    public void EffectStaircaseTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasStaircaseTTCMutSet(setId);
      CheckHasStaircaseTTC(elementId);

      var effect = new StaircaseTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsStaircaseTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new StaircaseTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsStaircaseTTCMutSet[setId] =
            new VersionAndIncarnation<StaircaseTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsStaircaseTTCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddStaircaseTTCMutSetObserver(int id, IStaircaseTTCMutSetEffectObserver observer) {
      List<IStaircaseTTCMutSetEffectObserver> obsies;
      if (!observersForStaircaseTTCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IStaircaseTTCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForStaircaseTTCMutSet[id] = obsies;
    }

    public void RemoveStaircaseTTCMutSetObserver(int id, IStaircaseTTCMutSetEffectObserver observer) {
      if (observersForStaircaseTTCMutSet.ContainsKey(id)) {
        var list = observersForStaircaseTTCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForStaircaseTTCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastStaircaseTTCMutSetEffects(
      SortedDictionary<int, List<IStaircaseTTCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsStaircaseTTCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IStaircaseTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnStaircaseTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IStaircaseTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnStaircaseTTCMutSetEffect(effect);
        }
        observersForStaircaseTTCMutSet.Remove(effect.id);
      }
    }
    effectsStaircaseTTCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsStaircaseTTCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IStaircaseTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnStaircaseTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IStaircaseTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnStaircaseTTCMutSetEffect(effect);
        }
      }
    }
    effectsStaircaseTTCMutSetAddEffect.Clear();

    foreach (var effect in effectsStaircaseTTCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IStaircaseTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnStaircaseTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IStaircaseTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnStaircaseTTCMutSetEffect(effect);
        }
      }
    }
    effectsStaircaseTTCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsStaircaseTTCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IStaircaseTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnStaircaseTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IStaircaseTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnStaircaseTTCMutSetEffect(effect);
        }
      }
    }
    effectsStaircaseTTCMutSetCreateEffect.Clear();

  }

    public int GetWallTTCMutSetHash(int id, int version, WallTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public WallTTCMutSetIncarnation GetWallTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsWallTTCMutSet[id].incarnation;
    }
    public WallTTCMutSet GetWallTTCMutSet(int id) {
      return new WallTTCMutSet(this, id);
    }
    public List<WallTTCMutSet> AllWallTTCMutSet() {
      List<WallTTCMutSet> result = new List<WallTTCMutSet>(rootIncarnation.incarnationsWallTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsWallTTCMutSet.Keys) {
        result.Add(new WallTTCMutSet(this, id));
      }
      return result;
    }
    public bool WallTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsWallTTCMutSet.ContainsKey(id);
    }
    public void CheckHasWallTTCMutSet(WallTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasWallTTCMutSet(thing.id);
    }
    public void CheckHasWallTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsWallTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid WallTTCMutSet}: " + id);
      }
    }
    public WallTTCMutSet EffectWallTTCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new WallTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateWallTTCMutSet(id, rootIncarnation.version, incarnation);
      return new WallTTCMutSet(this, id);
    }
    public void EffectInternalCreateWallTTCMutSet(int id, int incarnationVersion, WallTTCMutSetIncarnation incarnation) {
      var effect = new WallTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsWallTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<WallTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsWallTTCMutSetCreateEffect.Add(effect);
    }
    public void EffectWallTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new WallTTCMutSetDeleteEffect(id);
      effectsWallTTCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsWallTTCMutSet[id];
      rootIncarnation.incarnationsWallTTCMutSet.Remove(id);
    }

       
    public void EffectWallTTCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasWallTTCMutSet(setId);
      CheckHasWallTTC(elementId);

      var effect = new WallTTCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsWallTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new WallTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsWallTTCMutSet[setId] =
            new VersionAndIncarnation<WallTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsWallTTCMutSetAddEffect.Add(effect);
    }
    public void EffectWallTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasWallTTCMutSet(setId);
      CheckHasWallTTC(elementId);

      var effect = new WallTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsWallTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new WallTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsWallTTCMutSet[setId] =
            new VersionAndIncarnation<WallTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsWallTTCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddWallTTCMutSetObserver(int id, IWallTTCMutSetEffectObserver observer) {
      List<IWallTTCMutSetEffectObserver> obsies;
      if (!observersForWallTTCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IWallTTCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForWallTTCMutSet[id] = obsies;
    }

    public void RemoveWallTTCMutSetObserver(int id, IWallTTCMutSetEffectObserver observer) {
      if (observersForWallTTCMutSet.ContainsKey(id)) {
        var list = observersForWallTTCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForWallTTCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastWallTTCMutSetEffects(
      SortedDictionary<int, List<IWallTTCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsWallTTCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IWallTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnWallTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IWallTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnWallTTCMutSetEffect(effect);
        }
        observersForWallTTCMutSet.Remove(effect.id);
      }
    }
    effectsWallTTCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsWallTTCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IWallTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnWallTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IWallTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnWallTTCMutSetEffect(effect);
        }
      }
    }
    effectsWallTTCMutSetAddEffect.Clear();

    foreach (var effect in effectsWallTTCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IWallTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnWallTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IWallTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnWallTTCMutSetEffect(effect);
        }
      }
    }
    effectsWallTTCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsWallTTCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IWallTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnWallTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IWallTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnWallTTCMutSetEffect(effect);
        }
      }
    }
    effectsWallTTCMutSetCreateEffect.Clear();

  }

    public int GetBloodTTCMutSetHash(int id, int version, BloodTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BloodTTCMutSetIncarnation GetBloodTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBloodTTCMutSet[id].incarnation;
    }
    public BloodTTCMutSet GetBloodTTCMutSet(int id) {
      return new BloodTTCMutSet(this, id);
    }
    public List<BloodTTCMutSet> AllBloodTTCMutSet() {
      List<BloodTTCMutSet> result = new List<BloodTTCMutSet>(rootIncarnation.incarnationsBloodTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBloodTTCMutSet.Keys) {
        result.Add(new BloodTTCMutSet(this, id));
      }
      return result;
    }
    public bool BloodTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsBloodTTCMutSet.ContainsKey(id);
    }
    public void CheckHasBloodTTCMutSet(BloodTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBloodTTCMutSet(thing.id);
    }
    public void CheckHasBloodTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsBloodTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BloodTTCMutSet}: " + id);
      }
    }
    public BloodTTCMutSet EffectBloodTTCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new BloodTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateBloodTTCMutSet(id, rootIncarnation.version, incarnation);
      return new BloodTTCMutSet(this, id);
    }
    public void EffectInternalCreateBloodTTCMutSet(int id, int incarnationVersion, BloodTTCMutSetIncarnation incarnation) {
      var effect = new BloodTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsBloodTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<BloodTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsBloodTTCMutSetCreateEffect.Add(effect);
    }
    public void EffectBloodTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new BloodTTCMutSetDeleteEffect(id);
      effectsBloodTTCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsBloodTTCMutSet[id];
      rootIncarnation.incarnationsBloodTTCMutSet.Remove(id);
    }

       
    public void EffectBloodTTCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasBloodTTCMutSet(setId);
      CheckHasBloodTTC(elementId);

      var effect = new BloodTTCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBloodTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new BloodTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBloodTTCMutSet[setId] =
            new VersionAndIncarnation<BloodTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsBloodTTCMutSetAddEffect.Add(effect);
    }
    public void EffectBloodTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasBloodTTCMutSet(setId);
      CheckHasBloodTTC(elementId);

      var effect = new BloodTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBloodTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BloodTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBloodTTCMutSet[setId] =
            new VersionAndIncarnation<BloodTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsBloodTTCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddBloodTTCMutSetObserver(int id, IBloodTTCMutSetEffectObserver observer) {
      List<IBloodTTCMutSetEffectObserver> obsies;
      if (!observersForBloodTTCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IBloodTTCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForBloodTTCMutSet[id] = obsies;
    }

    public void RemoveBloodTTCMutSetObserver(int id, IBloodTTCMutSetEffectObserver observer) {
      if (observersForBloodTTCMutSet.ContainsKey(id)) {
        var list = observersForBloodTTCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForBloodTTCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastBloodTTCMutSetEffects(
      SortedDictionary<int, List<IBloodTTCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsBloodTTCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IBloodTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnBloodTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IBloodTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnBloodTTCMutSetEffect(effect);
        }
        observersForBloodTTCMutSet.Remove(effect.id);
      }
    }
    effectsBloodTTCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsBloodTTCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IBloodTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnBloodTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IBloodTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnBloodTTCMutSetEffect(effect);
        }
      }
    }
    effectsBloodTTCMutSetAddEffect.Clear();

    foreach (var effect in effectsBloodTTCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IBloodTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnBloodTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IBloodTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnBloodTTCMutSetEffect(effect);
        }
      }
    }
    effectsBloodTTCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsBloodTTCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IBloodTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnBloodTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IBloodTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnBloodTTCMutSetEffect(effect);
        }
      }
    }
    effectsBloodTTCMutSetCreateEffect.Clear();

  }

    public int GetRocksTTCMutSetHash(int id, int version, RocksTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public RocksTTCMutSetIncarnation GetRocksTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsRocksTTCMutSet[id].incarnation;
    }
    public RocksTTCMutSet GetRocksTTCMutSet(int id) {
      return new RocksTTCMutSet(this, id);
    }
    public List<RocksTTCMutSet> AllRocksTTCMutSet() {
      List<RocksTTCMutSet> result = new List<RocksTTCMutSet>(rootIncarnation.incarnationsRocksTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsRocksTTCMutSet.Keys) {
        result.Add(new RocksTTCMutSet(this, id));
      }
      return result;
    }
    public bool RocksTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsRocksTTCMutSet.ContainsKey(id);
    }
    public void CheckHasRocksTTCMutSet(RocksTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasRocksTTCMutSet(thing.id);
    }
    public void CheckHasRocksTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsRocksTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid RocksTTCMutSet}: " + id);
      }
    }
    public RocksTTCMutSet EffectRocksTTCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new RocksTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateRocksTTCMutSet(id, rootIncarnation.version, incarnation);
      return new RocksTTCMutSet(this, id);
    }
    public void EffectInternalCreateRocksTTCMutSet(int id, int incarnationVersion, RocksTTCMutSetIncarnation incarnation) {
      var effect = new RocksTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsRocksTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<RocksTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsRocksTTCMutSetCreateEffect.Add(effect);
    }
    public void EffectRocksTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new RocksTTCMutSetDeleteEffect(id);
      effectsRocksTTCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsRocksTTCMutSet[id];
      rootIncarnation.incarnationsRocksTTCMutSet.Remove(id);
    }

       
    public void EffectRocksTTCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasRocksTTCMutSet(setId);
      CheckHasRocksTTC(elementId);

      var effect = new RocksTTCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsRocksTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new RocksTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsRocksTTCMutSet[setId] =
            new VersionAndIncarnation<RocksTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsRocksTTCMutSetAddEffect.Add(effect);
    }
    public void EffectRocksTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasRocksTTCMutSet(setId);
      CheckHasRocksTTC(elementId);

      var effect = new RocksTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsRocksTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new RocksTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsRocksTTCMutSet[setId] =
            new VersionAndIncarnation<RocksTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsRocksTTCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddRocksTTCMutSetObserver(int id, IRocksTTCMutSetEffectObserver observer) {
      List<IRocksTTCMutSetEffectObserver> obsies;
      if (!observersForRocksTTCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IRocksTTCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForRocksTTCMutSet[id] = obsies;
    }

    public void RemoveRocksTTCMutSetObserver(int id, IRocksTTCMutSetEffectObserver observer) {
      if (observersForRocksTTCMutSet.ContainsKey(id)) {
        var list = observersForRocksTTCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForRocksTTCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastRocksTTCMutSetEffects(
      SortedDictionary<int, List<IRocksTTCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsRocksTTCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IRocksTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnRocksTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IRocksTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnRocksTTCMutSetEffect(effect);
        }
        observersForRocksTTCMutSet.Remove(effect.id);
      }
    }
    effectsRocksTTCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsRocksTTCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IRocksTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnRocksTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IRocksTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnRocksTTCMutSetEffect(effect);
        }
      }
    }
    effectsRocksTTCMutSetAddEffect.Clear();

    foreach (var effect in effectsRocksTTCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IRocksTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnRocksTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IRocksTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnRocksTTCMutSetEffect(effect);
        }
      }
    }
    effectsRocksTTCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsRocksTTCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IRocksTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnRocksTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IRocksTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnRocksTTCMutSetEffect(effect);
        }
      }
    }
    effectsRocksTTCMutSetCreateEffect.Clear();

  }

    public int GetDownstairsTTCMutSetHash(int id, int version, DownstairsTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public DownstairsTTCMutSetIncarnation GetDownstairsTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsDownstairsTTCMutSet[id].incarnation;
    }
    public DownstairsTTCMutSet GetDownstairsTTCMutSet(int id) {
      return new DownstairsTTCMutSet(this, id);
    }
    public List<DownstairsTTCMutSet> AllDownstairsTTCMutSet() {
      List<DownstairsTTCMutSet> result = new List<DownstairsTTCMutSet>(rootIncarnation.incarnationsDownstairsTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsDownstairsTTCMutSet.Keys) {
        result.Add(new DownstairsTTCMutSet(this, id));
      }
      return result;
    }
    public bool DownstairsTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsDownstairsTTCMutSet.ContainsKey(id);
    }
    public void CheckHasDownstairsTTCMutSet(DownstairsTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasDownstairsTTCMutSet(thing.id);
    }
    public void CheckHasDownstairsTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsDownstairsTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid DownstairsTTCMutSet}: " + id);
      }
    }
    public DownstairsTTCMutSet EffectDownstairsTTCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new DownstairsTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateDownstairsTTCMutSet(id, rootIncarnation.version, incarnation);
      return new DownstairsTTCMutSet(this, id);
    }
    public void EffectInternalCreateDownstairsTTCMutSet(int id, int incarnationVersion, DownstairsTTCMutSetIncarnation incarnation) {
      var effect = new DownstairsTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsDownstairsTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<DownstairsTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsDownstairsTTCMutSetCreateEffect.Add(effect);
    }
    public void EffectDownstairsTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new DownstairsTTCMutSetDeleteEffect(id);
      effectsDownstairsTTCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsDownstairsTTCMutSet[id];
      rootIncarnation.incarnationsDownstairsTTCMutSet.Remove(id);
    }

       
    public void EffectDownstairsTTCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasDownstairsTTCMutSet(setId);
      CheckHasDownstairsTTC(elementId);

      var effect = new DownstairsTTCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsDownstairsTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new DownstairsTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDownstairsTTCMutSet[setId] =
            new VersionAndIncarnation<DownstairsTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsDownstairsTTCMutSetAddEffect.Add(effect);
    }
    public void EffectDownstairsTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasDownstairsTTCMutSet(setId);
      CheckHasDownstairsTTC(elementId);

      var effect = new DownstairsTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsDownstairsTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new DownstairsTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDownstairsTTCMutSet[setId] =
            new VersionAndIncarnation<DownstairsTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsDownstairsTTCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddDownstairsTTCMutSetObserver(int id, IDownstairsTTCMutSetEffectObserver observer) {
      List<IDownstairsTTCMutSetEffectObserver> obsies;
      if (!observersForDownstairsTTCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IDownstairsTTCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForDownstairsTTCMutSet[id] = obsies;
    }

    public void RemoveDownstairsTTCMutSetObserver(int id, IDownstairsTTCMutSetEffectObserver observer) {
      if (observersForDownstairsTTCMutSet.ContainsKey(id)) {
        var list = observersForDownstairsTTCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForDownstairsTTCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastDownstairsTTCMutSetEffects(
      SortedDictionary<int, List<IDownstairsTTCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsDownstairsTTCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IDownstairsTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnDownstairsTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IDownstairsTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnDownstairsTTCMutSetEffect(effect);
        }
        observersForDownstairsTTCMutSet.Remove(effect.id);
      }
    }
    effectsDownstairsTTCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsDownstairsTTCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IDownstairsTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnDownstairsTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IDownstairsTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnDownstairsTTCMutSetEffect(effect);
        }
      }
    }
    effectsDownstairsTTCMutSetAddEffect.Clear();

    foreach (var effect in effectsDownstairsTTCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IDownstairsTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnDownstairsTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IDownstairsTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnDownstairsTTCMutSetEffect(effect);
        }
      }
    }
    effectsDownstairsTTCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsDownstairsTTCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IDownstairsTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnDownstairsTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IDownstairsTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnDownstairsTTCMutSetEffect(effect);
        }
      }
    }
    effectsDownstairsTTCMutSetCreateEffect.Clear();

  }

    public int GetUpstairsTTCMutSetHash(int id, int version, UpstairsTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public UpstairsTTCMutSetIncarnation GetUpstairsTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsUpstairsTTCMutSet[id].incarnation;
    }
    public UpstairsTTCMutSet GetUpstairsTTCMutSet(int id) {
      return new UpstairsTTCMutSet(this, id);
    }
    public List<UpstairsTTCMutSet> AllUpstairsTTCMutSet() {
      List<UpstairsTTCMutSet> result = new List<UpstairsTTCMutSet>(rootIncarnation.incarnationsUpstairsTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsUpstairsTTCMutSet.Keys) {
        result.Add(new UpstairsTTCMutSet(this, id));
      }
      return result;
    }
    public bool UpstairsTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsUpstairsTTCMutSet.ContainsKey(id);
    }
    public void CheckHasUpstairsTTCMutSet(UpstairsTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasUpstairsTTCMutSet(thing.id);
    }
    public void CheckHasUpstairsTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsUpstairsTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid UpstairsTTCMutSet}: " + id);
      }
    }
    public UpstairsTTCMutSet EffectUpstairsTTCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new UpstairsTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateUpstairsTTCMutSet(id, rootIncarnation.version, incarnation);
      return new UpstairsTTCMutSet(this, id);
    }
    public void EffectInternalCreateUpstairsTTCMutSet(int id, int incarnationVersion, UpstairsTTCMutSetIncarnation incarnation) {
      var effect = new UpstairsTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsUpstairsTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<UpstairsTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsUpstairsTTCMutSetCreateEffect.Add(effect);
    }
    public void EffectUpstairsTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new UpstairsTTCMutSetDeleteEffect(id);
      effectsUpstairsTTCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsUpstairsTTCMutSet[id];
      rootIncarnation.incarnationsUpstairsTTCMutSet.Remove(id);
    }

       
    public void EffectUpstairsTTCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasUpstairsTTCMutSet(setId);
      CheckHasUpstairsTTC(elementId);

      var effect = new UpstairsTTCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsUpstairsTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new UpstairsTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsUpstairsTTCMutSet[setId] =
            new VersionAndIncarnation<UpstairsTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsUpstairsTTCMutSetAddEffect.Add(effect);
    }
    public void EffectUpstairsTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasUpstairsTTCMutSet(setId);
      CheckHasUpstairsTTC(elementId);

      var effect = new UpstairsTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsUpstairsTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new UpstairsTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsUpstairsTTCMutSet[setId] =
            new VersionAndIncarnation<UpstairsTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsUpstairsTTCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddUpstairsTTCMutSetObserver(int id, IUpstairsTTCMutSetEffectObserver observer) {
      List<IUpstairsTTCMutSetEffectObserver> obsies;
      if (!observersForUpstairsTTCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IUpstairsTTCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForUpstairsTTCMutSet[id] = obsies;
    }

    public void RemoveUpstairsTTCMutSetObserver(int id, IUpstairsTTCMutSetEffectObserver observer) {
      if (observersForUpstairsTTCMutSet.ContainsKey(id)) {
        var list = observersForUpstairsTTCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForUpstairsTTCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastUpstairsTTCMutSetEffects(
      SortedDictionary<int, List<IUpstairsTTCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsUpstairsTTCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IUpstairsTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnUpstairsTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IUpstairsTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnUpstairsTTCMutSetEffect(effect);
        }
        observersForUpstairsTTCMutSet.Remove(effect.id);
      }
    }
    effectsUpstairsTTCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsUpstairsTTCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IUpstairsTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnUpstairsTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IUpstairsTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnUpstairsTTCMutSetEffect(effect);
        }
      }
    }
    effectsUpstairsTTCMutSetAddEffect.Clear();

    foreach (var effect in effectsUpstairsTTCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IUpstairsTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnUpstairsTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IUpstairsTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnUpstairsTTCMutSetEffect(effect);
        }
      }
    }
    effectsUpstairsTTCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsUpstairsTTCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IUpstairsTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnUpstairsTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IUpstairsTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnUpstairsTTCMutSetEffect(effect);
        }
      }
    }
    effectsUpstairsTTCMutSetCreateEffect.Clear();

  }

    public int GetCaveTTCMutSetHash(int id, int version, CaveTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CaveTTCMutSetIncarnation GetCaveTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsCaveTTCMutSet[id].incarnation;
    }
    public CaveTTCMutSet GetCaveTTCMutSet(int id) {
      return new CaveTTCMutSet(this, id);
    }
    public List<CaveTTCMutSet> AllCaveTTCMutSet() {
      List<CaveTTCMutSet> result = new List<CaveTTCMutSet>(rootIncarnation.incarnationsCaveTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsCaveTTCMutSet.Keys) {
        result.Add(new CaveTTCMutSet(this, id));
      }
      return result;
    }
    public bool CaveTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsCaveTTCMutSet.ContainsKey(id);
    }
    public void CheckHasCaveTTCMutSet(CaveTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCaveTTCMutSet(thing.id);
    }
    public void CheckHasCaveTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsCaveTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid CaveTTCMutSet}: " + id);
      }
    }
    public CaveTTCMutSet EffectCaveTTCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new CaveTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateCaveTTCMutSet(id, rootIncarnation.version, incarnation);
      return new CaveTTCMutSet(this, id);
    }
    public void EffectInternalCreateCaveTTCMutSet(int id, int incarnationVersion, CaveTTCMutSetIncarnation incarnation) {
      var effect = new CaveTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsCaveTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<CaveTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsCaveTTCMutSetCreateEffect.Add(effect);
    }
    public void EffectCaveTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new CaveTTCMutSetDeleteEffect(id);
      effectsCaveTTCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsCaveTTCMutSet[id];
      rootIncarnation.incarnationsCaveTTCMutSet.Remove(id);
    }

       
    public void EffectCaveTTCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasCaveTTCMutSet(setId);
      CheckHasCaveTTC(elementId);

      var effect = new CaveTTCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCaveTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new CaveTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCaveTTCMutSet[setId] =
            new VersionAndIncarnation<CaveTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsCaveTTCMutSetAddEffect.Add(effect);
    }
    public void EffectCaveTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasCaveTTCMutSet(setId);
      CheckHasCaveTTC(elementId);

      var effect = new CaveTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCaveTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new CaveTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCaveTTCMutSet[setId] =
            new VersionAndIncarnation<CaveTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsCaveTTCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddCaveTTCMutSetObserver(int id, ICaveTTCMutSetEffectObserver observer) {
      List<ICaveTTCMutSetEffectObserver> obsies;
      if (!observersForCaveTTCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<ICaveTTCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForCaveTTCMutSet[id] = obsies;
    }

    public void RemoveCaveTTCMutSetObserver(int id, ICaveTTCMutSetEffectObserver observer) {
      if (observersForCaveTTCMutSet.ContainsKey(id)) {
        var list = observersForCaveTTCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForCaveTTCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastCaveTTCMutSetEffects(
      SortedDictionary<int, List<ICaveTTCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsCaveTTCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<ICaveTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCaveTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICaveTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCaveTTCMutSetEffect(effect);
        }
        observersForCaveTTCMutSet.Remove(effect.id);
      }
    }
    effectsCaveTTCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsCaveTTCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<ICaveTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCaveTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICaveTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCaveTTCMutSetEffect(effect);
        }
      }
    }
    effectsCaveTTCMutSetAddEffect.Clear();

    foreach (var effect in effectsCaveTTCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<ICaveTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCaveTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICaveTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCaveTTCMutSetEffect(effect);
        }
      }
    }
    effectsCaveTTCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsCaveTTCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<ICaveTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCaveTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICaveTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCaveTTCMutSetEffect(effect);
        }
      }
    }
    effectsCaveTTCMutSetCreateEffect.Clear();

  }

    public int GetFallsTTCMutSetHash(int id, int version, FallsTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public FallsTTCMutSetIncarnation GetFallsTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsFallsTTCMutSet[id].incarnation;
    }
    public FallsTTCMutSet GetFallsTTCMutSet(int id) {
      return new FallsTTCMutSet(this, id);
    }
    public List<FallsTTCMutSet> AllFallsTTCMutSet() {
      List<FallsTTCMutSet> result = new List<FallsTTCMutSet>(rootIncarnation.incarnationsFallsTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsFallsTTCMutSet.Keys) {
        result.Add(new FallsTTCMutSet(this, id));
      }
      return result;
    }
    public bool FallsTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsFallsTTCMutSet.ContainsKey(id);
    }
    public void CheckHasFallsTTCMutSet(FallsTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasFallsTTCMutSet(thing.id);
    }
    public void CheckHasFallsTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsFallsTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid FallsTTCMutSet}: " + id);
      }
    }
    public FallsTTCMutSet EffectFallsTTCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new FallsTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateFallsTTCMutSet(id, rootIncarnation.version, incarnation);
      return new FallsTTCMutSet(this, id);
    }
    public void EffectInternalCreateFallsTTCMutSet(int id, int incarnationVersion, FallsTTCMutSetIncarnation incarnation) {
      var effect = new FallsTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsFallsTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<FallsTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsFallsTTCMutSetCreateEffect.Add(effect);
    }
    public void EffectFallsTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new FallsTTCMutSetDeleteEffect(id);
      effectsFallsTTCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsFallsTTCMutSet[id];
      rootIncarnation.incarnationsFallsTTCMutSet.Remove(id);
    }

       
    public void EffectFallsTTCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasFallsTTCMutSet(setId);
      CheckHasFallsTTC(elementId);

      var effect = new FallsTTCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsFallsTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new FallsTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFallsTTCMutSet[setId] =
            new VersionAndIncarnation<FallsTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsFallsTTCMutSetAddEffect.Add(effect);
    }
    public void EffectFallsTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasFallsTTCMutSet(setId);
      CheckHasFallsTTC(elementId);

      var effect = new FallsTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsFallsTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new FallsTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFallsTTCMutSet[setId] =
            new VersionAndIncarnation<FallsTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsFallsTTCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddFallsTTCMutSetObserver(int id, IFallsTTCMutSetEffectObserver observer) {
      List<IFallsTTCMutSetEffectObserver> obsies;
      if (!observersForFallsTTCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IFallsTTCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForFallsTTCMutSet[id] = obsies;
    }

    public void RemoveFallsTTCMutSetObserver(int id, IFallsTTCMutSetEffectObserver observer) {
      if (observersForFallsTTCMutSet.ContainsKey(id)) {
        var list = observersForFallsTTCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForFallsTTCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastFallsTTCMutSetEffects(
      SortedDictionary<int, List<IFallsTTCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsFallsTTCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IFallsTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnFallsTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IFallsTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnFallsTTCMutSetEffect(effect);
        }
        observersForFallsTTCMutSet.Remove(effect.id);
      }
    }
    effectsFallsTTCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsFallsTTCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IFallsTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnFallsTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IFallsTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnFallsTTCMutSetEffect(effect);
        }
      }
    }
    effectsFallsTTCMutSetAddEffect.Clear();

    foreach (var effect in effectsFallsTTCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IFallsTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnFallsTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IFallsTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnFallsTTCMutSetEffect(effect);
        }
      }
    }
    effectsFallsTTCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsFallsTTCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IFallsTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnFallsTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IFallsTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnFallsTTCMutSetEffect(effect);
        }
      }
    }
    effectsFallsTTCMutSetCreateEffect.Clear();

  }

    public int GetMagmaTTCMutSetHash(int id, int version, MagmaTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public MagmaTTCMutSetIncarnation GetMagmaTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsMagmaTTCMutSet[id].incarnation;
    }
    public MagmaTTCMutSet GetMagmaTTCMutSet(int id) {
      return new MagmaTTCMutSet(this, id);
    }
    public List<MagmaTTCMutSet> AllMagmaTTCMutSet() {
      List<MagmaTTCMutSet> result = new List<MagmaTTCMutSet>(rootIncarnation.incarnationsMagmaTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsMagmaTTCMutSet.Keys) {
        result.Add(new MagmaTTCMutSet(this, id));
      }
      return result;
    }
    public bool MagmaTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsMagmaTTCMutSet.ContainsKey(id);
    }
    public void CheckHasMagmaTTCMutSet(MagmaTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasMagmaTTCMutSet(thing.id);
    }
    public void CheckHasMagmaTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsMagmaTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid MagmaTTCMutSet}: " + id);
      }
    }
    public MagmaTTCMutSet EffectMagmaTTCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new MagmaTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateMagmaTTCMutSet(id, rootIncarnation.version, incarnation);
      return new MagmaTTCMutSet(this, id);
    }
    public void EffectInternalCreateMagmaTTCMutSet(int id, int incarnationVersion, MagmaTTCMutSetIncarnation incarnation) {
      var effect = new MagmaTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsMagmaTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<MagmaTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsMagmaTTCMutSetCreateEffect.Add(effect);
    }
    public void EffectMagmaTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new MagmaTTCMutSetDeleteEffect(id);
      effectsMagmaTTCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsMagmaTTCMutSet[id];
      rootIncarnation.incarnationsMagmaTTCMutSet.Remove(id);
    }

       
    public void EffectMagmaTTCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasMagmaTTCMutSet(setId);
      CheckHasMagmaTTC(elementId);

      var effect = new MagmaTTCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsMagmaTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new MagmaTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMagmaTTCMutSet[setId] =
            new VersionAndIncarnation<MagmaTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsMagmaTTCMutSetAddEffect.Add(effect);
    }
    public void EffectMagmaTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasMagmaTTCMutSet(setId);
      CheckHasMagmaTTC(elementId);

      var effect = new MagmaTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsMagmaTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new MagmaTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMagmaTTCMutSet[setId] =
            new VersionAndIncarnation<MagmaTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsMagmaTTCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddMagmaTTCMutSetObserver(int id, IMagmaTTCMutSetEffectObserver observer) {
      List<IMagmaTTCMutSetEffectObserver> obsies;
      if (!observersForMagmaTTCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IMagmaTTCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForMagmaTTCMutSet[id] = obsies;
    }

    public void RemoveMagmaTTCMutSetObserver(int id, IMagmaTTCMutSetEffectObserver observer) {
      if (observersForMagmaTTCMutSet.ContainsKey(id)) {
        var list = observersForMagmaTTCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForMagmaTTCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastMagmaTTCMutSetEffects(
      SortedDictionary<int, List<IMagmaTTCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsMagmaTTCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IMagmaTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnMagmaTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IMagmaTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnMagmaTTCMutSetEffect(effect);
        }
        observersForMagmaTTCMutSet.Remove(effect.id);
      }
    }
    effectsMagmaTTCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsMagmaTTCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IMagmaTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnMagmaTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IMagmaTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnMagmaTTCMutSetEffect(effect);
        }
      }
    }
    effectsMagmaTTCMutSetAddEffect.Clear();

    foreach (var effect in effectsMagmaTTCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IMagmaTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnMagmaTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IMagmaTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnMagmaTTCMutSetEffect(effect);
        }
      }
    }
    effectsMagmaTTCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsMagmaTTCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IMagmaTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnMagmaTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IMagmaTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnMagmaTTCMutSetEffect(effect);
        }
      }
    }
    effectsMagmaTTCMutSetCreateEffect.Clear();

  }

    public int GetCliffTTCMutSetHash(int id, int version, CliffTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CliffTTCMutSetIncarnation GetCliffTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsCliffTTCMutSet[id].incarnation;
    }
    public CliffTTCMutSet GetCliffTTCMutSet(int id) {
      return new CliffTTCMutSet(this, id);
    }
    public List<CliffTTCMutSet> AllCliffTTCMutSet() {
      List<CliffTTCMutSet> result = new List<CliffTTCMutSet>(rootIncarnation.incarnationsCliffTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsCliffTTCMutSet.Keys) {
        result.Add(new CliffTTCMutSet(this, id));
      }
      return result;
    }
    public bool CliffTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsCliffTTCMutSet.ContainsKey(id);
    }
    public void CheckHasCliffTTCMutSet(CliffTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCliffTTCMutSet(thing.id);
    }
    public void CheckHasCliffTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsCliffTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid CliffTTCMutSet}: " + id);
      }
    }
    public CliffTTCMutSet EffectCliffTTCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new CliffTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateCliffTTCMutSet(id, rootIncarnation.version, incarnation);
      return new CliffTTCMutSet(this, id);
    }
    public void EffectInternalCreateCliffTTCMutSet(int id, int incarnationVersion, CliffTTCMutSetIncarnation incarnation) {
      var effect = new CliffTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsCliffTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<CliffTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsCliffTTCMutSetCreateEffect.Add(effect);
    }
    public void EffectCliffTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new CliffTTCMutSetDeleteEffect(id);
      effectsCliffTTCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsCliffTTCMutSet[id];
      rootIncarnation.incarnationsCliffTTCMutSet.Remove(id);
    }

       
    public void EffectCliffTTCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasCliffTTCMutSet(setId);
      CheckHasCliffTTC(elementId);

      var effect = new CliffTTCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCliffTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new CliffTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCliffTTCMutSet[setId] =
            new VersionAndIncarnation<CliffTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsCliffTTCMutSetAddEffect.Add(effect);
    }
    public void EffectCliffTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasCliffTTCMutSet(setId);
      CheckHasCliffTTC(elementId);

      var effect = new CliffTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCliffTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new CliffTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCliffTTCMutSet[setId] =
            new VersionAndIncarnation<CliffTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsCliffTTCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddCliffTTCMutSetObserver(int id, ICliffTTCMutSetEffectObserver observer) {
      List<ICliffTTCMutSetEffectObserver> obsies;
      if (!observersForCliffTTCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<ICliffTTCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForCliffTTCMutSet[id] = obsies;
    }

    public void RemoveCliffTTCMutSetObserver(int id, ICliffTTCMutSetEffectObserver observer) {
      if (observersForCliffTTCMutSet.ContainsKey(id)) {
        var list = observersForCliffTTCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForCliffTTCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastCliffTTCMutSetEffects(
      SortedDictionary<int, List<ICliffTTCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsCliffTTCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<ICliffTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCliffTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICliffTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCliffTTCMutSetEffect(effect);
        }
        observersForCliffTTCMutSet.Remove(effect.id);
      }
    }
    effectsCliffTTCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsCliffTTCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<ICliffTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCliffTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICliffTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCliffTTCMutSetEffect(effect);
        }
      }
    }
    effectsCliffTTCMutSetAddEffect.Clear();

    foreach (var effect in effectsCliffTTCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<ICliffTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCliffTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICliffTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCliffTTCMutSetEffect(effect);
        }
      }
    }
    effectsCliffTTCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsCliffTTCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<ICliffTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCliffTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICliffTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCliffTTCMutSetEffect(effect);
        }
      }
    }
    effectsCliffTTCMutSetCreateEffect.Clear();

  }

    public int GetRavaNestTTCMutSetHash(int id, int version, RavaNestTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public RavaNestTTCMutSetIncarnation GetRavaNestTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsRavaNestTTCMutSet[id].incarnation;
    }
    public RavaNestTTCMutSet GetRavaNestTTCMutSet(int id) {
      return new RavaNestTTCMutSet(this, id);
    }
    public List<RavaNestTTCMutSet> AllRavaNestTTCMutSet() {
      List<RavaNestTTCMutSet> result = new List<RavaNestTTCMutSet>(rootIncarnation.incarnationsRavaNestTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsRavaNestTTCMutSet.Keys) {
        result.Add(new RavaNestTTCMutSet(this, id));
      }
      return result;
    }
    public bool RavaNestTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsRavaNestTTCMutSet.ContainsKey(id);
    }
    public void CheckHasRavaNestTTCMutSet(RavaNestTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasRavaNestTTCMutSet(thing.id);
    }
    public void CheckHasRavaNestTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsRavaNestTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid RavaNestTTCMutSet}: " + id);
      }
    }
    public RavaNestTTCMutSet EffectRavaNestTTCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new RavaNestTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateRavaNestTTCMutSet(id, rootIncarnation.version, incarnation);
      return new RavaNestTTCMutSet(this, id);
    }
    public void EffectInternalCreateRavaNestTTCMutSet(int id, int incarnationVersion, RavaNestTTCMutSetIncarnation incarnation) {
      var effect = new RavaNestTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsRavaNestTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<RavaNestTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsRavaNestTTCMutSetCreateEffect.Add(effect);
    }
    public void EffectRavaNestTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new RavaNestTTCMutSetDeleteEffect(id);
      effectsRavaNestTTCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsRavaNestTTCMutSet[id];
      rootIncarnation.incarnationsRavaNestTTCMutSet.Remove(id);
    }

       
    public void EffectRavaNestTTCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasRavaNestTTCMutSet(setId);
      CheckHasRavaNestTTC(elementId);

      var effect = new RavaNestTTCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsRavaNestTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new RavaNestTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsRavaNestTTCMutSet[setId] =
            new VersionAndIncarnation<RavaNestTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsRavaNestTTCMutSetAddEffect.Add(effect);
    }
    public void EffectRavaNestTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasRavaNestTTCMutSet(setId);
      CheckHasRavaNestTTC(elementId);

      var effect = new RavaNestTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsRavaNestTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new RavaNestTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsRavaNestTTCMutSet[setId] =
            new VersionAndIncarnation<RavaNestTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsRavaNestTTCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddRavaNestTTCMutSetObserver(int id, IRavaNestTTCMutSetEffectObserver observer) {
      List<IRavaNestTTCMutSetEffectObserver> obsies;
      if (!observersForRavaNestTTCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IRavaNestTTCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForRavaNestTTCMutSet[id] = obsies;
    }

    public void RemoveRavaNestTTCMutSetObserver(int id, IRavaNestTTCMutSetEffectObserver observer) {
      if (observersForRavaNestTTCMutSet.ContainsKey(id)) {
        var list = observersForRavaNestTTCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForRavaNestTTCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastRavaNestTTCMutSetEffects(
      SortedDictionary<int, List<IRavaNestTTCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsRavaNestTTCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IRavaNestTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnRavaNestTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IRavaNestTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnRavaNestTTCMutSetEffect(effect);
        }
        observersForRavaNestTTCMutSet.Remove(effect.id);
      }
    }
    effectsRavaNestTTCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsRavaNestTTCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IRavaNestTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnRavaNestTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IRavaNestTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnRavaNestTTCMutSetEffect(effect);
        }
      }
    }
    effectsRavaNestTTCMutSetAddEffect.Clear();

    foreach (var effect in effectsRavaNestTTCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IRavaNestTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnRavaNestTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IRavaNestTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnRavaNestTTCMutSetEffect(effect);
        }
      }
    }
    effectsRavaNestTTCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsRavaNestTTCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IRavaNestTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnRavaNestTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IRavaNestTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnRavaNestTTCMutSetEffect(effect);
        }
      }
    }
    effectsRavaNestTTCMutSetCreateEffect.Clear();

  }

    public int GetCliffLandingTTCMutSetHash(int id, int version, CliffLandingTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CliffLandingTTCMutSetIncarnation GetCliffLandingTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsCliffLandingTTCMutSet[id].incarnation;
    }
    public CliffLandingTTCMutSet GetCliffLandingTTCMutSet(int id) {
      return new CliffLandingTTCMutSet(this, id);
    }
    public List<CliffLandingTTCMutSet> AllCliffLandingTTCMutSet() {
      List<CliffLandingTTCMutSet> result = new List<CliffLandingTTCMutSet>(rootIncarnation.incarnationsCliffLandingTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsCliffLandingTTCMutSet.Keys) {
        result.Add(new CliffLandingTTCMutSet(this, id));
      }
      return result;
    }
    public bool CliffLandingTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsCliffLandingTTCMutSet.ContainsKey(id);
    }
    public void CheckHasCliffLandingTTCMutSet(CliffLandingTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCliffLandingTTCMutSet(thing.id);
    }
    public void CheckHasCliffLandingTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsCliffLandingTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid CliffLandingTTCMutSet}: " + id);
      }
    }
    public CliffLandingTTCMutSet EffectCliffLandingTTCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new CliffLandingTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateCliffLandingTTCMutSet(id, rootIncarnation.version, incarnation);
      return new CliffLandingTTCMutSet(this, id);
    }
    public void EffectInternalCreateCliffLandingTTCMutSet(int id, int incarnationVersion, CliffLandingTTCMutSetIncarnation incarnation) {
      var effect = new CliffLandingTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsCliffLandingTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<CliffLandingTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsCliffLandingTTCMutSetCreateEffect.Add(effect);
    }
    public void EffectCliffLandingTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new CliffLandingTTCMutSetDeleteEffect(id);
      effectsCliffLandingTTCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsCliffLandingTTCMutSet[id];
      rootIncarnation.incarnationsCliffLandingTTCMutSet.Remove(id);
    }

       
    public void EffectCliffLandingTTCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasCliffLandingTTCMutSet(setId);
      CheckHasCliffLandingTTC(elementId);

      var effect = new CliffLandingTTCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCliffLandingTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new CliffLandingTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCliffLandingTTCMutSet[setId] =
            new VersionAndIncarnation<CliffLandingTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsCliffLandingTTCMutSetAddEffect.Add(effect);
    }
    public void EffectCliffLandingTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasCliffLandingTTCMutSet(setId);
      CheckHasCliffLandingTTC(elementId);

      var effect = new CliffLandingTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCliffLandingTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new CliffLandingTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCliffLandingTTCMutSet[setId] =
            new VersionAndIncarnation<CliffLandingTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsCliffLandingTTCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddCliffLandingTTCMutSetObserver(int id, ICliffLandingTTCMutSetEffectObserver observer) {
      List<ICliffLandingTTCMutSetEffectObserver> obsies;
      if (!observersForCliffLandingTTCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<ICliffLandingTTCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForCliffLandingTTCMutSet[id] = obsies;
    }

    public void RemoveCliffLandingTTCMutSetObserver(int id, ICliffLandingTTCMutSetEffectObserver observer) {
      if (observersForCliffLandingTTCMutSet.ContainsKey(id)) {
        var list = observersForCliffLandingTTCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForCliffLandingTTCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastCliffLandingTTCMutSetEffects(
      SortedDictionary<int, List<ICliffLandingTTCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsCliffLandingTTCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<ICliffLandingTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCliffLandingTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICliffLandingTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCliffLandingTTCMutSetEffect(effect);
        }
        observersForCliffLandingTTCMutSet.Remove(effect.id);
      }
    }
    effectsCliffLandingTTCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsCliffLandingTTCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<ICliffLandingTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCliffLandingTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICliffLandingTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCliffLandingTTCMutSetEffect(effect);
        }
      }
    }
    effectsCliffLandingTTCMutSetAddEffect.Clear();

    foreach (var effect in effectsCliffLandingTTCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<ICliffLandingTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCliffLandingTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICliffLandingTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCliffLandingTTCMutSetEffect(effect);
        }
      }
    }
    effectsCliffLandingTTCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsCliffLandingTTCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<ICliffLandingTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnCliffLandingTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ICliffLandingTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnCliffLandingTTCMutSetEffect(effect);
        }
      }
    }
    effectsCliffLandingTTCMutSetCreateEffect.Clear();

  }

    public int GetStoneTTCMutSetHash(int id, int version, StoneTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public StoneTTCMutSetIncarnation GetStoneTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsStoneTTCMutSet[id].incarnation;
    }
    public StoneTTCMutSet GetStoneTTCMutSet(int id) {
      return new StoneTTCMutSet(this, id);
    }
    public List<StoneTTCMutSet> AllStoneTTCMutSet() {
      List<StoneTTCMutSet> result = new List<StoneTTCMutSet>(rootIncarnation.incarnationsStoneTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsStoneTTCMutSet.Keys) {
        result.Add(new StoneTTCMutSet(this, id));
      }
      return result;
    }
    public bool StoneTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsStoneTTCMutSet.ContainsKey(id);
    }
    public void CheckHasStoneTTCMutSet(StoneTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasStoneTTCMutSet(thing.id);
    }
    public void CheckHasStoneTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsStoneTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid StoneTTCMutSet}: " + id);
      }
    }
    public StoneTTCMutSet EffectStoneTTCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new StoneTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateStoneTTCMutSet(id, rootIncarnation.version, incarnation);
      return new StoneTTCMutSet(this, id);
    }
    public void EffectInternalCreateStoneTTCMutSet(int id, int incarnationVersion, StoneTTCMutSetIncarnation incarnation) {
      var effect = new StoneTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsStoneTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<StoneTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsStoneTTCMutSetCreateEffect.Add(effect);
    }
    public void EffectStoneTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new StoneTTCMutSetDeleteEffect(id);
      effectsStoneTTCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsStoneTTCMutSet[id];
      rootIncarnation.incarnationsStoneTTCMutSet.Remove(id);
    }

       
    public void EffectStoneTTCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasStoneTTCMutSet(setId);
      CheckHasStoneTTC(elementId);

      var effect = new StoneTTCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsStoneTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new StoneTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsStoneTTCMutSet[setId] =
            new VersionAndIncarnation<StoneTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsStoneTTCMutSetAddEffect.Add(effect);
    }
    public void EffectStoneTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasStoneTTCMutSet(setId);
      CheckHasStoneTTC(elementId);

      var effect = new StoneTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsStoneTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new StoneTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsStoneTTCMutSet[setId] =
            new VersionAndIncarnation<StoneTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsStoneTTCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddStoneTTCMutSetObserver(int id, IStoneTTCMutSetEffectObserver observer) {
      List<IStoneTTCMutSetEffectObserver> obsies;
      if (!observersForStoneTTCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IStoneTTCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForStoneTTCMutSet[id] = obsies;
    }

    public void RemoveStoneTTCMutSetObserver(int id, IStoneTTCMutSetEffectObserver observer) {
      if (observersForStoneTTCMutSet.ContainsKey(id)) {
        var list = observersForStoneTTCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForStoneTTCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastStoneTTCMutSetEffects(
      SortedDictionary<int, List<IStoneTTCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsStoneTTCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IStoneTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnStoneTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IStoneTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnStoneTTCMutSetEffect(effect);
        }
        observersForStoneTTCMutSet.Remove(effect.id);
      }
    }
    effectsStoneTTCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsStoneTTCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IStoneTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnStoneTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IStoneTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnStoneTTCMutSetEffect(effect);
        }
      }
    }
    effectsStoneTTCMutSetAddEffect.Clear();

    foreach (var effect in effectsStoneTTCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IStoneTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnStoneTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IStoneTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnStoneTTCMutSetEffect(effect);
        }
      }
    }
    effectsStoneTTCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsStoneTTCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IStoneTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnStoneTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IStoneTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnStoneTTCMutSetEffect(effect);
        }
      }
    }
    effectsStoneTTCMutSetCreateEffect.Clear();

  }

    public int GetGrassTTCMutSetHash(int id, int version, GrassTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public GrassTTCMutSetIncarnation GetGrassTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsGrassTTCMutSet[id].incarnation;
    }
    public GrassTTCMutSet GetGrassTTCMutSet(int id) {
      return new GrassTTCMutSet(this, id);
    }
    public List<GrassTTCMutSet> AllGrassTTCMutSet() {
      List<GrassTTCMutSet> result = new List<GrassTTCMutSet>(rootIncarnation.incarnationsGrassTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsGrassTTCMutSet.Keys) {
        result.Add(new GrassTTCMutSet(this, id));
      }
      return result;
    }
    public bool GrassTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsGrassTTCMutSet.ContainsKey(id);
    }
    public void CheckHasGrassTTCMutSet(GrassTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasGrassTTCMutSet(thing.id);
    }
    public void CheckHasGrassTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsGrassTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid GrassTTCMutSet}: " + id);
      }
    }
    public GrassTTCMutSet EffectGrassTTCMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new GrassTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateGrassTTCMutSet(id, rootIncarnation.version, incarnation);
      return new GrassTTCMutSet(this, id);
    }
    public void EffectInternalCreateGrassTTCMutSet(int id, int incarnationVersion, GrassTTCMutSetIncarnation incarnation) {
      var effect = new GrassTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsGrassTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<GrassTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsGrassTTCMutSetCreateEffect.Add(effect);
    }
    public void EffectGrassTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new GrassTTCMutSetDeleteEffect(id);
      effectsGrassTTCMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsGrassTTCMutSet[id];
      rootIncarnation.incarnationsGrassTTCMutSet.Remove(id);
    }

       
    public void EffectGrassTTCMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasGrassTTCMutSet(setId);
      CheckHasGrassTTC(elementId);

      var effect = new GrassTTCMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsGrassTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new GrassTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsGrassTTCMutSet[setId] =
            new VersionAndIncarnation<GrassTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsGrassTTCMutSetAddEffect.Add(effect);
    }
    public void EffectGrassTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasGrassTTCMutSet(setId);
      CheckHasGrassTTC(elementId);

      var effect = new GrassTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsGrassTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new GrassTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsGrassTTCMutSet[setId] =
            new VersionAndIncarnation<GrassTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsGrassTTCMutSetRemoveEffect.Add(effect);
    }

       
    public void AddGrassTTCMutSetObserver(int id, IGrassTTCMutSetEffectObserver observer) {
      List<IGrassTTCMutSetEffectObserver> obsies;
      if (!observersForGrassTTCMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IGrassTTCMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForGrassTTCMutSet[id] = obsies;
    }

    public void RemoveGrassTTCMutSetObserver(int id, IGrassTTCMutSetEffectObserver observer) {
      if (observersForGrassTTCMutSet.ContainsKey(id)) {
        var list = observersForGrassTTCMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForGrassTTCMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastGrassTTCMutSetEffects(
      SortedDictionary<int, List<IGrassTTCMutSetEffectObserver>> observers) {
    foreach (var effect in effectsGrassTTCMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IGrassTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnGrassTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IGrassTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnGrassTTCMutSetEffect(effect);
        }
        observersForGrassTTCMutSet.Remove(effect.id);
      }
    }
    effectsGrassTTCMutSetDeleteEffect.Clear();

    foreach (var effect in effectsGrassTTCMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IGrassTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnGrassTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IGrassTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnGrassTTCMutSetEffect(effect);
        }
      }
    }
    effectsGrassTTCMutSetAddEffect.Clear();

    foreach (var effect in effectsGrassTTCMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IGrassTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnGrassTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IGrassTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnGrassTTCMutSetEffect(effect);
        }
      }
    }
    effectsGrassTTCMutSetRemoveEffect.Clear();

    foreach (var effect in effectsGrassTTCMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IGrassTTCMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnGrassTTCMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IGrassTTCMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnGrassTTCMutSetEffect(effect);
        }
      }
    }
    effectsGrassTTCMutSetCreateEffect.Clear();

  }

    public int GetUnitMutSetHash(int id, int version, UnitMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public UnitMutSetIncarnation GetUnitMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsUnitMutSet[id].incarnation;
    }
    public UnitMutSet GetUnitMutSet(int id) {
      return new UnitMutSet(this, id);
    }
    public List<UnitMutSet> AllUnitMutSet() {
      List<UnitMutSet> result = new List<UnitMutSet>(rootIncarnation.incarnationsUnitMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsUnitMutSet.Keys) {
        result.Add(new UnitMutSet(this, id));
      }
      return result;
    }
    public bool UnitMutSetExists(int id) {
      return rootIncarnation.incarnationsUnitMutSet.ContainsKey(id);
    }
    public void CheckHasUnitMutSet(UnitMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasUnitMutSet(thing.id);
    }
    public void CheckHasUnitMutSet(int id) {
      if (!rootIncarnation.incarnationsUnitMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid UnitMutSet}: " + id);
      }
    }
    public UnitMutSet EffectUnitMutSetCreate() {
      CheckUnlocked();
      var id = NewId();
      var incarnation = new UnitMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateUnitMutSet(id, rootIncarnation.version, incarnation);
      return new UnitMutSet(this, id);
    }
    public void EffectInternalCreateUnitMutSet(int id, int incarnationVersion, UnitMutSetIncarnation incarnation) {
      var effect = new UnitMutSetCreateEffect(id);
      rootIncarnation.incarnationsUnitMutSet
          .Add(
              id,
              new VersionAndIncarnation<UnitMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsUnitMutSetCreateEffect.Add(effect);
    }
    public void EffectUnitMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new UnitMutSetDeleteEffect(id);
      effectsUnitMutSetDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsUnitMutSet[id];
      rootIncarnation.incarnationsUnitMutSet.Remove(id);
    }

       
    public void EffectUnitMutSetAdd(int setId, int elementId) {
      CheckUnlocked();
      CheckHasUnitMutSet(setId);
      CheckHasUnit(elementId);

      var effect = new UnitMutSetAddEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsUnitMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(elementId);
        var newIncarnation = new UnitMutSetIncarnation(newMap);
        rootIncarnation.incarnationsUnitMutSet[setId] =
            new VersionAndIncarnation<UnitMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsUnitMutSetAddEffect.Add(effect);
    }
    public void EffectUnitMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasUnitMutSet(setId);
      CheckHasUnit(elementId);

      var effect = new UnitMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsUnitMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new UnitMutSetIncarnation(newMap);
        rootIncarnation.incarnationsUnitMutSet[setId] =
            new VersionAndIncarnation<UnitMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsUnitMutSetRemoveEffect.Add(effect);
    }

       
    public void AddUnitMutSetObserver(int id, IUnitMutSetEffectObserver observer) {
      List<IUnitMutSetEffectObserver> obsies;
      if (!observersForUnitMutSet.TryGetValue(id, out obsies)) {
        obsies = new List<IUnitMutSetEffectObserver>();
      }
      obsies.Add(observer);
      observersForUnitMutSet[id] = obsies;
    }

    public void RemoveUnitMutSetObserver(int id, IUnitMutSetEffectObserver observer) {
      if (observersForUnitMutSet.ContainsKey(id)) {
        var list = observersForUnitMutSet[id];
        list.Remove(observer);
        if (list.Count == 0) {
          observersForUnitMutSet.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }
       
  public void BroadcastUnitMutSetEffects(
      SortedDictionary<int, List<IUnitMutSetEffectObserver>> observers) {
    foreach (var effect in effectsUnitMutSetDeleteEffect) {
      if (observers.TryGetValue(0, out List<IUnitMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnUnitMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IUnitMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnUnitMutSetEffect(effect);
        }
        observersForUnitMutSet.Remove(effect.id);
      }
    }
    effectsUnitMutSetDeleteEffect.Clear();

    foreach (var effect in effectsUnitMutSetAddEffect) {
      if (observers.TryGetValue(0, out List<IUnitMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnUnitMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IUnitMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnUnitMutSetEffect(effect);
        }
      }
    }
    effectsUnitMutSetAddEffect.Clear();

    foreach (var effect in effectsUnitMutSetRemoveEffect) {
      if (observers.TryGetValue(0, out List<IUnitMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnUnitMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IUnitMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnUnitMutSetEffect(effect);
        }
      }
    }
    effectsUnitMutSetRemoveEffect.Clear();

    foreach (var effect in effectsUnitMutSetCreateEffect) {
      if (observers.TryGetValue(0, out List<IUnitMutSetEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnUnitMutSetEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<IUnitMutSetEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnUnitMutSetEffect(effect);
        }
      }
    }
    effectsUnitMutSetCreateEffect.Clear();

  }

    public int GetTerrainTileByLocationMutMapHash(int id, int version, TerrainTileByLocationMutMapIncarnation incarnation) {
      int result = id * version;
      foreach (var entry in incarnation.map) {
        result += id * version * entry.Key.GetDeterministicHashCode() * entry.Value.GetDeterministicHashCode();
      }
      return result;
    }
    public TerrainTileByLocationMutMapIncarnation GetTerrainTileByLocationMutMapIncarnation(int id) {
      return rootIncarnation.incarnationsTerrainTileByLocationMutMap[id].incarnation;
    }
    public TerrainTileByLocationMutMap GetTerrainTileByLocationMutMap(int id) {
      return new TerrainTileByLocationMutMap(this, id);
    }
    public List<TerrainTileByLocationMutMap> AllTerrainTileByLocationMutMap() {
      List<TerrainTileByLocationMutMap> result = new List<TerrainTileByLocationMutMap>(rootIncarnation.incarnationsTerrainTileByLocationMutMap.Count);
      foreach (var id in rootIncarnation.incarnationsTerrainTileByLocationMutMap.Keys) {
        result.Add(new TerrainTileByLocationMutMap(this, id));
      }
      return result;
    }
    public bool TerrainTileByLocationMutMapExists(int id) {
      return rootIncarnation.incarnationsTerrainTileByLocationMutMap.ContainsKey(id);
    }
    public void CheckHasTerrainTileByLocationMutMap(TerrainTileByLocationMutMap thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasTerrainTileByLocationMutMap(thing.id);
    }
    public void CheckHasTerrainTileByLocationMutMap(int id) {
      if (!rootIncarnation.incarnationsTerrainTileByLocationMutMap.ContainsKey(id)) {
        throw new System.Exception("Invalid TerrainTileByLocationMutMap}: " + id);
      }
    }
    public TerrainTileByLocationMutMap EffectTerrainTileByLocationMutMapCreate() {
      CheckUnlocked();
      var id = NewId();
      EffectInternalCreateTerrainTileByLocationMutMap(
          id,
          rootIncarnation.version,
          new TerrainTileByLocationMutMapIncarnation(
              new SortedDictionary<Location, int>()));
      return new TerrainTileByLocationMutMap(this, id);
    }
       
    public void EffectInternalCreateTerrainTileByLocationMutMap(int id, int incarnationVersion, TerrainTileByLocationMutMapIncarnation incarnation) {
      var effect = new TerrainTileByLocationMutMapCreateEffect(id);
      rootIncarnation.incarnationsTerrainTileByLocationMutMap
          .Add(
              id,
              new VersionAndIncarnation<TerrainTileByLocationMutMapIncarnation>(
                  incarnationVersion,
                  incarnation));
      effectsTerrainTileByLocationMutMapCreateEffect.Add(effect);
    }
    public void EffectTerrainTileByLocationMutMapDelete(int id) {
      CheckUnlocked();
      var effect = new TerrainTileByLocationMutMapDeleteEffect(id);
      effectsTerrainTileByLocationMutMapDeleteEffect.Add(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsTerrainTileByLocationMutMap[id];
      rootIncarnation.incarnationsTerrainTileByLocationMutMap.Remove(id);
    }
    public void EffectTerrainTileByLocationMutMapAdd(int mapId, Location key, int value) {
      CheckUnlocked();
      CheckHasTerrainTileByLocationMutMap(mapId);
      CheckHasTerrainTile(value);

      var effect = new TerrainTileByLocationMutMapAddEffect(mapId, key, value);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTerrainTileByLocationMutMap[mapId];
      if (oldIncarnationAndVersion.incarnation.map.ContainsKey(key)) {
        throw new Exception("Key exists! " + key);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.map.Add(key, value);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.map;
        var newMap = new SortedDictionary<Location, int>(oldMap);
        newMap.Add(key, value);
        var newIncarnation = new TerrainTileByLocationMutMapIncarnation(newMap);
        rootIncarnation.incarnationsTerrainTileByLocationMutMap[mapId] =
            new VersionAndIncarnation<TerrainTileByLocationMutMapIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      effectsTerrainTileByLocationMutMapAddEffect.Add(effect);
    }
       
    public void EffectTerrainTileByLocationMutMapRemove(int mapId, Location key) {
      CheckUnlocked();
      CheckHasTerrainTileByLocationMutMap(mapId);

      var effect = new TerrainTileByLocationMutMapRemoveEffect(mapId, key);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTerrainTileByLocationMutMap[mapId];
      if (!oldIncarnationAndVersion.incarnation.map.ContainsKey(key)) {
        throw new Exception("Key doesnt exist! " + key);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        var oldValue = oldIncarnationAndVersion.incarnation.map[key];
        oldIncarnationAndVersion.incarnation.map.Remove(key);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.map;
        var newMap = new SortedDictionary<Location, int>(oldMap);
        newMap.Remove(key);
        var newIncarnation = new TerrainTileByLocationMutMapIncarnation(newMap);
        rootIncarnation.incarnationsTerrainTileByLocationMutMap[mapId] =
            new VersionAndIncarnation<TerrainTileByLocationMutMapIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      effectsTerrainTileByLocationMutMapRemoveEffect.Add(effect);
    }
    public void AddTerrainTileByLocationMutMapObserver(int id, ITerrainTileByLocationMutMapEffectObserver observer) {
      List<ITerrainTileByLocationMutMapEffectObserver> obsies;
      if (!observersForTerrainTileByLocationMutMap.TryGetValue(id, out obsies)) {
        obsies = new List<ITerrainTileByLocationMutMapEffectObserver>();
      }
      obsies.Add(observer);
      observersForTerrainTileByLocationMutMap[id] = obsies;
    }

    public void RemoveTerrainTileByLocationMutMapObserver(int id, ITerrainTileByLocationMutMapEffectObserver observer) {
      if (observersForTerrainTileByLocationMutMap.ContainsKey(id)) {
        var map = observersForTerrainTileByLocationMutMap[id];
        map.Remove(observer);
        if (map.Count == 0) {
          observersForTerrainTileByLocationMutMap.Remove(id);
        }
      } else {
        throw new Exception("Couldnt find!");
      }
    }

  public void BroadcastTerrainTileByLocationMutMapEffects(
      SortedDictionary<int, List<ITerrainTileByLocationMutMapEffectObserver>> observers) {
    foreach (var effect in effectsTerrainTileByLocationMutMapDeleteEffect) {
      if (observers.TryGetValue(0, out List<ITerrainTileByLocationMutMapEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTerrainTileByLocationMutMapEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITerrainTileByLocationMutMapEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTerrainTileByLocationMutMapEffect(effect);
        }
        observersForTerrainTileByLocationMutMap.Remove(effect.id);
      }
    }
    effectsTerrainTileByLocationMutMapDeleteEffect.Clear();

    foreach (var effect in effectsTerrainTileByLocationMutMapAddEffect) {
      if (observers.TryGetValue(0, out List<ITerrainTileByLocationMutMapEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTerrainTileByLocationMutMapEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITerrainTileByLocationMutMapEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTerrainTileByLocationMutMapEffect(effect);
        }
      }
    }
    effectsTerrainTileByLocationMutMapAddEffect.Clear();

    foreach (var effect in effectsTerrainTileByLocationMutMapRemoveEffect) {
      if (observers.TryGetValue(0, out List<ITerrainTileByLocationMutMapEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTerrainTileByLocationMutMapEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITerrainTileByLocationMutMapEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTerrainTileByLocationMutMapEffect(effect);
        }
      }
    }
    effectsTerrainTileByLocationMutMapRemoveEffect.Clear();

    foreach (var effect in effectsTerrainTileByLocationMutMapCreateEffect) {
      if (observers.TryGetValue(0, out List<ITerrainTileByLocationMutMapEffectObserver> globalObservers)) {
        foreach (var observer in globalObservers) {
          observer.OnTerrainTileByLocationMutMapEffect(effect);
        }
      }
      if (observers.TryGetValue(effect.id, out List<ITerrainTileByLocationMutMapEffectObserver> objObservers)) {
        foreach (var observer in objObservers) {
          observer.OnTerrainTileByLocationMutMapEffect(effect);
        }
      }
    }
    effectsTerrainTileByLocationMutMapCreateEffect.Clear();

  }
}

}
