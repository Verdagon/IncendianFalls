using System;
using System.Collections;

using System.Collections.Generic;

namespace Atharia.Model {

public interface ILogger {
  void Info(string str);
  void Warning(string str);
  void Error(string str);
}

public struct VersionAndIncarnation<T> {
  public int version;
  public T incarnation;
  public VersionAndIncarnation(int version, T incarnation) {
    this.version = version;
    this.incarnation = incarnation;
  }
}

public delegate void IEffectObserver(IEffect effect);

public interface IEffect {
  // True for deletes/removes, false for creates/adds/sets.
  bool isSubtractive();
  void visitIEffect(IEffectVisitor visitor);
}

public interface IEffectVisitor {
void visitRandEffect(IRandEffect effect);
void visitHoldPositionImpulseEffect(IHoldPositionImpulseEffect effect);
void visitWanderAICapabilityUCEffect(IWanderAICapabilityUCEffect effect);
void visitTutorialDefyCounterUCEffect(ITutorialDefyCounterUCEffect effect);
void visitUnitEffect(IUnitEffect effect);
void visitIUnitComponentMutBunchEffect(IIUnitComponentMutBunchEffect effect);
void visitLightningChargedUCEffect(ILightningChargedUCEffect effect);
void visitLightningChargingUCEffect(ILightningChargingUCEffect effect);
void visitDoomedUCEffect(IDoomedUCEffect effect);
void visitTemporaryCloneImpulseEffect(ITemporaryCloneImpulseEffect effect);
void visitTemporaryCloneAICapabilityUCEffect(ITemporaryCloneAICapabilityUCEffect effect);
void visitSummonImpulseEffect(ISummonImpulseEffect effect);
void visitSummonAICapabilityUCEffect(ISummonAICapabilityUCEffect effect);
void visitSorcerousUCEffect(ISorcerousUCEffect effect);
void visitBaseOffenseUCEffect(IBaseOffenseUCEffect effect);
void visitBaseSightRangeUCEffect(IBaseSightRangeUCEffect effect);
void visitBaseMovementTimeUCEffect(IBaseMovementTimeUCEffect effect);
void visitBaseDefenseUCEffect(IBaseDefenseUCEffect effect);
void visitBaseCombatTimeUCEffect(IBaseCombatTimeUCEffect effect);
void visitMiredUCEffect(IMiredUCEffect effect);
void visitMireImpulseEffect(IMireImpulseEffect effect);
void visitEvaporateImpulseEffect(IEvaporateImpulseEffect effect);
void visitTimeCloneAICapabilityUCEffect(ITimeCloneAICapabilityUCEffect effect);
void visitMoveImpulseEffect(IMoveImpulseEffect effect);
void visitKamikazeTargetTTCEffect(IKamikazeTargetTTCEffect effect);
void visitKamikazeJumpImpulseEffect(IKamikazeJumpImpulseEffect effect);
void visitKamikazeTargetImpulseEffect(IKamikazeTargetImpulseEffect effect);
void visitKamikazeAICapabilityUCEffect(IKamikazeAICapabilityUCEffect effect);
void visitInvincibilityUCEffect(IInvincibilityUCEffect effect);
void visitGuardAICapabilityUCEffect(IGuardAICapabilityUCEffect effect);
void visitNoImpulseEffect(INoImpulseEffect effect);
void visitFireImpulseEffect(IFireImpulseEffect effect);
void visitDefyingUCEffect(IDefyingUCEffect effect);
void visitDefyImpulseEffect(IDefyImpulseEffect effect);
void visitCounteringUCEffect(ICounteringUCEffect effect);
void visitCounterImpulseEffect(ICounterImpulseEffect effect);
void visitUnleashBideImpulseEffect(IUnleashBideImpulseEffect effect);
void visitContinueBidingImpulseEffect(IContinueBidingImpulseEffect effect);
void visitStartBidingImpulseEffect(IStartBidingImpulseEffect effect);
void visitBideAICapabilityUCEffect(IBideAICapabilityUCEffect effect);
void visitAttackImpulseEffect(IAttackImpulseEffect effect);
void visitPursueImpulseEffect(IPursueImpulseEffect effect);
void visitKillDirectiveEffect(IKillDirectiveEffect effect);
void visitAttackAICapabilityUCEffect(IAttackAICapabilityUCEffect effect);
void visitWarperTTCEffect(IWarperTTCEffect effect);
void visitTimeAnchorTTCEffect(ITimeAnchorTTCEffect effect);
void visitTerrainTileEffect(ITerrainTileEffect effect);
void visitITerrainTileComponentMutBunchEffect(IITerrainTileComponentMutBunchEffect effect);
void visitTerrainEffect(ITerrainEffect effect);
void visitSimplePresenceTriggerTTCEffect(ISimplePresenceTriggerTTCEffect effect);
void visitFireBombImpulseEffect(IFireBombImpulseEffect effect);
void visitFireBombTTCEffect(IFireBombTTCEffect effect);
void visitMarkerTTCEffect(IMarkerTTCEffect effect);
void visitLevelLinkTTCEffect(ILevelLinkTTCEffect effect);
void visitMudTTCEffect(IMudTTCEffect effect);
void visitDirtTTCEffect(IDirtTTCEffect effect);
void visitObsidianTTCEffect(IObsidianTTCEffect effect);
void visitDownStairsTTCEffect(IDownStairsTTCEffect effect);
void visitUpStairsTTCEffect(IUpStairsTTCEffect effect);
void visitWallTTCEffect(IWallTTCEffect effect);
void visitBloodTTCEffect(IBloodTTCEffect effect);
void visitRocksTTCEffect(IRocksTTCEffect effect);
void visitTreeTTCEffect(ITreeTTCEffect effect);
void visitWaterTTCEffect(IWaterTTCEffect effect);
void visitFloorTTCEffect(IFloorTTCEffect effect);
void visitCaveWallTTCEffect(ICaveWallTTCEffect effect);
void visitCaveTTCEffect(ICaveTTCEffect effect);
void visitFallsTTCEffect(IFallsTTCEffect effect);
void visitFireTTCEffect(IFireTTCEffect effect);
void visitObsidianFloorTTCEffect(IObsidianFloorTTCEffect effect);
void visitMagmaTTCEffect(IMagmaTTCEffect effect);
void visitCliffTTCEffect(ICliffTTCEffect effect);
void visitRavaNestTTCEffect(IRavaNestTTCEffect effect);
void visitCliffLandingTTCEffect(ICliffLandingTTCEffect effect);
void visitStoneTTCEffect(IStoneTTCEffect effect);
void visitGrassTTCEffect(IGrassTTCEffect effect);
void visitLevelEffect(ILevelEffect effect);
void visitSpeedRingEffect(ISpeedRingEffect effect);
void visitManaPotionEffect(IManaPotionEffect effect);
void visitWatEffect(IWatEffect effect);
void visitIPreActingUCWeakMutBunchEffect(IIPreActingUCWeakMutBunchEffect effect);
void visitIPostActingUCWeakMutBunchEffect(IIPostActingUCWeakMutBunchEffect effect);
void visitIImpulseStrongMutBunchEffect(IIImpulseStrongMutBunchEffect effect);
void visitIItemStrongMutBunchEffect(IIItemStrongMutBunchEffect effect);
void visitItemTTCEffect(IItemTTCEffect effect);
void visitHealthPotionEffect(IHealthPotionEffect effect);
void visitGlaiveEffect(IGlaiveEffect effect);
void visitSlowRodEffect(ISlowRodEffect effect);
void visitBlastRodEffect(IBlastRodEffect effect);
void visitArmorEffect(IArmorEffect effect);
void visitSquareCaveLevelControllerEffect(ISquareCaveLevelControllerEffect effect);
void visitRavashrikeLevelControllerEffect(IRavashrikeLevelControllerEffect effect);
void visitPentagonalCaveLevelControllerEffect(IPentagonalCaveLevelControllerEffect effect);
void visitIncendianFallsLevelLinkerTTCEffect(IIncendianFallsLevelLinkerTTCEffect effect);
void visitCliffLevelControllerEffect(ICliffLevelControllerEffect effect);
void visitPreGauntletLevelControllerEffect(IPreGauntletLevelControllerEffect effect);
void visitGauntletLevelControllerEffect(IGauntletLevelControllerEffect effect);
void visitCommEffect(ICommEffect effect);
void visitGameEffect(IGameEffect effect);
void visitVolcaetusLevelControllerEffect(IVolcaetusLevelControllerEffect effect);
void visitTutorial2LevelControllerEffect(ITutorial2LevelControllerEffect effect);
void visitTutorial1LevelControllerEffect(ITutorial1LevelControllerEffect effect);
void visitRetreatLevelControllerEffect(IRetreatLevelControllerEffect effect);
void visitSotaventoLevelControllerEffect(ISotaventoLevelControllerEffect effect);
void visitNestLevelControllerEffect(INestLevelControllerEffect effect);
void visitLakeLevelControllerEffect(ILakeLevelControllerEffect effect);
void visitEmberDeepLevelLinkerTTCEffect(IEmberDeepLevelLinkerTTCEffect effect);
void visitDirtRoadLevelControllerEffect(IDirtRoadLevelControllerEffect effect);
void visitCaveLevelControllerEffect(ICaveLevelControllerEffect effect);
void visitBridgesLevelControllerEffect(IBridgesLevelControllerEffect effect);
void visitAncientTownLevelControllerEffect(IAncientTownLevelControllerEffect effect);
void visitCommMutListEffect(ICommMutListEffect effect);
void visitLocationMutListEffect(ILocationMutListEffect effect);
void visitIRequestMutListEffect(IIRequestMutListEffect effect);
void visitLevelMutSetEffect(ILevelMutSetEffect effect);
void visitManaPotionStrongMutSetEffect(IManaPotionStrongMutSetEffect effect);
void visitHealthPotionStrongMutSetEffect(IHealthPotionStrongMutSetEffect effect);
void visitSpeedRingStrongMutSetEffect(ISpeedRingStrongMutSetEffect effect);
void visitGlaiveStrongMutSetEffect(IGlaiveStrongMutSetEffect effect);
void visitSlowRodStrongMutSetEffect(ISlowRodStrongMutSetEffect effect);
void visitBlastRodStrongMutSetEffect(IBlastRodStrongMutSetEffect effect);
void visitArmorStrongMutSetEffect(IArmorStrongMutSetEffect effect);
void visitHoldPositionImpulseStrongMutSetEffect(IHoldPositionImpulseStrongMutSetEffect effect);
void visitTemporaryCloneImpulseStrongMutSetEffect(ITemporaryCloneImpulseStrongMutSetEffect effect);
void visitSummonImpulseStrongMutSetEffect(ISummonImpulseStrongMutSetEffect effect);
void visitMireImpulseStrongMutSetEffect(IMireImpulseStrongMutSetEffect effect);
void visitEvaporateImpulseStrongMutSetEffect(IEvaporateImpulseStrongMutSetEffect effect);
void visitMoveImpulseStrongMutSetEffect(IMoveImpulseStrongMutSetEffect effect);
void visitKamikazeJumpImpulseStrongMutSetEffect(IKamikazeJumpImpulseStrongMutSetEffect effect);
void visitKamikazeTargetImpulseStrongMutSetEffect(IKamikazeTargetImpulseStrongMutSetEffect effect);
void visitNoImpulseStrongMutSetEffect(INoImpulseStrongMutSetEffect effect);
void visitFireImpulseStrongMutSetEffect(IFireImpulseStrongMutSetEffect effect);
void visitDefyImpulseStrongMutSetEffect(IDefyImpulseStrongMutSetEffect effect);
void visitCounterImpulseStrongMutSetEffect(ICounterImpulseStrongMutSetEffect effect);
void visitUnleashBideImpulseStrongMutSetEffect(IUnleashBideImpulseStrongMutSetEffect effect);
void visitContinueBidingImpulseStrongMutSetEffect(IContinueBidingImpulseStrongMutSetEffect effect);
void visitStartBidingImpulseStrongMutSetEffect(IStartBidingImpulseStrongMutSetEffect effect);
void visitAttackImpulseStrongMutSetEffect(IAttackImpulseStrongMutSetEffect effect);
void visitPursueImpulseStrongMutSetEffect(IPursueImpulseStrongMutSetEffect effect);
void visitFireBombImpulseStrongMutSetEffect(IFireBombImpulseStrongMutSetEffect effect);
void visitLightningChargedUCWeakMutSetEffect(ILightningChargedUCWeakMutSetEffect effect);
void visitTimeCloneAICapabilityUCWeakMutSetEffect(ITimeCloneAICapabilityUCWeakMutSetEffect effect);
void visitDoomedUCWeakMutSetEffect(IDoomedUCWeakMutSetEffect effect);
void visitMiredUCWeakMutSetEffect(IMiredUCWeakMutSetEffect effect);
void visitInvincibilityUCWeakMutSetEffect(IInvincibilityUCWeakMutSetEffect effect);
void visitDefyingUCWeakMutSetEffect(IDefyingUCWeakMutSetEffect effect);
void visitCounteringUCWeakMutSetEffect(ICounteringUCWeakMutSetEffect effect);
void visitAttackAICapabilityUCWeakMutSetEffect(IAttackAICapabilityUCWeakMutSetEffect effect);
void visitUnitMutSetEffect(IUnitMutSetEffect effect);
void visitSimplePresenceTriggerTTCMutSetEffect(ISimplePresenceTriggerTTCMutSetEffect effect);
void visitItemTTCMutSetEffect(IItemTTCMutSetEffect effect);
void visitKamikazeTargetTTCMutSetEffect(IKamikazeTargetTTCMutSetEffect effect);
void visitWarperTTCMutSetEffect(IWarperTTCMutSetEffect effect);
void visitTimeAnchorTTCMutSetEffect(ITimeAnchorTTCMutSetEffect effect);
void visitFireBombTTCMutSetEffect(IFireBombTTCMutSetEffect effect);
void visitMarkerTTCMutSetEffect(IMarkerTTCMutSetEffect effect);
void visitLevelLinkTTCMutSetEffect(ILevelLinkTTCMutSetEffect effect);
void visitMudTTCMutSetEffect(IMudTTCMutSetEffect effect);
void visitDirtTTCMutSetEffect(IDirtTTCMutSetEffect effect);
void visitObsidianTTCMutSetEffect(IObsidianTTCMutSetEffect effect);
void visitDownStairsTTCMutSetEffect(IDownStairsTTCMutSetEffect effect);
void visitUpStairsTTCMutSetEffect(IUpStairsTTCMutSetEffect effect);
void visitWallTTCMutSetEffect(IWallTTCMutSetEffect effect);
void visitBloodTTCMutSetEffect(IBloodTTCMutSetEffect effect);
void visitRocksTTCMutSetEffect(IRocksTTCMutSetEffect effect);
void visitTreeTTCMutSetEffect(ITreeTTCMutSetEffect effect);
void visitWaterTTCMutSetEffect(IWaterTTCMutSetEffect effect);
void visitFloorTTCMutSetEffect(IFloorTTCMutSetEffect effect);
void visitCaveWallTTCMutSetEffect(ICaveWallTTCMutSetEffect effect);
void visitCaveTTCMutSetEffect(ICaveTTCMutSetEffect effect);
void visitFallsTTCMutSetEffect(IFallsTTCMutSetEffect effect);
void visitFireTTCMutSetEffect(IFireTTCMutSetEffect effect);
void visitObsidianFloorTTCMutSetEffect(IObsidianFloorTTCMutSetEffect effect);
void visitMagmaTTCMutSetEffect(IMagmaTTCMutSetEffect effect);
void visitCliffTTCMutSetEffect(ICliffTTCMutSetEffect effect);
void visitRavaNestTTCMutSetEffect(IRavaNestTTCMutSetEffect effect);
void visitCliffLandingTTCMutSetEffect(ICliffLandingTTCMutSetEffect effect);
void visitStoneTTCMutSetEffect(IStoneTTCMutSetEffect effect);
void visitGrassTTCMutSetEffect(IGrassTTCMutSetEffect effect);
void visitIncendianFallsLevelLinkerTTCMutSetEffect(IIncendianFallsLevelLinkerTTCMutSetEffect effect);
void visitEmberDeepLevelLinkerTTCMutSetEffect(IEmberDeepLevelLinkerTTCMutSetEffect effect);
void visitTutorialDefyCounterUCMutSetEffect(ITutorialDefyCounterUCMutSetEffect effect);
void visitLightningChargingUCMutSetEffect(ILightningChargingUCMutSetEffect effect);
void visitWanderAICapabilityUCMutSetEffect(IWanderAICapabilityUCMutSetEffect effect);
void visitTemporaryCloneAICapabilityUCMutSetEffect(ITemporaryCloneAICapabilityUCMutSetEffect effect);
void visitSummonAICapabilityUCMutSetEffect(ISummonAICapabilityUCMutSetEffect effect);
void visitKamikazeAICapabilityUCMutSetEffect(IKamikazeAICapabilityUCMutSetEffect effect);
void visitGuardAICapabilityUCMutSetEffect(IGuardAICapabilityUCMutSetEffect effect);
void visitTimeCloneAICapabilityUCMutSetEffect(ITimeCloneAICapabilityUCMutSetEffect effect);
void visitDoomedUCMutSetEffect(IDoomedUCMutSetEffect effect);
void visitMiredUCMutSetEffect(IMiredUCMutSetEffect effect);
void visitAttackAICapabilityUCMutSetEffect(IAttackAICapabilityUCMutSetEffect effect);
void visitCounteringUCMutSetEffect(ICounteringUCMutSetEffect effect);
void visitLightningChargedUCMutSetEffect(ILightningChargedUCMutSetEffect effect);
void visitInvincibilityUCMutSetEffect(IInvincibilityUCMutSetEffect effect);
void visitDefyingUCMutSetEffect(IDefyingUCMutSetEffect effect);
void visitBideAICapabilityUCMutSetEffect(IBideAICapabilityUCMutSetEffect effect);
void visitBaseSightRangeUCMutSetEffect(IBaseSightRangeUCMutSetEffect effect);
void visitBaseMovementTimeUCMutSetEffect(IBaseMovementTimeUCMutSetEffect effect);
void visitBaseCombatTimeUCMutSetEffect(IBaseCombatTimeUCMutSetEffect effect);
void visitManaPotionMutSetEffect(IManaPotionMutSetEffect effect);
void visitHealthPotionMutSetEffect(IHealthPotionMutSetEffect effect);
void visitSpeedRingMutSetEffect(ISpeedRingMutSetEffect effect);
void visitGlaiveMutSetEffect(IGlaiveMutSetEffect effect);
void visitSlowRodMutSetEffect(ISlowRodMutSetEffect effect);
void visitBlastRodMutSetEffect(IBlastRodMutSetEffect effect);
void visitArmorMutSetEffect(IArmorMutSetEffect effect);
void visitSorcerousUCMutSetEffect(ISorcerousUCMutSetEffect effect);
void visitBaseOffenseUCMutSetEffect(IBaseOffenseUCMutSetEffect effect);
void visitBaseDefenseUCMutSetEffect(IBaseDefenseUCMutSetEffect effect);
void visitTerrainTileByLocationMutMapEffect(ITerrainTileByLocationMutMapEffect effect);
void visitKamikazeTargetTTCStrongByLocationMutMapEffect(IKamikazeTargetTTCStrongByLocationMutMapEffect effect);

}

public class Root {
  private static readonly int VERSION_HASH_MULTIPLIER = 179424673;
  private static readonly int NEXT_ID_HASH_MULTIPLIER = 373587883;

  private void CheckRootsEqual(Root a, Root b) {
    if (a != b) {
      throw new System.Exception("Given objects aren't from the same root!");
    }
  }

  public readonly ILogger logger;

  public List<IEffectObserver> effectObservers;

  // This *always* points to a live RootIncarnation. When we snapshot, we eagerly
  // make a new one of these.
  private RootIncarnation rootIncarnation;

  bool locked;

  // 0 means everything
  public Root(ILogger logger) {
    this.logger = logger;
    this.effectObservers = new List<IEffectObserver>();
    int initialVersion = 1;
    int initialNextId = 1;
    int initialHash = VERSION_HASH_MULTIPLIER * initialVersion + NEXT_ID_HASH_MULTIPLIER * initialNextId;
    rootIncarnation = new RootIncarnation(initialVersion, initialNextId, initialHash);
    this.locked = true;
  }

  public Root(ILogger logger, RootIncarnation rootIncarnation) {
    this.logger = logger;
    this.rootIncarnation = rootIncarnation;
    this.locked = false;
    this.Snapshot();
    this.locked = true;
  }

  public int nextId { get { return rootIncarnation.nextId; } }

  public int version { get { return rootIncarnation.version; } }

  public void AddObserver(IEffectObserver obs) {
    effectObservers.Add(obs);
  }

  public void RemoveObserver(IEffectObserver obs) {
    effectObservers.Remove(obs);
  }

  private void NotifyEffect(IEffect effect) {
    foreach (var obs in effectObservers) {
      obs(effect);
    }
  }

  public RootIncarnation Snapshot() {
    CheckUnlocked();
    RootIncarnation oldIncarnation = rootIncarnation;
    int newHash = oldIncarnation.hash;
    int newVersion = oldIncarnation.version + 1;
    rootIncarnation =
        new RootIncarnation(
            newVersion, oldIncarnation.nextId, newHash, oldIncarnation);
    return oldIncarnation;
  }

  public delegate T ITransaction<T>();

  public (List<IEffect>, T) Transact<T>(ITransaction<T> transaction) {
    var stopwatch = new System.Diagnostics.Stopwatch();
    stopwatch.Start();

    if (!locked) {
      throw new Exception("Can't unlock, not locked!");
    }
    locked = false;
    // var rollbackPoint = Snapshot();

    var effects = new List<IEffect>();
    IEffectObserver effectObserver = (effect) => effects.Add(effect);
    AddObserver(effectObserver);

    try {
      var result = transaction();
      return (effects, result);
    } catch (Exception e) {
      // logger.Error("Rolling back because of error: " + e.Message + "\n" + e.StackTrace);
      // Revert(rollbackPoint);
      logger.Error("Encountered error in transaction: " + e.Message + "\n" + e.StackTrace);
      throw;
    } finally {
      RemoveObserver(effectObserver);
      if (locked) {
        logger.Error("Can't lock, already locked!");
        Environment.Exit(1);
      }
      locked = true;
      // CheckForViolations();

      stopwatch.Stop();
      var calculationDuration = stopwatch.Elapsed.TotalMilliseconds;

      logger.Info("Transaction run time " + calculationDuration);
    }
  }

  public void CheckUnlocked() {
    if (locked) {
      throw new Exception("Can't proceed, superstructure is locked!");
    }
  }

  private int NewId() {
    this.UpdateHashOnNextIdChange(rootIncarnation.nextId, rootIncarnation.nextId + 1);
    return rootIncarnation.nextId++;
  }

  private void UpdateHashOnNextIdChange(int oldNextId, int newNextId) {
    int oldIdAndVersionHashContribution =
        VERSION_HASH_MULTIPLIER * rootIncarnation.version +
        NEXT_ID_HASH_MULTIPLIER * oldNextId;
    int newIdAndVersionHashContribution =
        VERSION_HASH_MULTIPLIER * rootIncarnation.version +
        NEXT_ID_HASH_MULTIPLIER * newNextId;
    rootIncarnation.hash =
        rootIncarnation.hash -
        oldIdAndVersionHashContribution +
        newIdAndVersionHashContribution;
  }

  private int RecalculateEntireHash() {
    int result =
        VERSION_HASH_MULTIPLIER * rootIncarnation.version +
        NEXT_ID_HASH_MULTIPLIER * rootIncarnation.nextId;

    foreach (var entry in this.rootIncarnation.incarnationsRand) {
      result += GetRandHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsHoldPositionImpulse) {
      result += GetHoldPositionImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWanderAICapabilityUC) {
      result += GetWanderAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTutorialDefyCounterUC) {
      result += GetTutorialDefyCounterUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsUnit) {
      result += GetUnitHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIUnitComponentMutBunch) {
      result += GetIUnitComponentMutBunchHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLightningChargedUC) {
      result += GetLightningChargedUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLightningChargingUC) {
      result += GetLightningChargingUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDoomedUC) {
      result += GetDoomedUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTemporaryCloneImpulse) {
      result += GetTemporaryCloneImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTemporaryCloneAICapabilityUC) {
      result += GetTemporaryCloneAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSummonImpulse) {
      result += GetSummonImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSummonAICapabilityUC) {
      result += GetSummonAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSorcerousUC) {
      result += GetSorcerousUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBaseOffenseUC) {
      result += GetBaseOffenseUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBaseSightRangeUC) {
      result += GetBaseSightRangeUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBaseMovementTimeUC) {
      result += GetBaseMovementTimeUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBaseDefenseUC) {
      result += GetBaseDefenseUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBaseCombatTimeUC) {
      result += GetBaseCombatTimeUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMiredUC) {
      result += GetMiredUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMireImpulse) {
      result += GetMireImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsEvaporateImpulse) {
      result += GetEvaporateImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTimeCloneAICapabilityUC) {
      result += GetTimeCloneAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMoveImpulse) {
      result += GetMoveImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKamikazeTargetTTC) {
      result += GetKamikazeTargetTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKamikazeJumpImpulse) {
      result += GetKamikazeJumpImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKamikazeTargetImpulse) {
      result += GetKamikazeTargetImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKamikazeAICapabilityUC) {
      result += GetKamikazeAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsInvincibilityUC) {
      result += GetInvincibilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGuardAICapabilityUC) {
      result += GetGuardAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsNoImpulse) {
      result += GetNoImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFireImpulse) {
      result += GetFireImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDefyingUC) {
      result += GetDefyingUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDefyImpulse) {
      result += GetDefyImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCounteringUC) {
      result += GetCounteringUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCounterImpulse) {
      result += GetCounterImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsUnleashBideImpulse) {
      result += GetUnleashBideImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsContinueBidingImpulse) {
      result += GetContinueBidingImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsStartBidingImpulse) {
      result += GetStartBidingImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBideAICapabilityUC) {
      result += GetBideAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsAttackImpulse) {
      result += GetAttackImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsPursueImpulse) {
      result += GetPursueImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKillDirective) {
      result += GetKillDirectiveHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsAttackAICapabilityUC) {
      result += GetAttackAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWarperTTC) {
      result += GetWarperTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTimeAnchorTTC) {
      result += GetTimeAnchorTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTerrainTile) {
      result += GetTerrainTileHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsITerrainTileComponentMutBunch) {
      result += GetITerrainTileComponentMutBunchHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTerrain) {
      result += GetTerrainHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSimplePresenceTriggerTTC) {
      result += GetSimplePresenceTriggerTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFireBombImpulse) {
      result += GetFireBombImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFireBombTTC) {
      result += GetFireBombTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMarkerTTC) {
      result += GetMarkerTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLevelLinkTTC) {
      result += GetLevelLinkTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMudTTC) {
      result += GetMudTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDirtTTC) {
      result += GetDirtTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsObsidianTTC) {
      result += GetObsidianTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDownStairsTTC) {
      result += GetDownStairsTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsUpStairsTTC) {
      result += GetUpStairsTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWallTTC) {
      result += GetWallTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBloodTTC) {
      result += GetBloodTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRocksTTC) {
      result += GetRocksTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTreeTTC) {
      result += GetTreeTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWaterTTC) {
      result += GetWaterTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFloorTTC) {
      result += GetFloorTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCaveWallTTC) {
      result += GetCaveWallTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCaveTTC) {
      result += GetCaveTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFallsTTC) {
      result += GetFallsTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFireTTC) {
      result += GetFireTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsObsidianFloorTTC) {
      result += GetObsidianFloorTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMagmaTTC) {
      result += GetMagmaTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCliffTTC) {
      result += GetCliffTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRavaNestTTC) {
      result += GetRavaNestTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCliffLandingTTC) {
      result += GetCliffLandingTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsStoneTTC) {
      result += GetStoneTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGrassTTC) {
      result += GetGrassTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLevel) {
      result += GetLevelHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSpeedRing) {
      result += GetSpeedRingHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsManaPotion) {
      result += GetManaPotionHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWat) {
      result += GetWatHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIPreActingUCWeakMutBunch) {
      result += GetIPreActingUCWeakMutBunchHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIPostActingUCWeakMutBunch) {
      result += GetIPostActingUCWeakMutBunchHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIImpulseStrongMutBunch) {
      result += GetIImpulseStrongMutBunchHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIItemStrongMutBunch) {
      result += GetIItemStrongMutBunchHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsItemTTC) {
      result += GetItemTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsHealthPotion) {
      result += GetHealthPotionHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGlaive) {
      result += GetGlaiveHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSlowRod) {
      result += GetSlowRodHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBlastRod) {
      result += GetBlastRodHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsArmor) {
      result += GetArmorHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSquareCaveLevelController) {
      result += GetSquareCaveLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRavashrikeLevelController) {
      result += GetRavashrikeLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsPentagonalCaveLevelController) {
      result += GetPentagonalCaveLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC) {
      result += GetIncendianFallsLevelLinkerTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCliffLevelController) {
      result += GetCliffLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsPreGauntletLevelController) {
      result += GetPreGauntletLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGauntletLevelController) {
      result += GetGauntletLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsComm) {
      result += GetCommHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGame) {
      result += GetGameHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsVolcaetusLevelController) {
      result += GetVolcaetusLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTutorial2LevelController) {
      result += GetTutorial2LevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTutorial1LevelController) {
      result += GetTutorial1LevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRetreatLevelController) {
      result += GetRetreatLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSotaventoLevelController) {
      result += GetSotaventoLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsNestLevelController) {
      result += GetNestLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLakeLevelController) {
      result += GetLakeLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsEmberDeepLevelLinkerTTC) {
      result += GetEmberDeepLevelLinkerTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDirtRoadLevelController) {
      result += GetDirtRoadLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCaveLevelController) {
      result += GetCaveLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBridgesLevelController) {
      result += GetBridgesLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsAncientTownLevelController) {
      result += GetAncientTownLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCommMutList) {
      result += GetCommMutListHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLocationMutList) {
      result += GetLocationMutListHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIRequestMutList) {
      result += GetIRequestMutListHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLevelMutSet) {
      result += GetLevelMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsManaPotionStrongMutSet) {
      result += GetManaPotionStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsHealthPotionStrongMutSet) {
      result += GetHealthPotionStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSpeedRingStrongMutSet) {
      result += GetSpeedRingStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGlaiveStrongMutSet) {
      result += GetGlaiveStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSlowRodStrongMutSet) {
      result += GetSlowRodStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBlastRodStrongMutSet) {
      result += GetBlastRodStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsArmorStrongMutSet) {
      result += GetArmorStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet) {
      result += GetHoldPositionImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet) {
      result += GetTemporaryCloneImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSummonImpulseStrongMutSet) {
      result += GetSummonImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMireImpulseStrongMutSet) {
      result += GetMireImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsEvaporateImpulseStrongMutSet) {
      result += GetEvaporateImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMoveImpulseStrongMutSet) {
      result += GetMoveImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet) {
      result += GetKamikazeJumpImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet) {
      result += GetKamikazeTargetImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsNoImpulseStrongMutSet) {
      result += GetNoImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFireImpulseStrongMutSet) {
      result += GetFireImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDefyImpulseStrongMutSet) {
      result += GetDefyImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCounterImpulseStrongMutSet) {
      result += GetCounterImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet) {
      result += GetUnleashBideImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet) {
      result += GetContinueBidingImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsStartBidingImpulseStrongMutSet) {
      result += GetStartBidingImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsAttackImpulseStrongMutSet) {
      result += GetAttackImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsPursueImpulseStrongMutSet) {
      result += GetPursueImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFireBombImpulseStrongMutSet) {
      result += GetFireBombImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLightningChargedUCWeakMutSet) {
      result += GetLightningChargedUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet) {
      result += GetTimeCloneAICapabilityUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDoomedUCWeakMutSet) {
      result += GetDoomedUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMiredUCWeakMutSet) {
      result += GetMiredUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsInvincibilityUCWeakMutSet) {
      result += GetInvincibilityUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDefyingUCWeakMutSet) {
      result += GetDefyingUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCounteringUCWeakMutSet) {
      result += GetCounteringUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet) {
      result += GetAttackAICapabilityUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsUnitMutSet) {
      result += GetUnitMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet) {
      result += GetSimplePresenceTriggerTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsItemTTCMutSet) {
      result += GetItemTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKamikazeTargetTTCMutSet) {
      result += GetKamikazeTargetTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWarperTTCMutSet) {
      result += GetWarperTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTimeAnchorTTCMutSet) {
      result += GetTimeAnchorTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFireBombTTCMutSet) {
      result += GetFireBombTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMarkerTTCMutSet) {
      result += GetMarkerTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLevelLinkTTCMutSet) {
      result += GetLevelLinkTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMudTTCMutSet) {
      result += GetMudTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDirtTTCMutSet) {
      result += GetDirtTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsObsidianTTCMutSet) {
      result += GetObsidianTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDownStairsTTCMutSet) {
      result += GetDownStairsTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsUpStairsTTCMutSet) {
      result += GetUpStairsTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWallTTCMutSet) {
      result += GetWallTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBloodTTCMutSet) {
      result += GetBloodTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRocksTTCMutSet) {
      result += GetRocksTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTreeTTCMutSet) {
      result += GetTreeTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWaterTTCMutSet) {
      result += GetWaterTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFloorTTCMutSet) {
      result += GetFloorTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCaveWallTTCMutSet) {
      result += GetCaveWallTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCaveTTCMutSet) {
      result += GetCaveTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFallsTTCMutSet) {
      result += GetFallsTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFireTTCMutSet) {
      result += GetFireTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsObsidianFloorTTCMutSet) {
      result += GetObsidianFloorTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMagmaTTCMutSet) {
      result += GetMagmaTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCliffTTCMutSet) {
      result += GetCliffTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRavaNestTTCMutSet) {
      result += GetRavaNestTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCliffLandingTTCMutSet) {
      result += GetCliffLandingTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsStoneTTCMutSet) {
      result += GetStoneTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGrassTTCMutSet) {
      result += GetGrassTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet) {
      result += GetIncendianFallsLevelLinkerTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet) {
      result += GetEmberDeepLevelLinkerTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTutorialDefyCounterUCMutSet) {
      result += GetTutorialDefyCounterUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLightningChargingUCMutSet) {
      result += GetLightningChargingUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWanderAICapabilityUCMutSet) {
      result += GetWanderAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet) {
      result += GetTemporaryCloneAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSummonAICapabilityUCMutSet) {
      result += GetSummonAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet) {
      result += GetKamikazeAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGuardAICapabilityUCMutSet) {
      result += GetGuardAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet) {
      result += GetTimeCloneAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDoomedUCMutSet) {
      result += GetDoomedUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMiredUCMutSet) {
      result += GetMiredUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsAttackAICapabilityUCMutSet) {
      result += GetAttackAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCounteringUCMutSet) {
      result += GetCounteringUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLightningChargedUCMutSet) {
      result += GetLightningChargedUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsInvincibilityUCMutSet) {
      result += GetInvincibilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDefyingUCMutSet) {
      result += GetDefyingUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBideAICapabilityUCMutSet) {
      result += GetBideAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBaseSightRangeUCMutSet) {
      result += GetBaseSightRangeUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBaseMovementTimeUCMutSet) {
      result += GetBaseMovementTimeUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBaseCombatTimeUCMutSet) {
      result += GetBaseCombatTimeUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsManaPotionMutSet) {
      result += GetManaPotionMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsHealthPotionMutSet) {
      result += GetHealthPotionMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSpeedRingMutSet) {
      result += GetSpeedRingMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGlaiveMutSet) {
      result += GetGlaiveMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSlowRodMutSet) {
      result += GetSlowRodMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBlastRodMutSet) {
      result += GetBlastRodMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsArmorMutSet) {
      result += GetArmorMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSorcerousUCMutSet) {
      result += GetSorcerousUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBaseOffenseUCMutSet) {
      result += GetBaseOffenseUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBaseDefenseUCMutSet) {
      result += GetBaseDefenseUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTerrainTileByLocationMutMap) {
      result += GetTerrainTileByLocationMutMapHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap) {
      result += GetKamikazeTargetTTCStrongByLocationMutMapHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    return result;
  }

  public void CheckForViolations() {
    List<string> violations = new List<string>();

    foreach (var obj in this.AllRand()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllHoldPositionImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWanderAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTutorialDefyCounterUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllUnit()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIUnitComponentMutBunch()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLightningChargedUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLightningChargingUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDoomedUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTemporaryCloneImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTemporaryCloneAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSummonImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSummonAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSorcerousUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBaseOffenseUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBaseSightRangeUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBaseMovementTimeUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBaseDefenseUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBaseCombatTimeUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMiredUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMireImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllEvaporateImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTimeCloneAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMoveImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKamikazeTargetTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKamikazeJumpImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKamikazeTargetImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKamikazeAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllInvincibilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGuardAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllNoImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFireImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDefyingUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDefyImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCounteringUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCounterImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllUnleashBideImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllContinueBidingImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllStartBidingImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBideAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllAttackImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllPursueImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKillDirective()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllAttackAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWarperTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTimeAnchorTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTerrainTile()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllITerrainTileComponentMutBunch()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTerrain()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSimplePresenceTriggerTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFireBombImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFireBombTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMarkerTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLevelLinkTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMudTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDirtTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllObsidianTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDownStairsTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllUpStairsTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWallTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBloodTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRocksTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTreeTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWaterTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFloorTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCaveWallTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCaveTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFallsTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFireTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllObsidianFloorTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMagmaTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCliffTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRavaNestTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCliffLandingTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllStoneTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGrassTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLevel()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSpeedRing()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllManaPotion()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWat()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIPreActingUCWeakMutBunch()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIPostActingUCWeakMutBunch()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIImpulseStrongMutBunch()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIItemStrongMutBunch()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllItemTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllHealthPotion()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGlaive()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSlowRod()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBlastRod()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllArmor()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSquareCaveLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRavashrikeLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllPentagonalCaveLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIncendianFallsLevelLinkerTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCliffLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllPreGauntletLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGauntletLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllComm()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGame()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllVolcaetusLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTutorial2LevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTutorial1LevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRetreatLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSotaventoLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllNestLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLakeLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllEmberDeepLevelLinkerTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDirtRoadLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCaveLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBridgesLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllAncientTownLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCommMutList()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLocationMutList()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIRequestMutList()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLevelMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllManaPotionStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllHealthPotionStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSpeedRingStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGlaiveStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSlowRodStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBlastRodStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllArmorStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllHoldPositionImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTemporaryCloneImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSummonImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMireImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllEvaporateImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMoveImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKamikazeJumpImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKamikazeTargetImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllNoImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFireImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDefyImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCounterImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllUnleashBideImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllContinueBidingImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllStartBidingImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllAttackImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllPursueImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFireBombImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLightningChargedUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTimeCloneAICapabilityUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDoomedUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMiredUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllInvincibilityUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDefyingUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCounteringUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllAttackAICapabilityUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllUnitMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSimplePresenceTriggerTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllItemTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKamikazeTargetTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWarperTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTimeAnchorTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFireBombTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMarkerTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLevelLinkTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMudTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDirtTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllObsidianTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDownStairsTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllUpStairsTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWallTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBloodTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRocksTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTreeTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWaterTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFloorTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCaveWallTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCaveTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFallsTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFireTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllObsidianFloorTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMagmaTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCliffTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRavaNestTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCliffLandingTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllStoneTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGrassTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIncendianFallsLevelLinkerTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllEmberDeepLevelLinkerTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTutorialDefyCounterUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLightningChargingUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWanderAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTemporaryCloneAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSummonAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKamikazeAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGuardAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTimeCloneAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDoomedUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMiredUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllAttackAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCounteringUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLightningChargedUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllInvincibilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDefyingUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBideAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBaseSightRangeUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBaseMovementTimeUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBaseCombatTimeUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllManaPotionMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllHealthPotionMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSpeedRingMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGlaiveMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSlowRodMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBlastRodMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllArmorMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSorcerousUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBaseOffenseUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBaseDefenseUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTerrainTileByLocationMutMap()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKamikazeTargetTTCStrongByLocationMutMap()) {
      obj.CheckForNullViolations(violations);
    }

    SortedSet<int> reachableIds = new SortedSet<int>();
    foreach (var rootStruct in this.AllGame()) {
      rootStruct.FindReachableObjects(reachableIds);
    }
    foreach (var obj in this.AllRand()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllHoldPositionImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWanderAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTutorialDefyCounterUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllUnit()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIUnitComponentMutBunch()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLightningChargedUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLightningChargingUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDoomedUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTemporaryCloneImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTemporaryCloneAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSummonImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSummonAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSorcerousUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBaseOffenseUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBaseSightRangeUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBaseMovementTimeUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBaseDefenseUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBaseCombatTimeUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMiredUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMireImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllEvaporateImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTimeCloneAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMoveImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKamikazeTargetTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKamikazeJumpImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKamikazeTargetImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKamikazeAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllInvincibilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGuardAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllNoImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFireImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDefyingUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDefyImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCounteringUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCounterImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllUnleashBideImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllContinueBidingImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllStartBidingImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBideAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllAttackImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllPursueImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKillDirective()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllAttackAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWarperTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTimeAnchorTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTerrainTile()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllITerrainTileComponentMutBunch()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTerrain()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSimplePresenceTriggerTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFireBombImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFireBombTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMarkerTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLevelLinkTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMudTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDirtTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllObsidianTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDownStairsTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllUpStairsTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWallTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBloodTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRocksTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTreeTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWaterTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFloorTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCaveWallTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCaveTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFallsTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFireTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllObsidianFloorTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMagmaTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCliffTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRavaNestTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCliffLandingTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllStoneTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGrassTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLevel()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSpeedRing()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllManaPotion()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWat()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIPreActingUCWeakMutBunch()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIPostActingUCWeakMutBunch()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIImpulseStrongMutBunch()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIItemStrongMutBunch()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllItemTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllHealthPotion()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGlaive()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSlowRod()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBlastRod()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllArmor()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSquareCaveLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRavashrikeLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllPentagonalCaveLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIncendianFallsLevelLinkerTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCliffLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllPreGauntletLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGauntletLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllComm()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGame()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllVolcaetusLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTutorial2LevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTutorial1LevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRetreatLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSotaventoLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllNestLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLakeLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllEmberDeepLevelLinkerTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDirtRoadLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCaveLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBridgesLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllAncientTownLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCommMutList()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLocationMutList()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIRequestMutList()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLevelMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllManaPotionStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllHealthPotionStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSpeedRingStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGlaiveStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSlowRodStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBlastRodStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllArmorStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllHoldPositionImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTemporaryCloneImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSummonImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMireImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllEvaporateImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMoveImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKamikazeJumpImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKamikazeTargetImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllNoImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFireImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDefyImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCounterImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllUnleashBideImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllContinueBidingImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllStartBidingImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllAttackImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllPursueImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFireBombImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLightningChargedUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTimeCloneAICapabilityUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDoomedUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMiredUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllInvincibilityUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDefyingUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCounteringUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllAttackAICapabilityUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllUnitMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSimplePresenceTriggerTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllItemTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKamikazeTargetTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWarperTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTimeAnchorTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFireBombTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMarkerTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLevelLinkTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMudTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDirtTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllObsidianTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDownStairsTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllUpStairsTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWallTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBloodTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRocksTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTreeTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWaterTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFloorTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCaveWallTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCaveTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFallsTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFireTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllObsidianFloorTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMagmaTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCliffTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRavaNestTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCliffLandingTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllStoneTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGrassTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIncendianFallsLevelLinkerTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllEmberDeepLevelLinkerTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTutorialDefyCounterUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLightningChargingUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWanderAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTemporaryCloneAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSummonAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKamikazeAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGuardAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTimeCloneAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDoomedUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMiredUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllAttackAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCounteringUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLightningChargedUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllInvincibilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDefyingUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBideAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBaseSightRangeUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBaseMovementTimeUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBaseCombatTimeUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllManaPotionMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllHealthPotionMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSpeedRingMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGlaiveMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSlowRodMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBlastRodMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllArmorMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSorcerousUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBaseOffenseUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBaseDefenseUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTerrainTileByLocationMutMap()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKamikazeTargetTTCStrongByLocationMutMap()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }

    if (violations.Count > 0) {
      string message = "Found violations!\n";
      foreach (var violation in violations) {
        message += violation + "\n";
      }
      throw new Exception(message);
    }
  }

  public int GetDeterministicHashCode() {
    // int doubleCheckHash = RecalculateEntireHash();
    // Asserts.Assert(doubleCheckHash == this.rootIncarnation.hash);
    return this.rootIncarnation.hash;
  }

  public void Revert(RootIncarnation sourceIncarnation) {
    CheckUnlocked();
    // We do all the adds first so that we don't violate any strong borrows.
    // Then we do all the changes, because those might be flipping things to point
    // at things that were just made.
    // Then we do all the removes.


    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRand) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRand.ContainsKey(sourceObjId)) {
        EffectInternalCreateRand(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHoldPositionImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsHoldPositionImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateHoldPositionImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWanderAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateWanderAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTutorialDefyCounterUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateTutorialDefyCounterUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnit) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsUnit.ContainsKey(sourceObjId)) {
        EffectInternalCreateUnit(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIUnitComponentMutBunch) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIUnitComponentMutBunch.ContainsKey(sourceObjId)) {
        EffectInternalCreateIUnitComponentMutBunch(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLightningChargedUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLightningChargedUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateLightningChargedUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLightningChargingUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLightningChargingUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateLightningChargingUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDoomedUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDoomedUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateDoomedUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTemporaryCloneImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTemporaryCloneImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateTemporaryCloneImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTemporaryCloneAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateTemporaryCloneAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSummonImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSummonImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateSummonImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSummonAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateSummonAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSorcerousUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSorcerousUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateSorcerousUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseOffenseUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateBaseOffenseUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseSightRangeUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateBaseSightRangeUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseMovementTimeUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateBaseMovementTimeUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseDefenseUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateBaseDefenseUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseCombatTimeUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateBaseCombatTimeUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMiredUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMiredUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateMiredUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMireImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMireImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateMireImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEvaporateImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateEvaporateImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeCloneAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateTimeCloneAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMoveImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMoveImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateMoveImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeTargetTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKamikazeTargetTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateKamikazeTargetTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeJumpImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKamikazeJumpImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateKamikazeJumpImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeTargetImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKamikazeTargetImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateKamikazeTargetImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateKamikazeAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsInvincibilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsInvincibilityUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateInvincibilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGuardAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateGuardAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsNoImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsNoImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateNoImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFireImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateFireImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefyingUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDefyingUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateDefyingUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefyImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDefyImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateDefyImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounteringUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCounteringUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateCounteringUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounterImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCounterImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateCounterImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnleashBideImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateUnleashBideImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsContinueBidingImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateContinueBidingImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStartBidingImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateStartBidingImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBideAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateBideAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsAttackImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateAttackImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPursueImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsPursueImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreatePursueImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKillDirective) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKillDirective.ContainsKey(sourceObjId)) {
        EffectInternalCreateKillDirective(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(sourceObjId)) {
        EffectInternalCreateAttackAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWarperTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWarperTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateWarperTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeAnchorTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateTimeAnchorTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTerrainTile) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTerrainTile.ContainsKey(sourceObjId)) {
        EffectInternalCreateTerrainTile(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsITerrainTileComponentMutBunch) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsITerrainTileComponentMutBunch.ContainsKey(sourceObjId)) {
        EffectInternalCreateITerrainTileComponentMutBunch(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTerrain) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTerrain.ContainsKey(sourceObjId)) {
        EffectInternalCreateTerrain(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSimplePresenceTriggerTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateSimplePresenceTriggerTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireBombImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFireBombImpulse.ContainsKey(sourceObjId)) {
        EffectInternalCreateFireBombImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireBombTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFireBombTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateFireBombTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMarkerTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMarkerTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateMarkerTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLevelLinkTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLevelLinkTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateLevelLinkTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMudTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMudTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateMudTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDirtTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDirtTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateDirtTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsObsidianTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsObsidianTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateObsidianTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDownStairsTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDownStairsTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateDownStairsTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUpStairsTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsUpStairsTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateUpStairsTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWallTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWallTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateWallTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBloodTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBloodTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateBloodTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRocksTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRocksTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateRocksTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTreeTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTreeTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateTreeTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWaterTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWaterTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateWaterTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFloorTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFloorTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateFloorTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveWallTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCaveWallTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateCaveWallTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCaveTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateCaveTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFallsTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFallsTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateFallsTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFireTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateFireTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsObsidianFloorTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsObsidianFloorTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateObsidianFloorTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMagmaTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMagmaTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateMagmaTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCliffTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateCliffTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavaNestTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRavaNestTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateRavaNestTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffLandingTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateCliffLandingTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStoneTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsStoneTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateStoneTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGrassTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGrassTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateGrassTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLevel) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLevel.ContainsKey(sourceObjId)) {
        EffectInternalCreateLevel(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSpeedRing) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSpeedRing.ContainsKey(sourceObjId)) {
        EffectInternalCreateSpeedRing(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsManaPotion) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsManaPotion.ContainsKey(sourceObjId)) {
        EffectInternalCreateManaPotion(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWat) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWat.ContainsKey(sourceObjId)) {
        EffectInternalCreateWat(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIPreActingUCWeakMutBunch) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIPreActingUCWeakMutBunch.ContainsKey(sourceObjId)) {
        EffectInternalCreateIPreActingUCWeakMutBunch(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIPostActingUCWeakMutBunch) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIPostActingUCWeakMutBunch.ContainsKey(sourceObjId)) {
        EffectInternalCreateIPostActingUCWeakMutBunch(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIImpulseStrongMutBunch) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIImpulseStrongMutBunch.ContainsKey(sourceObjId)) {
        EffectInternalCreateIImpulseStrongMutBunch(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIItemStrongMutBunch) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIItemStrongMutBunch.ContainsKey(sourceObjId)) {
        EffectInternalCreateIItemStrongMutBunch(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsItemTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsItemTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateItemTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHealthPotion) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsHealthPotion.ContainsKey(sourceObjId)) {
        EffectInternalCreateHealthPotion(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGlaive) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGlaive.ContainsKey(sourceObjId)) {
        EffectInternalCreateGlaive(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSlowRod) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSlowRod.ContainsKey(sourceObjId)) {
        EffectInternalCreateSlowRod(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBlastRod) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBlastRod.ContainsKey(sourceObjId)) {
        EffectInternalCreateBlastRod(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsArmor) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsArmor.ContainsKey(sourceObjId)) {
        EffectInternalCreateArmor(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSquareCaveLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreateSquareCaveLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavashrikeLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreateRavashrikeLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPentagonalCaveLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreatePentagonalCaveLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIncendianFallsLevelLinkerTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateIncendianFallsLevelLinkerTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCliffLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreateCliffLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPreGauntletLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreatePreGauntletLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGauntletLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGauntletLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreateGauntletLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsComm) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsComm.ContainsKey(sourceObjId)) {
        EffectInternalCreateComm(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGame) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGame.ContainsKey(sourceObjId)) {
        EffectInternalCreateGame(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsVolcaetusLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsVolcaetusLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreateVolcaetusLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTutorial2LevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTutorial2LevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreateTutorial2LevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTutorial1LevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTutorial1LevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreateTutorial1LevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRetreatLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRetreatLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreateRetreatLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSotaventoLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSotaventoLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreateSotaventoLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsNestLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsNestLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreateNestLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLakeLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLakeLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreateLakeLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEmberDeepLevelLinkerTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(sourceObjId)) {
        EffectInternalCreateEmberDeepLevelLinkerTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDirtRoadLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDirtRoadLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreateDirtRoadLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCaveLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreateCaveLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBridgesLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBridgesLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreateBridgesLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAncientTownLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsAncientTownLevelController.ContainsKey(sourceObjId)) {
        EffectInternalCreateAncientTownLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCommMutList) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCommMutList.ContainsKey(sourceObjId)) {
        EffectInternalCreateCommMutList(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLocationMutList) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLocationMutList.ContainsKey(sourceObjId)) {
        EffectInternalCreateLocationMutList(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIRequestMutList) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIRequestMutList.ContainsKey(sourceObjId)) {
        EffectInternalCreateIRequestMutList(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLevelMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLevelMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateLevelMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsManaPotionStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsManaPotionStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateManaPotionStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHealthPotionStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsHealthPotionStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateHealthPotionStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSpeedRingStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSpeedRingStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateSpeedRingStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGlaiveStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGlaiveStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateGlaiveStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSlowRodStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSlowRodStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateSlowRodStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBlastRodStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBlastRodStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateBlastRodStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsArmorStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsArmorStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateArmorStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHoldPositionImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateHoldPositionImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateTemporaryCloneImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSummonImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSummonImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateSummonImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMireImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMireImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateMireImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEvaporateImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsEvaporateImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateEvaporateImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMoveImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMoveImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateMoveImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateKamikazeJumpImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateKamikazeTargetImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsNoImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsNoImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateNoImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFireImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateFireImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefyImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDefyImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateDefyImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounterImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCounterImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateCounterImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnleashBideImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateUnleashBideImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsContinueBidingImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateContinueBidingImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStartBidingImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsStartBidingImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateStartBidingImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsAttackImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateAttackImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPursueImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsPursueImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreatePursueImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireBombImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFireBombImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateFireBombImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLightningChargedUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLightningChargedUCWeakMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateLightningChargedUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateTimeCloneAICapabilityUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDoomedUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDoomedUCWeakMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateDoomedUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMiredUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMiredUCWeakMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateMiredUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsInvincibilityUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsInvincibilityUCWeakMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateInvincibilityUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefyingUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDefyingUCWeakMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateDefyingUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounteringUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCounteringUCWeakMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateCounteringUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackAICapabilityUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateAttackAICapabilityUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnitMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsUnitMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateUnitMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSimplePresenceTriggerTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateSimplePresenceTriggerTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsItemTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsItemTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateItemTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeTargetTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKamikazeTargetTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateKamikazeTargetTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWarperTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWarperTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateWarperTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeAnchorTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTimeAnchorTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateTimeAnchorTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireBombTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFireBombTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateFireBombTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMarkerTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMarkerTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateMarkerTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLevelLinkTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLevelLinkTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateLevelLinkTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMudTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMudTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateMudTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDirtTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDirtTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateDirtTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsObsidianTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsObsidianTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateObsidianTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDownStairsTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDownStairsTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateDownStairsTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUpStairsTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsUpStairsTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateUpStairsTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWallTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWallTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateWallTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBloodTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBloodTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateBloodTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRocksTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRocksTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateRocksTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTreeTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTreeTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateTreeTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWaterTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWaterTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateWaterTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFloorTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFloorTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateFloorTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveWallTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCaveWallTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateCaveWallTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCaveTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateCaveTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFallsTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFallsTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateFallsTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFireTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateFireTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsObsidianFloorTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsObsidianFloorTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateObsidianFloorTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMagmaTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMagmaTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateMagmaTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCliffTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateCliffTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavaNestTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRavaNestTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateRavaNestTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffLandingTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCliffLandingTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateCliffLandingTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStoneTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsStoneTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateStoneTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGrassTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGrassTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateGrassTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateIncendianFallsLevelLinkerTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateEmberDeepLevelLinkerTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTutorialDefyCounterUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTutorialDefyCounterUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateTutorialDefyCounterUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLightningChargingUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLightningChargingUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateLightningChargingUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWanderAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWanderAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateWanderAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateTemporaryCloneAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSummonAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSummonAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateSummonAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateKamikazeAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGuardAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGuardAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateGuardAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeCloneAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateTimeCloneAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDoomedUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDoomedUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateDoomedUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMiredUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMiredUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateMiredUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsAttackAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateAttackAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounteringUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCounteringUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateCounteringUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLightningChargedUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLightningChargedUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateLightningChargedUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsInvincibilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsInvincibilityUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateInvincibilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefyingUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDefyingUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateDefyingUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBideAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBideAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateBideAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseSightRangeUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBaseSightRangeUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateBaseSightRangeUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseMovementTimeUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBaseMovementTimeUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateBaseMovementTimeUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseCombatTimeUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBaseCombatTimeUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateBaseCombatTimeUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsManaPotionMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsManaPotionMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateManaPotionMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHealthPotionMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsHealthPotionMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateHealthPotionMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSpeedRingMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSpeedRingMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateSpeedRingMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGlaiveMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGlaiveMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateGlaiveMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSlowRodMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSlowRodMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateSlowRodMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBlastRodMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBlastRodMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateBlastRodMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsArmorMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsArmorMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateArmorMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSorcerousUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSorcerousUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateSorcerousUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseOffenseUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBaseOffenseUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateBaseOffenseUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseDefenseUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBaseDefenseUCMutSet.ContainsKey(sourceObjId)) {
        EffectInternalCreateBaseDefenseUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTerrainTileByLocationMutMap) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTerrainTileByLocationMutMap.ContainsKey(sourceObjId)) {
        EffectInternalCreateTerrainTileByLocationMutMap(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap.ContainsKey(sourceObjId)) {
        EffectInternalCreateKamikazeTargetTTCStrongByLocationMutMap(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
      }
    }
         
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCommMutList) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCommMutList.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCommMutList[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            for (int i = currentObjIncarnation.list.Count - 1; i >= 0; i--) {
              EffectCommMutListRemoveAt(objId, i);
            }
            for (int i = 0; i < sourceObjIncarnation.list.Count; i++) {
              EffectCommMutListAdd(objId, i, sourceObjIncarnation.list[i]);
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
                  rootIncarnation.incarnationsCommMutList[objId] = sourceVersionAndObjIncarnation;

          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLocationMutList) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsLocationMutList.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLocationMutList[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            for (int i = currentObjIncarnation.list.Count - 1; i >= 0; i--) {
              EffectLocationMutListRemoveAt(objId, i);
            }
            for (int i = 0; i < sourceObjIncarnation.list.Count; i++) {
              EffectLocationMutListAdd(objId, i, sourceObjIncarnation.list[i]);
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
                  rootIncarnation.incarnationsLocationMutList[objId] = sourceVersionAndObjIncarnation;

          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIRequestMutList) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsIRequestMutList.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIRequestMutList[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            for (int i = currentObjIncarnation.list.Count - 1; i >= 0; i--) {
              EffectIRequestMutListRemoveAt(objId, i);
            }
            for (int i = 0; i < sourceObjIncarnation.list.Count; i++) {
              EffectIRequestMutListAdd(objId, i, sourceObjIncarnation.list[i]);
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
                  rootIncarnation.incarnationsIRequestMutList[objId] = sourceVersionAndObjIncarnation;

          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLevelMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsLevelMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLevelMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectLevelMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectLevelMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsLevelMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsManaPotionStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsManaPotionStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsManaPotionStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectManaPotionStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectManaPotionStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsManaPotionStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHealthPotionStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsHealthPotionStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsHealthPotionStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectHealthPotionStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectHealthPotionStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsHealthPotionStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSpeedRingStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsSpeedRingStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSpeedRingStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectSpeedRingStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectSpeedRingStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsSpeedRingStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGlaiveStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsGlaiveStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGlaiveStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectGlaiveStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectGlaiveStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsGlaiveStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSlowRodStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsSlowRodStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSlowRodStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectSlowRodStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectSlowRodStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsSlowRodStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBlastRodStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBlastRodStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBlastRodStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectBlastRodStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectBlastRodStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsBlastRodStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsArmorStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsArmorStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsArmorStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectArmorStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectArmorStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsArmorStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHoldPositionImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectHoldPositionImpulseStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectHoldPositionImpulseStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectTemporaryCloneImpulseStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectTemporaryCloneImpulseStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSummonImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsSummonImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSummonImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectSummonImpulseStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectSummonImpulseStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsSummonImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMireImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsMireImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMireImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectMireImpulseStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectMireImpulseStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsMireImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEvaporateImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsEvaporateImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsEvaporateImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectEvaporateImpulseStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectEvaporateImpulseStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsEvaporateImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMoveImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsMoveImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMoveImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectMoveImpulseStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectMoveImpulseStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsMoveImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectKamikazeJumpImpulseStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectKamikazeJumpImpulseStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectKamikazeTargetImpulseStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectKamikazeTargetImpulseStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsNoImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsNoImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsNoImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectNoImpulseStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectNoImpulseStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsNoImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsFireImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFireImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectFireImpulseStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectFireImpulseStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsFireImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefyImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsDefyImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDefyImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectDefyImpulseStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectDefyImpulseStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsDefyImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounterImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCounterImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCounterImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectCounterImpulseStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectCounterImpulseStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsCounterImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnleashBideImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectUnleashBideImpulseStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectUnleashBideImpulseStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsContinueBidingImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectContinueBidingImpulseStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectContinueBidingImpulseStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStartBidingImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsStartBidingImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsStartBidingImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectStartBidingImpulseStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectStartBidingImpulseStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsStartBidingImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsAttackImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsAttackImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectAttackImpulseStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectAttackImpulseStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsAttackImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPursueImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsPursueImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsPursueImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectPursueImpulseStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectPursueImpulseStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsPursueImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireBombImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsFireBombImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFireBombImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectFireBombImpulseStrongMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectFireBombImpulseStrongMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsFireBombImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLightningChargedUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsLightningChargedUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLightningChargedUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectLightningChargedUCWeakMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectLightningChargedUCWeakMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsLightningChargedUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectTimeCloneAICapabilityUCWeakMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectTimeCloneAICapabilityUCWeakMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDoomedUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsDoomedUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDoomedUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectDoomedUCWeakMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectDoomedUCWeakMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsDoomedUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMiredUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsMiredUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMiredUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectMiredUCWeakMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectMiredUCWeakMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsMiredUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsInvincibilityUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsInvincibilityUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsInvincibilityUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectInvincibilityUCWeakMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectInvincibilityUCWeakMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsInvincibilityUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefyingUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsDefyingUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDefyingUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectDefyingUCWeakMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectDefyingUCWeakMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsDefyingUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounteringUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCounteringUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCounteringUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectCounteringUCWeakMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectCounteringUCWeakMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsCounteringUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackAICapabilityUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectAttackAICapabilityUCWeakMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectAttackAICapabilityUCWeakMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnitMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsUnitMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsUnitMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectUnitMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectUnitMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsUnitMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSimplePresenceTriggerTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectSimplePresenceTriggerTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectSimplePresenceTriggerTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsItemTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsItemTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsItemTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectItemTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectItemTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsItemTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeTargetTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsKamikazeTargetTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKamikazeTargetTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectKamikazeTargetTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectKamikazeTargetTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsKamikazeTargetTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWarperTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsWarperTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWarperTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectWarperTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectWarperTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsWarperTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeAnchorTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsTimeAnchorTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTimeAnchorTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectTimeAnchorTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectTimeAnchorTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsTimeAnchorTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireBombTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsFireBombTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFireBombTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectFireBombTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectFireBombTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsFireBombTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMarkerTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsMarkerTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMarkerTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectMarkerTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectMarkerTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsMarkerTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLevelLinkTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsLevelLinkTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLevelLinkTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectLevelLinkTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectLevelLinkTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsLevelLinkTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMudTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsMudTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMudTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectMudTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectMudTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsMudTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDirtTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsDirtTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDirtTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectDirtTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectDirtTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsDirtTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsObsidianTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsObsidianTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsObsidianTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectObsidianTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectObsidianTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsObsidianTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDownStairsTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsDownStairsTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDownStairsTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectDownStairsTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectDownStairsTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsDownStairsTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUpStairsTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsUpStairsTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsUpStairsTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectUpStairsTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectUpStairsTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsUpStairsTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWallTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsWallTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWallTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectWallTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectWallTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsWallTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBloodTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBloodTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBloodTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectBloodTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectBloodTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsBloodTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRocksTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsRocksTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRocksTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectRocksTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectRocksTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsRocksTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTreeTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsTreeTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTreeTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectTreeTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectTreeTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsTreeTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWaterTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsWaterTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWaterTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectWaterTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectWaterTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsWaterTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFloorTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsFloorTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFloorTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectFloorTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectFloorTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsFloorTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveWallTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCaveWallTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCaveWallTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectCaveWallTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectCaveWallTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsCaveWallTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCaveTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCaveTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectCaveTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectCaveTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsCaveTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFallsTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsFallsTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFallsTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectFallsTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectFallsTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsFallsTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsFireTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFireTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectFireTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectFireTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsFireTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsObsidianFloorTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsObsidianFloorTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsObsidianFloorTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectObsidianFloorTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectObsidianFloorTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsObsidianFloorTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMagmaTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsMagmaTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMagmaTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectMagmaTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectMagmaTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsMagmaTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCliffTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCliffTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectCliffTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectCliffTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsCliffTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavaNestTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsRavaNestTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRavaNestTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectRavaNestTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectRavaNestTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsRavaNestTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffLandingTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCliffLandingTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCliffLandingTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectCliffLandingTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectCliffLandingTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsCliffLandingTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStoneTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsStoneTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsStoneTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectStoneTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectStoneTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsStoneTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGrassTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsGrassTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGrassTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectGrassTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectGrassTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsGrassTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectIncendianFallsLevelLinkerTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectIncendianFallsLevelLinkerTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectEmberDeepLevelLinkerTTCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectEmberDeepLevelLinkerTTCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTutorialDefyCounterUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsTutorialDefyCounterUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTutorialDefyCounterUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectTutorialDefyCounterUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectTutorialDefyCounterUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsTutorialDefyCounterUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLightningChargingUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsLightningChargingUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLightningChargingUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectLightningChargingUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectLightningChargingUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsLightningChargingUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWanderAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsWanderAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWanderAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectWanderAICapabilityUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectWanderAICapabilityUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsWanderAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectTemporaryCloneAICapabilityUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectTemporaryCloneAICapabilityUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSummonAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsSummonAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSummonAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectSummonAICapabilityUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectSummonAICapabilityUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsSummonAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectKamikazeAICapabilityUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectKamikazeAICapabilityUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGuardAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsGuardAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGuardAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectGuardAICapabilityUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectGuardAICapabilityUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsGuardAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeCloneAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectTimeCloneAICapabilityUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectTimeCloneAICapabilityUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDoomedUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsDoomedUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDoomedUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectDoomedUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectDoomedUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsDoomedUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMiredUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsMiredUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMiredUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectMiredUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectMiredUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsMiredUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsAttackAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsAttackAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectAttackAICapabilityUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectAttackAICapabilityUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsAttackAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounteringUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCounteringUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCounteringUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectCounteringUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectCounteringUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsCounteringUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLightningChargedUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsLightningChargedUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLightningChargedUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectLightningChargedUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectLightningChargedUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsLightningChargedUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsInvincibilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsInvincibilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsInvincibilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectInvincibilityUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectInvincibilityUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsInvincibilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefyingUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsDefyingUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDefyingUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectDefyingUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectDefyingUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsDefyingUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBideAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBideAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBideAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectBideAICapabilityUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectBideAICapabilityUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsBideAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseSightRangeUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBaseSightRangeUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBaseSightRangeUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectBaseSightRangeUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectBaseSightRangeUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsBaseSightRangeUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseMovementTimeUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBaseMovementTimeUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBaseMovementTimeUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectBaseMovementTimeUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectBaseMovementTimeUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsBaseMovementTimeUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseCombatTimeUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBaseCombatTimeUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBaseCombatTimeUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectBaseCombatTimeUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectBaseCombatTimeUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsBaseCombatTimeUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsManaPotionMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsManaPotionMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsManaPotionMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectManaPotionMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectManaPotionMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsManaPotionMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHealthPotionMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsHealthPotionMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsHealthPotionMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectHealthPotionMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectHealthPotionMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsHealthPotionMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSpeedRingMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsSpeedRingMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSpeedRingMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectSpeedRingMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectSpeedRingMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsSpeedRingMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGlaiveMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsGlaiveMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGlaiveMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectGlaiveMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectGlaiveMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsGlaiveMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSlowRodMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsSlowRodMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSlowRodMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectSlowRodMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectSlowRodMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsSlowRodMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBlastRodMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBlastRodMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBlastRodMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectBlastRodMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectBlastRodMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsBlastRodMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsArmorMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsArmorMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsArmorMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectArmorMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectArmorMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsArmorMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSorcerousUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsSorcerousUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSorcerousUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectSorcerousUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectSorcerousUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsSorcerousUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseOffenseUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBaseOffenseUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBaseOffenseUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectBaseOffenseUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectBaseOffenseUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsBaseOffenseUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseDefenseUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBaseDefenseUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBaseDefenseUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.set)) {
              if (!sourceObjIncarnation.set.Contains(objIdInCurrentObjIncarnation)) {
                EffectBaseDefenseUCMutSetRemove(objId, objIdInCurrentObjIncarnation);
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.set) {
              if (!currentObjIncarnation.set.Contains(unitIdInSourceObjIncarnation)) {
                EffectBaseDefenseUCMutSetAdd(objId, unitIdInSourceObjIncarnation);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsBaseDefenseUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTerrainTileByLocationMutMap) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsTerrainTileByLocationMutMap.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTerrainTileByLocationMutMap[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var entryInCurrentObjIncarnation in new SortedDictionary<Location, int>(currentObjIncarnation.map)) {
              var key = entryInCurrentObjIncarnation.Key;
              if (!sourceObjIncarnation.map.ContainsKey(key)) {
                EffectTerrainTileByLocationMutMapRemove(objId, key);
              }
            }
            foreach (var entryInSourceObjIncarnation in sourceObjIncarnation.map) {
              var key = entryInSourceObjIncarnation.Key;
              var element = entryInSourceObjIncarnation.Value;
              if (!currentObjIncarnation.map.ContainsKey(key)) {
                EffectTerrainTileByLocationMutMapAdd(objId, key, element);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsTerrainTileByLocationMutMap[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var entryInCurrentObjIncarnation in new SortedDictionary<Location, int>(currentObjIncarnation.map)) {
              var key = entryInCurrentObjIncarnation.Key;
              if (!sourceObjIncarnation.map.ContainsKey(key)) {
                EffectKamikazeTargetTTCStrongByLocationMutMapRemove(objId, key);
              }
            }
            foreach (var entryInSourceObjIncarnation in sourceObjIncarnation.map) {
              var key = entryInSourceObjIncarnation.Key;
              var element = entryInSourceObjIncarnation.Value;
              if (!currentObjIncarnation.map.ContainsKey(key)) {
                EffectKamikazeTargetTTCStrongByLocationMutMapAdd(objId, key, element);
              }
            }
            // Swap out the underlying incarnation. The only visible effect this has is
            // changing the version number.
            rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
             
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRand) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsRand.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRand[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.rand != currentObjIncarnation.rand) {
            EffectRandSetRand(objId, sourceObjIncarnation.rand);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsRand[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHoldPositionImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsHoldPositionImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsHoldPositionImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsHoldPositionImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWanderAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWanderAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsWanderAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTutorialDefyCounterUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTutorialDefyCounterUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.numDefiesRemaining != currentObjIncarnation.numDefiesRemaining) {
            EffectTutorialDefyCounterUCSetNumDefiesRemaining(objId, sourceObjIncarnation.numDefiesRemaining);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsTutorialDefyCounterUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnit) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsUnit.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsUnit[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.evvent != currentObjIncarnation.evvent) {
            EffectUnitSetEvvent(objId, sourceObjIncarnation.evvent);
          }

          if (sourceObjIncarnation.lifeEndTime != currentObjIncarnation.lifeEndTime) {
            EffectUnitSetLifeEndTime(objId, sourceObjIncarnation.lifeEndTime);
          }

          if (sourceObjIncarnation.location != currentObjIncarnation.location) {
            EffectUnitSetLocation(objId, sourceObjIncarnation.location);
          }

          if (sourceObjIncarnation.nextActionTime != currentObjIncarnation.nextActionTime) {
            EffectUnitSetNextActionTime(objId, sourceObjIncarnation.nextActionTime);
          }

          if (sourceObjIncarnation.hp != currentObjIncarnation.hp) {
            EffectUnitSetHp(objId, sourceObjIncarnation.hp);
          }

          if (sourceObjIncarnation.maxHp != currentObjIncarnation.maxHp) {
            EffectUnitSetMaxHp(objId, sourceObjIncarnation.maxHp);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsUnit[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIUnitComponentMutBunch) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsIUnitComponentMutBunch.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIUnitComponentMutBunch[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsIUnitComponentMutBunch[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLightningChargedUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsLightningChargedUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLightningChargedUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsLightningChargedUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLightningChargingUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsLightningChargingUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLightningChargingUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsLightningChargingUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDoomedUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsDoomedUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDoomedUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsDoomedUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTemporaryCloneImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTemporaryCloneImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTemporaryCloneImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsTemporaryCloneImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTemporaryCloneAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTemporaryCloneAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.charges != currentObjIncarnation.charges) {
            EffectTemporaryCloneAICapabilityUCSetCharges(objId, sourceObjIncarnation.charges);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsTemporaryCloneAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSummonImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsSummonImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSummonImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsSummonImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSummonAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSummonAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.charges != currentObjIncarnation.charges) {
            EffectSummonAICapabilityUCSetCharges(objId, sourceObjIncarnation.charges);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsSummonAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSorcerousUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsSorcerousUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSorcerousUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.mp != currentObjIncarnation.mp) {
            EffectSorcerousUCSetMp(objId, sourceObjIncarnation.mp);
          }

          if (sourceObjIncarnation.maxMp != currentObjIncarnation.maxMp) {
            EffectSorcerousUCSetMaxMp(objId, sourceObjIncarnation.maxMp);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsSorcerousUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseOffenseUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBaseOffenseUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsBaseOffenseUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseSightRangeUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBaseSightRangeUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsBaseSightRangeUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseMovementTimeUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBaseMovementTimeUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsBaseMovementTimeUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseDefenseUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBaseDefenseUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsBaseDefenseUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseCombatTimeUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBaseCombatTimeUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsBaseCombatTimeUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMiredUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsMiredUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMiredUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsMiredUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMireImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsMireImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMireImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsMireImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEvaporateImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsEvaporateImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsEvaporateImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeCloneAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTimeCloneAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsTimeCloneAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMoveImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsMoveImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMoveImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsMoveImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeTargetTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsKamikazeTargetTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKamikazeTargetTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsKamikazeTargetTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeJumpImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsKamikazeJumpImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKamikazeJumpImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsKamikazeJumpImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeTargetImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsKamikazeTargetImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKamikazeTargetImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsKamikazeTargetImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKamikazeAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.targetByLocation != currentObjIncarnation.targetByLocation) {
            EffectKamikazeAICapabilityUCSetTargetByLocation(objId, new KamikazeTargetTTCStrongByLocationMutMap(this, sourceObjIncarnation.targetByLocation));
          }

          if (sourceObjIncarnation.targetLocationCenter != currentObjIncarnation.targetLocationCenter) {
            EffectKamikazeAICapabilityUCSetTargetLocationCenter(objId, sourceObjIncarnation.targetLocationCenter);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsKamikazeAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsInvincibilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsInvincibilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsInvincibilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGuardAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGuardAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsGuardAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsNoImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsNoImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsNoImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsNoImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsFireImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFireImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsFireImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefyingUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsDefyingUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDefyingUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsDefyingUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefyImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsDefyImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDefyImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsDefyImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounteringUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCounteringUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCounteringUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsCounteringUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounterImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCounterImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCounterImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsCounterImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnleashBideImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsUnleashBideImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsUnleashBideImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsContinueBidingImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsContinueBidingImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsContinueBidingImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStartBidingImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsStartBidingImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsStartBidingImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBideAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBideAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.charge != currentObjIncarnation.charge) {
            EffectBideAICapabilityUCSetCharge(objId, sourceObjIncarnation.charge);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsBideAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsAttackImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsAttackImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsAttackImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPursueImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsPursueImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsPursueImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsPursueImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKillDirective) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsKillDirective.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKillDirective[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsKillDirective[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsAttackAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.killDirective != currentObjIncarnation.killDirective) {
            EffectAttackAICapabilityUCSetKillDirective(objId, new KillDirective(this, sourceObjIncarnation.killDirective));
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsAttackAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWarperTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsWarperTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWarperTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsWarperTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeAnchorTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTimeAnchorTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsTimeAnchorTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTerrainTile) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTerrainTile.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTerrainTile[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.evvent != currentObjIncarnation.evvent) {
            EffectTerrainTileSetEvvent(objId, sourceObjIncarnation.evvent);
          }

          if (sourceObjIncarnation.elevation != currentObjIncarnation.elevation) {
            EffectTerrainTileSetElevation(objId, sourceObjIncarnation.elevation);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsTerrainTile[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsITerrainTileComponentMutBunch) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsITerrainTileComponentMutBunch.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsITerrainTileComponentMutBunch[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsITerrainTileComponentMutBunch[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTerrain) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTerrain.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTerrain[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.pattern != currentObjIncarnation.pattern) {
            EffectTerrainSetPattern(objId, sourceObjIncarnation.pattern);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsTerrain[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSimplePresenceTriggerTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSimplePresenceTriggerTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsSimplePresenceTriggerTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireBombImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsFireBombImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFireBombImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsFireBombImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireBombTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsFireBombTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFireBombTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.turnsUntilExplosion != currentObjIncarnation.turnsUntilExplosion) {
            EffectFireBombTTCSetTurnsUntilExplosion(objId, sourceObjIncarnation.turnsUntilExplosion);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsFireBombTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMarkerTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsMarkerTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMarkerTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsMarkerTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLevelLinkTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsLevelLinkTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLevelLinkTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsLevelLinkTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMudTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsMudTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMudTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsMudTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDirtTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsDirtTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDirtTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsDirtTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsObsidianTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsObsidianTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsObsidianTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsObsidianTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDownStairsTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsDownStairsTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDownStairsTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsDownStairsTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUpStairsTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsUpStairsTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsUpStairsTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsUpStairsTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWallTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsWallTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWallTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsWallTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBloodTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBloodTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBloodTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsBloodTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRocksTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsRocksTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRocksTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsRocksTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTreeTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTreeTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTreeTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsTreeTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWaterTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsWaterTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWaterTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsWaterTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFloorTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsFloorTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFloorTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsFloorTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveWallTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCaveWallTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCaveWallTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsCaveWallTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCaveTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCaveTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsCaveTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFallsTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsFallsTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFallsTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsFallsTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsFireTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFireTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsFireTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsObsidianFloorTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsObsidianFloorTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsObsidianFloorTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsObsidianFloorTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMagmaTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMagmaTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsMagmaTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCliffTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCliffTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsCliffTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavaNestTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsRavaNestTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRavaNestTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsRavaNestTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffLandingTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCliffLandingTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsCliffLandingTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStoneTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsStoneTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsStoneTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsStoneTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGrassTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsGrassTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGrassTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsGrassTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLevel) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsLevel.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLevel[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.controller != currentObjIncarnation.controller) {
            EffectLevelSetController(objId, GetILevelController(sourceObjIncarnation.controller));
          }

          if (sourceObjIncarnation.time != currentObjIncarnation.time) {
            EffectLevelSetTime(objId, sourceObjIncarnation.time);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsLevel[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSpeedRing) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsSpeedRing.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSpeedRing[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsSpeedRing[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsManaPotion) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsManaPotion.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsManaPotion[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsManaPotion[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWat) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsWat.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWat[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsWat[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIPreActingUCWeakMutBunch) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsIPreActingUCWeakMutBunch.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIPreActingUCWeakMutBunch[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsIPreActingUCWeakMutBunch[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIPostActingUCWeakMutBunch) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsIPostActingUCWeakMutBunch.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIPostActingUCWeakMutBunch[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsIPostActingUCWeakMutBunch[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIImpulseStrongMutBunch) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsIImpulseStrongMutBunch.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIImpulseStrongMutBunch[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsIImpulseStrongMutBunch[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIItemStrongMutBunch) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsIItemStrongMutBunch.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIItemStrongMutBunch[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsIItemStrongMutBunch[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsItemTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsItemTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsItemTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsItemTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHealthPotion) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsHealthPotion.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsHealthPotion[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsHealthPotion[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGlaive) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsGlaive.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGlaive[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsGlaive[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSlowRod) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsSlowRod.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSlowRod[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsSlowRod[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBlastRod) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBlastRod.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBlastRod[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsBlastRod[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsArmor) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsArmor.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsArmor[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsArmor[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSquareCaveLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSquareCaveLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsSquareCaveLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavashrikeLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRavashrikeLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsRavashrikeLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPentagonalCaveLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsPentagonalCaveLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsPentagonalCaveLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIncendianFallsLevelLinkerTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCliffLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCliffLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsCliffLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPreGauntletLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsPreGauntletLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsPreGauntletLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGauntletLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsGauntletLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGauntletLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsGauntletLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsComm) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsComm.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsComm[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsComm[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGame) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsGame.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGame[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.player != currentObjIncarnation.player) {
            EffectGameSetPlayer(objId, new Unit(this, sourceObjIncarnation.player));
          }

          if (sourceObjIncarnation.level != currentObjIncarnation.level) {
            EffectGameSetLevel(objId, new Level(this, sourceObjIncarnation.level));
          }

          if (sourceObjIncarnation.time != currentObjIncarnation.time) {
            EffectGameSetTime(objId, sourceObjIncarnation.time);
          }

          if (sourceObjIncarnation.actingUnit != currentObjIncarnation.actingUnit) {
            EffectGameSetActingUnit(objId, new Unit(this, sourceObjIncarnation.actingUnit));
          }

          if (sourceObjIncarnation.pauseBeforeNextUnit != currentObjIncarnation.pauseBeforeNextUnit) {
            EffectGameSetPauseBeforeNextUnit(objId, sourceObjIncarnation.pauseBeforeNextUnit);
          }

          if (sourceObjIncarnation.actionNum != currentObjIncarnation.actionNum) {
            EffectGameSetActionNum(objId, sourceObjIncarnation.actionNum);
          }

          if (sourceObjIncarnation.instructions != currentObjIncarnation.instructions) {
            EffectGameSetInstructions(objId, sourceObjIncarnation.instructions);
          }

          if (sourceObjIncarnation.hideInput != currentObjIncarnation.hideInput) {
            EffectGameSetHideInput(objId, sourceObjIncarnation.hideInput);
          }

          if (sourceObjIncarnation.evvent != currentObjIncarnation.evvent) {
            EffectGameSetEvvent(objId, sourceObjIncarnation.evvent);
          }

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsGame[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsVolcaetusLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsVolcaetusLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsVolcaetusLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsVolcaetusLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTutorial2LevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTutorial2LevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTutorial2LevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsTutorial2LevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTutorial1LevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTutorial1LevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTutorial1LevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsTutorial1LevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRetreatLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsRetreatLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRetreatLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsRetreatLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSotaventoLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsSotaventoLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSotaventoLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsSotaventoLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsNestLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsNestLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsNestLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsNestLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLakeLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsLakeLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLakeLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsLakeLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEmberDeepLevelLinkerTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsEmberDeepLevelLinkerTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsEmberDeepLevelLinkerTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDirtRoadLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsDirtRoadLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDirtRoadLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsDirtRoadLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCaveLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCaveLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsCaveLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBridgesLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBridgesLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBridgesLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsBridgesLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAncientTownLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsAncientTownLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsAncientTownLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation. The only visible effect this has is
          // changing the version number.
          
          rootIncarnation.incarnationsAncientTownLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RandIncarnation>>(rootIncarnation.incarnationsRand)) {
      if (!sourceIncarnation.incarnationsRand.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectRandDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<HoldPositionImpulseIncarnation>>(rootIncarnation.incarnationsHoldPositionImpulse)) {
      if (!sourceIncarnation.incarnationsHoldPositionImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectHoldPositionImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WanderAICapabilityUCIncarnation>>(rootIncarnation.incarnationsWanderAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectWanderAICapabilityUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TutorialDefyCounterUCIncarnation>>(rootIncarnation.incarnationsTutorialDefyCounterUC)) {
      if (!sourceIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTutorialDefyCounterUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<UnitIncarnation>>(rootIncarnation.incarnationsUnit)) {
      if (!sourceIncarnation.incarnationsUnit.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectUnitDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IUnitComponentMutBunchIncarnation>>(rootIncarnation.incarnationsIUnitComponentMutBunch)) {
      if (!sourceIncarnation.incarnationsIUnitComponentMutBunch.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectIUnitComponentMutBunchDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LightningChargedUCIncarnation>>(rootIncarnation.incarnationsLightningChargedUC)) {
      if (!sourceIncarnation.incarnationsLightningChargedUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectLightningChargedUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LightningChargingUCIncarnation>>(rootIncarnation.incarnationsLightningChargingUC)) {
      if (!sourceIncarnation.incarnationsLightningChargingUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectLightningChargingUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DoomedUCIncarnation>>(rootIncarnation.incarnationsDoomedUC)) {
      if (!sourceIncarnation.incarnationsDoomedUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectDoomedUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TemporaryCloneImpulseIncarnation>>(rootIncarnation.incarnationsTemporaryCloneImpulse)) {
      if (!sourceIncarnation.incarnationsTemporaryCloneImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTemporaryCloneImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TemporaryCloneAICapabilityUCIncarnation>>(rootIncarnation.incarnationsTemporaryCloneAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTemporaryCloneAICapabilityUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SummonImpulseIncarnation>>(rootIncarnation.incarnationsSummonImpulse)) {
      if (!sourceIncarnation.incarnationsSummonImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectSummonImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SummonAICapabilityUCIncarnation>>(rootIncarnation.incarnationsSummonAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectSummonAICapabilityUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SorcerousUCIncarnation>>(rootIncarnation.incarnationsSorcerousUC)) {
      if (!sourceIncarnation.incarnationsSorcerousUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectSorcerousUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BaseOffenseUCIncarnation>>(rootIncarnation.incarnationsBaseOffenseUC)) {
      if (!sourceIncarnation.incarnationsBaseOffenseUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBaseOffenseUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BaseSightRangeUCIncarnation>>(rootIncarnation.incarnationsBaseSightRangeUC)) {
      if (!sourceIncarnation.incarnationsBaseSightRangeUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBaseSightRangeUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BaseMovementTimeUCIncarnation>>(rootIncarnation.incarnationsBaseMovementTimeUC)) {
      if (!sourceIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBaseMovementTimeUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BaseDefenseUCIncarnation>>(rootIncarnation.incarnationsBaseDefenseUC)) {
      if (!sourceIncarnation.incarnationsBaseDefenseUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBaseDefenseUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BaseCombatTimeUCIncarnation>>(rootIncarnation.incarnationsBaseCombatTimeUC)) {
      if (!sourceIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBaseCombatTimeUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MiredUCIncarnation>>(rootIncarnation.incarnationsMiredUC)) {
      if (!sourceIncarnation.incarnationsMiredUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectMiredUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MireImpulseIncarnation>>(rootIncarnation.incarnationsMireImpulse)) {
      if (!sourceIncarnation.incarnationsMireImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectMireImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<EvaporateImpulseIncarnation>>(rootIncarnation.incarnationsEvaporateImpulse)) {
      if (!sourceIncarnation.incarnationsEvaporateImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectEvaporateImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TimeCloneAICapabilityUCIncarnation>>(rootIncarnation.incarnationsTimeCloneAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTimeCloneAICapabilityUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MoveImpulseIncarnation>>(rootIncarnation.incarnationsMoveImpulse)) {
      if (!sourceIncarnation.incarnationsMoveImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectMoveImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KamikazeTargetTTCIncarnation>>(rootIncarnation.incarnationsKamikazeTargetTTC)) {
      if (!sourceIncarnation.incarnationsKamikazeTargetTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectKamikazeTargetTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KamikazeJumpImpulseIncarnation>>(rootIncarnation.incarnationsKamikazeJumpImpulse)) {
      if (!sourceIncarnation.incarnationsKamikazeJumpImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectKamikazeJumpImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KamikazeTargetImpulseIncarnation>>(rootIncarnation.incarnationsKamikazeTargetImpulse)) {
      if (!sourceIncarnation.incarnationsKamikazeTargetImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectKamikazeTargetImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KamikazeAICapabilityUCIncarnation>>(rootIncarnation.incarnationsKamikazeAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectKamikazeAICapabilityUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<InvincibilityUCIncarnation>>(rootIncarnation.incarnationsInvincibilityUC)) {
      if (!sourceIncarnation.incarnationsInvincibilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectInvincibilityUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GuardAICapabilityUCIncarnation>>(rootIncarnation.incarnationsGuardAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectGuardAICapabilityUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<NoImpulseIncarnation>>(rootIncarnation.incarnationsNoImpulse)) {
      if (!sourceIncarnation.incarnationsNoImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectNoImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FireImpulseIncarnation>>(rootIncarnation.incarnationsFireImpulse)) {
      if (!sourceIncarnation.incarnationsFireImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectFireImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DefyingUCIncarnation>>(rootIncarnation.incarnationsDefyingUC)) {
      if (!sourceIncarnation.incarnationsDefyingUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectDefyingUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DefyImpulseIncarnation>>(rootIncarnation.incarnationsDefyImpulse)) {
      if (!sourceIncarnation.incarnationsDefyImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectDefyImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CounteringUCIncarnation>>(rootIncarnation.incarnationsCounteringUC)) {
      if (!sourceIncarnation.incarnationsCounteringUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCounteringUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CounterImpulseIncarnation>>(rootIncarnation.incarnationsCounterImpulse)) {
      if (!sourceIncarnation.incarnationsCounterImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCounterImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<UnleashBideImpulseIncarnation>>(rootIncarnation.incarnationsUnleashBideImpulse)) {
      if (!sourceIncarnation.incarnationsUnleashBideImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectUnleashBideImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ContinueBidingImpulseIncarnation>>(rootIncarnation.incarnationsContinueBidingImpulse)) {
      if (!sourceIncarnation.incarnationsContinueBidingImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectContinueBidingImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<StartBidingImpulseIncarnation>>(rootIncarnation.incarnationsStartBidingImpulse)) {
      if (!sourceIncarnation.incarnationsStartBidingImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectStartBidingImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BideAICapabilityUCIncarnation>>(rootIncarnation.incarnationsBideAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsBideAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBideAICapabilityUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<AttackImpulseIncarnation>>(rootIncarnation.incarnationsAttackImpulse)) {
      if (!sourceIncarnation.incarnationsAttackImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectAttackImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<PursueImpulseIncarnation>>(rootIncarnation.incarnationsPursueImpulse)) {
      if (!sourceIncarnation.incarnationsPursueImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectPursueImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KillDirectiveIncarnation>>(rootIncarnation.incarnationsKillDirective)) {
      if (!sourceIncarnation.incarnationsKillDirective.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectKillDirectiveDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<AttackAICapabilityUCIncarnation>>(rootIncarnation.incarnationsAttackAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectAttackAICapabilityUCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WarperTTCIncarnation>>(rootIncarnation.incarnationsWarperTTC)) {
      if (!sourceIncarnation.incarnationsWarperTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectWarperTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TimeAnchorTTCIncarnation>>(rootIncarnation.incarnationsTimeAnchorTTC)) {
      if (!sourceIncarnation.incarnationsTimeAnchorTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTimeAnchorTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TerrainTileIncarnation>>(rootIncarnation.incarnationsTerrainTile)) {
      if (!sourceIncarnation.incarnationsTerrainTile.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTerrainTileDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ITerrainTileComponentMutBunchIncarnation>>(rootIncarnation.incarnationsITerrainTileComponentMutBunch)) {
      if (!sourceIncarnation.incarnationsITerrainTileComponentMutBunch.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectITerrainTileComponentMutBunchDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TerrainIncarnation>>(rootIncarnation.incarnationsTerrain)) {
      if (!sourceIncarnation.incarnationsTerrain.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTerrainDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SimplePresenceTriggerTTCIncarnation>>(rootIncarnation.incarnationsSimplePresenceTriggerTTC)) {
      if (!sourceIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectSimplePresenceTriggerTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FireBombImpulseIncarnation>>(rootIncarnation.incarnationsFireBombImpulse)) {
      if (!sourceIncarnation.incarnationsFireBombImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectFireBombImpulseDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FireBombTTCIncarnation>>(rootIncarnation.incarnationsFireBombTTC)) {
      if (!sourceIncarnation.incarnationsFireBombTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectFireBombTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MarkerTTCIncarnation>>(rootIncarnation.incarnationsMarkerTTC)) {
      if (!sourceIncarnation.incarnationsMarkerTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectMarkerTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LevelLinkTTCIncarnation>>(rootIncarnation.incarnationsLevelLinkTTC)) {
      if (!sourceIncarnation.incarnationsLevelLinkTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectLevelLinkTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MudTTCIncarnation>>(rootIncarnation.incarnationsMudTTC)) {
      if (!sourceIncarnation.incarnationsMudTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectMudTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DirtTTCIncarnation>>(rootIncarnation.incarnationsDirtTTC)) {
      if (!sourceIncarnation.incarnationsDirtTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectDirtTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ObsidianTTCIncarnation>>(rootIncarnation.incarnationsObsidianTTC)) {
      if (!sourceIncarnation.incarnationsObsidianTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectObsidianTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DownStairsTTCIncarnation>>(rootIncarnation.incarnationsDownStairsTTC)) {
      if (!sourceIncarnation.incarnationsDownStairsTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectDownStairsTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<UpStairsTTCIncarnation>>(rootIncarnation.incarnationsUpStairsTTC)) {
      if (!sourceIncarnation.incarnationsUpStairsTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectUpStairsTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WallTTCIncarnation>>(rootIncarnation.incarnationsWallTTC)) {
      if (!sourceIncarnation.incarnationsWallTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectWallTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BloodTTCIncarnation>>(rootIncarnation.incarnationsBloodTTC)) {
      if (!sourceIncarnation.incarnationsBloodTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBloodTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RocksTTCIncarnation>>(rootIncarnation.incarnationsRocksTTC)) {
      if (!sourceIncarnation.incarnationsRocksTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectRocksTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TreeTTCIncarnation>>(rootIncarnation.incarnationsTreeTTC)) {
      if (!sourceIncarnation.incarnationsTreeTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTreeTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WaterTTCIncarnation>>(rootIncarnation.incarnationsWaterTTC)) {
      if (!sourceIncarnation.incarnationsWaterTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectWaterTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FloorTTCIncarnation>>(rootIncarnation.incarnationsFloorTTC)) {
      if (!sourceIncarnation.incarnationsFloorTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectFloorTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CaveWallTTCIncarnation>>(rootIncarnation.incarnationsCaveWallTTC)) {
      if (!sourceIncarnation.incarnationsCaveWallTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCaveWallTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CaveTTCIncarnation>>(rootIncarnation.incarnationsCaveTTC)) {
      if (!sourceIncarnation.incarnationsCaveTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCaveTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FallsTTCIncarnation>>(rootIncarnation.incarnationsFallsTTC)) {
      if (!sourceIncarnation.incarnationsFallsTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectFallsTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FireTTCIncarnation>>(rootIncarnation.incarnationsFireTTC)) {
      if (!sourceIncarnation.incarnationsFireTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectFireTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ObsidianFloorTTCIncarnation>>(rootIncarnation.incarnationsObsidianFloorTTC)) {
      if (!sourceIncarnation.incarnationsObsidianFloorTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectObsidianFloorTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MagmaTTCIncarnation>>(rootIncarnation.incarnationsMagmaTTC)) {
      if (!sourceIncarnation.incarnationsMagmaTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectMagmaTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CliffTTCIncarnation>>(rootIncarnation.incarnationsCliffTTC)) {
      if (!sourceIncarnation.incarnationsCliffTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCliffTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RavaNestTTCIncarnation>>(rootIncarnation.incarnationsRavaNestTTC)) {
      if (!sourceIncarnation.incarnationsRavaNestTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectRavaNestTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CliffLandingTTCIncarnation>>(rootIncarnation.incarnationsCliffLandingTTC)) {
      if (!sourceIncarnation.incarnationsCliffLandingTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCliffLandingTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<StoneTTCIncarnation>>(rootIncarnation.incarnationsStoneTTC)) {
      if (!sourceIncarnation.incarnationsStoneTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectStoneTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GrassTTCIncarnation>>(rootIncarnation.incarnationsGrassTTC)) {
      if (!sourceIncarnation.incarnationsGrassTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectGrassTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LevelIncarnation>>(rootIncarnation.incarnationsLevel)) {
      if (!sourceIncarnation.incarnationsLevel.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectLevelDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SpeedRingIncarnation>>(rootIncarnation.incarnationsSpeedRing)) {
      if (!sourceIncarnation.incarnationsSpeedRing.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectSpeedRingDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ManaPotionIncarnation>>(rootIncarnation.incarnationsManaPotion)) {
      if (!sourceIncarnation.incarnationsManaPotion.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectManaPotionDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WatIncarnation>>(rootIncarnation.incarnationsWat)) {
      if (!sourceIncarnation.incarnationsWat.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectWatDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IPreActingUCWeakMutBunchIncarnation>>(rootIncarnation.incarnationsIPreActingUCWeakMutBunch)) {
      if (!sourceIncarnation.incarnationsIPreActingUCWeakMutBunch.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectIPreActingUCWeakMutBunchDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IPostActingUCWeakMutBunchIncarnation>>(rootIncarnation.incarnationsIPostActingUCWeakMutBunch)) {
      if (!sourceIncarnation.incarnationsIPostActingUCWeakMutBunch.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectIPostActingUCWeakMutBunchDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IImpulseStrongMutBunchIncarnation>>(rootIncarnation.incarnationsIImpulseStrongMutBunch)) {
      if (!sourceIncarnation.incarnationsIImpulseStrongMutBunch.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectIImpulseStrongMutBunchDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IItemStrongMutBunchIncarnation>>(rootIncarnation.incarnationsIItemStrongMutBunch)) {
      if (!sourceIncarnation.incarnationsIItemStrongMutBunch.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectIItemStrongMutBunchDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ItemTTCIncarnation>>(rootIncarnation.incarnationsItemTTC)) {
      if (!sourceIncarnation.incarnationsItemTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectItemTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<HealthPotionIncarnation>>(rootIncarnation.incarnationsHealthPotion)) {
      if (!sourceIncarnation.incarnationsHealthPotion.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectHealthPotionDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GlaiveIncarnation>>(rootIncarnation.incarnationsGlaive)) {
      if (!sourceIncarnation.incarnationsGlaive.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectGlaiveDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SlowRodIncarnation>>(rootIncarnation.incarnationsSlowRod)) {
      if (!sourceIncarnation.incarnationsSlowRod.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectSlowRodDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BlastRodIncarnation>>(rootIncarnation.incarnationsBlastRod)) {
      if (!sourceIncarnation.incarnationsBlastRod.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBlastRodDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ArmorIncarnation>>(rootIncarnation.incarnationsArmor)) {
      if (!sourceIncarnation.incarnationsArmor.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectArmorDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SquareCaveLevelControllerIncarnation>>(rootIncarnation.incarnationsSquareCaveLevelController)) {
      if (!sourceIncarnation.incarnationsSquareCaveLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectSquareCaveLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RavashrikeLevelControllerIncarnation>>(rootIncarnation.incarnationsRavashrikeLevelController)) {
      if (!sourceIncarnation.incarnationsRavashrikeLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectRavashrikeLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<PentagonalCaveLevelControllerIncarnation>>(rootIncarnation.incarnationsPentagonalCaveLevelController)) {
      if (!sourceIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectPentagonalCaveLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IncendianFallsLevelLinkerTTCIncarnation>>(rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC)) {
      if (!sourceIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectIncendianFallsLevelLinkerTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CliffLevelControllerIncarnation>>(rootIncarnation.incarnationsCliffLevelController)) {
      if (!sourceIncarnation.incarnationsCliffLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCliffLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<PreGauntletLevelControllerIncarnation>>(rootIncarnation.incarnationsPreGauntletLevelController)) {
      if (!sourceIncarnation.incarnationsPreGauntletLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectPreGauntletLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GauntletLevelControllerIncarnation>>(rootIncarnation.incarnationsGauntletLevelController)) {
      if (!sourceIncarnation.incarnationsGauntletLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectGauntletLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CommIncarnation>>(rootIncarnation.incarnationsComm)) {
      if (!sourceIncarnation.incarnationsComm.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCommDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GameIncarnation>>(rootIncarnation.incarnationsGame)) {
      if (!sourceIncarnation.incarnationsGame.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectGameDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<VolcaetusLevelControllerIncarnation>>(rootIncarnation.incarnationsVolcaetusLevelController)) {
      if (!sourceIncarnation.incarnationsVolcaetusLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectVolcaetusLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<Tutorial2LevelControllerIncarnation>>(rootIncarnation.incarnationsTutorial2LevelController)) {
      if (!sourceIncarnation.incarnationsTutorial2LevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTutorial2LevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<Tutorial1LevelControllerIncarnation>>(rootIncarnation.incarnationsTutorial1LevelController)) {
      if (!sourceIncarnation.incarnationsTutorial1LevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTutorial1LevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RetreatLevelControllerIncarnation>>(rootIncarnation.incarnationsRetreatLevelController)) {
      if (!sourceIncarnation.incarnationsRetreatLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectRetreatLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SotaventoLevelControllerIncarnation>>(rootIncarnation.incarnationsSotaventoLevelController)) {
      if (!sourceIncarnation.incarnationsSotaventoLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectSotaventoLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<NestLevelControllerIncarnation>>(rootIncarnation.incarnationsNestLevelController)) {
      if (!sourceIncarnation.incarnationsNestLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectNestLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LakeLevelControllerIncarnation>>(rootIncarnation.incarnationsLakeLevelController)) {
      if (!sourceIncarnation.incarnationsLakeLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectLakeLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<EmberDeepLevelLinkerTTCIncarnation>>(rootIncarnation.incarnationsEmberDeepLevelLinkerTTC)) {
      if (!sourceIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectEmberDeepLevelLinkerTTCDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DirtRoadLevelControllerIncarnation>>(rootIncarnation.incarnationsDirtRoadLevelController)) {
      if (!sourceIncarnation.incarnationsDirtRoadLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectDirtRoadLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CaveLevelControllerIncarnation>>(rootIncarnation.incarnationsCaveLevelController)) {
      if (!sourceIncarnation.incarnationsCaveLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCaveLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BridgesLevelControllerIncarnation>>(rootIncarnation.incarnationsBridgesLevelController)) {
      if (!sourceIncarnation.incarnationsBridgesLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBridgesLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<AncientTownLevelControllerIncarnation>>(rootIncarnation.incarnationsAncientTownLevelController)) {
      if (!sourceIncarnation.incarnationsAncientTownLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectAncientTownLevelControllerDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CommMutListIncarnation>>(rootIncarnation.incarnationsCommMutList)) {
      if (!sourceIncarnation.incarnationsCommMutList.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCommMutListDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LocationMutListIncarnation>>(rootIncarnation.incarnationsLocationMutList)) {
      if (!sourceIncarnation.incarnationsLocationMutList.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectLocationMutListDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IRequestMutListIncarnation>>(rootIncarnation.incarnationsIRequestMutList)) {
      if (!sourceIncarnation.incarnationsIRequestMutList.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectIRequestMutListDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LevelMutSetIncarnation>>(rootIncarnation.incarnationsLevelMutSet)) {
      if (!sourceIncarnation.incarnationsLevelMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectLevelMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ManaPotionStrongMutSetIncarnation>>(rootIncarnation.incarnationsManaPotionStrongMutSet)) {
      if (!sourceIncarnation.incarnationsManaPotionStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectManaPotionStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<HealthPotionStrongMutSetIncarnation>>(rootIncarnation.incarnationsHealthPotionStrongMutSet)) {
      if (!sourceIncarnation.incarnationsHealthPotionStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectHealthPotionStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SpeedRingStrongMutSetIncarnation>>(rootIncarnation.incarnationsSpeedRingStrongMutSet)) {
      if (!sourceIncarnation.incarnationsSpeedRingStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectSpeedRingStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GlaiveStrongMutSetIncarnation>>(rootIncarnation.incarnationsGlaiveStrongMutSet)) {
      if (!sourceIncarnation.incarnationsGlaiveStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectGlaiveStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SlowRodStrongMutSetIncarnation>>(rootIncarnation.incarnationsSlowRodStrongMutSet)) {
      if (!sourceIncarnation.incarnationsSlowRodStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectSlowRodStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BlastRodStrongMutSetIncarnation>>(rootIncarnation.incarnationsBlastRodStrongMutSet)) {
      if (!sourceIncarnation.incarnationsBlastRodStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBlastRodStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ArmorStrongMutSetIncarnation>>(rootIncarnation.incarnationsArmorStrongMutSet)) {
      if (!sourceIncarnation.incarnationsArmorStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectArmorStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<HoldPositionImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsHoldPositionImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectHoldPositionImpulseStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TemporaryCloneImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTemporaryCloneImpulseStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SummonImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsSummonImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsSummonImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectSummonImpulseStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MireImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsMireImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsMireImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectMireImpulseStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<EvaporateImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsEvaporateImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsEvaporateImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectEvaporateImpulseStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MoveImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsMoveImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsMoveImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectMoveImpulseStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KamikazeJumpImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectKamikazeJumpImpulseStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KamikazeTargetImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectKamikazeTargetImpulseStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<NoImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsNoImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsNoImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectNoImpulseStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FireImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsFireImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsFireImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectFireImpulseStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DefyImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsDefyImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsDefyImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectDefyImpulseStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CounterImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsCounterImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsCounterImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCounterImpulseStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<UnleashBideImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsUnleashBideImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectUnleashBideImpulseStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ContinueBidingImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsContinueBidingImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectContinueBidingImpulseStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<StartBidingImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsStartBidingImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsStartBidingImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectStartBidingImpulseStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<AttackImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsAttackImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsAttackImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectAttackImpulseStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<PursueImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsPursueImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsPursueImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectPursueImpulseStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FireBombImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsFireBombImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsFireBombImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectFireBombImpulseStrongMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LightningChargedUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsLightningChargedUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsLightningChargedUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectLightningChargedUCWeakMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TimeCloneAICapabilityUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTimeCloneAICapabilityUCWeakMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DoomedUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsDoomedUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsDoomedUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectDoomedUCWeakMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MiredUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsMiredUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsMiredUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectMiredUCWeakMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<InvincibilityUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsInvincibilityUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsInvincibilityUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectInvincibilityUCWeakMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DefyingUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsDefyingUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsDefyingUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectDefyingUCWeakMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CounteringUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsCounteringUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsCounteringUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCounteringUCWeakMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<AttackAICapabilityUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectAttackAICapabilityUCWeakMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<UnitMutSetIncarnation>>(rootIncarnation.incarnationsUnitMutSet)) {
      if (!sourceIncarnation.incarnationsUnitMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectUnitMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SimplePresenceTriggerTTCMutSetIncarnation>>(rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet)) {
      if (!sourceIncarnation.incarnationsSimplePresenceTriggerTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectSimplePresenceTriggerTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ItemTTCMutSetIncarnation>>(rootIncarnation.incarnationsItemTTCMutSet)) {
      if (!sourceIncarnation.incarnationsItemTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectItemTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KamikazeTargetTTCMutSetIncarnation>>(rootIncarnation.incarnationsKamikazeTargetTTCMutSet)) {
      if (!sourceIncarnation.incarnationsKamikazeTargetTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectKamikazeTargetTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WarperTTCMutSetIncarnation>>(rootIncarnation.incarnationsWarperTTCMutSet)) {
      if (!sourceIncarnation.incarnationsWarperTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectWarperTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TimeAnchorTTCMutSetIncarnation>>(rootIncarnation.incarnationsTimeAnchorTTCMutSet)) {
      if (!sourceIncarnation.incarnationsTimeAnchorTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTimeAnchorTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FireBombTTCMutSetIncarnation>>(rootIncarnation.incarnationsFireBombTTCMutSet)) {
      if (!sourceIncarnation.incarnationsFireBombTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectFireBombTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MarkerTTCMutSetIncarnation>>(rootIncarnation.incarnationsMarkerTTCMutSet)) {
      if (!sourceIncarnation.incarnationsMarkerTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectMarkerTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LevelLinkTTCMutSetIncarnation>>(rootIncarnation.incarnationsLevelLinkTTCMutSet)) {
      if (!sourceIncarnation.incarnationsLevelLinkTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectLevelLinkTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MudTTCMutSetIncarnation>>(rootIncarnation.incarnationsMudTTCMutSet)) {
      if (!sourceIncarnation.incarnationsMudTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectMudTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DirtTTCMutSetIncarnation>>(rootIncarnation.incarnationsDirtTTCMutSet)) {
      if (!sourceIncarnation.incarnationsDirtTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectDirtTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ObsidianTTCMutSetIncarnation>>(rootIncarnation.incarnationsObsidianTTCMutSet)) {
      if (!sourceIncarnation.incarnationsObsidianTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectObsidianTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DownStairsTTCMutSetIncarnation>>(rootIncarnation.incarnationsDownStairsTTCMutSet)) {
      if (!sourceIncarnation.incarnationsDownStairsTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectDownStairsTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<UpStairsTTCMutSetIncarnation>>(rootIncarnation.incarnationsUpStairsTTCMutSet)) {
      if (!sourceIncarnation.incarnationsUpStairsTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectUpStairsTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WallTTCMutSetIncarnation>>(rootIncarnation.incarnationsWallTTCMutSet)) {
      if (!sourceIncarnation.incarnationsWallTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectWallTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BloodTTCMutSetIncarnation>>(rootIncarnation.incarnationsBloodTTCMutSet)) {
      if (!sourceIncarnation.incarnationsBloodTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBloodTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RocksTTCMutSetIncarnation>>(rootIncarnation.incarnationsRocksTTCMutSet)) {
      if (!sourceIncarnation.incarnationsRocksTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectRocksTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TreeTTCMutSetIncarnation>>(rootIncarnation.incarnationsTreeTTCMutSet)) {
      if (!sourceIncarnation.incarnationsTreeTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTreeTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WaterTTCMutSetIncarnation>>(rootIncarnation.incarnationsWaterTTCMutSet)) {
      if (!sourceIncarnation.incarnationsWaterTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectWaterTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FloorTTCMutSetIncarnation>>(rootIncarnation.incarnationsFloorTTCMutSet)) {
      if (!sourceIncarnation.incarnationsFloorTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectFloorTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CaveWallTTCMutSetIncarnation>>(rootIncarnation.incarnationsCaveWallTTCMutSet)) {
      if (!sourceIncarnation.incarnationsCaveWallTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCaveWallTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CaveTTCMutSetIncarnation>>(rootIncarnation.incarnationsCaveTTCMutSet)) {
      if (!sourceIncarnation.incarnationsCaveTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCaveTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FallsTTCMutSetIncarnation>>(rootIncarnation.incarnationsFallsTTCMutSet)) {
      if (!sourceIncarnation.incarnationsFallsTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectFallsTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FireTTCMutSetIncarnation>>(rootIncarnation.incarnationsFireTTCMutSet)) {
      if (!sourceIncarnation.incarnationsFireTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectFireTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ObsidianFloorTTCMutSetIncarnation>>(rootIncarnation.incarnationsObsidianFloorTTCMutSet)) {
      if (!sourceIncarnation.incarnationsObsidianFloorTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectObsidianFloorTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MagmaTTCMutSetIncarnation>>(rootIncarnation.incarnationsMagmaTTCMutSet)) {
      if (!sourceIncarnation.incarnationsMagmaTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectMagmaTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CliffTTCMutSetIncarnation>>(rootIncarnation.incarnationsCliffTTCMutSet)) {
      if (!sourceIncarnation.incarnationsCliffTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCliffTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RavaNestTTCMutSetIncarnation>>(rootIncarnation.incarnationsRavaNestTTCMutSet)) {
      if (!sourceIncarnation.incarnationsRavaNestTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectRavaNestTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CliffLandingTTCMutSetIncarnation>>(rootIncarnation.incarnationsCliffLandingTTCMutSet)) {
      if (!sourceIncarnation.incarnationsCliffLandingTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCliffLandingTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<StoneTTCMutSetIncarnation>>(rootIncarnation.incarnationsStoneTTCMutSet)) {
      if (!sourceIncarnation.incarnationsStoneTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectStoneTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GrassTTCMutSetIncarnation>>(rootIncarnation.incarnationsGrassTTCMutSet)) {
      if (!sourceIncarnation.incarnationsGrassTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectGrassTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IncendianFallsLevelLinkerTTCMutSetIncarnation>>(rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet)) {
      if (!sourceIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectIncendianFallsLevelLinkerTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<EmberDeepLevelLinkerTTCMutSetIncarnation>>(rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet)) {
      if (!sourceIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectEmberDeepLevelLinkerTTCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TutorialDefyCounterUCMutSetIncarnation>>(rootIncarnation.incarnationsTutorialDefyCounterUCMutSet)) {
      if (!sourceIncarnation.incarnationsTutorialDefyCounterUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTutorialDefyCounterUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LightningChargingUCMutSetIncarnation>>(rootIncarnation.incarnationsLightningChargingUCMutSet)) {
      if (!sourceIncarnation.incarnationsLightningChargingUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectLightningChargingUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WanderAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsWanderAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsWanderAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectWanderAICapabilityUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TemporaryCloneAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTemporaryCloneAICapabilityUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SummonAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsSummonAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsSummonAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectSummonAICapabilityUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KamikazeAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsKamikazeAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectKamikazeAICapabilityUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GuardAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsGuardAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsGuardAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectGuardAICapabilityUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TimeCloneAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTimeCloneAICapabilityUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DoomedUCMutSetIncarnation>>(rootIncarnation.incarnationsDoomedUCMutSet)) {
      if (!sourceIncarnation.incarnationsDoomedUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectDoomedUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MiredUCMutSetIncarnation>>(rootIncarnation.incarnationsMiredUCMutSet)) {
      if (!sourceIncarnation.incarnationsMiredUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectMiredUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<AttackAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsAttackAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsAttackAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectAttackAICapabilityUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CounteringUCMutSetIncarnation>>(rootIncarnation.incarnationsCounteringUCMutSet)) {
      if (!sourceIncarnation.incarnationsCounteringUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectCounteringUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LightningChargedUCMutSetIncarnation>>(rootIncarnation.incarnationsLightningChargedUCMutSet)) {
      if (!sourceIncarnation.incarnationsLightningChargedUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectLightningChargedUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<InvincibilityUCMutSetIncarnation>>(rootIncarnation.incarnationsInvincibilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsInvincibilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectInvincibilityUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DefyingUCMutSetIncarnation>>(rootIncarnation.incarnationsDefyingUCMutSet)) {
      if (!sourceIncarnation.incarnationsDefyingUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectDefyingUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BideAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsBideAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsBideAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBideAICapabilityUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BaseSightRangeUCMutSetIncarnation>>(rootIncarnation.incarnationsBaseSightRangeUCMutSet)) {
      if (!sourceIncarnation.incarnationsBaseSightRangeUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBaseSightRangeUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BaseMovementTimeUCMutSetIncarnation>>(rootIncarnation.incarnationsBaseMovementTimeUCMutSet)) {
      if (!sourceIncarnation.incarnationsBaseMovementTimeUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBaseMovementTimeUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BaseCombatTimeUCMutSetIncarnation>>(rootIncarnation.incarnationsBaseCombatTimeUCMutSet)) {
      if (!sourceIncarnation.incarnationsBaseCombatTimeUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBaseCombatTimeUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ManaPotionMutSetIncarnation>>(rootIncarnation.incarnationsManaPotionMutSet)) {
      if (!sourceIncarnation.incarnationsManaPotionMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectManaPotionMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<HealthPotionMutSetIncarnation>>(rootIncarnation.incarnationsHealthPotionMutSet)) {
      if (!sourceIncarnation.incarnationsHealthPotionMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectHealthPotionMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SpeedRingMutSetIncarnation>>(rootIncarnation.incarnationsSpeedRingMutSet)) {
      if (!sourceIncarnation.incarnationsSpeedRingMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectSpeedRingMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GlaiveMutSetIncarnation>>(rootIncarnation.incarnationsGlaiveMutSet)) {
      if (!sourceIncarnation.incarnationsGlaiveMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectGlaiveMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SlowRodMutSetIncarnation>>(rootIncarnation.incarnationsSlowRodMutSet)) {
      if (!sourceIncarnation.incarnationsSlowRodMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectSlowRodMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BlastRodMutSetIncarnation>>(rootIncarnation.incarnationsBlastRodMutSet)) {
      if (!sourceIncarnation.incarnationsBlastRodMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBlastRodMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ArmorMutSetIncarnation>>(rootIncarnation.incarnationsArmorMutSet)) {
      if (!sourceIncarnation.incarnationsArmorMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectArmorMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SorcerousUCMutSetIncarnation>>(rootIncarnation.incarnationsSorcerousUCMutSet)) {
      if (!sourceIncarnation.incarnationsSorcerousUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectSorcerousUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BaseOffenseUCMutSetIncarnation>>(rootIncarnation.incarnationsBaseOffenseUCMutSet)) {
      if (!sourceIncarnation.incarnationsBaseOffenseUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBaseOffenseUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BaseDefenseUCMutSetIncarnation>>(rootIncarnation.incarnationsBaseDefenseUCMutSet)) {
      if (!sourceIncarnation.incarnationsBaseDefenseUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectBaseDefenseUCMutSetDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TerrainTileByLocationMutMapIncarnation>>(rootIncarnation.incarnationsTerrainTileByLocationMutMap)) {
      if (!sourceIncarnation.incarnationsTerrainTileByLocationMutMap.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectTerrainTileByLocationMutMapDelete(id);
      }
    }

    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KamikazeTargetTTCStrongByLocationMutMapIncarnation>>(rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap)) {
      if (!sourceIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        EffectKamikazeTargetTTCStrongByLocationMutMapDelete(id);
      }
    }

    logger.Error("after reverting next id " + rootIncarnation.nextId);
  }
       public RandIncarnation GetRandIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsRand[id].incarnation;
  }
  public bool RandExists(int id) {
    return rootIncarnation.incarnationsRand.ContainsKey(id);
  }
  public Rand GetRand(int id) {
    CheckHasRand(id);
    return new Rand(this, id);
  }
  public Rand GetRandOrNull(int id) {
    if (RandExists(id)) {
      return new Rand(this, id);
    } else {
      return new Rand(this, 0);
    }
  }
  public List<Rand> AllRand() {
    List<Rand> result = new List<Rand>(rootIncarnation.incarnationsRand.Count);
    foreach (var id in rootIncarnation.incarnationsRand.Keys) {
      result.Add(new Rand(this, id));
    }
    return result;
  }
  public IEnumerator<Rand> EnumAllRand() {
    foreach (var id in rootIncarnation.incarnationsRand.Keys) {
      yield return GetRand(id);
    }
  }
  public void CheckHasRand(Rand thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasRand(thing.id);
  }
  public void CheckHasRand(int id) {
    if (!rootIncarnation.incarnationsRand.ContainsKey(id)) {
      throw new System.Exception("Invalid Rand: " + id);
    }
  }
  public Rand EffectRandCreate(
      int rand) {
    return TrustedEffectRandCreateWithId(NewId()
            ,rand    );
  }
  public Rand TrustedEffectRandCreateWithId(int id
,      int rand) {
    CheckUnlocked();

    var incarnation =
        new RandIncarnation(
            rand
            );
    return EffectInternalCreateRand(id, rootIncarnation.version, incarnation);
  }
  public Rand EffectInternalCreateRand(
      int id,
      int incarnationVersion,
      RandIncarnation incarnation) {
    CheckUnlocked();
    var effect = new RandCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsRand.Add(
        id,
        new VersionAndIncarnation<RandIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new Rand(this, id);
  }

  public void EffectRandDelete(int id) {
    CheckUnlocked();
    var effect = new RandDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsRand[id];

    rootIncarnation.incarnationsRand.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetRandHash(int id, int version, RandIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.rand.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectRandSetRand(int id, int newValue) {
    CheckUnlocked();
    CheckHasRand(id);
var effect = new RandSetRandEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsRand[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.rand;
      oldIncarnationAndVersion.incarnation.rand = newValue;

    } else {
      var newIncarnation =
          new RandIncarnation(
              newValue);
      rootIncarnation.incarnationsRand[id] =
          new VersionAndIncarnation<RandIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }
  public HoldPositionImpulseIncarnation GetHoldPositionImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsHoldPositionImpulse[id].incarnation;
  }
  public bool HoldPositionImpulseExists(int id) {
    return rootIncarnation.incarnationsHoldPositionImpulse.ContainsKey(id);
  }
  public HoldPositionImpulse GetHoldPositionImpulse(int id) {
    CheckHasHoldPositionImpulse(id);
    return new HoldPositionImpulse(this, id);
  }
  public HoldPositionImpulse GetHoldPositionImpulseOrNull(int id) {
    if (HoldPositionImpulseExists(id)) {
      return new HoldPositionImpulse(this, id);
    } else {
      return new HoldPositionImpulse(this, 0);
    }
  }
  public List<HoldPositionImpulse> AllHoldPositionImpulse() {
    List<HoldPositionImpulse> result = new List<HoldPositionImpulse>(rootIncarnation.incarnationsHoldPositionImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsHoldPositionImpulse.Keys) {
      result.Add(new HoldPositionImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<HoldPositionImpulse> EnumAllHoldPositionImpulse() {
    foreach (var id in rootIncarnation.incarnationsHoldPositionImpulse.Keys) {
      yield return GetHoldPositionImpulse(id);
    }
  }
  public void CheckHasHoldPositionImpulse(HoldPositionImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasHoldPositionImpulse(thing.id);
  }
  public void CheckHasHoldPositionImpulse(int id) {
    if (!rootIncarnation.incarnationsHoldPositionImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid HoldPositionImpulse: " + id);
    }
  }
  public HoldPositionImpulse EffectHoldPositionImpulseCreate(
      int weight,
      int duration) {
    return TrustedEffectHoldPositionImpulseCreateWithId(NewId()
            ,weight
            ,duration    );
  }
  public HoldPositionImpulse TrustedEffectHoldPositionImpulseCreateWithId(int id
,      int weight
,      int duration) {
    CheckUnlocked();

    var incarnation =
        new HoldPositionImpulseIncarnation(
            weight,
            duration
            );
    return EffectInternalCreateHoldPositionImpulse(id, rootIncarnation.version, incarnation);
  }
  public HoldPositionImpulse EffectInternalCreateHoldPositionImpulse(
      int id,
      int incarnationVersion,
      HoldPositionImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new HoldPositionImpulseCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsHoldPositionImpulse.Add(
        id,
        new VersionAndIncarnation<HoldPositionImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new HoldPositionImpulse(this, id);
  }

  public void EffectHoldPositionImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new HoldPositionImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsHoldPositionImpulse[id];

    rootIncarnation.incarnationsHoldPositionImpulse.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetHoldPositionImpulseHash(int id, int version, HoldPositionImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.duration.GetDeterministicHashCode();
    return result;
  }
       public WanderAICapabilityUCIncarnation GetWanderAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsWanderAICapabilityUC[id].incarnation;
  }
  public bool WanderAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id);
  }
  public WanderAICapabilityUC GetWanderAICapabilityUC(int id) {
    CheckHasWanderAICapabilityUC(id);
    return new WanderAICapabilityUC(this, id);
  }
  public WanderAICapabilityUC GetWanderAICapabilityUCOrNull(int id) {
    if (WanderAICapabilityUCExists(id)) {
      return new WanderAICapabilityUC(this, id);
    } else {
      return new WanderAICapabilityUC(this, 0);
    }
  }
  public List<WanderAICapabilityUC> AllWanderAICapabilityUC() {
    List<WanderAICapabilityUC> result = new List<WanderAICapabilityUC>(rootIncarnation.incarnationsWanderAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsWanderAICapabilityUC.Keys) {
      result.Add(new WanderAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<WanderAICapabilityUC> EnumAllWanderAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsWanderAICapabilityUC.Keys) {
      yield return GetWanderAICapabilityUC(id);
    }
  }
  public void CheckHasWanderAICapabilityUC(WanderAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasWanderAICapabilityUC(thing.id);
  }
  public void CheckHasWanderAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid WanderAICapabilityUC: " + id);
    }
  }
  public WanderAICapabilityUC EffectWanderAICapabilityUCCreate(
) {
    return TrustedEffectWanderAICapabilityUCCreateWithId(NewId()
    );
  }
  public WanderAICapabilityUC TrustedEffectWanderAICapabilityUCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new WanderAICapabilityUCIncarnation(

            );
    return EffectInternalCreateWanderAICapabilityUC(id, rootIncarnation.version, incarnation);
  }
  public WanderAICapabilityUC EffectInternalCreateWanderAICapabilityUC(
      int id,
      int incarnationVersion,
      WanderAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new WanderAICapabilityUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsWanderAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<WanderAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new WanderAICapabilityUC(this, id);
  }

  public void EffectWanderAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = new WanderAICapabilityUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsWanderAICapabilityUC[id];

    rootIncarnation.incarnationsWanderAICapabilityUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetWanderAICapabilityUCHash(int id, int version, WanderAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public TutorialDefyCounterUCIncarnation GetTutorialDefyCounterUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTutorialDefyCounterUC[id].incarnation;
  }
  public bool TutorialDefyCounterUCExists(int id) {
    return rootIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(id);
  }
  public TutorialDefyCounterUC GetTutorialDefyCounterUC(int id) {
    CheckHasTutorialDefyCounterUC(id);
    return new TutorialDefyCounterUC(this, id);
  }
  public TutorialDefyCounterUC GetTutorialDefyCounterUCOrNull(int id) {
    if (TutorialDefyCounterUCExists(id)) {
      return new TutorialDefyCounterUC(this, id);
    } else {
      return new TutorialDefyCounterUC(this, 0);
    }
  }
  public List<TutorialDefyCounterUC> AllTutorialDefyCounterUC() {
    List<TutorialDefyCounterUC> result = new List<TutorialDefyCounterUC>(rootIncarnation.incarnationsTutorialDefyCounterUC.Count);
    foreach (var id in rootIncarnation.incarnationsTutorialDefyCounterUC.Keys) {
      result.Add(new TutorialDefyCounterUC(this, id));
    }
    return result;
  }
  public IEnumerator<TutorialDefyCounterUC> EnumAllTutorialDefyCounterUC() {
    foreach (var id in rootIncarnation.incarnationsTutorialDefyCounterUC.Keys) {
      yield return GetTutorialDefyCounterUC(id);
    }
  }
  public void CheckHasTutorialDefyCounterUC(TutorialDefyCounterUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTutorialDefyCounterUC(thing.id);
  }
  public void CheckHasTutorialDefyCounterUC(int id) {
    if (!rootIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(id)) {
      throw new System.Exception("Invalid TutorialDefyCounterUC: " + id);
    }
  }
  public TutorialDefyCounterUC EffectTutorialDefyCounterUCCreate(
      int numDefiesRemaining,
      string onChangeTriggerName) {
    return TrustedEffectTutorialDefyCounterUCCreateWithId(NewId()
            ,numDefiesRemaining
            ,onChangeTriggerName    );
  }
  public TutorialDefyCounterUC TrustedEffectTutorialDefyCounterUCCreateWithId(int id
,      int numDefiesRemaining
,      string onChangeTriggerName) {
    CheckUnlocked();

    var incarnation =
        new TutorialDefyCounterUCIncarnation(
            numDefiesRemaining,
            onChangeTriggerName
            );
    return EffectInternalCreateTutorialDefyCounterUC(id, rootIncarnation.version, incarnation);
  }
  public TutorialDefyCounterUC EffectInternalCreateTutorialDefyCounterUC(
      int id,
      int incarnationVersion,
      TutorialDefyCounterUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new TutorialDefyCounterUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsTutorialDefyCounterUC.Add(
        id,
        new VersionAndIncarnation<TutorialDefyCounterUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new TutorialDefyCounterUC(this, id);
  }

  public void EffectTutorialDefyCounterUCDelete(int id) {
    CheckUnlocked();
    var effect = new TutorialDefyCounterUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTutorialDefyCounterUC[id];

    rootIncarnation.incarnationsTutorialDefyCounterUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetTutorialDefyCounterUCHash(int id, int version, TutorialDefyCounterUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.numDefiesRemaining.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.onChangeTriggerName.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectTutorialDefyCounterUCSetNumDefiesRemaining(int id, int newValue) {
    CheckUnlocked();
    CheckHasTutorialDefyCounterUC(id);
var effect = new TutorialDefyCounterUCSetNumDefiesRemainingEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsTutorialDefyCounterUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.numDefiesRemaining;
      oldIncarnationAndVersion.incarnation.numDefiesRemaining = newValue;

    } else {
      var newIncarnation =
          new TutorialDefyCounterUCIncarnation(
              newValue,
              oldIncarnationAndVersion.incarnation.onChangeTriggerName);
      rootIncarnation.incarnationsTutorialDefyCounterUC[id] =
          new VersionAndIncarnation<TutorialDefyCounterUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }
  public UnitIncarnation GetUnitIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsUnit[id].incarnation;
  }
  public bool UnitExists(int id) {
    return rootIncarnation.incarnationsUnit.ContainsKey(id);
  }
  public Unit GetUnit(int id) {
    CheckHasUnit(id);
    return new Unit(this, id);
  }
  public Unit GetUnitOrNull(int id) {
    if (UnitExists(id)) {
      return new Unit(this, id);
    } else {
      return new Unit(this, 0);
    }
  }
  public List<Unit> AllUnit() {
    List<Unit> result = new List<Unit>(rootIncarnation.incarnationsUnit.Count);
    foreach (var id in rootIncarnation.incarnationsUnit.Keys) {
      result.Add(new Unit(this, id));
    }
    return result;
  }
  public IEnumerator<Unit> EnumAllUnit() {
    foreach (var id in rootIncarnation.incarnationsUnit.Keys) {
      yield return GetUnit(id);
    }
  }
  public void CheckHasUnit(Unit thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasUnit(thing.id);
  }
  public void CheckHasUnit(int id) {
    if (!rootIncarnation.incarnationsUnit.ContainsKey(id)) {
      throw new System.Exception("Invalid Unit: " + id);
    }
  }
  public Unit EffectUnitCreate(
      IUnitEvent evvent,
      int lifeEndTime,
      Location location,
      string classId,
      int nextActionTime,
      int hp,
      int maxHp,
      IUnitComponentMutBunch components,
      bool good) {
    CheckHasIUnitComponentMutBunch(components);
    return TrustedEffectUnitCreateWithId(NewId()
            ,evvent
            ,lifeEndTime
            ,location
            ,classId
            ,nextActionTime
            ,hp
            ,maxHp
            ,components.id
            ,good    );
  }
  public Unit TrustedEffectUnitCreateWithId(int id
,      IUnitEvent evvent
,      int lifeEndTime
,      Location location
,      string classId
,      int nextActionTime
,      int hp
,      int maxHp
,      int components
,      bool good) {
    CheckUnlocked();

    var incarnation =
        new UnitIncarnation(
            evvent,
            lifeEndTime,
            location,
            classId,
            nextActionTime,
            hp,
            maxHp,
            components,
            good
            );
    return EffectInternalCreateUnit(id, rootIncarnation.version, incarnation);
  }
  public Unit EffectInternalCreateUnit(
      int id,
      int incarnationVersion,
      UnitIncarnation incarnation) {
    CheckUnlocked();
    var effect = new UnitCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsUnit.Add(
        id,
        new VersionAndIncarnation<UnitIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new Unit(this, id);
  }

  public void EffectUnitDelete(int id) {
    CheckUnlocked();
    var effect = new UnitDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsUnit[id];

    rootIncarnation.incarnationsUnit.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetUnitHash(int id, int version, UnitIncarnation incarnation) {
    int result = id * version;
    if (!object.ReferenceEquals(incarnation.evvent, null)) {
      result += id * version * 1 * incarnation.evvent.GetDeterministicHashCode();
    }
    result += id * version * 2 * incarnation.lifeEndTime.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.location.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.classId.GetDeterministicHashCode();
    result += id * version * 5 * incarnation.nextActionTime.GetDeterministicHashCode();
    result += id * version * 6 * incarnation.hp.GetDeterministicHashCode();
    result += id * version * 7 * incarnation.maxHp.GetDeterministicHashCode();
    result += id * version * 8 * incarnation.components.GetDeterministicHashCode();
    result += id * version * 9 * incarnation.good.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectUnitSetEvvent(int id, IUnitEvent newValue) {
    CheckUnlocked();
    CheckHasUnit(id);
var effect = new UnitSetEvventEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsUnit[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.evvent;
      oldIncarnationAndVersion.incarnation.evvent = newValue;

    } else {
      var newIncarnation =
          new UnitIncarnation(
              newValue,
              oldIncarnationAndVersion.incarnation.lifeEndTime,
              oldIncarnationAndVersion.incarnation.location,
              oldIncarnationAndVersion.incarnation.classId,
              oldIncarnationAndVersion.incarnation.nextActionTime,
              oldIncarnationAndVersion.incarnation.hp,
              oldIncarnationAndVersion.incarnation.maxHp,
              oldIncarnationAndVersion.incarnation.components,
              oldIncarnationAndVersion.incarnation.good);
      rootIncarnation.incarnationsUnit[id] =
          new VersionAndIncarnation<UnitIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }

  public void EffectUnitSetLifeEndTime(int id, int newValue) {
    CheckUnlocked();
    CheckHasUnit(id);
var effect = new UnitSetLifeEndTimeEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsUnit[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.lifeEndTime;
      oldIncarnationAndVersion.incarnation.lifeEndTime = newValue;

    } else {
      var newIncarnation =
          new UnitIncarnation(
              oldIncarnationAndVersion.incarnation.evvent,
              newValue,
              oldIncarnationAndVersion.incarnation.location,
              oldIncarnationAndVersion.incarnation.classId,
              oldIncarnationAndVersion.incarnation.nextActionTime,
              oldIncarnationAndVersion.incarnation.hp,
              oldIncarnationAndVersion.incarnation.maxHp,
              oldIncarnationAndVersion.incarnation.components,
              oldIncarnationAndVersion.incarnation.good);
      rootIncarnation.incarnationsUnit[id] =
          new VersionAndIncarnation<UnitIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }

  public void EffectUnitSetLocation(int id, Location newValue) {
    CheckUnlocked();
    CheckHasUnit(id);
var effect = new UnitSetLocationEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsUnit[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.location;
      oldIncarnationAndVersion.incarnation.location = newValue;

    } else {
      var newIncarnation =
          new UnitIncarnation(
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.lifeEndTime,
              newValue,
              oldIncarnationAndVersion.incarnation.classId,
              oldIncarnationAndVersion.incarnation.nextActionTime,
              oldIncarnationAndVersion.incarnation.hp,
              oldIncarnationAndVersion.incarnation.maxHp,
              oldIncarnationAndVersion.incarnation.components,
              oldIncarnationAndVersion.incarnation.good);
      rootIncarnation.incarnationsUnit[id] =
          new VersionAndIncarnation<UnitIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }

  public void EffectUnitSetNextActionTime(int id, int newValue) {
    CheckUnlocked();
    CheckHasUnit(id);
var effect = new UnitSetNextActionTimeEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsUnit[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.nextActionTime;
      oldIncarnationAndVersion.incarnation.nextActionTime = newValue;

    } else {
      var newIncarnation =
          new UnitIncarnation(
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.lifeEndTime,
              oldIncarnationAndVersion.incarnation.location,
              oldIncarnationAndVersion.incarnation.classId,
              newValue,
              oldIncarnationAndVersion.incarnation.hp,
              oldIncarnationAndVersion.incarnation.maxHp,
              oldIncarnationAndVersion.incarnation.components,
              oldIncarnationAndVersion.incarnation.good);
      rootIncarnation.incarnationsUnit[id] =
          new VersionAndIncarnation<UnitIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }

  public void EffectUnitSetHp(int id, int newValue) {
    CheckUnlocked();
    CheckHasUnit(id);
var effect = new UnitSetHpEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsUnit[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.hp;
      oldIncarnationAndVersion.incarnation.hp = newValue;

    } else {
      var newIncarnation =
          new UnitIncarnation(
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.lifeEndTime,
              oldIncarnationAndVersion.incarnation.location,
              oldIncarnationAndVersion.incarnation.classId,
              oldIncarnationAndVersion.incarnation.nextActionTime,
              newValue,
              oldIncarnationAndVersion.incarnation.maxHp,
              oldIncarnationAndVersion.incarnation.components,
              oldIncarnationAndVersion.incarnation.good);
      rootIncarnation.incarnationsUnit[id] =
          new VersionAndIncarnation<UnitIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }

  public void EffectUnitSetMaxHp(int id, int newValue) {
    CheckUnlocked();
    CheckHasUnit(id);
var effect = new UnitSetMaxHpEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsUnit[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.maxHp;
      oldIncarnationAndVersion.incarnation.maxHp = newValue;

    } else {
      var newIncarnation =
          new UnitIncarnation(
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.lifeEndTime,
              oldIncarnationAndVersion.incarnation.location,
              oldIncarnationAndVersion.incarnation.classId,
              oldIncarnationAndVersion.incarnation.nextActionTime,
              oldIncarnationAndVersion.incarnation.hp,
              newValue,
              oldIncarnationAndVersion.incarnation.components,
              oldIncarnationAndVersion.incarnation.good);
      rootIncarnation.incarnationsUnit[id] =
          new VersionAndIncarnation<UnitIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }
  public IUnitComponentMutBunchIncarnation GetIUnitComponentMutBunchIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsIUnitComponentMutBunch[id].incarnation;
  }
  public bool IUnitComponentMutBunchExists(int id) {
    return rootIncarnation.incarnationsIUnitComponentMutBunch.ContainsKey(id);
  }
  public IUnitComponentMutBunch GetIUnitComponentMutBunch(int id) {
    CheckHasIUnitComponentMutBunch(id);
    return new IUnitComponentMutBunch(this, id);
  }
  public IUnitComponentMutBunch GetIUnitComponentMutBunchOrNull(int id) {
    if (IUnitComponentMutBunchExists(id)) {
      return new IUnitComponentMutBunch(this, id);
    } else {
      return new IUnitComponentMutBunch(this, 0);
    }
  }
  public List<IUnitComponentMutBunch> AllIUnitComponentMutBunch() {
    List<IUnitComponentMutBunch> result = new List<IUnitComponentMutBunch>(rootIncarnation.incarnationsIUnitComponentMutBunch.Count);
    foreach (var id in rootIncarnation.incarnationsIUnitComponentMutBunch.Keys) {
      result.Add(new IUnitComponentMutBunch(this, id));
    }
    return result;
  }
  public IEnumerator<IUnitComponentMutBunch> EnumAllIUnitComponentMutBunch() {
    foreach (var id in rootIncarnation.incarnationsIUnitComponentMutBunch.Keys) {
      yield return GetIUnitComponentMutBunch(id);
    }
  }
  public void CheckHasIUnitComponentMutBunch(IUnitComponentMutBunch thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasIUnitComponentMutBunch(thing.id);
  }
  public void CheckHasIUnitComponentMutBunch(int id) {
    if (!rootIncarnation.incarnationsIUnitComponentMutBunch.ContainsKey(id)) {
      throw new System.Exception("Invalid IUnitComponentMutBunch: " + id);
    }
  }
  public IUnitComponentMutBunch EffectIUnitComponentMutBunchCreate(
      TutorialDefyCounterUCMutSet membersTutorialDefyCounterUCMutSet,
      LightningChargingUCMutSet membersLightningChargingUCMutSet,
      WanderAICapabilityUCMutSet membersWanderAICapabilityUCMutSet,
      TemporaryCloneAICapabilityUCMutSet membersTemporaryCloneAICapabilityUCMutSet,
      SummonAICapabilityUCMutSet membersSummonAICapabilityUCMutSet,
      KamikazeAICapabilityUCMutSet membersKamikazeAICapabilityUCMutSet,
      GuardAICapabilityUCMutSet membersGuardAICapabilityUCMutSet,
      TimeCloneAICapabilityUCMutSet membersTimeCloneAICapabilityUCMutSet,
      DoomedUCMutSet membersDoomedUCMutSet,
      MiredUCMutSet membersMiredUCMutSet,
      AttackAICapabilityUCMutSet membersAttackAICapabilityUCMutSet,
      CounteringUCMutSet membersCounteringUCMutSet,
      LightningChargedUCMutSet membersLightningChargedUCMutSet,
      InvincibilityUCMutSet membersInvincibilityUCMutSet,
      DefyingUCMutSet membersDefyingUCMutSet,
      BideAICapabilityUCMutSet membersBideAICapabilityUCMutSet,
      BaseSightRangeUCMutSet membersBaseSightRangeUCMutSet,
      BaseMovementTimeUCMutSet membersBaseMovementTimeUCMutSet,
      BaseCombatTimeUCMutSet membersBaseCombatTimeUCMutSet,
      ManaPotionMutSet membersManaPotionMutSet,
      HealthPotionMutSet membersHealthPotionMutSet,
      SpeedRingMutSet membersSpeedRingMutSet,
      GlaiveMutSet membersGlaiveMutSet,
      SlowRodMutSet membersSlowRodMutSet,
      BlastRodMutSet membersBlastRodMutSet,
      ArmorMutSet membersArmorMutSet,
      SorcerousUCMutSet membersSorcerousUCMutSet,
      BaseOffenseUCMutSet membersBaseOffenseUCMutSet,
      BaseDefenseUCMutSet membersBaseDefenseUCMutSet) {
    CheckHasTutorialDefyCounterUCMutSet(membersTutorialDefyCounterUCMutSet);
    CheckHasLightningChargingUCMutSet(membersLightningChargingUCMutSet);
    CheckHasWanderAICapabilityUCMutSet(membersWanderAICapabilityUCMutSet);
    CheckHasTemporaryCloneAICapabilityUCMutSet(membersTemporaryCloneAICapabilityUCMutSet);
    CheckHasSummonAICapabilityUCMutSet(membersSummonAICapabilityUCMutSet);
    CheckHasKamikazeAICapabilityUCMutSet(membersKamikazeAICapabilityUCMutSet);
    CheckHasGuardAICapabilityUCMutSet(membersGuardAICapabilityUCMutSet);
    CheckHasTimeCloneAICapabilityUCMutSet(membersTimeCloneAICapabilityUCMutSet);
    CheckHasDoomedUCMutSet(membersDoomedUCMutSet);
    CheckHasMiredUCMutSet(membersMiredUCMutSet);
    CheckHasAttackAICapabilityUCMutSet(membersAttackAICapabilityUCMutSet);
    CheckHasCounteringUCMutSet(membersCounteringUCMutSet);
    CheckHasLightningChargedUCMutSet(membersLightningChargedUCMutSet);
    CheckHasInvincibilityUCMutSet(membersInvincibilityUCMutSet);
    CheckHasDefyingUCMutSet(membersDefyingUCMutSet);
    CheckHasBideAICapabilityUCMutSet(membersBideAICapabilityUCMutSet);
    CheckHasBaseSightRangeUCMutSet(membersBaseSightRangeUCMutSet);
    CheckHasBaseMovementTimeUCMutSet(membersBaseMovementTimeUCMutSet);
    CheckHasBaseCombatTimeUCMutSet(membersBaseCombatTimeUCMutSet);
    CheckHasManaPotionMutSet(membersManaPotionMutSet);
    CheckHasHealthPotionMutSet(membersHealthPotionMutSet);
    CheckHasSpeedRingMutSet(membersSpeedRingMutSet);
    CheckHasGlaiveMutSet(membersGlaiveMutSet);
    CheckHasSlowRodMutSet(membersSlowRodMutSet);
    CheckHasBlastRodMutSet(membersBlastRodMutSet);
    CheckHasArmorMutSet(membersArmorMutSet);
    CheckHasSorcerousUCMutSet(membersSorcerousUCMutSet);
    CheckHasBaseOffenseUCMutSet(membersBaseOffenseUCMutSet);
    CheckHasBaseDefenseUCMutSet(membersBaseDefenseUCMutSet);
    return TrustedEffectIUnitComponentMutBunchCreateWithId(NewId()
            ,membersTutorialDefyCounterUCMutSet.id
            ,membersLightningChargingUCMutSet.id
            ,membersWanderAICapabilityUCMutSet.id
            ,membersTemporaryCloneAICapabilityUCMutSet.id
            ,membersSummonAICapabilityUCMutSet.id
            ,membersKamikazeAICapabilityUCMutSet.id
            ,membersGuardAICapabilityUCMutSet.id
            ,membersTimeCloneAICapabilityUCMutSet.id
            ,membersDoomedUCMutSet.id
            ,membersMiredUCMutSet.id
            ,membersAttackAICapabilityUCMutSet.id
            ,membersCounteringUCMutSet.id
            ,membersLightningChargedUCMutSet.id
            ,membersInvincibilityUCMutSet.id
            ,membersDefyingUCMutSet.id
            ,membersBideAICapabilityUCMutSet.id
            ,membersBaseSightRangeUCMutSet.id
            ,membersBaseMovementTimeUCMutSet.id
            ,membersBaseCombatTimeUCMutSet.id
            ,membersManaPotionMutSet.id
            ,membersHealthPotionMutSet.id
            ,membersSpeedRingMutSet.id
            ,membersGlaiveMutSet.id
            ,membersSlowRodMutSet.id
            ,membersBlastRodMutSet.id
            ,membersArmorMutSet.id
            ,membersSorcerousUCMutSet.id
            ,membersBaseOffenseUCMutSet.id
            ,membersBaseDefenseUCMutSet.id    );
  }
  public IUnitComponentMutBunch TrustedEffectIUnitComponentMutBunchCreateWithId(int id
,      int membersTutorialDefyCounterUCMutSet
,      int membersLightningChargingUCMutSet
,      int membersWanderAICapabilityUCMutSet
,      int membersTemporaryCloneAICapabilityUCMutSet
,      int membersSummonAICapabilityUCMutSet
,      int membersKamikazeAICapabilityUCMutSet
,      int membersGuardAICapabilityUCMutSet
,      int membersTimeCloneAICapabilityUCMutSet
,      int membersDoomedUCMutSet
,      int membersMiredUCMutSet
,      int membersAttackAICapabilityUCMutSet
,      int membersCounteringUCMutSet
,      int membersLightningChargedUCMutSet
,      int membersInvincibilityUCMutSet
,      int membersDefyingUCMutSet
,      int membersBideAICapabilityUCMutSet
,      int membersBaseSightRangeUCMutSet
,      int membersBaseMovementTimeUCMutSet
,      int membersBaseCombatTimeUCMutSet
,      int membersManaPotionMutSet
,      int membersHealthPotionMutSet
,      int membersSpeedRingMutSet
,      int membersGlaiveMutSet
,      int membersSlowRodMutSet
,      int membersBlastRodMutSet
,      int membersArmorMutSet
,      int membersSorcerousUCMutSet
,      int membersBaseOffenseUCMutSet
,      int membersBaseDefenseUCMutSet) {
    CheckUnlocked();

    var incarnation =
        new IUnitComponentMutBunchIncarnation(
            membersTutorialDefyCounterUCMutSet,
            membersLightningChargingUCMutSet,
            membersWanderAICapabilityUCMutSet,
            membersTemporaryCloneAICapabilityUCMutSet,
            membersSummonAICapabilityUCMutSet,
            membersKamikazeAICapabilityUCMutSet,
            membersGuardAICapabilityUCMutSet,
            membersTimeCloneAICapabilityUCMutSet,
            membersDoomedUCMutSet,
            membersMiredUCMutSet,
            membersAttackAICapabilityUCMutSet,
            membersCounteringUCMutSet,
            membersLightningChargedUCMutSet,
            membersInvincibilityUCMutSet,
            membersDefyingUCMutSet,
            membersBideAICapabilityUCMutSet,
            membersBaseSightRangeUCMutSet,
            membersBaseMovementTimeUCMutSet,
            membersBaseCombatTimeUCMutSet,
            membersManaPotionMutSet,
            membersHealthPotionMutSet,
            membersSpeedRingMutSet,
            membersGlaiveMutSet,
            membersSlowRodMutSet,
            membersBlastRodMutSet,
            membersArmorMutSet,
            membersSorcerousUCMutSet,
            membersBaseOffenseUCMutSet,
            membersBaseDefenseUCMutSet
            );
    return EffectInternalCreateIUnitComponentMutBunch(id, rootIncarnation.version, incarnation);
  }
  public IUnitComponentMutBunch EffectInternalCreateIUnitComponentMutBunch(
      int id,
      int incarnationVersion,
      IUnitComponentMutBunchIncarnation incarnation) {
    CheckUnlocked();
    var effect = new IUnitComponentMutBunchCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsIUnitComponentMutBunch.Add(
        id,
        new VersionAndIncarnation<IUnitComponentMutBunchIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new IUnitComponentMutBunch(this, id);
  }

  public void EffectIUnitComponentMutBunchDelete(int id) {
    CheckUnlocked();
    var effect = new IUnitComponentMutBunchDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsIUnitComponentMutBunch[id];

    rootIncarnation.incarnationsIUnitComponentMutBunch.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetIUnitComponentMutBunchHash(int id, int version, IUnitComponentMutBunchIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.membersTutorialDefyCounterUCMutSet.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.membersLightningChargingUCMutSet.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.membersWanderAICapabilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.membersTemporaryCloneAICapabilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 5 * incarnation.membersSummonAICapabilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 6 * incarnation.membersKamikazeAICapabilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 7 * incarnation.membersGuardAICapabilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 8 * incarnation.membersTimeCloneAICapabilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 9 * incarnation.membersDoomedUCMutSet.GetDeterministicHashCode();
    result += id * version * 10 * incarnation.membersMiredUCMutSet.GetDeterministicHashCode();
    result += id * version * 11 * incarnation.membersAttackAICapabilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 12 * incarnation.membersCounteringUCMutSet.GetDeterministicHashCode();
    result += id * version * 13 * incarnation.membersLightningChargedUCMutSet.GetDeterministicHashCode();
    result += id * version * 14 * incarnation.membersInvincibilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 15 * incarnation.membersDefyingUCMutSet.GetDeterministicHashCode();
    result += id * version * 16 * incarnation.membersBideAICapabilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 17 * incarnation.membersBaseSightRangeUCMutSet.GetDeterministicHashCode();
    result += id * version * 18 * incarnation.membersBaseMovementTimeUCMutSet.GetDeterministicHashCode();
    result += id * version * 19 * incarnation.membersBaseCombatTimeUCMutSet.GetDeterministicHashCode();
    result += id * version * 20 * incarnation.membersManaPotionMutSet.GetDeterministicHashCode();
    result += id * version * 21 * incarnation.membersHealthPotionMutSet.GetDeterministicHashCode();
    result += id * version * 22 * incarnation.membersSpeedRingMutSet.GetDeterministicHashCode();
    result += id * version * 23 * incarnation.membersGlaiveMutSet.GetDeterministicHashCode();
    result += id * version * 24 * incarnation.membersSlowRodMutSet.GetDeterministicHashCode();
    result += id * version * 25 * incarnation.membersBlastRodMutSet.GetDeterministicHashCode();
    result += id * version * 26 * incarnation.membersArmorMutSet.GetDeterministicHashCode();
    result += id * version * 27 * incarnation.membersSorcerousUCMutSet.GetDeterministicHashCode();
    result += id * version * 28 * incarnation.membersBaseOffenseUCMutSet.GetDeterministicHashCode();
    result += id * version * 29 * incarnation.membersBaseDefenseUCMutSet.GetDeterministicHashCode();
    return result;
  }
       public LightningChargedUCIncarnation GetLightningChargedUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsLightningChargedUC[id].incarnation;
  }
  public bool LightningChargedUCExists(int id) {
    return rootIncarnation.incarnationsLightningChargedUC.ContainsKey(id);
  }
  public LightningChargedUC GetLightningChargedUC(int id) {
    CheckHasLightningChargedUC(id);
    return new LightningChargedUC(this, id);
  }
  public LightningChargedUC GetLightningChargedUCOrNull(int id) {
    if (LightningChargedUCExists(id)) {
      return new LightningChargedUC(this, id);
    } else {
      return new LightningChargedUC(this, 0);
    }
  }
  public List<LightningChargedUC> AllLightningChargedUC() {
    List<LightningChargedUC> result = new List<LightningChargedUC>(rootIncarnation.incarnationsLightningChargedUC.Count);
    foreach (var id in rootIncarnation.incarnationsLightningChargedUC.Keys) {
      result.Add(new LightningChargedUC(this, id));
    }
    return result;
  }
  public IEnumerator<LightningChargedUC> EnumAllLightningChargedUC() {
    foreach (var id in rootIncarnation.incarnationsLightningChargedUC.Keys) {
      yield return GetLightningChargedUC(id);
    }
  }
  public void CheckHasLightningChargedUC(LightningChargedUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasLightningChargedUC(thing.id);
  }
  public void CheckHasLightningChargedUC(int id) {
    if (!rootIncarnation.incarnationsLightningChargedUC.ContainsKey(id)) {
      throw new System.Exception("Invalid LightningChargedUC: " + id);
    }
  }
  public LightningChargedUC EffectLightningChargedUCCreate(
) {
    return TrustedEffectLightningChargedUCCreateWithId(NewId()
    );
  }
  public LightningChargedUC TrustedEffectLightningChargedUCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new LightningChargedUCIncarnation(

            );
    return EffectInternalCreateLightningChargedUC(id, rootIncarnation.version, incarnation);
  }
  public LightningChargedUC EffectInternalCreateLightningChargedUC(
      int id,
      int incarnationVersion,
      LightningChargedUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new LightningChargedUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsLightningChargedUC.Add(
        id,
        new VersionAndIncarnation<LightningChargedUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new LightningChargedUC(this, id);
  }

  public void EffectLightningChargedUCDelete(int id) {
    CheckUnlocked();
    var effect = new LightningChargedUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsLightningChargedUC[id];

    rootIncarnation.incarnationsLightningChargedUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetLightningChargedUCHash(int id, int version, LightningChargedUCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public LightningChargingUCIncarnation GetLightningChargingUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsLightningChargingUC[id].incarnation;
  }
  public bool LightningChargingUCExists(int id) {
    return rootIncarnation.incarnationsLightningChargingUC.ContainsKey(id);
  }
  public LightningChargingUC GetLightningChargingUC(int id) {
    CheckHasLightningChargingUC(id);
    return new LightningChargingUC(this, id);
  }
  public LightningChargingUC GetLightningChargingUCOrNull(int id) {
    if (LightningChargingUCExists(id)) {
      return new LightningChargingUC(this, id);
    } else {
      return new LightningChargingUC(this, 0);
    }
  }
  public List<LightningChargingUC> AllLightningChargingUC() {
    List<LightningChargingUC> result = new List<LightningChargingUC>(rootIncarnation.incarnationsLightningChargingUC.Count);
    foreach (var id in rootIncarnation.incarnationsLightningChargingUC.Keys) {
      result.Add(new LightningChargingUC(this, id));
    }
    return result;
  }
  public IEnumerator<LightningChargingUC> EnumAllLightningChargingUC() {
    foreach (var id in rootIncarnation.incarnationsLightningChargingUC.Keys) {
      yield return GetLightningChargingUC(id);
    }
  }
  public void CheckHasLightningChargingUC(LightningChargingUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasLightningChargingUC(thing.id);
  }
  public void CheckHasLightningChargingUC(int id) {
    if (!rootIncarnation.incarnationsLightningChargingUC.ContainsKey(id)) {
      throw new System.Exception("Invalid LightningChargingUC: " + id);
    }
  }
  public LightningChargingUC EffectLightningChargingUCCreate(
) {
    return TrustedEffectLightningChargingUCCreateWithId(NewId()
    );
  }
  public LightningChargingUC TrustedEffectLightningChargingUCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new LightningChargingUCIncarnation(

            );
    return EffectInternalCreateLightningChargingUC(id, rootIncarnation.version, incarnation);
  }
  public LightningChargingUC EffectInternalCreateLightningChargingUC(
      int id,
      int incarnationVersion,
      LightningChargingUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new LightningChargingUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsLightningChargingUC.Add(
        id,
        new VersionAndIncarnation<LightningChargingUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new LightningChargingUC(this, id);
  }

  public void EffectLightningChargingUCDelete(int id) {
    CheckUnlocked();
    var effect = new LightningChargingUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsLightningChargingUC[id];

    rootIncarnation.incarnationsLightningChargingUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetLightningChargingUCHash(int id, int version, LightningChargingUCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public DoomedUCIncarnation GetDoomedUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsDoomedUC[id].incarnation;
  }
  public bool DoomedUCExists(int id) {
    return rootIncarnation.incarnationsDoomedUC.ContainsKey(id);
  }
  public DoomedUC GetDoomedUC(int id) {
    CheckHasDoomedUC(id);
    return new DoomedUC(this, id);
  }
  public DoomedUC GetDoomedUCOrNull(int id) {
    if (DoomedUCExists(id)) {
      return new DoomedUC(this, id);
    } else {
      return new DoomedUC(this, 0);
    }
  }
  public List<DoomedUC> AllDoomedUC() {
    List<DoomedUC> result = new List<DoomedUC>(rootIncarnation.incarnationsDoomedUC.Count);
    foreach (var id in rootIncarnation.incarnationsDoomedUC.Keys) {
      result.Add(new DoomedUC(this, id));
    }
    return result;
  }
  public IEnumerator<DoomedUC> EnumAllDoomedUC() {
    foreach (var id in rootIncarnation.incarnationsDoomedUC.Keys) {
      yield return GetDoomedUC(id);
    }
  }
  public void CheckHasDoomedUC(DoomedUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasDoomedUC(thing.id);
  }
  public void CheckHasDoomedUC(int id) {
    if (!rootIncarnation.incarnationsDoomedUC.ContainsKey(id)) {
      throw new System.Exception("Invalid DoomedUC: " + id);
    }
  }
  public DoomedUC EffectDoomedUCCreate(
      int deathTime) {
    return TrustedEffectDoomedUCCreateWithId(NewId()
            ,deathTime    );
  }
  public DoomedUC TrustedEffectDoomedUCCreateWithId(int id
,      int deathTime) {
    CheckUnlocked();

    var incarnation =
        new DoomedUCIncarnation(
            deathTime
            );
    return EffectInternalCreateDoomedUC(id, rootIncarnation.version, incarnation);
  }
  public DoomedUC EffectInternalCreateDoomedUC(
      int id,
      int incarnationVersion,
      DoomedUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new DoomedUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsDoomedUC.Add(
        id,
        new VersionAndIncarnation<DoomedUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new DoomedUC(this, id);
  }

  public void EffectDoomedUCDelete(int id) {
    CheckUnlocked();
    var effect = new DoomedUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsDoomedUC[id];

    rootIncarnation.incarnationsDoomedUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetDoomedUCHash(int id, int version, DoomedUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.deathTime.GetDeterministicHashCode();
    return result;
  }
       public TemporaryCloneImpulseIncarnation GetTemporaryCloneImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTemporaryCloneImpulse[id].incarnation;
  }
  public bool TemporaryCloneImpulseExists(int id) {
    return rootIncarnation.incarnationsTemporaryCloneImpulse.ContainsKey(id);
  }
  public TemporaryCloneImpulse GetTemporaryCloneImpulse(int id) {
    CheckHasTemporaryCloneImpulse(id);
    return new TemporaryCloneImpulse(this, id);
  }
  public TemporaryCloneImpulse GetTemporaryCloneImpulseOrNull(int id) {
    if (TemporaryCloneImpulseExists(id)) {
      return new TemporaryCloneImpulse(this, id);
    } else {
      return new TemporaryCloneImpulse(this, 0);
    }
  }
  public List<TemporaryCloneImpulse> AllTemporaryCloneImpulse() {
    List<TemporaryCloneImpulse> result = new List<TemporaryCloneImpulse>(rootIncarnation.incarnationsTemporaryCloneImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsTemporaryCloneImpulse.Keys) {
      result.Add(new TemporaryCloneImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<TemporaryCloneImpulse> EnumAllTemporaryCloneImpulse() {
    foreach (var id in rootIncarnation.incarnationsTemporaryCloneImpulse.Keys) {
      yield return GetTemporaryCloneImpulse(id);
    }
  }
  public void CheckHasTemporaryCloneImpulse(TemporaryCloneImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTemporaryCloneImpulse(thing.id);
  }
  public void CheckHasTemporaryCloneImpulse(int id) {
    if (!rootIncarnation.incarnationsTemporaryCloneImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid TemporaryCloneImpulse: " + id);
    }
  }
  public TemporaryCloneImpulse EffectTemporaryCloneImpulseCreate(
      int weight,
      string blueprintName,
      Location location,
      int hp) {
    return TrustedEffectTemporaryCloneImpulseCreateWithId(NewId()
            ,weight
            ,blueprintName
            ,location
            ,hp    );
  }
  public TemporaryCloneImpulse TrustedEffectTemporaryCloneImpulseCreateWithId(int id
,      int weight
,      string blueprintName
,      Location location
,      int hp) {
    CheckUnlocked();

    var incarnation =
        new TemporaryCloneImpulseIncarnation(
            weight,
            blueprintName,
            location,
            hp
            );
    return EffectInternalCreateTemporaryCloneImpulse(id, rootIncarnation.version, incarnation);
  }
  public TemporaryCloneImpulse EffectInternalCreateTemporaryCloneImpulse(
      int id,
      int incarnationVersion,
      TemporaryCloneImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new TemporaryCloneImpulseCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsTemporaryCloneImpulse.Add(
        id,
        new VersionAndIncarnation<TemporaryCloneImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new TemporaryCloneImpulse(this, id);
  }

  public void EffectTemporaryCloneImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new TemporaryCloneImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTemporaryCloneImpulse[id];

    rootIncarnation.incarnationsTemporaryCloneImpulse.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetTemporaryCloneImpulseHash(int id, int version, TemporaryCloneImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.blueprintName.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.location.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.hp.GetDeterministicHashCode();
    return result;
  }
       public TemporaryCloneAICapabilityUCIncarnation GetTemporaryCloneAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTemporaryCloneAICapabilityUC[id].incarnation;
  }
  public bool TemporaryCloneAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(id);
  }
  public TemporaryCloneAICapabilityUC GetTemporaryCloneAICapabilityUC(int id) {
    CheckHasTemporaryCloneAICapabilityUC(id);
    return new TemporaryCloneAICapabilityUC(this, id);
  }
  public TemporaryCloneAICapabilityUC GetTemporaryCloneAICapabilityUCOrNull(int id) {
    if (TemporaryCloneAICapabilityUCExists(id)) {
      return new TemporaryCloneAICapabilityUC(this, id);
    } else {
      return new TemporaryCloneAICapabilityUC(this, 0);
    }
  }
  public List<TemporaryCloneAICapabilityUC> AllTemporaryCloneAICapabilityUC() {
    List<TemporaryCloneAICapabilityUC> result = new List<TemporaryCloneAICapabilityUC>(rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.Keys) {
      result.Add(new TemporaryCloneAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<TemporaryCloneAICapabilityUC> EnumAllTemporaryCloneAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.Keys) {
      yield return GetTemporaryCloneAICapabilityUC(id);
    }
  }
  public void CheckHasTemporaryCloneAICapabilityUC(TemporaryCloneAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTemporaryCloneAICapabilityUC(thing.id);
  }
  public void CheckHasTemporaryCloneAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid TemporaryCloneAICapabilityUC: " + id);
    }
  }
  public TemporaryCloneAICapabilityUC EffectTemporaryCloneAICapabilityUCCreate(
      string blueprintName,
      int charges) {
    return TrustedEffectTemporaryCloneAICapabilityUCCreateWithId(NewId()
            ,blueprintName
            ,charges    );
  }
  public TemporaryCloneAICapabilityUC TrustedEffectTemporaryCloneAICapabilityUCCreateWithId(int id
,      string blueprintName
,      int charges) {
    CheckUnlocked();

    var incarnation =
        new TemporaryCloneAICapabilityUCIncarnation(
            blueprintName,
            charges
            );
    return EffectInternalCreateTemporaryCloneAICapabilityUC(id, rootIncarnation.version, incarnation);
  }
  public TemporaryCloneAICapabilityUC EffectInternalCreateTemporaryCloneAICapabilityUC(
      int id,
      int incarnationVersion,
      TemporaryCloneAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new TemporaryCloneAICapabilityUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<TemporaryCloneAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new TemporaryCloneAICapabilityUC(this, id);
  }

  public void EffectTemporaryCloneAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = new TemporaryCloneAICapabilityUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTemporaryCloneAICapabilityUC[id];

    rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetTemporaryCloneAICapabilityUCHash(int id, int version, TemporaryCloneAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.blueprintName.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.charges.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectTemporaryCloneAICapabilityUCSetCharges(int id, int newValue) {
    CheckUnlocked();
    CheckHasTemporaryCloneAICapabilityUC(id);
var effect = new TemporaryCloneAICapabilityUCSetChargesEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsTemporaryCloneAICapabilityUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.charges;
      oldIncarnationAndVersion.incarnation.charges = newValue;

    } else {
      var newIncarnation =
          new TemporaryCloneAICapabilityUCIncarnation(
              oldIncarnationAndVersion.incarnation.blueprintName,
              newValue);
      rootIncarnation.incarnationsTemporaryCloneAICapabilityUC[id] =
          new VersionAndIncarnation<TemporaryCloneAICapabilityUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }
  public SummonImpulseIncarnation GetSummonImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsSummonImpulse[id].incarnation;
  }
  public bool SummonImpulseExists(int id) {
    return rootIncarnation.incarnationsSummonImpulse.ContainsKey(id);
  }
  public SummonImpulse GetSummonImpulse(int id) {
    CheckHasSummonImpulse(id);
    return new SummonImpulse(this, id);
  }
  public SummonImpulse GetSummonImpulseOrNull(int id) {
    if (SummonImpulseExists(id)) {
      return new SummonImpulse(this, id);
    } else {
      return new SummonImpulse(this, 0);
    }
  }
  public List<SummonImpulse> AllSummonImpulse() {
    List<SummonImpulse> result = new List<SummonImpulse>(rootIncarnation.incarnationsSummonImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsSummonImpulse.Keys) {
      result.Add(new SummonImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<SummonImpulse> EnumAllSummonImpulse() {
    foreach (var id in rootIncarnation.incarnationsSummonImpulse.Keys) {
      yield return GetSummonImpulse(id);
    }
  }
  public void CheckHasSummonImpulse(SummonImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasSummonImpulse(thing.id);
  }
  public void CheckHasSummonImpulse(int id) {
    if (!rootIncarnation.incarnationsSummonImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid SummonImpulse: " + id);
    }
  }
  public SummonImpulse EffectSummonImpulseCreate(
      int weight,
      string blueprintName,
      Location location) {
    return TrustedEffectSummonImpulseCreateWithId(NewId()
            ,weight
            ,blueprintName
            ,location    );
  }
  public SummonImpulse TrustedEffectSummonImpulseCreateWithId(int id
,      int weight
,      string blueprintName
,      Location location) {
    CheckUnlocked();

    var incarnation =
        new SummonImpulseIncarnation(
            weight,
            blueprintName,
            location
            );
    return EffectInternalCreateSummonImpulse(id, rootIncarnation.version, incarnation);
  }
  public SummonImpulse EffectInternalCreateSummonImpulse(
      int id,
      int incarnationVersion,
      SummonImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new SummonImpulseCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsSummonImpulse.Add(
        id,
        new VersionAndIncarnation<SummonImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new SummonImpulse(this, id);
  }

  public void EffectSummonImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new SummonImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsSummonImpulse[id];

    rootIncarnation.incarnationsSummonImpulse.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetSummonImpulseHash(int id, int version, SummonImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.blueprintName.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.location.GetDeterministicHashCode();
    return result;
  }
       public SummonAICapabilityUCIncarnation GetSummonAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsSummonAICapabilityUC[id].incarnation;
  }
  public bool SummonAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(id);
  }
  public SummonAICapabilityUC GetSummonAICapabilityUC(int id) {
    CheckHasSummonAICapabilityUC(id);
    return new SummonAICapabilityUC(this, id);
  }
  public SummonAICapabilityUC GetSummonAICapabilityUCOrNull(int id) {
    if (SummonAICapabilityUCExists(id)) {
      return new SummonAICapabilityUC(this, id);
    } else {
      return new SummonAICapabilityUC(this, 0);
    }
  }
  public List<SummonAICapabilityUC> AllSummonAICapabilityUC() {
    List<SummonAICapabilityUC> result = new List<SummonAICapabilityUC>(rootIncarnation.incarnationsSummonAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsSummonAICapabilityUC.Keys) {
      result.Add(new SummonAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<SummonAICapabilityUC> EnumAllSummonAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsSummonAICapabilityUC.Keys) {
      yield return GetSummonAICapabilityUC(id);
    }
  }
  public void CheckHasSummonAICapabilityUC(SummonAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasSummonAICapabilityUC(thing.id);
  }
  public void CheckHasSummonAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid SummonAICapabilityUC: " + id);
    }
  }
  public SummonAICapabilityUC EffectSummonAICapabilityUCCreate(
      string blueprintName,
      int charges) {
    return TrustedEffectSummonAICapabilityUCCreateWithId(NewId()
            ,blueprintName
            ,charges    );
  }
  public SummonAICapabilityUC TrustedEffectSummonAICapabilityUCCreateWithId(int id
,      string blueprintName
,      int charges) {
    CheckUnlocked();

    var incarnation =
        new SummonAICapabilityUCIncarnation(
            blueprintName,
            charges
            );
    return EffectInternalCreateSummonAICapabilityUC(id, rootIncarnation.version, incarnation);
  }
  public SummonAICapabilityUC EffectInternalCreateSummonAICapabilityUC(
      int id,
      int incarnationVersion,
      SummonAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new SummonAICapabilityUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsSummonAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<SummonAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new SummonAICapabilityUC(this, id);
  }

  public void EffectSummonAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = new SummonAICapabilityUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsSummonAICapabilityUC[id];

    rootIncarnation.incarnationsSummonAICapabilityUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetSummonAICapabilityUCHash(int id, int version, SummonAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.blueprintName.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.charges.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectSummonAICapabilityUCSetCharges(int id, int newValue) {
    CheckUnlocked();
    CheckHasSummonAICapabilityUC(id);
var effect = new SummonAICapabilityUCSetChargesEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsSummonAICapabilityUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.charges;
      oldIncarnationAndVersion.incarnation.charges = newValue;

    } else {
      var newIncarnation =
          new SummonAICapabilityUCIncarnation(
              oldIncarnationAndVersion.incarnation.blueprintName,
              newValue);
      rootIncarnation.incarnationsSummonAICapabilityUC[id] =
          new VersionAndIncarnation<SummonAICapabilityUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }
  public SorcerousUCIncarnation GetSorcerousUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsSorcerousUC[id].incarnation;
  }
  public bool SorcerousUCExists(int id) {
    return rootIncarnation.incarnationsSorcerousUC.ContainsKey(id);
  }
  public SorcerousUC GetSorcerousUC(int id) {
    CheckHasSorcerousUC(id);
    return new SorcerousUC(this, id);
  }
  public SorcerousUC GetSorcerousUCOrNull(int id) {
    if (SorcerousUCExists(id)) {
      return new SorcerousUC(this, id);
    } else {
      return new SorcerousUC(this, 0);
    }
  }
  public List<SorcerousUC> AllSorcerousUC() {
    List<SorcerousUC> result = new List<SorcerousUC>(rootIncarnation.incarnationsSorcerousUC.Count);
    foreach (var id in rootIncarnation.incarnationsSorcerousUC.Keys) {
      result.Add(new SorcerousUC(this, id));
    }
    return result;
  }
  public IEnumerator<SorcerousUC> EnumAllSorcerousUC() {
    foreach (var id in rootIncarnation.incarnationsSorcerousUC.Keys) {
      yield return GetSorcerousUC(id);
    }
  }
  public void CheckHasSorcerousUC(SorcerousUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasSorcerousUC(thing.id);
  }
  public void CheckHasSorcerousUC(int id) {
    if (!rootIncarnation.incarnationsSorcerousUC.ContainsKey(id)) {
      throw new System.Exception("Invalid SorcerousUC: " + id);
    }
  }
  public SorcerousUC EffectSorcerousUCCreate(
      int mp,
      int maxMp) {
    return TrustedEffectSorcerousUCCreateWithId(NewId()
            ,mp
            ,maxMp    );
  }
  public SorcerousUC TrustedEffectSorcerousUCCreateWithId(int id
,      int mp
,      int maxMp) {
    CheckUnlocked();

    var incarnation =
        new SorcerousUCIncarnation(
            mp,
            maxMp
            );
    return EffectInternalCreateSorcerousUC(id, rootIncarnation.version, incarnation);
  }
  public SorcerousUC EffectInternalCreateSorcerousUC(
      int id,
      int incarnationVersion,
      SorcerousUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new SorcerousUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsSorcerousUC.Add(
        id,
        new VersionAndIncarnation<SorcerousUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new SorcerousUC(this, id);
  }

  public void EffectSorcerousUCDelete(int id) {
    CheckUnlocked();
    var effect = new SorcerousUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsSorcerousUC[id];

    rootIncarnation.incarnationsSorcerousUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetSorcerousUCHash(int id, int version, SorcerousUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.mp.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.maxMp.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectSorcerousUCSetMp(int id, int newValue) {
    CheckUnlocked();
    CheckHasSorcerousUC(id);
var effect = new SorcerousUCSetMpEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsSorcerousUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.mp;
      oldIncarnationAndVersion.incarnation.mp = newValue;

    } else {
      var newIncarnation =
          new SorcerousUCIncarnation(
              newValue,
              oldIncarnationAndVersion.incarnation.maxMp);
      rootIncarnation.incarnationsSorcerousUC[id] =
          new VersionAndIncarnation<SorcerousUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }

  public void EffectSorcerousUCSetMaxMp(int id, int newValue) {
    CheckUnlocked();
    CheckHasSorcerousUC(id);
var effect = new SorcerousUCSetMaxMpEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsSorcerousUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.maxMp;
      oldIncarnationAndVersion.incarnation.maxMp = newValue;

    } else {
      var newIncarnation =
          new SorcerousUCIncarnation(
              oldIncarnationAndVersion.incarnation.mp,
              newValue);
      rootIncarnation.incarnationsSorcerousUC[id] =
          new VersionAndIncarnation<SorcerousUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }
  public BaseOffenseUCIncarnation GetBaseOffenseUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBaseOffenseUC[id].incarnation;
  }
  public bool BaseOffenseUCExists(int id) {
    return rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(id);
  }
  public BaseOffenseUC GetBaseOffenseUC(int id) {
    CheckHasBaseOffenseUC(id);
    return new BaseOffenseUC(this, id);
  }
  public BaseOffenseUC GetBaseOffenseUCOrNull(int id) {
    if (BaseOffenseUCExists(id)) {
      return new BaseOffenseUC(this, id);
    } else {
      return new BaseOffenseUC(this, 0);
    }
  }
  public List<BaseOffenseUC> AllBaseOffenseUC() {
    List<BaseOffenseUC> result = new List<BaseOffenseUC>(rootIncarnation.incarnationsBaseOffenseUC.Count);
    foreach (var id in rootIncarnation.incarnationsBaseOffenseUC.Keys) {
      result.Add(new BaseOffenseUC(this, id));
    }
    return result;
  }
  public IEnumerator<BaseOffenseUC> EnumAllBaseOffenseUC() {
    foreach (var id in rootIncarnation.incarnationsBaseOffenseUC.Keys) {
      yield return GetBaseOffenseUC(id);
    }
  }
  public void CheckHasBaseOffenseUC(BaseOffenseUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBaseOffenseUC(thing.id);
  }
  public void CheckHasBaseOffenseUC(int id) {
    if (!rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(id)) {
      throw new System.Exception("Invalid BaseOffenseUC: " + id);
    }
  }
  public BaseOffenseUC EffectBaseOffenseUCCreate(
      int outgoingDamageAddConstant,
      int outgoingDamageMultiplierPercent) {
    return TrustedEffectBaseOffenseUCCreateWithId(NewId()
            ,outgoingDamageAddConstant
            ,outgoingDamageMultiplierPercent    );
  }
  public BaseOffenseUC TrustedEffectBaseOffenseUCCreateWithId(int id
,      int outgoingDamageAddConstant
,      int outgoingDamageMultiplierPercent) {
    CheckUnlocked();

    var incarnation =
        new BaseOffenseUCIncarnation(
            outgoingDamageAddConstant,
            outgoingDamageMultiplierPercent
            );
    return EffectInternalCreateBaseOffenseUC(id, rootIncarnation.version, incarnation);
  }
  public BaseOffenseUC EffectInternalCreateBaseOffenseUC(
      int id,
      int incarnationVersion,
      BaseOffenseUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new BaseOffenseUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsBaseOffenseUC.Add(
        id,
        new VersionAndIncarnation<BaseOffenseUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new BaseOffenseUC(this, id);
  }

  public void EffectBaseOffenseUCDelete(int id) {
    CheckUnlocked();
    var effect = new BaseOffenseUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBaseOffenseUC[id];

    rootIncarnation.incarnationsBaseOffenseUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetBaseOffenseUCHash(int id, int version, BaseOffenseUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.outgoingDamageAddConstant.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.outgoingDamageMultiplierPercent.GetDeterministicHashCode();
    return result;
  }
       public BaseSightRangeUCIncarnation GetBaseSightRangeUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBaseSightRangeUC[id].incarnation;
  }
  public bool BaseSightRangeUCExists(int id) {
    return rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(id);
  }
  public BaseSightRangeUC GetBaseSightRangeUC(int id) {
    CheckHasBaseSightRangeUC(id);
    return new BaseSightRangeUC(this, id);
  }
  public BaseSightRangeUC GetBaseSightRangeUCOrNull(int id) {
    if (BaseSightRangeUCExists(id)) {
      return new BaseSightRangeUC(this, id);
    } else {
      return new BaseSightRangeUC(this, 0);
    }
  }
  public List<BaseSightRangeUC> AllBaseSightRangeUC() {
    List<BaseSightRangeUC> result = new List<BaseSightRangeUC>(rootIncarnation.incarnationsBaseSightRangeUC.Count);
    foreach (var id in rootIncarnation.incarnationsBaseSightRangeUC.Keys) {
      result.Add(new BaseSightRangeUC(this, id));
    }
    return result;
  }
  public IEnumerator<BaseSightRangeUC> EnumAllBaseSightRangeUC() {
    foreach (var id in rootIncarnation.incarnationsBaseSightRangeUC.Keys) {
      yield return GetBaseSightRangeUC(id);
    }
  }
  public void CheckHasBaseSightRangeUC(BaseSightRangeUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBaseSightRangeUC(thing.id);
  }
  public void CheckHasBaseSightRangeUC(int id) {
    if (!rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(id)) {
      throw new System.Exception("Invalid BaseSightRangeUC: " + id);
    }
  }
  public BaseSightRangeUC EffectBaseSightRangeUCCreate(
      int sightRangeAddConstant,
      int sightRangeMultiplierPercent) {
    return TrustedEffectBaseSightRangeUCCreateWithId(NewId()
            ,sightRangeAddConstant
            ,sightRangeMultiplierPercent    );
  }
  public BaseSightRangeUC TrustedEffectBaseSightRangeUCCreateWithId(int id
,      int sightRangeAddConstant
,      int sightRangeMultiplierPercent) {
    CheckUnlocked();

    var incarnation =
        new BaseSightRangeUCIncarnation(
            sightRangeAddConstant,
            sightRangeMultiplierPercent
            );
    return EffectInternalCreateBaseSightRangeUC(id, rootIncarnation.version, incarnation);
  }
  public BaseSightRangeUC EffectInternalCreateBaseSightRangeUC(
      int id,
      int incarnationVersion,
      BaseSightRangeUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new BaseSightRangeUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsBaseSightRangeUC.Add(
        id,
        new VersionAndIncarnation<BaseSightRangeUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new BaseSightRangeUC(this, id);
  }

  public void EffectBaseSightRangeUCDelete(int id) {
    CheckUnlocked();
    var effect = new BaseSightRangeUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBaseSightRangeUC[id];

    rootIncarnation.incarnationsBaseSightRangeUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetBaseSightRangeUCHash(int id, int version, BaseSightRangeUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.sightRangeAddConstant.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.sightRangeMultiplierPercent.GetDeterministicHashCode();
    return result;
  }
       public BaseMovementTimeUCIncarnation GetBaseMovementTimeUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBaseMovementTimeUC[id].incarnation;
  }
  public bool BaseMovementTimeUCExists(int id) {
    return rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(id);
  }
  public BaseMovementTimeUC GetBaseMovementTimeUC(int id) {
    CheckHasBaseMovementTimeUC(id);
    return new BaseMovementTimeUC(this, id);
  }
  public BaseMovementTimeUC GetBaseMovementTimeUCOrNull(int id) {
    if (BaseMovementTimeUCExists(id)) {
      return new BaseMovementTimeUC(this, id);
    } else {
      return new BaseMovementTimeUC(this, 0);
    }
  }
  public List<BaseMovementTimeUC> AllBaseMovementTimeUC() {
    List<BaseMovementTimeUC> result = new List<BaseMovementTimeUC>(rootIncarnation.incarnationsBaseMovementTimeUC.Count);
    foreach (var id in rootIncarnation.incarnationsBaseMovementTimeUC.Keys) {
      result.Add(new BaseMovementTimeUC(this, id));
    }
    return result;
  }
  public IEnumerator<BaseMovementTimeUC> EnumAllBaseMovementTimeUC() {
    foreach (var id in rootIncarnation.incarnationsBaseMovementTimeUC.Keys) {
      yield return GetBaseMovementTimeUC(id);
    }
  }
  public void CheckHasBaseMovementTimeUC(BaseMovementTimeUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBaseMovementTimeUC(thing.id);
  }
  public void CheckHasBaseMovementTimeUC(int id) {
    if (!rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(id)) {
      throw new System.Exception("Invalid BaseMovementTimeUC: " + id);
    }
  }
  public BaseMovementTimeUC EffectBaseMovementTimeUCCreate(
      int movementTimeAddConstant,
      int movementTimeMultiplierPercent) {
    return TrustedEffectBaseMovementTimeUCCreateWithId(NewId()
            ,movementTimeAddConstant
            ,movementTimeMultiplierPercent    );
  }
  public BaseMovementTimeUC TrustedEffectBaseMovementTimeUCCreateWithId(int id
,      int movementTimeAddConstant
,      int movementTimeMultiplierPercent) {
    CheckUnlocked();

    var incarnation =
        new BaseMovementTimeUCIncarnation(
            movementTimeAddConstant,
            movementTimeMultiplierPercent
            );
    return EffectInternalCreateBaseMovementTimeUC(id, rootIncarnation.version, incarnation);
  }
  public BaseMovementTimeUC EffectInternalCreateBaseMovementTimeUC(
      int id,
      int incarnationVersion,
      BaseMovementTimeUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new BaseMovementTimeUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsBaseMovementTimeUC.Add(
        id,
        new VersionAndIncarnation<BaseMovementTimeUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new BaseMovementTimeUC(this, id);
  }

  public void EffectBaseMovementTimeUCDelete(int id) {
    CheckUnlocked();
    var effect = new BaseMovementTimeUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBaseMovementTimeUC[id];

    rootIncarnation.incarnationsBaseMovementTimeUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetBaseMovementTimeUCHash(int id, int version, BaseMovementTimeUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.movementTimeAddConstant.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.movementTimeMultiplierPercent.GetDeterministicHashCode();
    return result;
  }
       public BaseDefenseUCIncarnation GetBaseDefenseUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBaseDefenseUC[id].incarnation;
  }
  public bool BaseDefenseUCExists(int id) {
    return rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(id);
  }
  public BaseDefenseUC GetBaseDefenseUC(int id) {
    CheckHasBaseDefenseUC(id);
    return new BaseDefenseUC(this, id);
  }
  public BaseDefenseUC GetBaseDefenseUCOrNull(int id) {
    if (BaseDefenseUCExists(id)) {
      return new BaseDefenseUC(this, id);
    } else {
      return new BaseDefenseUC(this, 0);
    }
  }
  public List<BaseDefenseUC> AllBaseDefenseUC() {
    List<BaseDefenseUC> result = new List<BaseDefenseUC>(rootIncarnation.incarnationsBaseDefenseUC.Count);
    foreach (var id in rootIncarnation.incarnationsBaseDefenseUC.Keys) {
      result.Add(new BaseDefenseUC(this, id));
    }
    return result;
  }
  public IEnumerator<BaseDefenseUC> EnumAllBaseDefenseUC() {
    foreach (var id in rootIncarnation.incarnationsBaseDefenseUC.Keys) {
      yield return GetBaseDefenseUC(id);
    }
  }
  public void CheckHasBaseDefenseUC(BaseDefenseUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBaseDefenseUC(thing.id);
  }
  public void CheckHasBaseDefenseUC(int id) {
    if (!rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(id)) {
      throw new System.Exception("Invalid BaseDefenseUC: " + id);
    }
  }
  public BaseDefenseUC EffectBaseDefenseUCCreate(
      int incomingDamageAddConstant,
      int incomingDamageMultiplierPercent) {
    return TrustedEffectBaseDefenseUCCreateWithId(NewId()
            ,incomingDamageAddConstant
            ,incomingDamageMultiplierPercent    );
  }
  public BaseDefenseUC TrustedEffectBaseDefenseUCCreateWithId(int id
,      int incomingDamageAddConstant
,      int incomingDamageMultiplierPercent) {
    CheckUnlocked();

    var incarnation =
        new BaseDefenseUCIncarnation(
            incomingDamageAddConstant,
            incomingDamageMultiplierPercent
            );
    return EffectInternalCreateBaseDefenseUC(id, rootIncarnation.version, incarnation);
  }
  public BaseDefenseUC EffectInternalCreateBaseDefenseUC(
      int id,
      int incarnationVersion,
      BaseDefenseUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new BaseDefenseUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsBaseDefenseUC.Add(
        id,
        new VersionAndIncarnation<BaseDefenseUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new BaseDefenseUC(this, id);
  }

  public void EffectBaseDefenseUCDelete(int id) {
    CheckUnlocked();
    var effect = new BaseDefenseUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBaseDefenseUC[id];

    rootIncarnation.incarnationsBaseDefenseUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetBaseDefenseUCHash(int id, int version, BaseDefenseUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.incomingDamageAddConstant.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.incomingDamageMultiplierPercent.GetDeterministicHashCode();
    return result;
  }
       public BaseCombatTimeUCIncarnation GetBaseCombatTimeUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBaseCombatTimeUC[id].incarnation;
  }
  public bool BaseCombatTimeUCExists(int id) {
    return rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(id);
  }
  public BaseCombatTimeUC GetBaseCombatTimeUC(int id) {
    CheckHasBaseCombatTimeUC(id);
    return new BaseCombatTimeUC(this, id);
  }
  public BaseCombatTimeUC GetBaseCombatTimeUCOrNull(int id) {
    if (BaseCombatTimeUCExists(id)) {
      return new BaseCombatTimeUC(this, id);
    } else {
      return new BaseCombatTimeUC(this, 0);
    }
  }
  public List<BaseCombatTimeUC> AllBaseCombatTimeUC() {
    List<BaseCombatTimeUC> result = new List<BaseCombatTimeUC>(rootIncarnation.incarnationsBaseCombatTimeUC.Count);
    foreach (var id in rootIncarnation.incarnationsBaseCombatTimeUC.Keys) {
      result.Add(new BaseCombatTimeUC(this, id));
    }
    return result;
  }
  public IEnumerator<BaseCombatTimeUC> EnumAllBaseCombatTimeUC() {
    foreach (var id in rootIncarnation.incarnationsBaseCombatTimeUC.Keys) {
      yield return GetBaseCombatTimeUC(id);
    }
  }
  public void CheckHasBaseCombatTimeUC(BaseCombatTimeUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBaseCombatTimeUC(thing.id);
  }
  public void CheckHasBaseCombatTimeUC(int id) {
    if (!rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(id)) {
      throw new System.Exception("Invalid BaseCombatTimeUC: " + id);
    }
  }
  public BaseCombatTimeUC EffectBaseCombatTimeUCCreate(
      int combatTimeAddConstant,
      int combatTimeMultiplierPercent) {
    return TrustedEffectBaseCombatTimeUCCreateWithId(NewId()
            ,combatTimeAddConstant
            ,combatTimeMultiplierPercent    );
  }
  public BaseCombatTimeUC TrustedEffectBaseCombatTimeUCCreateWithId(int id
,      int combatTimeAddConstant
,      int combatTimeMultiplierPercent) {
    CheckUnlocked();

    var incarnation =
        new BaseCombatTimeUCIncarnation(
            combatTimeAddConstant,
            combatTimeMultiplierPercent
            );
    return EffectInternalCreateBaseCombatTimeUC(id, rootIncarnation.version, incarnation);
  }
  public BaseCombatTimeUC EffectInternalCreateBaseCombatTimeUC(
      int id,
      int incarnationVersion,
      BaseCombatTimeUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new BaseCombatTimeUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsBaseCombatTimeUC.Add(
        id,
        new VersionAndIncarnation<BaseCombatTimeUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new BaseCombatTimeUC(this, id);
  }

  public void EffectBaseCombatTimeUCDelete(int id) {
    CheckUnlocked();
    var effect = new BaseCombatTimeUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBaseCombatTimeUC[id];

    rootIncarnation.incarnationsBaseCombatTimeUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetBaseCombatTimeUCHash(int id, int version, BaseCombatTimeUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.combatTimeAddConstant.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.combatTimeMultiplierPercent.GetDeterministicHashCode();
    return result;
  }
       public MiredUCIncarnation GetMiredUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsMiredUC[id].incarnation;
  }
  public bool MiredUCExists(int id) {
    return rootIncarnation.incarnationsMiredUC.ContainsKey(id);
  }
  public MiredUC GetMiredUC(int id) {
    CheckHasMiredUC(id);
    return new MiredUC(this, id);
  }
  public MiredUC GetMiredUCOrNull(int id) {
    if (MiredUCExists(id)) {
      return new MiredUC(this, id);
    } else {
      return new MiredUC(this, 0);
    }
  }
  public List<MiredUC> AllMiredUC() {
    List<MiredUC> result = new List<MiredUC>(rootIncarnation.incarnationsMiredUC.Count);
    foreach (var id in rootIncarnation.incarnationsMiredUC.Keys) {
      result.Add(new MiredUC(this, id));
    }
    return result;
  }
  public IEnumerator<MiredUC> EnumAllMiredUC() {
    foreach (var id in rootIncarnation.incarnationsMiredUC.Keys) {
      yield return GetMiredUC(id);
    }
  }
  public void CheckHasMiredUC(MiredUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasMiredUC(thing.id);
  }
  public void CheckHasMiredUC(int id) {
    if (!rootIncarnation.incarnationsMiredUC.ContainsKey(id)) {
      throw new System.Exception("Invalid MiredUC: " + id);
    }
  }
  public MiredUC EffectMiredUCCreate(
) {
    return TrustedEffectMiredUCCreateWithId(NewId()
    );
  }
  public MiredUC TrustedEffectMiredUCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new MiredUCIncarnation(

            );
    return EffectInternalCreateMiredUC(id, rootIncarnation.version, incarnation);
  }
  public MiredUC EffectInternalCreateMiredUC(
      int id,
      int incarnationVersion,
      MiredUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new MiredUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsMiredUC.Add(
        id,
        new VersionAndIncarnation<MiredUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new MiredUC(this, id);
  }

  public void EffectMiredUCDelete(int id) {
    CheckUnlocked();
    var effect = new MiredUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsMiredUC[id];

    rootIncarnation.incarnationsMiredUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetMiredUCHash(int id, int version, MiredUCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public MireImpulseIncarnation GetMireImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsMireImpulse[id].incarnation;
  }
  public bool MireImpulseExists(int id) {
    return rootIncarnation.incarnationsMireImpulse.ContainsKey(id);
  }
  public MireImpulse GetMireImpulse(int id) {
    CheckHasMireImpulse(id);
    return new MireImpulse(this, id);
  }
  public MireImpulse GetMireImpulseOrNull(int id) {
    if (MireImpulseExists(id)) {
      return new MireImpulse(this, id);
    } else {
      return new MireImpulse(this, 0);
    }
  }
  public List<MireImpulse> AllMireImpulse() {
    List<MireImpulse> result = new List<MireImpulse>(rootIncarnation.incarnationsMireImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsMireImpulse.Keys) {
      result.Add(new MireImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<MireImpulse> EnumAllMireImpulse() {
    foreach (var id in rootIncarnation.incarnationsMireImpulse.Keys) {
      yield return GetMireImpulse(id);
    }
  }
  public void CheckHasMireImpulse(MireImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasMireImpulse(thing.id);
  }
  public void CheckHasMireImpulse(int id) {
    if (!rootIncarnation.incarnationsMireImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid MireImpulse: " + id);
    }
  }
  public MireImpulse EffectMireImpulseCreate(
      int weight,
      Unit targetUnit) {
    CheckHasUnit(targetUnit);
    return TrustedEffectMireImpulseCreateWithId(NewId()
            ,weight
            ,targetUnit.id    );
  }
  public MireImpulse TrustedEffectMireImpulseCreateWithId(int id
,      int weight
,      int targetUnit) {
    CheckUnlocked();

    var incarnation =
        new MireImpulseIncarnation(
            weight,
            targetUnit
            );
    return EffectInternalCreateMireImpulse(id, rootIncarnation.version, incarnation);
  }
  public MireImpulse EffectInternalCreateMireImpulse(
      int id,
      int incarnationVersion,
      MireImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new MireImpulseCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsMireImpulse.Add(
        id,
        new VersionAndIncarnation<MireImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new MireImpulse(this, id);
  }

  public void EffectMireImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new MireImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsMireImpulse[id];

    rootIncarnation.incarnationsMireImpulse.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetMireImpulseHash(int id, int version, MireImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.targetUnit.GetDeterministicHashCode();
    return result;
  }
       public EvaporateImpulseIncarnation GetEvaporateImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsEvaporateImpulse[id].incarnation;
  }
  public bool EvaporateImpulseExists(int id) {
    return rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(id);
  }
  public EvaporateImpulse GetEvaporateImpulse(int id) {
    CheckHasEvaporateImpulse(id);
    return new EvaporateImpulse(this, id);
  }
  public EvaporateImpulse GetEvaporateImpulseOrNull(int id) {
    if (EvaporateImpulseExists(id)) {
      return new EvaporateImpulse(this, id);
    } else {
      return new EvaporateImpulse(this, 0);
    }
  }
  public List<EvaporateImpulse> AllEvaporateImpulse() {
    List<EvaporateImpulse> result = new List<EvaporateImpulse>(rootIncarnation.incarnationsEvaporateImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsEvaporateImpulse.Keys) {
      result.Add(new EvaporateImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<EvaporateImpulse> EnumAllEvaporateImpulse() {
    foreach (var id in rootIncarnation.incarnationsEvaporateImpulse.Keys) {
      yield return GetEvaporateImpulse(id);
    }
  }
  public void CheckHasEvaporateImpulse(EvaporateImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasEvaporateImpulse(thing.id);
  }
  public void CheckHasEvaporateImpulse(int id) {
    if (!rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid EvaporateImpulse: " + id);
    }
  }
  public EvaporateImpulse EffectEvaporateImpulseCreate(
) {
    return TrustedEffectEvaporateImpulseCreateWithId(NewId()
    );
  }
  public EvaporateImpulse TrustedEffectEvaporateImpulseCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new EvaporateImpulseIncarnation(

            );
    return EffectInternalCreateEvaporateImpulse(id, rootIncarnation.version, incarnation);
  }
  public EvaporateImpulse EffectInternalCreateEvaporateImpulse(
      int id,
      int incarnationVersion,
      EvaporateImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new EvaporateImpulseCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsEvaporateImpulse.Add(
        id,
        new VersionAndIncarnation<EvaporateImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new EvaporateImpulse(this, id);
  }

  public void EffectEvaporateImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new EvaporateImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsEvaporateImpulse[id];

    rootIncarnation.incarnationsEvaporateImpulse.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetEvaporateImpulseHash(int id, int version, EvaporateImpulseIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public TimeCloneAICapabilityUCIncarnation GetTimeCloneAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTimeCloneAICapabilityUC[id].incarnation;
  }
  public bool TimeCloneAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id);
  }
  public TimeCloneAICapabilityUC GetTimeCloneAICapabilityUC(int id) {
    CheckHasTimeCloneAICapabilityUC(id);
    return new TimeCloneAICapabilityUC(this, id);
  }
  public TimeCloneAICapabilityUC GetTimeCloneAICapabilityUCOrNull(int id) {
    if (TimeCloneAICapabilityUCExists(id)) {
      return new TimeCloneAICapabilityUC(this, id);
    } else {
      return new TimeCloneAICapabilityUC(this, 0);
    }
  }
  public List<TimeCloneAICapabilityUC> AllTimeCloneAICapabilityUC() {
    List<TimeCloneAICapabilityUC> result = new List<TimeCloneAICapabilityUC>(rootIncarnation.incarnationsTimeCloneAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsTimeCloneAICapabilityUC.Keys) {
      result.Add(new TimeCloneAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<TimeCloneAICapabilityUC> EnumAllTimeCloneAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsTimeCloneAICapabilityUC.Keys) {
      yield return GetTimeCloneAICapabilityUC(id);
    }
  }
  public void CheckHasTimeCloneAICapabilityUC(TimeCloneAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTimeCloneAICapabilityUC(thing.id);
  }
  public void CheckHasTimeCloneAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid TimeCloneAICapabilityUC: " + id);
    }
  }
  public TimeCloneAICapabilityUC EffectTimeCloneAICapabilityUCCreate(
      IRequestMutList script) {
    return TrustedEffectTimeCloneAICapabilityUCCreateWithId(NewId()
            ,script.id    );
  }
  public TimeCloneAICapabilityUC TrustedEffectTimeCloneAICapabilityUCCreateWithId(int id
,      int script) {
    CheckUnlocked();

    var incarnation =
        new TimeCloneAICapabilityUCIncarnation(
            script
            );
    return EffectInternalCreateTimeCloneAICapabilityUC(id, rootIncarnation.version, incarnation);
  }
  public TimeCloneAICapabilityUC EffectInternalCreateTimeCloneAICapabilityUC(
      int id,
      int incarnationVersion,
      TimeCloneAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new TimeCloneAICapabilityUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsTimeCloneAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<TimeCloneAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new TimeCloneAICapabilityUC(this, id);
  }

  public void EffectTimeCloneAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = new TimeCloneAICapabilityUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTimeCloneAICapabilityUC[id];

    rootIncarnation.incarnationsTimeCloneAICapabilityUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetTimeCloneAICapabilityUCHash(int id, int version, TimeCloneAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    if (!object.ReferenceEquals(incarnation.script, null)) {
      result += id * version * 1 * incarnation.script.GetDeterministicHashCode();
    }
    return result;
  }
       public MoveImpulseIncarnation GetMoveImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsMoveImpulse[id].incarnation;
  }
  public bool MoveImpulseExists(int id) {
    return rootIncarnation.incarnationsMoveImpulse.ContainsKey(id);
  }
  public MoveImpulse GetMoveImpulse(int id) {
    CheckHasMoveImpulse(id);
    return new MoveImpulse(this, id);
  }
  public MoveImpulse GetMoveImpulseOrNull(int id) {
    if (MoveImpulseExists(id)) {
      return new MoveImpulse(this, id);
    } else {
      return new MoveImpulse(this, 0);
    }
  }
  public List<MoveImpulse> AllMoveImpulse() {
    List<MoveImpulse> result = new List<MoveImpulse>(rootIncarnation.incarnationsMoveImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsMoveImpulse.Keys) {
      result.Add(new MoveImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<MoveImpulse> EnumAllMoveImpulse() {
    foreach (var id in rootIncarnation.incarnationsMoveImpulse.Keys) {
      yield return GetMoveImpulse(id);
    }
  }
  public void CheckHasMoveImpulse(MoveImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasMoveImpulse(thing.id);
  }
  public void CheckHasMoveImpulse(int id) {
    if (!rootIncarnation.incarnationsMoveImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid MoveImpulse: " + id);
    }
  }
  public MoveImpulse EffectMoveImpulseCreate(
      int weight,
      Location stepLocation) {
    return TrustedEffectMoveImpulseCreateWithId(NewId()
            ,weight
            ,stepLocation    );
  }
  public MoveImpulse TrustedEffectMoveImpulseCreateWithId(int id
,      int weight
,      Location stepLocation) {
    CheckUnlocked();

    var incarnation =
        new MoveImpulseIncarnation(
            weight,
            stepLocation
            );
    return EffectInternalCreateMoveImpulse(id, rootIncarnation.version, incarnation);
  }
  public MoveImpulse EffectInternalCreateMoveImpulse(
      int id,
      int incarnationVersion,
      MoveImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new MoveImpulseCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsMoveImpulse.Add(
        id,
        new VersionAndIncarnation<MoveImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new MoveImpulse(this, id);
  }

  public void EffectMoveImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new MoveImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsMoveImpulse[id];

    rootIncarnation.incarnationsMoveImpulse.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetMoveImpulseHash(int id, int version, MoveImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.stepLocation.GetDeterministicHashCode();
    return result;
  }
       public KamikazeTargetTTCIncarnation GetKamikazeTargetTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsKamikazeTargetTTC[id].incarnation;
  }
  public bool KamikazeTargetTTCExists(int id) {
    return rootIncarnation.incarnationsKamikazeTargetTTC.ContainsKey(id);
  }
  public KamikazeTargetTTC GetKamikazeTargetTTC(int id) {
    CheckHasKamikazeTargetTTC(id);
    return new KamikazeTargetTTC(this, id);
  }
  public KamikazeTargetTTC GetKamikazeTargetTTCOrNull(int id) {
    if (KamikazeTargetTTCExists(id)) {
      return new KamikazeTargetTTC(this, id);
    } else {
      return new KamikazeTargetTTC(this, 0);
    }
  }
  public List<KamikazeTargetTTC> AllKamikazeTargetTTC() {
    List<KamikazeTargetTTC> result = new List<KamikazeTargetTTC>(rootIncarnation.incarnationsKamikazeTargetTTC.Count);
    foreach (var id in rootIncarnation.incarnationsKamikazeTargetTTC.Keys) {
      result.Add(new KamikazeTargetTTC(this, id));
    }
    return result;
  }
  public IEnumerator<KamikazeTargetTTC> EnumAllKamikazeTargetTTC() {
    foreach (var id in rootIncarnation.incarnationsKamikazeTargetTTC.Keys) {
      yield return GetKamikazeTargetTTC(id);
    }
  }
  public void CheckHasKamikazeTargetTTC(KamikazeTargetTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasKamikazeTargetTTC(thing.id);
  }
  public void CheckHasKamikazeTargetTTC(int id) {
    if (!rootIncarnation.incarnationsKamikazeTargetTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid KamikazeTargetTTC: " + id);
    }
  }
  public KamikazeTargetTTC EffectKamikazeTargetTTCCreate(
      KamikazeAICapabilityUC capability) {
    CheckHasKamikazeAICapabilityUC(capability);
    return TrustedEffectKamikazeTargetTTCCreateWithId(NewId()
            ,capability.id    );
  }
  public KamikazeTargetTTC TrustedEffectKamikazeTargetTTCCreateWithId(int id
,      int capability) {
    CheckUnlocked();

    var incarnation =
        new KamikazeTargetTTCIncarnation(
            capability
            );
    return EffectInternalCreateKamikazeTargetTTC(id, rootIncarnation.version, incarnation);
  }
  public KamikazeTargetTTC EffectInternalCreateKamikazeTargetTTC(
      int id,
      int incarnationVersion,
      KamikazeTargetTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new KamikazeTargetTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsKamikazeTargetTTC.Add(
        id,
        new VersionAndIncarnation<KamikazeTargetTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new KamikazeTargetTTC(this, id);
  }

  public void EffectKamikazeTargetTTCDelete(int id) {
    CheckUnlocked();
    var effect = new KamikazeTargetTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsKamikazeTargetTTC[id];

    rootIncarnation.incarnationsKamikazeTargetTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetKamikazeTargetTTCHash(int id, int version, KamikazeTargetTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.capability.GetDeterministicHashCode();
    return result;
  }
       public KamikazeJumpImpulseIncarnation GetKamikazeJumpImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsKamikazeJumpImpulse[id].incarnation;
  }
  public bool KamikazeJumpImpulseExists(int id) {
    return rootIncarnation.incarnationsKamikazeJumpImpulse.ContainsKey(id);
  }
  public KamikazeJumpImpulse GetKamikazeJumpImpulse(int id) {
    CheckHasKamikazeJumpImpulse(id);
    return new KamikazeJumpImpulse(this, id);
  }
  public KamikazeJumpImpulse GetKamikazeJumpImpulseOrNull(int id) {
    if (KamikazeJumpImpulseExists(id)) {
      return new KamikazeJumpImpulse(this, id);
    } else {
      return new KamikazeJumpImpulse(this, 0);
    }
  }
  public List<KamikazeJumpImpulse> AllKamikazeJumpImpulse() {
    List<KamikazeJumpImpulse> result = new List<KamikazeJumpImpulse>(rootIncarnation.incarnationsKamikazeJumpImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsKamikazeJumpImpulse.Keys) {
      result.Add(new KamikazeJumpImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<KamikazeJumpImpulse> EnumAllKamikazeJumpImpulse() {
    foreach (var id in rootIncarnation.incarnationsKamikazeJumpImpulse.Keys) {
      yield return GetKamikazeJumpImpulse(id);
    }
  }
  public void CheckHasKamikazeJumpImpulse(KamikazeJumpImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasKamikazeJumpImpulse(thing.id);
  }
  public void CheckHasKamikazeJumpImpulse(int id) {
    if (!rootIncarnation.incarnationsKamikazeJumpImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid KamikazeJumpImpulse: " + id);
    }
  }
  public KamikazeJumpImpulse EffectKamikazeJumpImpulseCreate(
      int weight,
      KamikazeAICapabilityUC capability,
      Location jumpTarget) {
    CheckHasKamikazeAICapabilityUC(capability);
    return TrustedEffectKamikazeJumpImpulseCreateWithId(NewId()
            ,weight
            ,capability.id
            ,jumpTarget    );
  }
  public KamikazeJumpImpulse TrustedEffectKamikazeJumpImpulseCreateWithId(int id
,      int weight
,      int capability
,      Location jumpTarget) {
    CheckUnlocked();

    var incarnation =
        new KamikazeJumpImpulseIncarnation(
            weight,
            capability,
            jumpTarget
            );
    return EffectInternalCreateKamikazeJumpImpulse(id, rootIncarnation.version, incarnation);
  }
  public KamikazeJumpImpulse EffectInternalCreateKamikazeJumpImpulse(
      int id,
      int incarnationVersion,
      KamikazeJumpImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new KamikazeJumpImpulseCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsKamikazeJumpImpulse.Add(
        id,
        new VersionAndIncarnation<KamikazeJumpImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new KamikazeJumpImpulse(this, id);
  }

  public void EffectKamikazeJumpImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new KamikazeJumpImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsKamikazeJumpImpulse[id];

    rootIncarnation.incarnationsKamikazeJumpImpulse.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetKamikazeJumpImpulseHash(int id, int version, KamikazeJumpImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.capability.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.jumpTarget.GetDeterministicHashCode();
    return result;
  }
       public KamikazeTargetImpulseIncarnation GetKamikazeTargetImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsKamikazeTargetImpulse[id].incarnation;
  }
  public bool KamikazeTargetImpulseExists(int id) {
    return rootIncarnation.incarnationsKamikazeTargetImpulse.ContainsKey(id);
  }
  public KamikazeTargetImpulse GetKamikazeTargetImpulse(int id) {
    CheckHasKamikazeTargetImpulse(id);
    return new KamikazeTargetImpulse(this, id);
  }
  public KamikazeTargetImpulse GetKamikazeTargetImpulseOrNull(int id) {
    if (KamikazeTargetImpulseExists(id)) {
      return new KamikazeTargetImpulse(this, id);
    } else {
      return new KamikazeTargetImpulse(this, 0);
    }
  }
  public List<KamikazeTargetImpulse> AllKamikazeTargetImpulse() {
    List<KamikazeTargetImpulse> result = new List<KamikazeTargetImpulse>(rootIncarnation.incarnationsKamikazeTargetImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsKamikazeTargetImpulse.Keys) {
      result.Add(new KamikazeTargetImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<KamikazeTargetImpulse> EnumAllKamikazeTargetImpulse() {
    foreach (var id in rootIncarnation.incarnationsKamikazeTargetImpulse.Keys) {
      yield return GetKamikazeTargetImpulse(id);
    }
  }
  public void CheckHasKamikazeTargetImpulse(KamikazeTargetImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasKamikazeTargetImpulse(thing.id);
  }
  public void CheckHasKamikazeTargetImpulse(int id) {
    if (!rootIncarnation.incarnationsKamikazeTargetImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid KamikazeTargetImpulse: " + id);
    }
  }
  public KamikazeTargetImpulse EffectKamikazeTargetImpulseCreate(
      int weight,
      KamikazeAICapabilityUC capability,
      Location targetLocationCenter,
      LocationImmList targetLocations) {
    CheckHasKamikazeAICapabilityUC(capability);
    return TrustedEffectKamikazeTargetImpulseCreateWithId(NewId()
            ,weight
            ,capability.id
            ,targetLocationCenter
            ,targetLocations    );
  }
  public KamikazeTargetImpulse TrustedEffectKamikazeTargetImpulseCreateWithId(int id
,      int weight
,      int capability
,      Location targetLocationCenter
,      LocationImmList targetLocations) {
    CheckUnlocked();

    var incarnation =
        new KamikazeTargetImpulseIncarnation(
            weight,
            capability,
            targetLocationCenter,
            targetLocations
            );
    return EffectInternalCreateKamikazeTargetImpulse(id, rootIncarnation.version, incarnation);
  }
  public KamikazeTargetImpulse EffectInternalCreateKamikazeTargetImpulse(
      int id,
      int incarnationVersion,
      KamikazeTargetImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new KamikazeTargetImpulseCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsKamikazeTargetImpulse.Add(
        id,
        new VersionAndIncarnation<KamikazeTargetImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new KamikazeTargetImpulse(this, id);
  }

  public void EffectKamikazeTargetImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new KamikazeTargetImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsKamikazeTargetImpulse[id];

    rootIncarnation.incarnationsKamikazeTargetImpulse.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetKamikazeTargetImpulseHash(int id, int version, KamikazeTargetImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.capability.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.targetLocationCenter.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.targetLocations.GetDeterministicHashCode();
    return result;
  }
       public KamikazeAICapabilityUCIncarnation GetKamikazeAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsKamikazeAICapabilityUC[id].incarnation;
  }
  public bool KamikazeAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id);
  }
  public KamikazeAICapabilityUC GetKamikazeAICapabilityUC(int id) {
    CheckHasKamikazeAICapabilityUC(id);
    return new KamikazeAICapabilityUC(this, id);
  }
  public KamikazeAICapabilityUC GetKamikazeAICapabilityUCOrNull(int id) {
    if (KamikazeAICapabilityUCExists(id)) {
      return new KamikazeAICapabilityUC(this, id);
    } else {
      return new KamikazeAICapabilityUC(this, 0);
    }
  }
  public List<KamikazeAICapabilityUC> AllKamikazeAICapabilityUC() {
    List<KamikazeAICapabilityUC> result = new List<KamikazeAICapabilityUC>(rootIncarnation.incarnationsKamikazeAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsKamikazeAICapabilityUC.Keys) {
      result.Add(new KamikazeAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<KamikazeAICapabilityUC> EnumAllKamikazeAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsKamikazeAICapabilityUC.Keys) {
      yield return GetKamikazeAICapabilityUC(id);
    }
  }
  public void CheckHasKamikazeAICapabilityUC(KamikazeAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasKamikazeAICapabilityUC(thing.id);
  }
  public void CheckHasKamikazeAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid KamikazeAICapabilityUC: " + id);
    }
  }
  public KamikazeAICapabilityUC EffectKamikazeAICapabilityUCCreate(
      KamikazeTargetTTCStrongByLocationMutMap targetByLocation,
      Location targetLocationCenter) {
    CheckHasKamikazeTargetTTCStrongByLocationMutMap(targetByLocation);
    return TrustedEffectKamikazeAICapabilityUCCreateWithId(NewId()
            ,targetByLocation.id
            ,targetLocationCenter    );
  }
  public KamikazeAICapabilityUC TrustedEffectKamikazeAICapabilityUCCreateWithId(int id
,      int targetByLocation
,      Location targetLocationCenter) {
    CheckUnlocked();

    var incarnation =
        new KamikazeAICapabilityUCIncarnation(
            targetByLocation,
            targetLocationCenter
            );
    return EffectInternalCreateKamikazeAICapabilityUC(id, rootIncarnation.version, incarnation);
  }
  public KamikazeAICapabilityUC EffectInternalCreateKamikazeAICapabilityUC(
      int id,
      int incarnationVersion,
      KamikazeAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new KamikazeAICapabilityUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsKamikazeAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<KamikazeAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new KamikazeAICapabilityUC(this, id);
  }

  public void EffectKamikazeAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = new KamikazeAICapabilityUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsKamikazeAICapabilityUC[id];

    rootIncarnation.incarnationsKamikazeAICapabilityUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetKamikazeAICapabilityUCHash(int id, int version, KamikazeAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.targetByLocation.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.targetLocationCenter.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectKamikazeAICapabilityUCSetTargetByLocation(int id, KamikazeTargetTTCStrongByLocationMutMap newValue) {
    CheckUnlocked();
    CheckHasKamikazeAICapabilityUC(id);
var effect = new KamikazeAICapabilityUCSetTargetByLocationEffect(id, newValue.id);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeAICapabilityUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldId = oldIncarnationAndVersion.incarnation.targetByLocation;
      oldIncarnationAndVersion.incarnation.targetByLocation = newValue.id;

    } else {
      var newIncarnation =
          new KamikazeAICapabilityUCIncarnation(
              newValue.id,
              oldIncarnationAndVersion.incarnation.targetLocationCenter);
      rootIncarnation.incarnationsKamikazeAICapabilityUC[id] =
          new VersionAndIncarnation<KamikazeAICapabilityUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }

  public void EffectKamikazeAICapabilityUCSetTargetLocationCenter(int id, Location newValue) {
    CheckUnlocked();
    CheckHasKamikazeAICapabilityUC(id);
var effect = new KamikazeAICapabilityUCSetTargetLocationCenterEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeAICapabilityUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.targetLocationCenter;
      oldIncarnationAndVersion.incarnation.targetLocationCenter = newValue;

    } else {
      var newIncarnation =
          new KamikazeAICapabilityUCIncarnation(
              oldIncarnationAndVersion.incarnation.targetByLocation,
              newValue);
      rootIncarnation.incarnationsKamikazeAICapabilityUC[id] =
          new VersionAndIncarnation<KamikazeAICapabilityUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }
  public InvincibilityUCIncarnation GetInvincibilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsInvincibilityUC[id].incarnation;
  }
  public bool InvincibilityUCExists(int id) {
    return rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id);
  }
  public InvincibilityUC GetInvincibilityUC(int id) {
    CheckHasInvincibilityUC(id);
    return new InvincibilityUC(this, id);
  }
  public InvincibilityUC GetInvincibilityUCOrNull(int id) {
    if (InvincibilityUCExists(id)) {
      return new InvincibilityUC(this, id);
    } else {
      return new InvincibilityUC(this, 0);
    }
  }
  public List<InvincibilityUC> AllInvincibilityUC() {
    List<InvincibilityUC> result = new List<InvincibilityUC>(rootIncarnation.incarnationsInvincibilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsInvincibilityUC.Keys) {
      result.Add(new InvincibilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<InvincibilityUC> EnumAllInvincibilityUC() {
    foreach (var id in rootIncarnation.incarnationsInvincibilityUC.Keys) {
      yield return GetInvincibilityUC(id);
    }
  }
  public void CheckHasInvincibilityUC(InvincibilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasInvincibilityUC(thing.id);
  }
  public void CheckHasInvincibilityUC(int id) {
    if (!rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid InvincibilityUC: " + id);
    }
  }
  public InvincibilityUC EffectInvincibilityUCCreate(
) {
    return TrustedEffectInvincibilityUCCreateWithId(NewId()
    );
  }
  public InvincibilityUC TrustedEffectInvincibilityUCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new InvincibilityUCIncarnation(

            );
    return EffectInternalCreateInvincibilityUC(id, rootIncarnation.version, incarnation);
  }
  public InvincibilityUC EffectInternalCreateInvincibilityUC(
      int id,
      int incarnationVersion,
      InvincibilityUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new InvincibilityUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsInvincibilityUC.Add(
        id,
        new VersionAndIncarnation<InvincibilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new InvincibilityUC(this, id);
  }

  public void EffectInvincibilityUCDelete(int id) {
    CheckUnlocked();
    var effect = new InvincibilityUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsInvincibilityUC[id];

    rootIncarnation.incarnationsInvincibilityUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetInvincibilityUCHash(int id, int version, InvincibilityUCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public GuardAICapabilityUCIncarnation GetGuardAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsGuardAICapabilityUC[id].incarnation;
  }
  public bool GuardAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(id);
  }
  public GuardAICapabilityUC GetGuardAICapabilityUC(int id) {
    CheckHasGuardAICapabilityUC(id);
    return new GuardAICapabilityUC(this, id);
  }
  public GuardAICapabilityUC GetGuardAICapabilityUCOrNull(int id) {
    if (GuardAICapabilityUCExists(id)) {
      return new GuardAICapabilityUC(this, id);
    } else {
      return new GuardAICapabilityUC(this, 0);
    }
  }
  public List<GuardAICapabilityUC> AllGuardAICapabilityUC() {
    List<GuardAICapabilityUC> result = new List<GuardAICapabilityUC>(rootIncarnation.incarnationsGuardAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsGuardAICapabilityUC.Keys) {
      result.Add(new GuardAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<GuardAICapabilityUC> EnumAllGuardAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsGuardAICapabilityUC.Keys) {
      yield return GetGuardAICapabilityUC(id);
    }
  }
  public void CheckHasGuardAICapabilityUC(GuardAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasGuardAICapabilityUC(thing.id);
  }
  public void CheckHasGuardAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid GuardAICapabilityUC: " + id);
    }
  }
  public GuardAICapabilityUC EffectGuardAICapabilityUCCreate(
      Location guardCenterLocation,
      int guardRadius) {
    return TrustedEffectGuardAICapabilityUCCreateWithId(NewId()
            ,guardCenterLocation
            ,guardRadius    );
  }
  public GuardAICapabilityUC TrustedEffectGuardAICapabilityUCCreateWithId(int id
,      Location guardCenterLocation
,      int guardRadius) {
    CheckUnlocked();

    var incarnation =
        new GuardAICapabilityUCIncarnation(
            guardCenterLocation,
            guardRadius
            );
    return EffectInternalCreateGuardAICapabilityUC(id, rootIncarnation.version, incarnation);
  }
  public GuardAICapabilityUC EffectInternalCreateGuardAICapabilityUC(
      int id,
      int incarnationVersion,
      GuardAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new GuardAICapabilityUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsGuardAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<GuardAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new GuardAICapabilityUC(this, id);
  }

  public void EffectGuardAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = new GuardAICapabilityUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsGuardAICapabilityUC[id];

    rootIncarnation.incarnationsGuardAICapabilityUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetGuardAICapabilityUCHash(int id, int version, GuardAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.guardCenterLocation.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.guardRadius.GetDeterministicHashCode();
    return result;
  }
       public NoImpulseIncarnation GetNoImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsNoImpulse[id].incarnation;
  }
  public bool NoImpulseExists(int id) {
    return rootIncarnation.incarnationsNoImpulse.ContainsKey(id);
  }
  public NoImpulse GetNoImpulse(int id) {
    CheckHasNoImpulse(id);
    return new NoImpulse(this, id);
  }
  public NoImpulse GetNoImpulseOrNull(int id) {
    if (NoImpulseExists(id)) {
      return new NoImpulse(this, id);
    } else {
      return new NoImpulse(this, 0);
    }
  }
  public List<NoImpulse> AllNoImpulse() {
    List<NoImpulse> result = new List<NoImpulse>(rootIncarnation.incarnationsNoImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsNoImpulse.Keys) {
      result.Add(new NoImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<NoImpulse> EnumAllNoImpulse() {
    foreach (var id in rootIncarnation.incarnationsNoImpulse.Keys) {
      yield return GetNoImpulse(id);
    }
  }
  public void CheckHasNoImpulse(NoImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasNoImpulse(thing.id);
  }
  public void CheckHasNoImpulse(int id) {
    if (!rootIncarnation.incarnationsNoImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid NoImpulse: " + id);
    }
  }
  public NoImpulse EffectNoImpulseCreate(
) {
    return TrustedEffectNoImpulseCreateWithId(NewId()
    );
  }
  public NoImpulse TrustedEffectNoImpulseCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new NoImpulseIncarnation(

            );
    return EffectInternalCreateNoImpulse(id, rootIncarnation.version, incarnation);
  }
  public NoImpulse EffectInternalCreateNoImpulse(
      int id,
      int incarnationVersion,
      NoImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new NoImpulseCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsNoImpulse.Add(
        id,
        new VersionAndIncarnation<NoImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new NoImpulse(this, id);
  }

  public void EffectNoImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new NoImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsNoImpulse[id];

    rootIncarnation.incarnationsNoImpulse.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetNoImpulseHash(int id, int version, NoImpulseIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public FireImpulseIncarnation GetFireImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsFireImpulse[id].incarnation;
  }
  public bool FireImpulseExists(int id) {
    return rootIncarnation.incarnationsFireImpulse.ContainsKey(id);
  }
  public FireImpulse GetFireImpulse(int id) {
    CheckHasFireImpulse(id);
    return new FireImpulse(this, id);
  }
  public FireImpulse GetFireImpulseOrNull(int id) {
    if (FireImpulseExists(id)) {
      return new FireImpulse(this, id);
    } else {
      return new FireImpulse(this, 0);
    }
  }
  public List<FireImpulse> AllFireImpulse() {
    List<FireImpulse> result = new List<FireImpulse>(rootIncarnation.incarnationsFireImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsFireImpulse.Keys) {
      result.Add(new FireImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<FireImpulse> EnumAllFireImpulse() {
    foreach (var id in rootIncarnation.incarnationsFireImpulse.Keys) {
      yield return GetFireImpulse(id);
    }
  }
  public void CheckHasFireImpulse(FireImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasFireImpulse(thing.id);
  }
  public void CheckHasFireImpulse(int id) {
    if (!rootIncarnation.incarnationsFireImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid FireImpulse: " + id);
    }
  }
  public FireImpulse EffectFireImpulseCreate(
      int weight,
      Unit targetUnit) {
    CheckHasUnit(targetUnit);
    return TrustedEffectFireImpulseCreateWithId(NewId()
            ,weight
            ,targetUnit.id    );
  }
  public FireImpulse TrustedEffectFireImpulseCreateWithId(int id
,      int weight
,      int targetUnit) {
    CheckUnlocked();

    var incarnation =
        new FireImpulseIncarnation(
            weight,
            targetUnit
            );
    return EffectInternalCreateFireImpulse(id, rootIncarnation.version, incarnation);
  }
  public FireImpulse EffectInternalCreateFireImpulse(
      int id,
      int incarnationVersion,
      FireImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new FireImpulseCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsFireImpulse.Add(
        id,
        new VersionAndIncarnation<FireImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new FireImpulse(this, id);
  }

  public void EffectFireImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new FireImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsFireImpulse[id];

    rootIncarnation.incarnationsFireImpulse.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetFireImpulseHash(int id, int version, FireImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.targetUnit.GetDeterministicHashCode();
    return result;
  }
       public DefyingUCIncarnation GetDefyingUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsDefyingUC[id].incarnation;
  }
  public bool DefyingUCExists(int id) {
    return rootIncarnation.incarnationsDefyingUC.ContainsKey(id);
  }
  public DefyingUC GetDefyingUC(int id) {
    CheckHasDefyingUC(id);
    return new DefyingUC(this, id);
  }
  public DefyingUC GetDefyingUCOrNull(int id) {
    if (DefyingUCExists(id)) {
      return new DefyingUC(this, id);
    } else {
      return new DefyingUC(this, 0);
    }
  }
  public List<DefyingUC> AllDefyingUC() {
    List<DefyingUC> result = new List<DefyingUC>(rootIncarnation.incarnationsDefyingUC.Count);
    foreach (var id in rootIncarnation.incarnationsDefyingUC.Keys) {
      result.Add(new DefyingUC(this, id));
    }
    return result;
  }
  public IEnumerator<DefyingUC> EnumAllDefyingUC() {
    foreach (var id in rootIncarnation.incarnationsDefyingUC.Keys) {
      yield return GetDefyingUC(id);
    }
  }
  public void CheckHasDefyingUC(DefyingUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasDefyingUC(thing.id);
  }
  public void CheckHasDefyingUC(int id) {
    if (!rootIncarnation.incarnationsDefyingUC.ContainsKey(id)) {
      throw new System.Exception("Invalid DefyingUC: " + id);
    }
  }
  public DefyingUC EffectDefyingUCCreate(
) {
    return TrustedEffectDefyingUCCreateWithId(NewId()
    );
  }
  public DefyingUC TrustedEffectDefyingUCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new DefyingUCIncarnation(

            );
    return EffectInternalCreateDefyingUC(id, rootIncarnation.version, incarnation);
  }
  public DefyingUC EffectInternalCreateDefyingUC(
      int id,
      int incarnationVersion,
      DefyingUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new DefyingUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsDefyingUC.Add(
        id,
        new VersionAndIncarnation<DefyingUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new DefyingUC(this, id);
  }

  public void EffectDefyingUCDelete(int id) {
    CheckUnlocked();
    var effect = new DefyingUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsDefyingUC[id];

    rootIncarnation.incarnationsDefyingUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetDefyingUCHash(int id, int version, DefyingUCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public DefyImpulseIncarnation GetDefyImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsDefyImpulse[id].incarnation;
  }
  public bool DefyImpulseExists(int id) {
    return rootIncarnation.incarnationsDefyImpulse.ContainsKey(id);
  }
  public DefyImpulse GetDefyImpulse(int id) {
    CheckHasDefyImpulse(id);
    return new DefyImpulse(this, id);
  }
  public DefyImpulse GetDefyImpulseOrNull(int id) {
    if (DefyImpulseExists(id)) {
      return new DefyImpulse(this, id);
    } else {
      return new DefyImpulse(this, 0);
    }
  }
  public List<DefyImpulse> AllDefyImpulse() {
    List<DefyImpulse> result = new List<DefyImpulse>(rootIncarnation.incarnationsDefyImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsDefyImpulse.Keys) {
      result.Add(new DefyImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<DefyImpulse> EnumAllDefyImpulse() {
    foreach (var id in rootIncarnation.incarnationsDefyImpulse.Keys) {
      yield return GetDefyImpulse(id);
    }
  }
  public void CheckHasDefyImpulse(DefyImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasDefyImpulse(thing.id);
  }
  public void CheckHasDefyImpulse(int id) {
    if (!rootIncarnation.incarnationsDefyImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid DefyImpulse: " + id);
    }
  }
  public DefyImpulse EffectDefyImpulseCreate(
      int weight) {
    return TrustedEffectDefyImpulseCreateWithId(NewId()
            ,weight    );
  }
  public DefyImpulse TrustedEffectDefyImpulseCreateWithId(int id
,      int weight) {
    CheckUnlocked();

    var incarnation =
        new DefyImpulseIncarnation(
            weight
            );
    return EffectInternalCreateDefyImpulse(id, rootIncarnation.version, incarnation);
  }
  public DefyImpulse EffectInternalCreateDefyImpulse(
      int id,
      int incarnationVersion,
      DefyImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new DefyImpulseCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsDefyImpulse.Add(
        id,
        new VersionAndIncarnation<DefyImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new DefyImpulse(this, id);
  }

  public void EffectDefyImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new DefyImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsDefyImpulse[id];

    rootIncarnation.incarnationsDefyImpulse.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetDefyImpulseHash(int id, int version, DefyImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    return result;
  }
       public CounteringUCIncarnation GetCounteringUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCounteringUC[id].incarnation;
  }
  public bool CounteringUCExists(int id) {
    return rootIncarnation.incarnationsCounteringUC.ContainsKey(id);
  }
  public CounteringUC GetCounteringUC(int id) {
    CheckHasCounteringUC(id);
    return new CounteringUC(this, id);
  }
  public CounteringUC GetCounteringUCOrNull(int id) {
    if (CounteringUCExists(id)) {
      return new CounteringUC(this, id);
    } else {
      return new CounteringUC(this, 0);
    }
  }
  public List<CounteringUC> AllCounteringUC() {
    List<CounteringUC> result = new List<CounteringUC>(rootIncarnation.incarnationsCounteringUC.Count);
    foreach (var id in rootIncarnation.incarnationsCounteringUC.Keys) {
      result.Add(new CounteringUC(this, id));
    }
    return result;
  }
  public IEnumerator<CounteringUC> EnumAllCounteringUC() {
    foreach (var id in rootIncarnation.incarnationsCounteringUC.Keys) {
      yield return GetCounteringUC(id);
    }
  }
  public void CheckHasCounteringUC(CounteringUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCounteringUC(thing.id);
  }
  public void CheckHasCounteringUC(int id) {
    if (!rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      throw new System.Exception("Invalid CounteringUC: " + id);
    }
  }
  public CounteringUC EffectCounteringUCCreate(
) {
    return TrustedEffectCounteringUCCreateWithId(NewId()
    );
  }
  public CounteringUC TrustedEffectCounteringUCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new CounteringUCIncarnation(

            );
    return EffectInternalCreateCounteringUC(id, rootIncarnation.version, incarnation);
  }
  public CounteringUC EffectInternalCreateCounteringUC(
      int id,
      int incarnationVersion,
      CounteringUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new CounteringUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsCounteringUC.Add(
        id,
        new VersionAndIncarnation<CounteringUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new CounteringUC(this, id);
  }

  public void EffectCounteringUCDelete(int id) {
    CheckUnlocked();
    var effect = new CounteringUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCounteringUC[id];

    rootIncarnation.incarnationsCounteringUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetCounteringUCHash(int id, int version, CounteringUCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public CounterImpulseIncarnation GetCounterImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCounterImpulse[id].incarnation;
  }
  public bool CounterImpulseExists(int id) {
    return rootIncarnation.incarnationsCounterImpulse.ContainsKey(id);
  }
  public CounterImpulse GetCounterImpulse(int id) {
    CheckHasCounterImpulse(id);
    return new CounterImpulse(this, id);
  }
  public CounterImpulse GetCounterImpulseOrNull(int id) {
    if (CounterImpulseExists(id)) {
      return new CounterImpulse(this, id);
    } else {
      return new CounterImpulse(this, 0);
    }
  }
  public List<CounterImpulse> AllCounterImpulse() {
    List<CounterImpulse> result = new List<CounterImpulse>(rootIncarnation.incarnationsCounterImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsCounterImpulse.Keys) {
      result.Add(new CounterImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<CounterImpulse> EnumAllCounterImpulse() {
    foreach (var id in rootIncarnation.incarnationsCounterImpulse.Keys) {
      yield return GetCounterImpulse(id);
    }
  }
  public void CheckHasCounterImpulse(CounterImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCounterImpulse(thing.id);
  }
  public void CheckHasCounterImpulse(int id) {
    if (!rootIncarnation.incarnationsCounterImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid CounterImpulse: " + id);
    }
  }
  public CounterImpulse EffectCounterImpulseCreate(
      int weight) {
    return TrustedEffectCounterImpulseCreateWithId(NewId()
            ,weight    );
  }
  public CounterImpulse TrustedEffectCounterImpulseCreateWithId(int id
,      int weight) {
    CheckUnlocked();

    var incarnation =
        new CounterImpulseIncarnation(
            weight
            );
    return EffectInternalCreateCounterImpulse(id, rootIncarnation.version, incarnation);
  }
  public CounterImpulse EffectInternalCreateCounterImpulse(
      int id,
      int incarnationVersion,
      CounterImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new CounterImpulseCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsCounterImpulse.Add(
        id,
        new VersionAndIncarnation<CounterImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new CounterImpulse(this, id);
  }

  public void EffectCounterImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new CounterImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCounterImpulse[id];

    rootIncarnation.incarnationsCounterImpulse.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetCounterImpulseHash(int id, int version, CounterImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    return result;
  }
       public UnleashBideImpulseIncarnation GetUnleashBideImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsUnleashBideImpulse[id].incarnation;
  }
  public bool UnleashBideImpulseExists(int id) {
    return rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(id);
  }
  public UnleashBideImpulse GetUnleashBideImpulse(int id) {
    CheckHasUnleashBideImpulse(id);
    return new UnleashBideImpulse(this, id);
  }
  public UnleashBideImpulse GetUnleashBideImpulseOrNull(int id) {
    if (UnleashBideImpulseExists(id)) {
      return new UnleashBideImpulse(this, id);
    } else {
      return new UnleashBideImpulse(this, 0);
    }
  }
  public List<UnleashBideImpulse> AllUnleashBideImpulse() {
    List<UnleashBideImpulse> result = new List<UnleashBideImpulse>(rootIncarnation.incarnationsUnleashBideImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsUnleashBideImpulse.Keys) {
      result.Add(new UnleashBideImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<UnleashBideImpulse> EnumAllUnleashBideImpulse() {
    foreach (var id in rootIncarnation.incarnationsUnleashBideImpulse.Keys) {
      yield return GetUnleashBideImpulse(id);
    }
  }
  public void CheckHasUnleashBideImpulse(UnleashBideImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasUnleashBideImpulse(thing.id);
  }
  public void CheckHasUnleashBideImpulse(int id) {
    if (!rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid UnleashBideImpulse: " + id);
    }
  }
  public UnleashBideImpulse EffectUnleashBideImpulseCreate(
      int weight) {
    return TrustedEffectUnleashBideImpulseCreateWithId(NewId()
            ,weight    );
  }
  public UnleashBideImpulse TrustedEffectUnleashBideImpulseCreateWithId(int id
,      int weight) {
    CheckUnlocked();

    var incarnation =
        new UnleashBideImpulseIncarnation(
            weight
            );
    return EffectInternalCreateUnleashBideImpulse(id, rootIncarnation.version, incarnation);
  }
  public UnleashBideImpulse EffectInternalCreateUnleashBideImpulse(
      int id,
      int incarnationVersion,
      UnleashBideImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new UnleashBideImpulseCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsUnleashBideImpulse.Add(
        id,
        new VersionAndIncarnation<UnleashBideImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new UnleashBideImpulse(this, id);
  }

  public void EffectUnleashBideImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new UnleashBideImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsUnleashBideImpulse[id];

    rootIncarnation.incarnationsUnleashBideImpulse.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetUnleashBideImpulseHash(int id, int version, UnleashBideImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    return result;
  }
       public ContinueBidingImpulseIncarnation GetContinueBidingImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsContinueBidingImpulse[id].incarnation;
  }
  public bool ContinueBidingImpulseExists(int id) {
    return rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(id);
  }
  public ContinueBidingImpulse GetContinueBidingImpulse(int id) {
    CheckHasContinueBidingImpulse(id);
    return new ContinueBidingImpulse(this, id);
  }
  public ContinueBidingImpulse GetContinueBidingImpulseOrNull(int id) {
    if (ContinueBidingImpulseExists(id)) {
      return new ContinueBidingImpulse(this, id);
    } else {
      return new ContinueBidingImpulse(this, 0);
    }
  }
  public List<ContinueBidingImpulse> AllContinueBidingImpulse() {
    List<ContinueBidingImpulse> result = new List<ContinueBidingImpulse>(rootIncarnation.incarnationsContinueBidingImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsContinueBidingImpulse.Keys) {
      result.Add(new ContinueBidingImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<ContinueBidingImpulse> EnumAllContinueBidingImpulse() {
    foreach (var id in rootIncarnation.incarnationsContinueBidingImpulse.Keys) {
      yield return GetContinueBidingImpulse(id);
    }
  }
  public void CheckHasContinueBidingImpulse(ContinueBidingImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasContinueBidingImpulse(thing.id);
  }
  public void CheckHasContinueBidingImpulse(int id) {
    if (!rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid ContinueBidingImpulse: " + id);
    }
  }
  public ContinueBidingImpulse EffectContinueBidingImpulseCreate(
      int weight) {
    return TrustedEffectContinueBidingImpulseCreateWithId(NewId()
            ,weight    );
  }
  public ContinueBidingImpulse TrustedEffectContinueBidingImpulseCreateWithId(int id
,      int weight) {
    CheckUnlocked();

    var incarnation =
        new ContinueBidingImpulseIncarnation(
            weight
            );
    return EffectInternalCreateContinueBidingImpulse(id, rootIncarnation.version, incarnation);
  }
  public ContinueBidingImpulse EffectInternalCreateContinueBidingImpulse(
      int id,
      int incarnationVersion,
      ContinueBidingImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new ContinueBidingImpulseCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsContinueBidingImpulse.Add(
        id,
        new VersionAndIncarnation<ContinueBidingImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new ContinueBidingImpulse(this, id);
  }

  public void EffectContinueBidingImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new ContinueBidingImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsContinueBidingImpulse[id];

    rootIncarnation.incarnationsContinueBidingImpulse.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetContinueBidingImpulseHash(int id, int version, ContinueBidingImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    return result;
  }
       public StartBidingImpulseIncarnation GetStartBidingImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsStartBidingImpulse[id].incarnation;
  }
  public bool StartBidingImpulseExists(int id) {
    return rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(id);
  }
  public StartBidingImpulse GetStartBidingImpulse(int id) {
    CheckHasStartBidingImpulse(id);
    return new StartBidingImpulse(this, id);
  }
  public StartBidingImpulse GetStartBidingImpulseOrNull(int id) {
    if (StartBidingImpulseExists(id)) {
      return new StartBidingImpulse(this, id);
    } else {
      return new StartBidingImpulse(this, 0);
    }
  }
  public List<StartBidingImpulse> AllStartBidingImpulse() {
    List<StartBidingImpulse> result = new List<StartBidingImpulse>(rootIncarnation.incarnationsStartBidingImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsStartBidingImpulse.Keys) {
      result.Add(new StartBidingImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<StartBidingImpulse> EnumAllStartBidingImpulse() {
    foreach (var id in rootIncarnation.incarnationsStartBidingImpulse.Keys) {
      yield return GetStartBidingImpulse(id);
    }
  }
  public void CheckHasStartBidingImpulse(StartBidingImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasStartBidingImpulse(thing.id);
  }
  public void CheckHasStartBidingImpulse(int id) {
    if (!rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid StartBidingImpulse: " + id);
    }
  }
  public StartBidingImpulse EffectStartBidingImpulseCreate(
      int weight) {
    return TrustedEffectStartBidingImpulseCreateWithId(NewId()
            ,weight    );
  }
  public StartBidingImpulse TrustedEffectStartBidingImpulseCreateWithId(int id
,      int weight) {
    CheckUnlocked();

    var incarnation =
        new StartBidingImpulseIncarnation(
            weight
            );
    return EffectInternalCreateStartBidingImpulse(id, rootIncarnation.version, incarnation);
  }
  public StartBidingImpulse EffectInternalCreateStartBidingImpulse(
      int id,
      int incarnationVersion,
      StartBidingImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new StartBidingImpulseCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsStartBidingImpulse.Add(
        id,
        new VersionAndIncarnation<StartBidingImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new StartBidingImpulse(this, id);
  }

  public void EffectStartBidingImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new StartBidingImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsStartBidingImpulse[id];

    rootIncarnation.incarnationsStartBidingImpulse.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetStartBidingImpulseHash(int id, int version, StartBidingImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    return result;
  }
       public BideAICapabilityUCIncarnation GetBideAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBideAICapabilityUC[id].incarnation;
  }
  public bool BideAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id);
  }
  public BideAICapabilityUC GetBideAICapabilityUC(int id) {
    CheckHasBideAICapabilityUC(id);
    return new BideAICapabilityUC(this, id);
  }
  public BideAICapabilityUC GetBideAICapabilityUCOrNull(int id) {
    if (BideAICapabilityUCExists(id)) {
      return new BideAICapabilityUC(this, id);
    } else {
      return new BideAICapabilityUC(this, 0);
    }
  }
  public List<BideAICapabilityUC> AllBideAICapabilityUC() {
    List<BideAICapabilityUC> result = new List<BideAICapabilityUC>(rootIncarnation.incarnationsBideAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsBideAICapabilityUC.Keys) {
      result.Add(new BideAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<BideAICapabilityUC> EnumAllBideAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsBideAICapabilityUC.Keys) {
      yield return GetBideAICapabilityUC(id);
    }
  }
  public void CheckHasBideAICapabilityUC(BideAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBideAICapabilityUC(thing.id);
  }
  public void CheckHasBideAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid BideAICapabilityUC: " + id);
    }
  }
  public BideAICapabilityUC EffectBideAICapabilityUCCreate(
      int charge) {
    return TrustedEffectBideAICapabilityUCCreateWithId(NewId()
            ,charge    );
  }
  public BideAICapabilityUC TrustedEffectBideAICapabilityUCCreateWithId(int id
,      int charge) {
    CheckUnlocked();

    var incarnation =
        new BideAICapabilityUCIncarnation(
            charge
            );
    return EffectInternalCreateBideAICapabilityUC(id, rootIncarnation.version, incarnation);
  }
  public BideAICapabilityUC EffectInternalCreateBideAICapabilityUC(
      int id,
      int incarnationVersion,
      BideAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new BideAICapabilityUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsBideAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<BideAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new BideAICapabilityUC(this, id);
  }

  public void EffectBideAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = new BideAICapabilityUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBideAICapabilityUC[id];

    rootIncarnation.incarnationsBideAICapabilityUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetBideAICapabilityUCHash(int id, int version, BideAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.charge.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectBideAICapabilityUCSetCharge(int id, int newValue) {
    CheckUnlocked();
    CheckHasBideAICapabilityUC(id);
var effect = new BideAICapabilityUCSetChargeEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsBideAICapabilityUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.charge;
      oldIncarnationAndVersion.incarnation.charge = newValue;

    } else {
      var newIncarnation =
          new BideAICapabilityUCIncarnation(
              newValue);
      rootIncarnation.incarnationsBideAICapabilityUC[id] =
          new VersionAndIncarnation<BideAICapabilityUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }
  public AttackImpulseIncarnation GetAttackImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsAttackImpulse[id].incarnation;
  }
  public bool AttackImpulseExists(int id) {
    return rootIncarnation.incarnationsAttackImpulse.ContainsKey(id);
  }
  public AttackImpulse GetAttackImpulse(int id) {
    CheckHasAttackImpulse(id);
    return new AttackImpulse(this, id);
  }
  public AttackImpulse GetAttackImpulseOrNull(int id) {
    if (AttackImpulseExists(id)) {
      return new AttackImpulse(this, id);
    } else {
      return new AttackImpulse(this, 0);
    }
  }
  public List<AttackImpulse> AllAttackImpulse() {
    List<AttackImpulse> result = new List<AttackImpulse>(rootIncarnation.incarnationsAttackImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsAttackImpulse.Keys) {
      result.Add(new AttackImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<AttackImpulse> EnumAllAttackImpulse() {
    foreach (var id in rootIncarnation.incarnationsAttackImpulse.Keys) {
      yield return GetAttackImpulse(id);
    }
  }
  public void CheckHasAttackImpulse(AttackImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasAttackImpulse(thing.id);
  }
  public void CheckHasAttackImpulse(int id) {
    if (!rootIncarnation.incarnationsAttackImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid AttackImpulse: " + id);
    }
  }
  public AttackImpulse EffectAttackImpulseCreate(
      int weight,
      Unit targetUnit) {
    CheckHasUnit(targetUnit);
    return TrustedEffectAttackImpulseCreateWithId(NewId()
            ,weight
            ,targetUnit.id    );
  }
  public AttackImpulse TrustedEffectAttackImpulseCreateWithId(int id
,      int weight
,      int targetUnit) {
    CheckUnlocked();

    var incarnation =
        new AttackImpulseIncarnation(
            weight,
            targetUnit
            );
    return EffectInternalCreateAttackImpulse(id, rootIncarnation.version, incarnation);
  }
  public AttackImpulse EffectInternalCreateAttackImpulse(
      int id,
      int incarnationVersion,
      AttackImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new AttackImpulseCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsAttackImpulse.Add(
        id,
        new VersionAndIncarnation<AttackImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new AttackImpulse(this, id);
  }

  public void EffectAttackImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new AttackImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsAttackImpulse[id];

    rootIncarnation.incarnationsAttackImpulse.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetAttackImpulseHash(int id, int version, AttackImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.targetUnit.GetDeterministicHashCode();
    return result;
  }
       public PursueImpulseIncarnation GetPursueImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsPursueImpulse[id].incarnation;
  }
  public bool PursueImpulseExists(int id) {
    return rootIncarnation.incarnationsPursueImpulse.ContainsKey(id);
  }
  public PursueImpulse GetPursueImpulse(int id) {
    CheckHasPursueImpulse(id);
    return new PursueImpulse(this, id);
  }
  public PursueImpulse GetPursueImpulseOrNull(int id) {
    if (PursueImpulseExists(id)) {
      return new PursueImpulse(this, id);
    } else {
      return new PursueImpulse(this, 0);
    }
  }
  public List<PursueImpulse> AllPursueImpulse() {
    List<PursueImpulse> result = new List<PursueImpulse>(rootIncarnation.incarnationsPursueImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsPursueImpulse.Keys) {
      result.Add(new PursueImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<PursueImpulse> EnumAllPursueImpulse() {
    foreach (var id in rootIncarnation.incarnationsPursueImpulse.Keys) {
      yield return GetPursueImpulse(id);
    }
  }
  public void CheckHasPursueImpulse(PursueImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasPursueImpulse(thing.id);
  }
  public void CheckHasPursueImpulse(int id) {
    if (!rootIncarnation.incarnationsPursueImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid PursueImpulse: " + id);
    }
  }
  public PursueImpulse EffectPursueImpulseCreate(
      int weight,
      bool isClearPath) {
    return TrustedEffectPursueImpulseCreateWithId(NewId()
            ,weight
            ,isClearPath    );
  }
  public PursueImpulse TrustedEffectPursueImpulseCreateWithId(int id
,      int weight
,      bool isClearPath) {
    CheckUnlocked();

    var incarnation =
        new PursueImpulseIncarnation(
            weight,
            isClearPath
            );
    return EffectInternalCreatePursueImpulse(id, rootIncarnation.version, incarnation);
  }
  public PursueImpulse EffectInternalCreatePursueImpulse(
      int id,
      int incarnationVersion,
      PursueImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new PursueImpulseCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsPursueImpulse.Add(
        id,
        new VersionAndIncarnation<PursueImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new PursueImpulse(this, id);
  }

  public void EffectPursueImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new PursueImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsPursueImpulse[id];

    rootIncarnation.incarnationsPursueImpulse.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetPursueImpulseHash(int id, int version, PursueImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.isClearPath.GetDeterministicHashCode();
    return result;
  }
       public KillDirectiveIncarnation GetKillDirectiveIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsKillDirective[id].incarnation;
  }
  public bool KillDirectiveExists(int id) {
    return rootIncarnation.incarnationsKillDirective.ContainsKey(id);
  }
  public KillDirective GetKillDirective(int id) {
    CheckHasKillDirective(id);
    return new KillDirective(this, id);
  }
  public KillDirective GetKillDirectiveOrNull(int id) {
    if (KillDirectiveExists(id)) {
      return new KillDirective(this, id);
    } else {
      return new KillDirective(this, 0);
    }
  }
  public List<KillDirective> AllKillDirective() {
    List<KillDirective> result = new List<KillDirective>(rootIncarnation.incarnationsKillDirective.Count);
    foreach (var id in rootIncarnation.incarnationsKillDirective.Keys) {
      result.Add(new KillDirective(this, id));
    }
    return result;
  }
  public IEnumerator<KillDirective> EnumAllKillDirective() {
    foreach (var id in rootIncarnation.incarnationsKillDirective.Keys) {
      yield return GetKillDirective(id);
    }
  }
  public void CheckHasKillDirective(KillDirective thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasKillDirective(thing.id);
  }
  public void CheckHasKillDirective(int id) {
    if (!rootIncarnation.incarnationsKillDirective.ContainsKey(id)) {
      throw new System.Exception("Invalid KillDirective: " + id);
    }
  }
  public KillDirective EffectKillDirectiveCreate(
      Unit targetUnit,
      LocationMutList pathToLastSeenLocation) {
    CheckHasUnit(targetUnit);
    CheckHasLocationMutList(pathToLastSeenLocation);
    return TrustedEffectKillDirectiveCreateWithId(NewId()
            ,targetUnit.id
            ,pathToLastSeenLocation.id    );
  }
  public KillDirective TrustedEffectKillDirectiveCreateWithId(int id
,      int targetUnit
,      int pathToLastSeenLocation) {
    CheckUnlocked();

    var incarnation =
        new KillDirectiveIncarnation(
            targetUnit,
            pathToLastSeenLocation
            );
    return EffectInternalCreateKillDirective(id, rootIncarnation.version, incarnation);
  }
  public KillDirective EffectInternalCreateKillDirective(
      int id,
      int incarnationVersion,
      KillDirectiveIncarnation incarnation) {
    CheckUnlocked();
    var effect = new KillDirectiveCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsKillDirective.Add(
        id,
        new VersionAndIncarnation<KillDirectiveIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new KillDirective(this, id);
  }

  public void EffectKillDirectiveDelete(int id) {
    CheckUnlocked();
    var effect = new KillDirectiveDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsKillDirective[id];

    rootIncarnation.incarnationsKillDirective.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetKillDirectiveHash(int id, int version, KillDirectiveIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.targetUnit.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.pathToLastSeenLocation.GetDeterministicHashCode();
    return result;
  }
       public AttackAICapabilityUCIncarnation GetAttackAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsAttackAICapabilityUC[id].incarnation;
  }
  public bool AttackAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id);
  }
  public AttackAICapabilityUC GetAttackAICapabilityUC(int id) {
    CheckHasAttackAICapabilityUC(id);
    return new AttackAICapabilityUC(this, id);
  }
  public AttackAICapabilityUC GetAttackAICapabilityUCOrNull(int id) {
    if (AttackAICapabilityUCExists(id)) {
      return new AttackAICapabilityUC(this, id);
    } else {
      return new AttackAICapabilityUC(this, 0);
    }
  }
  public List<AttackAICapabilityUC> AllAttackAICapabilityUC() {
    List<AttackAICapabilityUC> result = new List<AttackAICapabilityUC>(rootIncarnation.incarnationsAttackAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsAttackAICapabilityUC.Keys) {
      result.Add(new AttackAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<AttackAICapabilityUC> EnumAllAttackAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsAttackAICapabilityUC.Keys) {
      yield return GetAttackAICapabilityUC(id);
    }
  }
  public void CheckHasAttackAICapabilityUC(AttackAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasAttackAICapabilityUC(thing.id);
  }
  public void CheckHasAttackAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid AttackAICapabilityUC: " + id);
    }
  }
  public AttackAICapabilityUC EffectAttackAICapabilityUCCreate(
      KillDirective killDirective) {
    return TrustedEffectAttackAICapabilityUCCreateWithId(NewId()
            ,killDirective.id    );
  }
  public AttackAICapabilityUC TrustedEffectAttackAICapabilityUCCreateWithId(int id
,      int killDirective) {
    CheckUnlocked();

    var incarnation =
        new AttackAICapabilityUCIncarnation(
            killDirective
            );
    return EffectInternalCreateAttackAICapabilityUC(id, rootIncarnation.version, incarnation);
  }
  public AttackAICapabilityUC EffectInternalCreateAttackAICapabilityUC(
      int id,
      int incarnationVersion,
      AttackAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new AttackAICapabilityUCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsAttackAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<AttackAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new AttackAICapabilityUC(this, id);
  }

  public void EffectAttackAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = new AttackAICapabilityUCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsAttackAICapabilityUC[id];

    rootIncarnation.incarnationsAttackAICapabilityUC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetAttackAICapabilityUCHash(int id, int version, AttackAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    if (!object.ReferenceEquals(incarnation.killDirective, null)) {
      result += id * version * 1 * incarnation.killDirective.GetDeterministicHashCode();
    }
    return result;
  }
     
  public void EffectAttackAICapabilityUCSetKillDirective(int id, KillDirective newValue) {
    CheckUnlocked();
    CheckHasAttackAICapabilityUC(id);
var effect = new AttackAICapabilityUCSetKillDirectiveEffect(id, newValue.id);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsAttackAICapabilityUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldId = oldIncarnationAndVersion.incarnation.killDirective;
      oldIncarnationAndVersion.incarnation.killDirective = newValue.id;

    } else {
      var newIncarnation =
          new AttackAICapabilityUCIncarnation(
              newValue.id);
      rootIncarnation.incarnationsAttackAICapabilityUC[id] =
          new VersionAndIncarnation<AttackAICapabilityUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }
  public WarperTTCIncarnation GetWarperTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsWarperTTC[id].incarnation;
  }
  public bool WarperTTCExists(int id) {
    return rootIncarnation.incarnationsWarperTTC.ContainsKey(id);
  }
  public WarperTTC GetWarperTTC(int id) {
    CheckHasWarperTTC(id);
    return new WarperTTC(this, id);
  }
  public WarperTTC GetWarperTTCOrNull(int id) {
    if (WarperTTCExists(id)) {
      return new WarperTTC(this, id);
    } else {
      return new WarperTTC(this, 0);
    }
  }
  public List<WarperTTC> AllWarperTTC() {
    List<WarperTTC> result = new List<WarperTTC>(rootIncarnation.incarnationsWarperTTC.Count);
    foreach (var id in rootIncarnation.incarnationsWarperTTC.Keys) {
      result.Add(new WarperTTC(this, id));
    }
    return result;
  }
  public IEnumerator<WarperTTC> EnumAllWarperTTC() {
    foreach (var id in rootIncarnation.incarnationsWarperTTC.Keys) {
      yield return GetWarperTTC(id);
    }
  }
  public void CheckHasWarperTTC(WarperTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasWarperTTC(thing.id);
  }
  public void CheckHasWarperTTC(int id) {
    if (!rootIncarnation.incarnationsWarperTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid WarperTTC: " + id);
    }
  }
  public WarperTTC EffectWarperTTCCreate(
      Location destinationLocation) {
    return TrustedEffectWarperTTCCreateWithId(NewId()
            ,destinationLocation    );
  }
  public WarperTTC TrustedEffectWarperTTCCreateWithId(int id
,      Location destinationLocation) {
    CheckUnlocked();

    var incarnation =
        new WarperTTCIncarnation(
            destinationLocation
            );
    return EffectInternalCreateWarperTTC(id, rootIncarnation.version, incarnation);
  }
  public WarperTTC EffectInternalCreateWarperTTC(
      int id,
      int incarnationVersion,
      WarperTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new WarperTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsWarperTTC.Add(
        id,
        new VersionAndIncarnation<WarperTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new WarperTTC(this, id);
  }

  public void EffectWarperTTCDelete(int id) {
    CheckUnlocked();
    var effect = new WarperTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsWarperTTC[id];

    rootIncarnation.incarnationsWarperTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetWarperTTCHash(int id, int version, WarperTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.destinationLocation.GetDeterministicHashCode();
    return result;
  }
       public TimeAnchorTTCIncarnation GetTimeAnchorTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTimeAnchorTTC[id].incarnation;
  }
  public bool TimeAnchorTTCExists(int id) {
    return rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(id);
  }
  public TimeAnchorTTC GetTimeAnchorTTC(int id) {
    CheckHasTimeAnchorTTC(id);
    return new TimeAnchorTTC(this, id);
  }
  public TimeAnchorTTC GetTimeAnchorTTCOrNull(int id) {
    if (TimeAnchorTTCExists(id)) {
      return new TimeAnchorTTC(this, id);
    } else {
      return new TimeAnchorTTC(this, 0);
    }
  }
  public List<TimeAnchorTTC> AllTimeAnchorTTC() {
    List<TimeAnchorTTC> result = new List<TimeAnchorTTC>(rootIncarnation.incarnationsTimeAnchorTTC.Count);
    foreach (var id in rootIncarnation.incarnationsTimeAnchorTTC.Keys) {
      result.Add(new TimeAnchorTTC(this, id));
    }
    return result;
  }
  public IEnumerator<TimeAnchorTTC> EnumAllTimeAnchorTTC() {
    foreach (var id in rootIncarnation.incarnationsTimeAnchorTTC.Keys) {
      yield return GetTimeAnchorTTC(id);
    }
  }
  public void CheckHasTimeAnchorTTC(TimeAnchorTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTimeAnchorTTC(thing.id);
  }
  public void CheckHasTimeAnchorTTC(int id) {
    if (!rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid TimeAnchorTTC: " + id);
    }
  }
  public TimeAnchorTTC EffectTimeAnchorTTCCreate(
      int pastVersion) {
    return TrustedEffectTimeAnchorTTCCreateWithId(NewId()
            ,pastVersion    );
  }
  public TimeAnchorTTC TrustedEffectTimeAnchorTTCCreateWithId(int id
,      int pastVersion) {
    CheckUnlocked();

    var incarnation =
        new TimeAnchorTTCIncarnation(
            pastVersion
            );
    return EffectInternalCreateTimeAnchorTTC(id, rootIncarnation.version, incarnation);
  }
  public TimeAnchorTTC EffectInternalCreateTimeAnchorTTC(
      int id,
      int incarnationVersion,
      TimeAnchorTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new TimeAnchorTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsTimeAnchorTTC.Add(
        id,
        new VersionAndIncarnation<TimeAnchorTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new TimeAnchorTTC(this, id);
  }

  public void EffectTimeAnchorTTCDelete(int id) {
    CheckUnlocked();
    var effect = new TimeAnchorTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTimeAnchorTTC[id];

    rootIncarnation.incarnationsTimeAnchorTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetTimeAnchorTTCHash(int id, int version, TimeAnchorTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.pastVersion.GetDeterministicHashCode();
    return result;
  }
       public TerrainTileIncarnation GetTerrainTileIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTerrainTile[id].incarnation;
  }
  public bool TerrainTileExists(int id) {
    return rootIncarnation.incarnationsTerrainTile.ContainsKey(id);
  }
  public TerrainTile GetTerrainTile(int id) {
    CheckHasTerrainTile(id);
    return new TerrainTile(this, id);
  }
  public TerrainTile GetTerrainTileOrNull(int id) {
    if (TerrainTileExists(id)) {
      return new TerrainTile(this, id);
    } else {
      return new TerrainTile(this, 0);
    }
  }
  public List<TerrainTile> AllTerrainTile() {
    List<TerrainTile> result = new List<TerrainTile>(rootIncarnation.incarnationsTerrainTile.Count);
    foreach (var id in rootIncarnation.incarnationsTerrainTile.Keys) {
      result.Add(new TerrainTile(this, id));
    }
    return result;
  }
  public IEnumerator<TerrainTile> EnumAllTerrainTile() {
    foreach (var id in rootIncarnation.incarnationsTerrainTile.Keys) {
      yield return GetTerrainTile(id);
    }
  }
  public void CheckHasTerrainTile(TerrainTile thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTerrainTile(thing.id);
  }
  public void CheckHasTerrainTile(int id) {
    if (!rootIncarnation.incarnationsTerrainTile.ContainsKey(id)) {
      throw new System.Exception("Invalid TerrainTile: " + id);
    }
  }
  public TerrainTile EffectTerrainTileCreate(
      ITerrainTileEvent evvent,
      int elevation,
      ITerrainTileComponentMutBunch components) {
    CheckHasITerrainTileComponentMutBunch(components);
    return TrustedEffectTerrainTileCreateWithId(NewId()
            ,evvent
            ,elevation
            ,components.id    );
  }
  public TerrainTile TrustedEffectTerrainTileCreateWithId(int id
,      ITerrainTileEvent evvent
,      int elevation
,      int components) {
    CheckUnlocked();

    var incarnation =
        new TerrainTileIncarnation(
            evvent,
            elevation,
            components
            );
    return EffectInternalCreateTerrainTile(id, rootIncarnation.version, incarnation);
  }
  public TerrainTile EffectInternalCreateTerrainTile(
      int id,
      int incarnationVersion,
      TerrainTileIncarnation incarnation) {
    CheckUnlocked();
    var effect = new TerrainTileCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsTerrainTile.Add(
        id,
        new VersionAndIncarnation<TerrainTileIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new TerrainTile(this, id);
  }

  public void EffectTerrainTileDelete(int id) {
    CheckUnlocked();
    var effect = new TerrainTileDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTerrainTile[id];

    rootIncarnation.incarnationsTerrainTile.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetTerrainTileHash(int id, int version, TerrainTileIncarnation incarnation) {
    int result = id * version;
    if (!object.ReferenceEquals(incarnation.evvent, null)) {
      result += id * version * 1 * incarnation.evvent.GetDeterministicHashCode();
    }
    result += id * version * 2 * incarnation.elevation.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.components.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectTerrainTileSetEvvent(int id, ITerrainTileEvent newValue) {
    CheckUnlocked();
    CheckHasTerrainTile(id);
var effect = new TerrainTileSetEvventEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsTerrainTile[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.evvent;
      oldIncarnationAndVersion.incarnation.evvent = newValue;

    } else {
      var newIncarnation =
          new TerrainTileIncarnation(
              newValue,
              oldIncarnationAndVersion.incarnation.elevation,
              oldIncarnationAndVersion.incarnation.components);
      rootIncarnation.incarnationsTerrainTile[id] =
          new VersionAndIncarnation<TerrainTileIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }

  public void EffectTerrainTileSetElevation(int id, int newValue) {
    CheckUnlocked();
    CheckHasTerrainTile(id);
var effect = new TerrainTileSetElevationEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsTerrainTile[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.elevation;
      oldIncarnationAndVersion.incarnation.elevation = newValue;

    } else {
      var newIncarnation =
          new TerrainTileIncarnation(
              oldIncarnationAndVersion.incarnation.evvent,
              newValue,
              oldIncarnationAndVersion.incarnation.components);
      rootIncarnation.incarnationsTerrainTile[id] =
          new VersionAndIncarnation<TerrainTileIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }
  public ITerrainTileComponentMutBunchIncarnation GetITerrainTileComponentMutBunchIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsITerrainTileComponentMutBunch[id].incarnation;
  }
  public bool ITerrainTileComponentMutBunchExists(int id) {
    return rootIncarnation.incarnationsITerrainTileComponentMutBunch.ContainsKey(id);
  }
  public ITerrainTileComponentMutBunch GetITerrainTileComponentMutBunch(int id) {
    CheckHasITerrainTileComponentMutBunch(id);
    return new ITerrainTileComponentMutBunch(this, id);
  }
  public ITerrainTileComponentMutBunch GetITerrainTileComponentMutBunchOrNull(int id) {
    if (ITerrainTileComponentMutBunchExists(id)) {
      return new ITerrainTileComponentMutBunch(this, id);
    } else {
      return new ITerrainTileComponentMutBunch(this, 0);
    }
  }
  public List<ITerrainTileComponentMutBunch> AllITerrainTileComponentMutBunch() {
    List<ITerrainTileComponentMutBunch> result = new List<ITerrainTileComponentMutBunch>(rootIncarnation.incarnationsITerrainTileComponentMutBunch.Count);
    foreach (var id in rootIncarnation.incarnationsITerrainTileComponentMutBunch.Keys) {
      result.Add(new ITerrainTileComponentMutBunch(this, id));
    }
    return result;
  }
  public IEnumerator<ITerrainTileComponentMutBunch> EnumAllITerrainTileComponentMutBunch() {
    foreach (var id in rootIncarnation.incarnationsITerrainTileComponentMutBunch.Keys) {
      yield return GetITerrainTileComponentMutBunch(id);
    }
  }
  public void CheckHasITerrainTileComponentMutBunch(ITerrainTileComponentMutBunch thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasITerrainTileComponentMutBunch(thing.id);
  }
  public void CheckHasITerrainTileComponentMutBunch(int id) {
    if (!rootIncarnation.incarnationsITerrainTileComponentMutBunch.ContainsKey(id)) {
      throw new System.Exception("Invalid ITerrainTileComponentMutBunch: " + id);
    }
  }
  public ITerrainTileComponentMutBunch EffectITerrainTileComponentMutBunchCreate(
      SimplePresenceTriggerTTCMutSet membersSimplePresenceTriggerTTCMutSet,
      ItemTTCMutSet membersItemTTCMutSet,
      KamikazeTargetTTCMutSet membersKamikazeTargetTTCMutSet,
      WarperTTCMutSet membersWarperTTCMutSet,
      TimeAnchorTTCMutSet membersTimeAnchorTTCMutSet,
      FireBombTTCMutSet membersFireBombTTCMutSet,
      MarkerTTCMutSet membersMarkerTTCMutSet,
      LevelLinkTTCMutSet membersLevelLinkTTCMutSet,
      MudTTCMutSet membersMudTTCMutSet,
      DirtTTCMutSet membersDirtTTCMutSet,
      ObsidianTTCMutSet membersObsidianTTCMutSet,
      DownStairsTTCMutSet membersDownStairsTTCMutSet,
      UpStairsTTCMutSet membersUpStairsTTCMutSet,
      WallTTCMutSet membersWallTTCMutSet,
      BloodTTCMutSet membersBloodTTCMutSet,
      RocksTTCMutSet membersRocksTTCMutSet,
      TreeTTCMutSet membersTreeTTCMutSet,
      WaterTTCMutSet membersWaterTTCMutSet,
      FloorTTCMutSet membersFloorTTCMutSet,
      CaveWallTTCMutSet membersCaveWallTTCMutSet,
      CaveTTCMutSet membersCaveTTCMutSet,
      FallsTTCMutSet membersFallsTTCMutSet,
      FireTTCMutSet membersFireTTCMutSet,
      ObsidianFloorTTCMutSet membersObsidianFloorTTCMutSet,
      MagmaTTCMutSet membersMagmaTTCMutSet,
      CliffTTCMutSet membersCliffTTCMutSet,
      RavaNestTTCMutSet membersRavaNestTTCMutSet,
      CliffLandingTTCMutSet membersCliffLandingTTCMutSet,
      StoneTTCMutSet membersStoneTTCMutSet,
      GrassTTCMutSet membersGrassTTCMutSet,
      IncendianFallsLevelLinkerTTCMutSet membersIncendianFallsLevelLinkerTTCMutSet,
      EmberDeepLevelLinkerTTCMutSet membersEmberDeepLevelLinkerTTCMutSet) {
    CheckHasSimplePresenceTriggerTTCMutSet(membersSimplePresenceTriggerTTCMutSet);
    CheckHasItemTTCMutSet(membersItemTTCMutSet);
    CheckHasKamikazeTargetTTCMutSet(membersKamikazeTargetTTCMutSet);
    CheckHasWarperTTCMutSet(membersWarperTTCMutSet);
    CheckHasTimeAnchorTTCMutSet(membersTimeAnchorTTCMutSet);
    CheckHasFireBombTTCMutSet(membersFireBombTTCMutSet);
    CheckHasMarkerTTCMutSet(membersMarkerTTCMutSet);
    CheckHasLevelLinkTTCMutSet(membersLevelLinkTTCMutSet);
    CheckHasMudTTCMutSet(membersMudTTCMutSet);
    CheckHasDirtTTCMutSet(membersDirtTTCMutSet);
    CheckHasObsidianTTCMutSet(membersObsidianTTCMutSet);
    CheckHasDownStairsTTCMutSet(membersDownStairsTTCMutSet);
    CheckHasUpStairsTTCMutSet(membersUpStairsTTCMutSet);
    CheckHasWallTTCMutSet(membersWallTTCMutSet);
    CheckHasBloodTTCMutSet(membersBloodTTCMutSet);
    CheckHasRocksTTCMutSet(membersRocksTTCMutSet);
    CheckHasTreeTTCMutSet(membersTreeTTCMutSet);
    CheckHasWaterTTCMutSet(membersWaterTTCMutSet);
    CheckHasFloorTTCMutSet(membersFloorTTCMutSet);
    CheckHasCaveWallTTCMutSet(membersCaveWallTTCMutSet);
    CheckHasCaveTTCMutSet(membersCaveTTCMutSet);
    CheckHasFallsTTCMutSet(membersFallsTTCMutSet);
    CheckHasFireTTCMutSet(membersFireTTCMutSet);
    CheckHasObsidianFloorTTCMutSet(membersObsidianFloorTTCMutSet);
    CheckHasMagmaTTCMutSet(membersMagmaTTCMutSet);
    CheckHasCliffTTCMutSet(membersCliffTTCMutSet);
    CheckHasRavaNestTTCMutSet(membersRavaNestTTCMutSet);
    CheckHasCliffLandingTTCMutSet(membersCliffLandingTTCMutSet);
    CheckHasStoneTTCMutSet(membersStoneTTCMutSet);
    CheckHasGrassTTCMutSet(membersGrassTTCMutSet);
    CheckHasIncendianFallsLevelLinkerTTCMutSet(membersIncendianFallsLevelLinkerTTCMutSet);
    CheckHasEmberDeepLevelLinkerTTCMutSet(membersEmberDeepLevelLinkerTTCMutSet);
    return TrustedEffectITerrainTileComponentMutBunchCreateWithId(NewId()
            ,membersSimplePresenceTriggerTTCMutSet.id
            ,membersItemTTCMutSet.id
            ,membersKamikazeTargetTTCMutSet.id
            ,membersWarperTTCMutSet.id
            ,membersTimeAnchorTTCMutSet.id
            ,membersFireBombTTCMutSet.id
            ,membersMarkerTTCMutSet.id
            ,membersLevelLinkTTCMutSet.id
            ,membersMudTTCMutSet.id
            ,membersDirtTTCMutSet.id
            ,membersObsidianTTCMutSet.id
            ,membersDownStairsTTCMutSet.id
            ,membersUpStairsTTCMutSet.id
            ,membersWallTTCMutSet.id
            ,membersBloodTTCMutSet.id
            ,membersRocksTTCMutSet.id
            ,membersTreeTTCMutSet.id
            ,membersWaterTTCMutSet.id
            ,membersFloorTTCMutSet.id
            ,membersCaveWallTTCMutSet.id
            ,membersCaveTTCMutSet.id
            ,membersFallsTTCMutSet.id
            ,membersFireTTCMutSet.id
            ,membersObsidianFloorTTCMutSet.id
            ,membersMagmaTTCMutSet.id
            ,membersCliffTTCMutSet.id
            ,membersRavaNestTTCMutSet.id
            ,membersCliffLandingTTCMutSet.id
            ,membersStoneTTCMutSet.id
            ,membersGrassTTCMutSet.id
            ,membersIncendianFallsLevelLinkerTTCMutSet.id
            ,membersEmberDeepLevelLinkerTTCMutSet.id    );
  }
  public ITerrainTileComponentMutBunch TrustedEffectITerrainTileComponentMutBunchCreateWithId(int id
,      int membersSimplePresenceTriggerTTCMutSet
,      int membersItemTTCMutSet
,      int membersKamikazeTargetTTCMutSet
,      int membersWarperTTCMutSet
,      int membersTimeAnchorTTCMutSet
,      int membersFireBombTTCMutSet
,      int membersMarkerTTCMutSet
,      int membersLevelLinkTTCMutSet
,      int membersMudTTCMutSet
,      int membersDirtTTCMutSet
,      int membersObsidianTTCMutSet
,      int membersDownStairsTTCMutSet
,      int membersUpStairsTTCMutSet
,      int membersWallTTCMutSet
,      int membersBloodTTCMutSet
,      int membersRocksTTCMutSet
,      int membersTreeTTCMutSet
,      int membersWaterTTCMutSet
,      int membersFloorTTCMutSet
,      int membersCaveWallTTCMutSet
,      int membersCaveTTCMutSet
,      int membersFallsTTCMutSet
,      int membersFireTTCMutSet
,      int membersObsidianFloorTTCMutSet
,      int membersMagmaTTCMutSet
,      int membersCliffTTCMutSet
,      int membersRavaNestTTCMutSet
,      int membersCliffLandingTTCMutSet
,      int membersStoneTTCMutSet
,      int membersGrassTTCMutSet
,      int membersIncendianFallsLevelLinkerTTCMutSet
,      int membersEmberDeepLevelLinkerTTCMutSet) {
    CheckUnlocked();

    var incarnation =
        new ITerrainTileComponentMutBunchIncarnation(
            membersSimplePresenceTriggerTTCMutSet,
            membersItemTTCMutSet,
            membersKamikazeTargetTTCMutSet,
            membersWarperTTCMutSet,
            membersTimeAnchorTTCMutSet,
            membersFireBombTTCMutSet,
            membersMarkerTTCMutSet,
            membersLevelLinkTTCMutSet,
            membersMudTTCMutSet,
            membersDirtTTCMutSet,
            membersObsidianTTCMutSet,
            membersDownStairsTTCMutSet,
            membersUpStairsTTCMutSet,
            membersWallTTCMutSet,
            membersBloodTTCMutSet,
            membersRocksTTCMutSet,
            membersTreeTTCMutSet,
            membersWaterTTCMutSet,
            membersFloorTTCMutSet,
            membersCaveWallTTCMutSet,
            membersCaveTTCMutSet,
            membersFallsTTCMutSet,
            membersFireTTCMutSet,
            membersObsidianFloorTTCMutSet,
            membersMagmaTTCMutSet,
            membersCliffTTCMutSet,
            membersRavaNestTTCMutSet,
            membersCliffLandingTTCMutSet,
            membersStoneTTCMutSet,
            membersGrassTTCMutSet,
            membersIncendianFallsLevelLinkerTTCMutSet,
            membersEmberDeepLevelLinkerTTCMutSet
            );
    return EffectInternalCreateITerrainTileComponentMutBunch(id, rootIncarnation.version, incarnation);
  }
  public ITerrainTileComponentMutBunch EffectInternalCreateITerrainTileComponentMutBunch(
      int id,
      int incarnationVersion,
      ITerrainTileComponentMutBunchIncarnation incarnation) {
    CheckUnlocked();
    var effect = new ITerrainTileComponentMutBunchCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsITerrainTileComponentMutBunch.Add(
        id,
        new VersionAndIncarnation<ITerrainTileComponentMutBunchIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new ITerrainTileComponentMutBunch(this, id);
  }

  public void EffectITerrainTileComponentMutBunchDelete(int id) {
    CheckUnlocked();
    var effect = new ITerrainTileComponentMutBunchDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsITerrainTileComponentMutBunch[id];

    rootIncarnation.incarnationsITerrainTileComponentMutBunch.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetITerrainTileComponentMutBunchHash(int id, int version, ITerrainTileComponentMutBunchIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.membersSimplePresenceTriggerTTCMutSet.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.membersItemTTCMutSet.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.membersKamikazeTargetTTCMutSet.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.membersWarperTTCMutSet.GetDeterministicHashCode();
    result += id * version * 5 * incarnation.membersTimeAnchorTTCMutSet.GetDeterministicHashCode();
    result += id * version * 6 * incarnation.membersFireBombTTCMutSet.GetDeterministicHashCode();
    result += id * version * 7 * incarnation.membersMarkerTTCMutSet.GetDeterministicHashCode();
    result += id * version * 8 * incarnation.membersLevelLinkTTCMutSet.GetDeterministicHashCode();
    result += id * version * 9 * incarnation.membersMudTTCMutSet.GetDeterministicHashCode();
    result += id * version * 10 * incarnation.membersDirtTTCMutSet.GetDeterministicHashCode();
    result += id * version * 11 * incarnation.membersObsidianTTCMutSet.GetDeterministicHashCode();
    result += id * version * 12 * incarnation.membersDownStairsTTCMutSet.GetDeterministicHashCode();
    result += id * version * 13 * incarnation.membersUpStairsTTCMutSet.GetDeterministicHashCode();
    result += id * version * 14 * incarnation.membersWallTTCMutSet.GetDeterministicHashCode();
    result += id * version * 15 * incarnation.membersBloodTTCMutSet.GetDeterministicHashCode();
    result += id * version * 16 * incarnation.membersRocksTTCMutSet.GetDeterministicHashCode();
    result += id * version * 17 * incarnation.membersTreeTTCMutSet.GetDeterministicHashCode();
    result += id * version * 18 * incarnation.membersWaterTTCMutSet.GetDeterministicHashCode();
    result += id * version * 19 * incarnation.membersFloorTTCMutSet.GetDeterministicHashCode();
    result += id * version * 20 * incarnation.membersCaveWallTTCMutSet.GetDeterministicHashCode();
    result += id * version * 21 * incarnation.membersCaveTTCMutSet.GetDeterministicHashCode();
    result += id * version * 22 * incarnation.membersFallsTTCMutSet.GetDeterministicHashCode();
    result += id * version * 23 * incarnation.membersFireTTCMutSet.GetDeterministicHashCode();
    result += id * version * 24 * incarnation.membersObsidianFloorTTCMutSet.GetDeterministicHashCode();
    result += id * version * 25 * incarnation.membersMagmaTTCMutSet.GetDeterministicHashCode();
    result += id * version * 26 * incarnation.membersCliffTTCMutSet.GetDeterministicHashCode();
    result += id * version * 27 * incarnation.membersRavaNestTTCMutSet.GetDeterministicHashCode();
    result += id * version * 28 * incarnation.membersCliffLandingTTCMutSet.GetDeterministicHashCode();
    result += id * version * 29 * incarnation.membersStoneTTCMutSet.GetDeterministicHashCode();
    result += id * version * 30 * incarnation.membersGrassTTCMutSet.GetDeterministicHashCode();
    result += id * version * 31 * incarnation.membersIncendianFallsLevelLinkerTTCMutSet.GetDeterministicHashCode();
    result += id * version * 32 * incarnation.membersEmberDeepLevelLinkerTTCMutSet.GetDeterministicHashCode();
    return result;
  }
       public TerrainIncarnation GetTerrainIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTerrain[id].incarnation;
  }
  public bool TerrainExists(int id) {
    return rootIncarnation.incarnationsTerrain.ContainsKey(id);
  }
  public Terrain GetTerrain(int id) {
    CheckHasTerrain(id);
    return new Terrain(this, id);
  }
  public Terrain GetTerrainOrNull(int id) {
    if (TerrainExists(id)) {
      return new Terrain(this, id);
    } else {
      return new Terrain(this, 0);
    }
  }
  public List<Terrain> AllTerrain() {
    List<Terrain> result = new List<Terrain>(rootIncarnation.incarnationsTerrain.Count);
    foreach (var id in rootIncarnation.incarnationsTerrain.Keys) {
      result.Add(new Terrain(this, id));
    }
    return result;
  }
  public IEnumerator<Terrain> EnumAllTerrain() {
    foreach (var id in rootIncarnation.incarnationsTerrain.Keys) {
      yield return GetTerrain(id);
    }
  }
  public void CheckHasTerrain(Terrain thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTerrain(thing.id);
  }
  public void CheckHasTerrain(int id) {
    if (!rootIncarnation.incarnationsTerrain.ContainsKey(id)) {
      throw new System.Exception("Invalid Terrain: " + id);
    }
  }
  public Terrain EffectTerrainCreate(
      Pattern pattern,
      float elevationStepHeight,
      TerrainTileByLocationMutMap tiles) {
    CheckHasTerrainTileByLocationMutMap(tiles);
    return TrustedEffectTerrainCreateWithId(NewId()
            ,pattern
            ,elevationStepHeight
            ,tiles.id    );
  }
  public Terrain TrustedEffectTerrainCreateWithId(int id
,      Pattern pattern
,      float elevationStepHeight
,      int tiles) {
    CheckUnlocked();

    var incarnation =
        new TerrainIncarnation(
            pattern,
            elevationStepHeight,
            tiles
            );
    return EffectInternalCreateTerrain(id, rootIncarnation.version, incarnation);
  }
  public Terrain EffectInternalCreateTerrain(
      int id,
      int incarnationVersion,
      TerrainIncarnation incarnation) {
    CheckUnlocked();
    var effect = new TerrainCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsTerrain.Add(
        id,
        new VersionAndIncarnation<TerrainIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new Terrain(this, id);
  }

  public void EffectTerrainDelete(int id) {
    CheckUnlocked();
    var effect = new TerrainDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTerrain[id];

    rootIncarnation.incarnationsTerrain.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetTerrainHash(int id, int version, TerrainIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.pattern.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.elevationStepHeight.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.tiles.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectTerrainSetPattern(int id, Pattern newValue) {
    CheckUnlocked();
    CheckHasTerrain(id);
var effect = new TerrainSetPatternEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsTerrain[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.pattern;
      oldIncarnationAndVersion.incarnation.pattern = newValue;

    } else {
      var newIncarnation =
          new TerrainIncarnation(
              newValue,
              oldIncarnationAndVersion.incarnation.elevationStepHeight,
              oldIncarnationAndVersion.incarnation.tiles);
      rootIncarnation.incarnationsTerrain[id] =
          new VersionAndIncarnation<TerrainIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }
  public SimplePresenceTriggerTTCIncarnation GetSimplePresenceTriggerTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsSimplePresenceTriggerTTC[id].incarnation;
  }
  public bool SimplePresenceTriggerTTCExists(int id) {
    return rootIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(id);
  }
  public SimplePresenceTriggerTTC GetSimplePresenceTriggerTTC(int id) {
    CheckHasSimplePresenceTriggerTTC(id);
    return new SimplePresenceTriggerTTC(this, id);
  }
  public SimplePresenceTriggerTTC GetSimplePresenceTriggerTTCOrNull(int id) {
    if (SimplePresenceTriggerTTCExists(id)) {
      return new SimplePresenceTriggerTTC(this, id);
    } else {
      return new SimplePresenceTriggerTTC(this, 0);
    }
  }
  public List<SimplePresenceTriggerTTC> AllSimplePresenceTriggerTTC() {
    List<SimplePresenceTriggerTTC> result = new List<SimplePresenceTriggerTTC>(rootIncarnation.incarnationsSimplePresenceTriggerTTC.Count);
    foreach (var id in rootIncarnation.incarnationsSimplePresenceTriggerTTC.Keys) {
      result.Add(new SimplePresenceTriggerTTC(this, id));
    }
    return result;
  }
  public IEnumerator<SimplePresenceTriggerTTC> EnumAllSimplePresenceTriggerTTC() {
    foreach (var id in rootIncarnation.incarnationsSimplePresenceTriggerTTC.Keys) {
      yield return GetSimplePresenceTriggerTTC(id);
    }
  }
  public void CheckHasSimplePresenceTriggerTTC(SimplePresenceTriggerTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasSimplePresenceTriggerTTC(thing.id);
  }
  public void CheckHasSimplePresenceTriggerTTC(int id) {
    if (!rootIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid SimplePresenceTriggerTTC: " + id);
    }
  }
  public SimplePresenceTriggerTTC EffectSimplePresenceTriggerTTCCreate(
      string name) {
    return TrustedEffectSimplePresenceTriggerTTCCreateWithId(NewId()
            ,name    );
  }
  public SimplePresenceTriggerTTC TrustedEffectSimplePresenceTriggerTTCCreateWithId(int id
,      string name) {
    CheckUnlocked();

    var incarnation =
        new SimplePresenceTriggerTTCIncarnation(
            name
            );
    return EffectInternalCreateSimplePresenceTriggerTTC(id, rootIncarnation.version, incarnation);
  }
  public SimplePresenceTriggerTTC EffectInternalCreateSimplePresenceTriggerTTC(
      int id,
      int incarnationVersion,
      SimplePresenceTriggerTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new SimplePresenceTriggerTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsSimplePresenceTriggerTTC.Add(
        id,
        new VersionAndIncarnation<SimplePresenceTriggerTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new SimplePresenceTriggerTTC(this, id);
  }

  public void EffectSimplePresenceTriggerTTCDelete(int id) {
    CheckUnlocked();
    var effect = new SimplePresenceTriggerTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsSimplePresenceTriggerTTC[id];

    rootIncarnation.incarnationsSimplePresenceTriggerTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetSimplePresenceTriggerTTCHash(int id, int version, SimplePresenceTriggerTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.name.GetDeterministicHashCode();
    return result;
  }
       public FireBombImpulseIncarnation GetFireBombImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsFireBombImpulse[id].incarnation;
  }
  public bool FireBombImpulseExists(int id) {
    return rootIncarnation.incarnationsFireBombImpulse.ContainsKey(id);
  }
  public FireBombImpulse GetFireBombImpulse(int id) {
    CheckHasFireBombImpulse(id);
    return new FireBombImpulse(this, id);
  }
  public FireBombImpulse GetFireBombImpulseOrNull(int id) {
    if (FireBombImpulseExists(id)) {
      return new FireBombImpulse(this, id);
    } else {
      return new FireBombImpulse(this, 0);
    }
  }
  public List<FireBombImpulse> AllFireBombImpulse() {
    List<FireBombImpulse> result = new List<FireBombImpulse>(rootIncarnation.incarnationsFireBombImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsFireBombImpulse.Keys) {
      result.Add(new FireBombImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<FireBombImpulse> EnumAllFireBombImpulse() {
    foreach (var id in rootIncarnation.incarnationsFireBombImpulse.Keys) {
      yield return GetFireBombImpulse(id);
    }
  }
  public void CheckHasFireBombImpulse(FireBombImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasFireBombImpulse(thing.id);
  }
  public void CheckHasFireBombImpulse(int id) {
    if (!rootIncarnation.incarnationsFireBombImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid FireBombImpulse: " + id);
    }
  }
  public FireBombImpulse EffectFireBombImpulseCreate(
      int weight,
      Location location) {
    return TrustedEffectFireBombImpulseCreateWithId(NewId()
            ,weight
            ,location    );
  }
  public FireBombImpulse TrustedEffectFireBombImpulseCreateWithId(int id
,      int weight
,      Location location) {
    CheckUnlocked();

    var incarnation =
        new FireBombImpulseIncarnation(
            weight,
            location
            );
    return EffectInternalCreateFireBombImpulse(id, rootIncarnation.version, incarnation);
  }
  public FireBombImpulse EffectInternalCreateFireBombImpulse(
      int id,
      int incarnationVersion,
      FireBombImpulseIncarnation incarnation) {
    CheckUnlocked();
    var effect = new FireBombImpulseCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsFireBombImpulse.Add(
        id,
        new VersionAndIncarnation<FireBombImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new FireBombImpulse(this, id);
  }

  public void EffectFireBombImpulseDelete(int id) {
    CheckUnlocked();
    var effect = new FireBombImpulseDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsFireBombImpulse[id];

    rootIncarnation.incarnationsFireBombImpulse.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetFireBombImpulseHash(int id, int version, FireBombImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.location.GetDeterministicHashCode();
    return result;
  }
       public FireBombTTCIncarnation GetFireBombTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsFireBombTTC[id].incarnation;
  }
  public bool FireBombTTCExists(int id) {
    return rootIncarnation.incarnationsFireBombTTC.ContainsKey(id);
  }
  public FireBombTTC GetFireBombTTC(int id) {
    CheckHasFireBombTTC(id);
    return new FireBombTTC(this, id);
  }
  public FireBombTTC GetFireBombTTCOrNull(int id) {
    if (FireBombTTCExists(id)) {
      return new FireBombTTC(this, id);
    } else {
      return new FireBombTTC(this, 0);
    }
  }
  public List<FireBombTTC> AllFireBombTTC() {
    List<FireBombTTC> result = new List<FireBombTTC>(rootIncarnation.incarnationsFireBombTTC.Count);
    foreach (var id in rootIncarnation.incarnationsFireBombTTC.Keys) {
      result.Add(new FireBombTTC(this, id));
    }
    return result;
  }
  public IEnumerator<FireBombTTC> EnumAllFireBombTTC() {
    foreach (var id in rootIncarnation.incarnationsFireBombTTC.Keys) {
      yield return GetFireBombTTC(id);
    }
  }
  public void CheckHasFireBombTTC(FireBombTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasFireBombTTC(thing.id);
  }
  public void CheckHasFireBombTTC(int id) {
    if (!rootIncarnation.incarnationsFireBombTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid FireBombTTC: " + id);
    }
  }
  public FireBombTTC EffectFireBombTTCCreate(
      int turnsUntilExplosion) {
    return TrustedEffectFireBombTTCCreateWithId(NewId()
            ,turnsUntilExplosion    );
  }
  public FireBombTTC TrustedEffectFireBombTTCCreateWithId(int id
,      int turnsUntilExplosion) {
    CheckUnlocked();

    var incarnation =
        new FireBombTTCIncarnation(
            turnsUntilExplosion
            );
    return EffectInternalCreateFireBombTTC(id, rootIncarnation.version, incarnation);
  }
  public FireBombTTC EffectInternalCreateFireBombTTC(
      int id,
      int incarnationVersion,
      FireBombTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new FireBombTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsFireBombTTC.Add(
        id,
        new VersionAndIncarnation<FireBombTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new FireBombTTC(this, id);
  }

  public void EffectFireBombTTCDelete(int id) {
    CheckUnlocked();
    var effect = new FireBombTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsFireBombTTC[id];

    rootIncarnation.incarnationsFireBombTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetFireBombTTCHash(int id, int version, FireBombTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.turnsUntilExplosion.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectFireBombTTCSetTurnsUntilExplosion(int id, int newValue) {
    CheckUnlocked();
    CheckHasFireBombTTC(id);
var effect = new FireBombTTCSetTurnsUntilExplosionEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsFireBombTTC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.turnsUntilExplosion;
      oldIncarnationAndVersion.incarnation.turnsUntilExplosion = newValue;

    } else {
      var newIncarnation =
          new FireBombTTCIncarnation(
              newValue);
      rootIncarnation.incarnationsFireBombTTC[id] =
          new VersionAndIncarnation<FireBombTTCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }
  public MarkerTTCIncarnation GetMarkerTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsMarkerTTC[id].incarnation;
  }
  public bool MarkerTTCExists(int id) {
    return rootIncarnation.incarnationsMarkerTTC.ContainsKey(id);
  }
  public MarkerTTC GetMarkerTTC(int id) {
    CheckHasMarkerTTC(id);
    return new MarkerTTC(this, id);
  }
  public MarkerTTC GetMarkerTTCOrNull(int id) {
    if (MarkerTTCExists(id)) {
      return new MarkerTTC(this, id);
    } else {
      return new MarkerTTC(this, 0);
    }
  }
  public List<MarkerTTC> AllMarkerTTC() {
    List<MarkerTTC> result = new List<MarkerTTC>(rootIncarnation.incarnationsMarkerTTC.Count);
    foreach (var id in rootIncarnation.incarnationsMarkerTTC.Keys) {
      result.Add(new MarkerTTC(this, id));
    }
    return result;
  }
  public IEnumerator<MarkerTTC> EnumAllMarkerTTC() {
    foreach (var id in rootIncarnation.incarnationsMarkerTTC.Keys) {
      yield return GetMarkerTTC(id);
    }
  }
  public void CheckHasMarkerTTC(MarkerTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasMarkerTTC(thing.id);
  }
  public void CheckHasMarkerTTC(int id) {
    if (!rootIncarnation.incarnationsMarkerTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid MarkerTTC: " + id);
    }
  }
  public MarkerTTC EffectMarkerTTCCreate(
      string name) {
    return TrustedEffectMarkerTTCCreateWithId(NewId()
            ,name    );
  }
  public MarkerTTC TrustedEffectMarkerTTCCreateWithId(int id
,      string name) {
    CheckUnlocked();

    var incarnation =
        new MarkerTTCIncarnation(
            name
            );
    return EffectInternalCreateMarkerTTC(id, rootIncarnation.version, incarnation);
  }
  public MarkerTTC EffectInternalCreateMarkerTTC(
      int id,
      int incarnationVersion,
      MarkerTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new MarkerTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsMarkerTTC.Add(
        id,
        new VersionAndIncarnation<MarkerTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new MarkerTTC(this, id);
  }

  public void EffectMarkerTTCDelete(int id) {
    CheckUnlocked();
    var effect = new MarkerTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsMarkerTTC[id];

    rootIncarnation.incarnationsMarkerTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetMarkerTTCHash(int id, int version, MarkerTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.name.GetDeterministicHashCode();
    return result;
  }
       public LevelLinkTTCIncarnation GetLevelLinkTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsLevelLinkTTC[id].incarnation;
  }
  public bool LevelLinkTTCExists(int id) {
    return rootIncarnation.incarnationsLevelLinkTTC.ContainsKey(id);
  }
  public LevelLinkTTC GetLevelLinkTTC(int id) {
    CheckHasLevelLinkTTC(id);
    return new LevelLinkTTC(this, id);
  }
  public LevelLinkTTC GetLevelLinkTTCOrNull(int id) {
    if (LevelLinkTTCExists(id)) {
      return new LevelLinkTTC(this, id);
    } else {
      return new LevelLinkTTC(this, 0);
    }
  }
  public List<LevelLinkTTC> AllLevelLinkTTC() {
    List<LevelLinkTTC> result = new List<LevelLinkTTC>(rootIncarnation.incarnationsLevelLinkTTC.Count);
    foreach (var id in rootIncarnation.incarnationsLevelLinkTTC.Keys) {
      result.Add(new LevelLinkTTC(this, id));
    }
    return result;
  }
  public IEnumerator<LevelLinkTTC> EnumAllLevelLinkTTC() {
    foreach (var id in rootIncarnation.incarnationsLevelLinkTTC.Keys) {
      yield return GetLevelLinkTTC(id);
    }
  }
  public void CheckHasLevelLinkTTC(LevelLinkTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasLevelLinkTTC(thing.id);
  }
  public void CheckHasLevelLinkTTC(int id) {
    if (!rootIncarnation.incarnationsLevelLinkTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid LevelLinkTTC: " + id);
    }
  }
  public LevelLinkTTC EffectLevelLinkTTCCreate(
      bool destroyThisLevel,
      Level destinationLevel,
      Location destinationLevelLocation) {
    CheckHasLevel(destinationLevel);
    return TrustedEffectLevelLinkTTCCreateWithId(NewId()
            ,destroyThisLevel
            ,destinationLevel.id
            ,destinationLevelLocation    );
  }
  public LevelLinkTTC TrustedEffectLevelLinkTTCCreateWithId(int id
,      bool destroyThisLevel
,      int destinationLevel
,      Location destinationLevelLocation) {
    CheckUnlocked();

    var incarnation =
        new LevelLinkTTCIncarnation(
            destroyThisLevel,
            destinationLevel,
            destinationLevelLocation
            );
    return EffectInternalCreateLevelLinkTTC(id, rootIncarnation.version, incarnation);
  }
  public LevelLinkTTC EffectInternalCreateLevelLinkTTC(
      int id,
      int incarnationVersion,
      LevelLinkTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new LevelLinkTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsLevelLinkTTC.Add(
        id,
        new VersionAndIncarnation<LevelLinkTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new LevelLinkTTC(this, id);
  }

  public void EffectLevelLinkTTCDelete(int id) {
    CheckUnlocked();
    var effect = new LevelLinkTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsLevelLinkTTC[id];

    rootIncarnation.incarnationsLevelLinkTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetLevelLinkTTCHash(int id, int version, LevelLinkTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.destroyThisLevel.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.destinationLevel.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.destinationLevelLocation.GetDeterministicHashCode();
    return result;
  }
       public MudTTCIncarnation GetMudTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsMudTTC[id].incarnation;
  }
  public bool MudTTCExists(int id) {
    return rootIncarnation.incarnationsMudTTC.ContainsKey(id);
  }
  public MudTTC GetMudTTC(int id) {
    CheckHasMudTTC(id);
    return new MudTTC(this, id);
  }
  public MudTTC GetMudTTCOrNull(int id) {
    if (MudTTCExists(id)) {
      return new MudTTC(this, id);
    } else {
      return new MudTTC(this, 0);
    }
  }
  public List<MudTTC> AllMudTTC() {
    List<MudTTC> result = new List<MudTTC>(rootIncarnation.incarnationsMudTTC.Count);
    foreach (var id in rootIncarnation.incarnationsMudTTC.Keys) {
      result.Add(new MudTTC(this, id));
    }
    return result;
  }
  public IEnumerator<MudTTC> EnumAllMudTTC() {
    foreach (var id in rootIncarnation.incarnationsMudTTC.Keys) {
      yield return GetMudTTC(id);
    }
  }
  public void CheckHasMudTTC(MudTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasMudTTC(thing.id);
  }
  public void CheckHasMudTTC(int id) {
    if (!rootIncarnation.incarnationsMudTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid MudTTC: " + id);
    }
  }
  public MudTTC EffectMudTTCCreate(
) {
    return TrustedEffectMudTTCCreateWithId(NewId()
    );
  }
  public MudTTC TrustedEffectMudTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new MudTTCIncarnation(

            );
    return EffectInternalCreateMudTTC(id, rootIncarnation.version, incarnation);
  }
  public MudTTC EffectInternalCreateMudTTC(
      int id,
      int incarnationVersion,
      MudTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new MudTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsMudTTC.Add(
        id,
        new VersionAndIncarnation<MudTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new MudTTC(this, id);
  }

  public void EffectMudTTCDelete(int id) {
    CheckUnlocked();
    var effect = new MudTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsMudTTC[id];

    rootIncarnation.incarnationsMudTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetMudTTCHash(int id, int version, MudTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public DirtTTCIncarnation GetDirtTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsDirtTTC[id].incarnation;
  }
  public bool DirtTTCExists(int id) {
    return rootIncarnation.incarnationsDirtTTC.ContainsKey(id);
  }
  public DirtTTC GetDirtTTC(int id) {
    CheckHasDirtTTC(id);
    return new DirtTTC(this, id);
  }
  public DirtTTC GetDirtTTCOrNull(int id) {
    if (DirtTTCExists(id)) {
      return new DirtTTC(this, id);
    } else {
      return new DirtTTC(this, 0);
    }
  }
  public List<DirtTTC> AllDirtTTC() {
    List<DirtTTC> result = new List<DirtTTC>(rootIncarnation.incarnationsDirtTTC.Count);
    foreach (var id in rootIncarnation.incarnationsDirtTTC.Keys) {
      result.Add(new DirtTTC(this, id));
    }
    return result;
  }
  public IEnumerator<DirtTTC> EnumAllDirtTTC() {
    foreach (var id in rootIncarnation.incarnationsDirtTTC.Keys) {
      yield return GetDirtTTC(id);
    }
  }
  public void CheckHasDirtTTC(DirtTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasDirtTTC(thing.id);
  }
  public void CheckHasDirtTTC(int id) {
    if (!rootIncarnation.incarnationsDirtTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid DirtTTC: " + id);
    }
  }
  public DirtTTC EffectDirtTTCCreate(
) {
    return TrustedEffectDirtTTCCreateWithId(NewId()
    );
  }
  public DirtTTC TrustedEffectDirtTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new DirtTTCIncarnation(

            );
    return EffectInternalCreateDirtTTC(id, rootIncarnation.version, incarnation);
  }
  public DirtTTC EffectInternalCreateDirtTTC(
      int id,
      int incarnationVersion,
      DirtTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new DirtTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsDirtTTC.Add(
        id,
        new VersionAndIncarnation<DirtTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new DirtTTC(this, id);
  }

  public void EffectDirtTTCDelete(int id) {
    CheckUnlocked();
    var effect = new DirtTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsDirtTTC[id];

    rootIncarnation.incarnationsDirtTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetDirtTTCHash(int id, int version, DirtTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public ObsidianTTCIncarnation GetObsidianTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsObsidianTTC[id].incarnation;
  }
  public bool ObsidianTTCExists(int id) {
    return rootIncarnation.incarnationsObsidianTTC.ContainsKey(id);
  }
  public ObsidianTTC GetObsidianTTC(int id) {
    CheckHasObsidianTTC(id);
    return new ObsidianTTC(this, id);
  }
  public ObsidianTTC GetObsidianTTCOrNull(int id) {
    if (ObsidianTTCExists(id)) {
      return new ObsidianTTC(this, id);
    } else {
      return new ObsidianTTC(this, 0);
    }
  }
  public List<ObsidianTTC> AllObsidianTTC() {
    List<ObsidianTTC> result = new List<ObsidianTTC>(rootIncarnation.incarnationsObsidianTTC.Count);
    foreach (var id in rootIncarnation.incarnationsObsidianTTC.Keys) {
      result.Add(new ObsidianTTC(this, id));
    }
    return result;
  }
  public IEnumerator<ObsidianTTC> EnumAllObsidianTTC() {
    foreach (var id in rootIncarnation.incarnationsObsidianTTC.Keys) {
      yield return GetObsidianTTC(id);
    }
  }
  public void CheckHasObsidianTTC(ObsidianTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasObsidianTTC(thing.id);
  }
  public void CheckHasObsidianTTC(int id) {
    if (!rootIncarnation.incarnationsObsidianTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid ObsidianTTC: " + id);
    }
  }
  public ObsidianTTC EffectObsidianTTCCreate(
) {
    return TrustedEffectObsidianTTCCreateWithId(NewId()
    );
  }
  public ObsidianTTC TrustedEffectObsidianTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new ObsidianTTCIncarnation(

            );
    return EffectInternalCreateObsidianTTC(id, rootIncarnation.version, incarnation);
  }
  public ObsidianTTC EffectInternalCreateObsidianTTC(
      int id,
      int incarnationVersion,
      ObsidianTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new ObsidianTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsObsidianTTC.Add(
        id,
        new VersionAndIncarnation<ObsidianTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new ObsidianTTC(this, id);
  }

  public void EffectObsidianTTCDelete(int id) {
    CheckUnlocked();
    var effect = new ObsidianTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsObsidianTTC[id];

    rootIncarnation.incarnationsObsidianTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetObsidianTTCHash(int id, int version, ObsidianTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public DownStairsTTCIncarnation GetDownStairsTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsDownStairsTTC[id].incarnation;
  }
  public bool DownStairsTTCExists(int id) {
    return rootIncarnation.incarnationsDownStairsTTC.ContainsKey(id);
  }
  public DownStairsTTC GetDownStairsTTC(int id) {
    CheckHasDownStairsTTC(id);
    return new DownStairsTTC(this, id);
  }
  public DownStairsTTC GetDownStairsTTCOrNull(int id) {
    if (DownStairsTTCExists(id)) {
      return new DownStairsTTC(this, id);
    } else {
      return new DownStairsTTC(this, 0);
    }
  }
  public List<DownStairsTTC> AllDownStairsTTC() {
    List<DownStairsTTC> result = new List<DownStairsTTC>(rootIncarnation.incarnationsDownStairsTTC.Count);
    foreach (var id in rootIncarnation.incarnationsDownStairsTTC.Keys) {
      result.Add(new DownStairsTTC(this, id));
    }
    return result;
  }
  public IEnumerator<DownStairsTTC> EnumAllDownStairsTTC() {
    foreach (var id in rootIncarnation.incarnationsDownStairsTTC.Keys) {
      yield return GetDownStairsTTC(id);
    }
  }
  public void CheckHasDownStairsTTC(DownStairsTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasDownStairsTTC(thing.id);
  }
  public void CheckHasDownStairsTTC(int id) {
    if (!rootIncarnation.incarnationsDownStairsTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid DownStairsTTC: " + id);
    }
  }
  public DownStairsTTC EffectDownStairsTTCCreate(
) {
    return TrustedEffectDownStairsTTCCreateWithId(NewId()
    );
  }
  public DownStairsTTC TrustedEffectDownStairsTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new DownStairsTTCIncarnation(

            );
    return EffectInternalCreateDownStairsTTC(id, rootIncarnation.version, incarnation);
  }
  public DownStairsTTC EffectInternalCreateDownStairsTTC(
      int id,
      int incarnationVersion,
      DownStairsTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new DownStairsTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsDownStairsTTC.Add(
        id,
        new VersionAndIncarnation<DownStairsTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new DownStairsTTC(this, id);
  }

  public void EffectDownStairsTTCDelete(int id) {
    CheckUnlocked();
    var effect = new DownStairsTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsDownStairsTTC[id];

    rootIncarnation.incarnationsDownStairsTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetDownStairsTTCHash(int id, int version, DownStairsTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public UpStairsTTCIncarnation GetUpStairsTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsUpStairsTTC[id].incarnation;
  }
  public bool UpStairsTTCExists(int id) {
    return rootIncarnation.incarnationsUpStairsTTC.ContainsKey(id);
  }
  public UpStairsTTC GetUpStairsTTC(int id) {
    CheckHasUpStairsTTC(id);
    return new UpStairsTTC(this, id);
  }
  public UpStairsTTC GetUpStairsTTCOrNull(int id) {
    if (UpStairsTTCExists(id)) {
      return new UpStairsTTC(this, id);
    } else {
      return new UpStairsTTC(this, 0);
    }
  }
  public List<UpStairsTTC> AllUpStairsTTC() {
    List<UpStairsTTC> result = new List<UpStairsTTC>(rootIncarnation.incarnationsUpStairsTTC.Count);
    foreach (var id in rootIncarnation.incarnationsUpStairsTTC.Keys) {
      result.Add(new UpStairsTTC(this, id));
    }
    return result;
  }
  public IEnumerator<UpStairsTTC> EnumAllUpStairsTTC() {
    foreach (var id in rootIncarnation.incarnationsUpStairsTTC.Keys) {
      yield return GetUpStairsTTC(id);
    }
  }
  public void CheckHasUpStairsTTC(UpStairsTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasUpStairsTTC(thing.id);
  }
  public void CheckHasUpStairsTTC(int id) {
    if (!rootIncarnation.incarnationsUpStairsTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid UpStairsTTC: " + id);
    }
  }
  public UpStairsTTC EffectUpStairsTTCCreate(
) {
    return TrustedEffectUpStairsTTCCreateWithId(NewId()
    );
  }
  public UpStairsTTC TrustedEffectUpStairsTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new UpStairsTTCIncarnation(

            );
    return EffectInternalCreateUpStairsTTC(id, rootIncarnation.version, incarnation);
  }
  public UpStairsTTC EffectInternalCreateUpStairsTTC(
      int id,
      int incarnationVersion,
      UpStairsTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new UpStairsTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsUpStairsTTC.Add(
        id,
        new VersionAndIncarnation<UpStairsTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new UpStairsTTC(this, id);
  }

  public void EffectUpStairsTTCDelete(int id) {
    CheckUnlocked();
    var effect = new UpStairsTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsUpStairsTTC[id];

    rootIncarnation.incarnationsUpStairsTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetUpStairsTTCHash(int id, int version, UpStairsTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public WallTTCIncarnation GetWallTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsWallTTC[id].incarnation;
  }
  public bool WallTTCExists(int id) {
    return rootIncarnation.incarnationsWallTTC.ContainsKey(id);
  }
  public WallTTC GetWallTTC(int id) {
    CheckHasWallTTC(id);
    return new WallTTC(this, id);
  }
  public WallTTC GetWallTTCOrNull(int id) {
    if (WallTTCExists(id)) {
      return new WallTTC(this, id);
    } else {
      return new WallTTC(this, 0);
    }
  }
  public List<WallTTC> AllWallTTC() {
    List<WallTTC> result = new List<WallTTC>(rootIncarnation.incarnationsWallTTC.Count);
    foreach (var id in rootIncarnation.incarnationsWallTTC.Keys) {
      result.Add(new WallTTC(this, id));
    }
    return result;
  }
  public IEnumerator<WallTTC> EnumAllWallTTC() {
    foreach (var id in rootIncarnation.incarnationsWallTTC.Keys) {
      yield return GetWallTTC(id);
    }
  }
  public void CheckHasWallTTC(WallTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasWallTTC(thing.id);
  }
  public void CheckHasWallTTC(int id) {
    if (!rootIncarnation.incarnationsWallTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid WallTTC: " + id);
    }
  }
  public WallTTC EffectWallTTCCreate(
) {
    return TrustedEffectWallTTCCreateWithId(NewId()
    );
  }
  public WallTTC TrustedEffectWallTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new WallTTCIncarnation(

            );
    return EffectInternalCreateWallTTC(id, rootIncarnation.version, incarnation);
  }
  public WallTTC EffectInternalCreateWallTTC(
      int id,
      int incarnationVersion,
      WallTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new WallTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsWallTTC.Add(
        id,
        new VersionAndIncarnation<WallTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new WallTTC(this, id);
  }

  public void EffectWallTTCDelete(int id) {
    CheckUnlocked();
    var effect = new WallTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsWallTTC[id];

    rootIncarnation.incarnationsWallTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetWallTTCHash(int id, int version, WallTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public BloodTTCIncarnation GetBloodTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBloodTTC[id].incarnation;
  }
  public bool BloodTTCExists(int id) {
    return rootIncarnation.incarnationsBloodTTC.ContainsKey(id);
  }
  public BloodTTC GetBloodTTC(int id) {
    CheckHasBloodTTC(id);
    return new BloodTTC(this, id);
  }
  public BloodTTC GetBloodTTCOrNull(int id) {
    if (BloodTTCExists(id)) {
      return new BloodTTC(this, id);
    } else {
      return new BloodTTC(this, 0);
    }
  }
  public List<BloodTTC> AllBloodTTC() {
    List<BloodTTC> result = new List<BloodTTC>(rootIncarnation.incarnationsBloodTTC.Count);
    foreach (var id in rootIncarnation.incarnationsBloodTTC.Keys) {
      result.Add(new BloodTTC(this, id));
    }
    return result;
  }
  public IEnumerator<BloodTTC> EnumAllBloodTTC() {
    foreach (var id in rootIncarnation.incarnationsBloodTTC.Keys) {
      yield return GetBloodTTC(id);
    }
  }
  public void CheckHasBloodTTC(BloodTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBloodTTC(thing.id);
  }
  public void CheckHasBloodTTC(int id) {
    if (!rootIncarnation.incarnationsBloodTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid BloodTTC: " + id);
    }
  }
  public BloodTTC EffectBloodTTCCreate(
) {
    return TrustedEffectBloodTTCCreateWithId(NewId()
    );
  }
  public BloodTTC TrustedEffectBloodTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new BloodTTCIncarnation(

            );
    return EffectInternalCreateBloodTTC(id, rootIncarnation.version, incarnation);
  }
  public BloodTTC EffectInternalCreateBloodTTC(
      int id,
      int incarnationVersion,
      BloodTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new BloodTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsBloodTTC.Add(
        id,
        new VersionAndIncarnation<BloodTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new BloodTTC(this, id);
  }

  public void EffectBloodTTCDelete(int id) {
    CheckUnlocked();
    var effect = new BloodTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBloodTTC[id];

    rootIncarnation.incarnationsBloodTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetBloodTTCHash(int id, int version, BloodTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public RocksTTCIncarnation GetRocksTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsRocksTTC[id].incarnation;
  }
  public bool RocksTTCExists(int id) {
    return rootIncarnation.incarnationsRocksTTC.ContainsKey(id);
  }
  public RocksTTC GetRocksTTC(int id) {
    CheckHasRocksTTC(id);
    return new RocksTTC(this, id);
  }
  public RocksTTC GetRocksTTCOrNull(int id) {
    if (RocksTTCExists(id)) {
      return new RocksTTC(this, id);
    } else {
      return new RocksTTC(this, 0);
    }
  }
  public List<RocksTTC> AllRocksTTC() {
    List<RocksTTC> result = new List<RocksTTC>(rootIncarnation.incarnationsRocksTTC.Count);
    foreach (var id in rootIncarnation.incarnationsRocksTTC.Keys) {
      result.Add(new RocksTTC(this, id));
    }
    return result;
  }
  public IEnumerator<RocksTTC> EnumAllRocksTTC() {
    foreach (var id in rootIncarnation.incarnationsRocksTTC.Keys) {
      yield return GetRocksTTC(id);
    }
  }
  public void CheckHasRocksTTC(RocksTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasRocksTTC(thing.id);
  }
  public void CheckHasRocksTTC(int id) {
    if (!rootIncarnation.incarnationsRocksTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid RocksTTC: " + id);
    }
  }
  public RocksTTC EffectRocksTTCCreate(
) {
    return TrustedEffectRocksTTCCreateWithId(NewId()
    );
  }
  public RocksTTC TrustedEffectRocksTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new RocksTTCIncarnation(

            );
    return EffectInternalCreateRocksTTC(id, rootIncarnation.version, incarnation);
  }
  public RocksTTC EffectInternalCreateRocksTTC(
      int id,
      int incarnationVersion,
      RocksTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new RocksTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsRocksTTC.Add(
        id,
        new VersionAndIncarnation<RocksTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new RocksTTC(this, id);
  }

  public void EffectRocksTTCDelete(int id) {
    CheckUnlocked();
    var effect = new RocksTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsRocksTTC[id];

    rootIncarnation.incarnationsRocksTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetRocksTTCHash(int id, int version, RocksTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public TreeTTCIncarnation GetTreeTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTreeTTC[id].incarnation;
  }
  public bool TreeTTCExists(int id) {
    return rootIncarnation.incarnationsTreeTTC.ContainsKey(id);
  }
  public TreeTTC GetTreeTTC(int id) {
    CheckHasTreeTTC(id);
    return new TreeTTC(this, id);
  }
  public TreeTTC GetTreeTTCOrNull(int id) {
    if (TreeTTCExists(id)) {
      return new TreeTTC(this, id);
    } else {
      return new TreeTTC(this, 0);
    }
  }
  public List<TreeTTC> AllTreeTTC() {
    List<TreeTTC> result = new List<TreeTTC>(rootIncarnation.incarnationsTreeTTC.Count);
    foreach (var id in rootIncarnation.incarnationsTreeTTC.Keys) {
      result.Add(new TreeTTC(this, id));
    }
    return result;
  }
  public IEnumerator<TreeTTC> EnumAllTreeTTC() {
    foreach (var id in rootIncarnation.incarnationsTreeTTC.Keys) {
      yield return GetTreeTTC(id);
    }
  }
  public void CheckHasTreeTTC(TreeTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTreeTTC(thing.id);
  }
  public void CheckHasTreeTTC(int id) {
    if (!rootIncarnation.incarnationsTreeTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid TreeTTC: " + id);
    }
  }
  public TreeTTC EffectTreeTTCCreate(
) {
    return TrustedEffectTreeTTCCreateWithId(NewId()
    );
  }
  public TreeTTC TrustedEffectTreeTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new TreeTTCIncarnation(

            );
    return EffectInternalCreateTreeTTC(id, rootIncarnation.version, incarnation);
  }
  public TreeTTC EffectInternalCreateTreeTTC(
      int id,
      int incarnationVersion,
      TreeTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new TreeTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsTreeTTC.Add(
        id,
        new VersionAndIncarnation<TreeTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new TreeTTC(this, id);
  }

  public void EffectTreeTTCDelete(int id) {
    CheckUnlocked();
    var effect = new TreeTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTreeTTC[id];

    rootIncarnation.incarnationsTreeTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetTreeTTCHash(int id, int version, TreeTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public WaterTTCIncarnation GetWaterTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsWaterTTC[id].incarnation;
  }
  public bool WaterTTCExists(int id) {
    return rootIncarnation.incarnationsWaterTTC.ContainsKey(id);
  }
  public WaterTTC GetWaterTTC(int id) {
    CheckHasWaterTTC(id);
    return new WaterTTC(this, id);
  }
  public WaterTTC GetWaterTTCOrNull(int id) {
    if (WaterTTCExists(id)) {
      return new WaterTTC(this, id);
    } else {
      return new WaterTTC(this, 0);
    }
  }
  public List<WaterTTC> AllWaterTTC() {
    List<WaterTTC> result = new List<WaterTTC>(rootIncarnation.incarnationsWaterTTC.Count);
    foreach (var id in rootIncarnation.incarnationsWaterTTC.Keys) {
      result.Add(new WaterTTC(this, id));
    }
    return result;
  }
  public IEnumerator<WaterTTC> EnumAllWaterTTC() {
    foreach (var id in rootIncarnation.incarnationsWaterTTC.Keys) {
      yield return GetWaterTTC(id);
    }
  }
  public void CheckHasWaterTTC(WaterTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasWaterTTC(thing.id);
  }
  public void CheckHasWaterTTC(int id) {
    if (!rootIncarnation.incarnationsWaterTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid WaterTTC: " + id);
    }
  }
  public WaterTTC EffectWaterTTCCreate(
) {
    return TrustedEffectWaterTTCCreateWithId(NewId()
    );
  }
  public WaterTTC TrustedEffectWaterTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new WaterTTCIncarnation(

            );
    return EffectInternalCreateWaterTTC(id, rootIncarnation.version, incarnation);
  }
  public WaterTTC EffectInternalCreateWaterTTC(
      int id,
      int incarnationVersion,
      WaterTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new WaterTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsWaterTTC.Add(
        id,
        new VersionAndIncarnation<WaterTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new WaterTTC(this, id);
  }

  public void EffectWaterTTCDelete(int id) {
    CheckUnlocked();
    var effect = new WaterTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsWaterTTC[id];

    rootIncarnation.incarnationsWaterTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetWaterTTCHash(int id, int version, WaterTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public FloorTTCIncarnation GetFloorTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsFloorTTC[id].incarnation;
  }
  public bool FloorTTCExists(int id) {
    return rootIncarnation.incarnationsFloorTTC.ContainsKey(id);
  }
  public FloorTTC GetFloorTTC(int id) {
    CheckHasFloorTTC(id);
    return new FloorTTC(this, id);
  }
  public FloorTTC GetFloorTTCOrNull(int id) {
    if (FloorTTCExists(id)) {
      return new FloorTTC(this, id);
    } else {
      return new FloorTTC(this, 0);
    }
  }
  public List<FloorTTC> AllFloorTTC() {
    List<FloorTTC> result = new List<FloorTTC>(rootIncarnation.incarnationsFloorTTC.Count);
    foreach (var id in rootIncarnation.incarnationsFloorTTC.Keys) {
      result.Add(new FloorTTC(this, id));
    }
    return result;
  }
  public IEnumerator<FloorTTC> EnumAllFloorTTC() {
    foreach (var id in rootIncarnation.incarnationsFloorTTC.Keys) {
      yield return GetFloorTTC(id);
    }
  }
  public void CheckHasFloorTTC(FloorTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasFloorTTC(thing.id);
  }
  public void CheckHasFloorTTC(int id) {
    if (!rootIncarnation.incarnationsFloorTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid FloorTTC: " + id);
    }
  }
  public FloorTTC EffectFloorTTCCreate(
) {
    return TrustedEffectFloorTTCCreateWithId(NewId()
    );
  }
  public FloorTTC TrustedEffectFloorTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new FloorTTCIncarnation(

            );
    return EffectInternalCreateFloorTTC(id, rootIncarnation.version, incarnation);
  }
  public FloorTTC EffectInternalCreateFloorTTC(
      int id,
      int incarnationVersion,
      FloorTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new FloorTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsFloorTTC.Add(
        id,
        new VersionAndIncarnation<FloorTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new FloorTTC(this, id);
  }

  public void EffectFloorTTCDelete(int id) {
    CheckUnlocked();
    var effect = new FloorTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsFloorTTC[id];

    rootIncarnation.incarnationsFloorTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetFloorTTCHash(int id, int version, FloorTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public CaveWallTTCIncarnation GetCaveWallTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCaveWallTTC[id].incarnation;
  }
  public bool CaveWallTTCExists(int id) {
    return rootIncarnation.incarnationsCaveWallTTC.ContainsKey(id);
  }
  public CaveWallTTC GetCaveWallTTC(int id) {
    CheckHasCaveWallTTC(id);
    return new CaveWallTTC(this, id);
  }
  public CaveWallTTC GetCaveWallTTCOrNull(int id) {
    if (CaveWallTTCExists(id)) {
      return new CaveWallTTC(this, id);
    } else {
      return new CaveWallTTC(this, 0);
    }
  }
  public List<CaveWallTTC> AllCaveWallTTC() {
    List<CaveWallTTC> result = new List<CaveWallTTC>(rootIncarnation.incarnationsCaveWallTTC.Count);
    foreach (var id in rootIncarnation.incarnationsCaveWallTTC.Keys) {
      result.Add(new CaveWallTTC(this, id));
    }
    return result;
  }
  public IEnumerator<CaveWallTTC> EnumAllCaveWallTTC() {
    foreach (var id in rootIncarnation.incarnationsCaveWallTTC.Keys) {
      yield return GetCaveWallTTC(id);
    }
  }
  public void CheckHasCaveWallTTC(CaveWallTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCaveWallTTC(thing.id);
  }
  public void CheckHasCaveWallTTC(int id) {
    if (!rootIncarnation.incarnationsCaveWallTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid CaveWallTTC: " + id);
    }
  }
  public CaveWallTTC EffectCaveWallTTCCreate(
) {
    return TrustedEffectCaveWallTTCCreateWithId(NewId()
    );
  }
  public CaveWallTTC TrustedEffectCaveWallTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new CaveWallTTCIncarnation(

            );
    return EffectInternalCreateCaveWallTTC(id, rootIncarnation.version, incarnation);
  }
  public CaveWallTTC EffectInternalCreateCaveWallTTC(
      int id,
      int incarnationVersion,
      CaveWallTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new CaveWallTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsCaveWallTTC.Add(
        id,
        new VersionAndIncarnation<CaveWallTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new CaveWallTTC(this, id);
  }

  public void EffectCaveWallTTCDelete(int id) {
    CheckUnlocked();
    var effect = new CaveWallTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCaveWallTTC[id];

    rootIncarnation.incarnationsCaveWallTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetCaveWallTTCHash(int id, int version, CaveWallTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public CaveTTCIncarnation GetCaveTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCaveTTC[id].incarnation;
  }
  public bool CaveTTCExists(int id) {
    return rootIncarnation.incarnationsCaveTTC.ContainsKey(id);
  }
  public CaveTTC GetCaveTTC(int id) {
    CheckHasCaveTTC(id);
    return new CaveTTC(this, id);
  }
  public CaveTTC GetCaveTTCOrNull(int id) {
    if (CaveTTCExists(id)) {
      return new CaveTTC(this, id);
    } else {
      return new CaveTTC(this, 0);
    }
  }
  public List<CaveTTC> AllCaveTTC() {
    List<CaveTTC> result = new List<CaveTTC>(rootIncarnation.incarnationsCaveTTC.Count);
    foreach (var id in rootIncarnation.incarnationsCaveTTC.Keys) {
      result.Add(new CaveTTC(this, id));
    }
    return result;
  }
  public IEnumerator<CaveTTC> EnumAllCaveTTC() {
    foreach (var id in rootIncarnation.incarnationsCaveTTC.Keys) {
      yield return GetCaveTTC(id);
    }
  }
  public void CheckHasCaveTTC(CaveTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCaveTTC(thing.id);
  }
  public void CheckHasCaveTTC(int id) {
    if (!rootIncarnation.incarnationsCaveTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid CaveTTC: " + id);
    }
  }
  public CaveTTC EffectCaveTTCCreate(
) {
    return TrustedEffectCaveTTCCreateWithId(NewId()
    );
  }
  public CaveTTC TrustedEffectCaveTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new CaveTTCIncarnation(

            );
    return EffectInternalCreateCaveTTC(id, rootIncarnation.version, incarnation);
  }
  public CaveTTC EffectInternalCreateCaveTTC(
      int id,
      int incarnationVersion,
      CaveTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new CaveTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsCaveTTC.Add(
        id,
        new VersionAndIncarnation<CaveTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new CaveTTC(this, id);
  }

  public void EffectCaveTTCDelete(int id) {
    CheckUnlocked();
    var effect = new CaveTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCaveTTC[id];

    rootIncarnation.incarnationsCaveTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetCaveTTCHash(int id, int version, CaveTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public FallsTTCIncarnation GetFallsTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsFallsTTC[id].incarnation;
  }
  public bool FallsTTCExists(int id) {
    return rootIncarnation.incarnationsFallsTTC.ContainsKey(id);
  }
  public FallsTTC GetFallsTTC(int id) {
    CheckHasFallsTTC(id);
    return new FallsTTC(this, id);
  }
  public FallsTTC GetFallsTTCOrNull(int id) {
    if (FallsTTCExists(id)) {
      return new FallsTTC(this, id);
    } else {
      return new FallsTTC(this, 0);
    }
  }
  public List<FallsTTC> AllFallsTTC() {
    List<FallsTTC> result = new List<FallsTTC>(rootIncarnation.incarnationsFallsTTC.Count);
    foreach (var id in rootIncarnation.incarnationsFallsTTC.Keys) {
      result.Add(new FallsTTC(this, id));
    }
    return result;
  }
  public IEnumerator<FallsTTC> EnumAllFallsTTC() {
    foreach (var id in rootIncarnation.incarnationsFallsTTC.Keys) {
      yield return GetFallsTTC(id);
    }
  }
  public void CheckHasFallsTTC(FallsTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasFallsTTC(thing.id);
  }
  public void CheckHasFallsTTC(int id) {
    if (!rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid FallsTTC: " + id);
    }
  }
  public FallsTTC EffectFallsTTCCreate(
) {
    return TrustedEffectFallsTTCCreateWithId(NewId()
    );
  }
  public FallsTTC TrustedEffectFallsTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new FallsTTCIncarnation(

            );
    return EffectInternalCreateFallsTTC(id, rootIncarnation.version, incarnation);
  }
  public FallsTTC EffectInternalCreateFallsTTC(
      int id,
      int incarnationVersion,
      FallsTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new FallsTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsFallsTTC.Add(
        id,
        new VersionAndIncarnation<FallsTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new FallsTTC(this, id);
  }

  public void EffectFallsTTCDelete(int id) {
    CheckUnlocked();
    var effect = new FallsTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsFallsTTC[id];

    rootIncarnation.incarnationsFallsTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetFallsTTCHash(int id, int version, FallsTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public FireTTCIncarnation GetFireTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsFireTTC[id].incarnation;
  }
  public bool FireTTCExists(int id) {
    return rootIncarnation.incarnationsFireTTC.ContainsKey(id);
  }
  public FireTTC GetFireTTC(int id) {
    CheckHasFireTTC(id);
    return new FireTTC(this, id);
  }
  public FireTTC GetFireTTCOrNull(int id) {
    if (FireTTCExists(id)) {
      return new FireTTC(this, id);
    } else {
      return new FireTTC(this, 0);
    }
  }
  public List<FireTTC> AllFireTTC() {
    List<FireTTC> result = new List<FireTTC>(rootIncarnation.incarnationsFireTTC.Count);
    foreach (var id in rootIncarnation.incarnationsFireTTC.Keys) {
      result.Add(new FireTTC(this, id));
    }
    return result;
  }
  public IEnumerator<FireTTC> EnumAllFireTTC() {
    foreach (var id in rootIncarnation.incarnationsFireTTC.Keys) {
      yield return GetFireTTC(id);
    }
  }
  public void CheckHasFireTTC(FireTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasFireTTC(thing.id);
  }
  public void CheckHasFireTTC(int id) {
    if (!rootIncarnation.incarnationsFireTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid FireTTC: " + id);
    }
  }
  public FireTTC EffectFireTTCCreate(
) {
    return TrustedEffectFireTTCCreateWithId(NewId()
    );
  }
  public FireTTC TrustedEffectFireTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new FireTTCIncarnation(

            );
    return EffectInternalCreateFireTTC(id, rootIncarnation.version, incarnation);
  }
  public FireTTC EffectInternalCreateFireTTC(
      int id,
      int incarnationVersion,
      FireTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new FireTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsFireTTC.Add(
        id,
        new VersionAndIncarnation<FireTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new FireTTC(this, id);
  }

  public void EffectFireTTCDelete(int id) {
    CheckUnlocked();
    var effect = new FireTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsFireTTC[id];

    rootIncarnation.incarnationsFireTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetFireTTCHash(int id, int version, FireTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public ObsidianFloorTTCIncarnation GetObsidianFloorTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsObsidianFloorTTC[id].incarnation;
  }
  public bool ObsidianFloorTTCExists(int id) {
    return rootIncarnation.incarnationsObsidianFloorTTC.ContainsKey(id);
  }
  public ObsidianFloorTTC GetObsidianFloorTTC(int id) {
    CheckHasObsidianFloorTTC(id);
    return new ObsidianFloorTTC(this, id);
  }
  public ObsidianFloorTTC GetObsidianFloorTTCOrNull(int id) {
    if (ObsidianFloorTTCExists(id)) {
      return new ObsidianFloorTTC(this, id);
    } else {
      return new ObsidianFloorTTC(this, 0);
    }
  }
  public List<ObsidianFloorTTC> AllObsidianFloorTTC() {
    List<ObsidianFloorTTC> result = new List<ObsidianFloorTTC>(rootIncarnation.incarnationsObsidianFloorTTC.Count);
    foreach (var id in rootIncarnation.incarnationsObsidianFloorTTC.Keys) {
      result.Add(new ObsidianFloorTTC(this, id));
    }
    return result;
  }
  public IEnumerator<ObsidianFloorTTC> EnumAllObsidianFloorTTC() {
    foreach (var id in rootIncarnation.incarnationsObsidianFloorTTC.Keys) {
      yield return GetObsidianFloorTTC(id);
    }
  }
  public void CheckHasObsidianFloorTTC(ObsidianFloorTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasObsidianFloorTTC(thing.id);
  }
  public void CheckHasObsidianFloorTTC(int id) {
    if (!rootIncarnation.incarnationsObsidianFloorTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid ObsidianFloorTTC: " + id);
    }
  }
  public ObsidianFloorTTC EffectObsidianFloorTTCCreate(
) {
    return TrustedEffectObsidianFloorTTCCreateWithId(NewId()
    );
  }
  public ObsidianFloorTTC TrustedEffectObsidianFloorTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new ObsidianFloorTTCIncarnation(

            );
    return EffectInternalCreateObsidianFloorTTC(id, rootIncarnation.version, incarnation);
  }
  public ObsidianFloorTTC EffectInternalCreateObsidianFloorTTC(
      int id,
      int incarnationVersion,
      ObsidianFloorTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new ObsidianFloorTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsObsidianFloorTTC.Add(
        id,
        new VersionAndIncarnation<ObsidianFloorTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new ObsidianFloorTTC(this, id);
  }

  public void EffectObsidianFloorTTCDelete(int id) {
    CheckUnlocked();
    var effect = new ObsidianFloorTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsObsidianFloorTTC[id];

    rootIncarnation.incarnationsObsidianFloorTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetObsidianFloorTTCHash(int id, int version, ObsidianFloorTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public MagmaTTCIncarnation GetMagmaTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsMagmaTTC[id].incarnation;
  }
  public bool MagmaTTCExists(int id) {
    return rootIncarnation.incarnationsMagmaTTC.ContainsKey(id);
  }
  public MagmaTTC GetMagmaTTC(int id) {
    CheckHasMagmaTTC(id);
    return new MagmaTTC(this, id);
  }
  public MagmaTTC GetMagmaTTCOrNull(int id) {
    if (MagmaTTCExists(id)) {
      return new MagmaTTC(this, id);
    } else {
      return new MagmaTTC(this, 0);
    }
  }
  public List<MagmaTTC> AllMagmaTTC() {
    List<MagmaTTC> result = new List<MagmaTTC>(rootIncarnation.incarnationsMagmaTTC.Count);
    foreach (var id in rootIncarnation.incarnationsMagmaTTC.Keys) {
      result.Add(new MagmaTTC(this, id));
    }
    return result;
  }
  public IEnumerator<MagmaTTC> EnumAllMagmaTTC() {
    foreach (var id in rootIncarnation.incarnationsMagmaTTC.Keys) {
      yield return GetMagmaTTC(id);
    }
  }
  public void CheckHasMagmaTTC(MagmaTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasMagmaTTC(thing.id);
  }
  public void CheckHasMagmaTTC(int id) {
    if (!rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid MagmaTTC: " + id);
    }
  }
  public MagmaTTC EffectMagmaTTCCreate(
) {
    return TrustedEffectMagmaTTCCreateWithId(NewId()
    );
  }
  public MagmaTTC TrustedEffectMagmaTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new MagmaTTCIncarnation(

            );
    return EffectInternalCreateMagmaTTC(id, rootIncarnation.version, incarnation);
  }
  public MagmaTTC EffectInternalCreateMagmaTTC(
      int id,
      int incarnationVersion,
      MagmaTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new MagmaTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsMagmaTTC.Add(
        id,
        new VersionAndIncarnation<MagmaTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new MagmaTTC(this, id);
  }

  public void EffectMagmaTTCDelete(int id) {
    CheckUnlocked();
    var effect = new MagmaTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsMagmaTTC[id];

    rootIncarnation.incarnationsMagmaTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetMagmaTTCHash(int id, int version, MagmaTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public CliffTTCIncarnation GetCliffTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCliffTTC[id].incarnation;
  }
  public bool CliffTTCExists(int id) {
    return rootIncarnation.incarnationsCliffTTC.ContainsKey(id);
  }
  public CliffTTC GetCliffTTC(int id) {
    CheckHasCliffTTC(id);
    return new CliffTTC(this, id);
  }
  public CliffTTC GetCliffTTCOrNull(int id) {
    if (CliffTTCExists(id)) {
      return new CliffTTC(this, id);
    } else {
      return new CliffTTC(this, 0);
    }
  }
  public List<CliffTTC> AllCliffTTC() {
    List<CliffTTC> result = new List<CliffTTC>(rootIncarnation.incarnationsCliffTTC.Count);
    foreach (var id in rootIncarnation.incarnationsCliffTTC.Keys) {
      result.Add(new CliffTTC(this, id));
    }
    return result;
  }
  public IEnumerator<CliffTTC> EnumAllCliffTTC() {
    foreach (var id in rootIncarnation.incarnationsCliffTTC.Keys) {
      yield return GetCliffTTC(id);
    }
  }
  public void CheckHasCliffTTC(CliffTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCliffTTC(thing.id);
  }
  public void CheckHasCliffTTC(int id) {
    if (!rootIncarnation.incarnationsCliffTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid CliffTTC: " + id);
    }
  }
  public CliffTTC EffectCliffTTCCreate(
) {
    return TrustedEffectCliffTTCCreateWithId(NewId()
    );
  }
  public CliffTTC TrustedEffectCliffTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new CliffTTCIncarnation(

            );
    return EffectInternalCreateCliffTTC(id, rootIncarnation.version, incarnation);
  }
  public CliffTTC EffectInternalCreateCliffTTC(
      int id,
      int incarnationVersion,
      CliffTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new CliffTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsCliffTTC.Add(
        id,
        new VersionAndIncarnation<CliffTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new CliffTTC(this, id);
  }

  public void EffectCliffTTCDelete(int id) {
    CheckUnlocked();
    var effect = new CliffTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCliffTTC[id];

    rootIncarnation.incarnationsCliffTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetCliffTTCHash(int id, int version, CliffTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public RavaNestTTCIncarnation GetRavaNestTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsRavaNestTTC[id].incarnation;
  }
  public bool RavaNestTTCExists(int id) {
    return rootIncarnation.incarnationsRavaNestTTC.ContainsKey(id);
  }
  public RavaNestTTC GetRavaNestTTC(int id) {
    CheckHasRavaNestTTC(id);
    return new RavaNestTTC(this, id);
  }
  public RavaNestTTC GetRavaNestTTCOrNull(int id) {
    if (RavaNestTTCExists(id)) {
      return new RavaNestTTC(this, id);
    } else {
      return new RavaNestTTC(this, 0);
    }
  }
  public List<RavaNestTTC> AllRavaNestTTC() {
    List<RavaNestTTC> result = new List<RavaNestTTC>(rootIncarnation.incarnationsRavaNestTTC.Count);
    foreach (var id in rootIncarnation.incarnationsRavaNestTTC.Keys) {
      result.Add(new RavaNestTTC(this, id));
    }
    return result;
  }
  public IEnumerator<RavaNestTTC> EnumAllRavaNestTTC() {
    foreach (var id in rootIncarnation.incarnationsRavaNestTTC.Keys) {
      yield return GetRavaNestTTC(id);
    }
  }
  public void CheckHasRavaNestTTC(RavaNestTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasRavaNestTTC(thing.id);
  }
  public void CheckHasRavaNestTTC(int id) {
    if (!rootIncarnation.incarnationsRavaNestTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid RavaNestTTC: " + id);
    }
  }
  public RavaNestTTC EffectRavaNestTTCCreate(
) {
    return TrustedEffectRavaNestTTCCreateWithId(NewId()
    );
  }
  public RavaNestTTC TrustedEffectRavaNestTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new RavaNestTTCIncarnation(

            );
    return EffectInternalCreateRavaNestTTC(id, rootIncarnation.version, incarnation);
  }
  public RavaNestTTC EffectInternalCreateRavaNestTTC(
      int id,
      int incarnationVersion,
      RavaNestTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new RavaNestTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsRavaNestTTC.Add(
        id,
        new VersionAndIncarnation<RavaNestTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new RavaNestTTC(this, id);
  }

  public void EffectRavaNestTTCDelete(int id) {
    CheckUnlocked();
    var effect = new RavaNestTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsRavaNestTTC[id];

    rootIncarnation.incarnationsRavaNestTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetRavaNestTTCHash(int id, int version, RavaNestTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public CliffLandingTTCIncarnation GetCliffLandingTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCliffLandingTTC[id].incarnation;
  }
  public bool CliffLandingTTCExists(int id) {
    return rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(id);
  }
  public CliffLandingTTC GetCliffLandingTTC(int id) {
    CheckHasCliffLandingTTC(id);
    return new CliffLandingTTC(this, id);
  }
  public CliffLandingTTC GetCliffLandingTTCOrNull(int id) {
    if (CliffLandingTTCExists(id)) {
      return new CliffLandingTTC(this, id);
    } else {
      return new CliffLandingTTC(this, 0);
    }
  }
  public List<CliffLandingTTC> AllCliffLandingTTC() {
    List<CliffLandingTTC> result = new List<CliffLandingTTC>(rootIncarnation.incarnationsCliffLandingTTC.Count);
    foreach (var id in rootIncarnation.incarnationsCliffLandingTTC.Keys) {
      result.Add(new CliffLandingTTC(this, id));
    }
    return result;
  }
  public IEnumerator<CliffLandingTTC> EnumAllCliffLandingTTC() {
    foreach (var id in rootIncarnation.incarnationsCliffLandingTTC.Keys) {
      yield return GetCliffLandingTTC(id);
    }
  }
  public void CheckHasCliffLandingTTC(CliffLandingTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCliffLandingTTC(thing.id);
  }
  public void CheckHasCliffLandingTTC(int id) {
    if (!rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid CliffLandingTTC: " + id);
    }
  }
  public CliffLandingTTC EffectCliffLandingTTCCreate(
) {
    return TrustedEffectCliffLandingTTCCreateWithId(NewId()
    );
  }
  public CliffLandingTTC TrustedEffectCliffLandingTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new CliffLandingTTCIncarnation(

            );
    return EffectInternalCreateCliffLandingTTC(id, rootIncarnation.version, incarnation);
  }
  public CliffLandingTTC EffectInternalCreateCliffLandingTTC(
      int id,
      int incarnationVersion,
      CliffLandingTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new CliffLandingTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsCliffLandingTTC.Add(
        id,
        new VersionAndIncarnation<CliffLandingTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new CliffLandingTTC(this, id);
  }

  public void EffectCliffLandingTTCDelete(int id) {
    CheckUnlocked();
    var effect = new CliffLandingTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCliffLandingTTC[id];

    rootIncarnation.incarnationsCliffLandingTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetCliffLandingTTCHash(int id, int version, CliffLandingTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public StoneTTCIncarnation GetStoneTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsStoneTTC[id].incarnation;
  }
  public bool StoneTTCExists(int id) {
    return rootIncarnation.incarnationsStoneTTC.ContainsKey(id);
  }
  public StoneTTC GetStoneTTC(int id) {
    CheckHasStoneTTC(id);
    return new StoneTTC(this, id);
  }
  public StoneTTC GetStoneTTCOrNull(int id) {
    if (StoneTTCExists(id)) {
      return new StoneTTC(this, id);
    } else {
      return new StoneTTC(this, 0);
    }
  }
  public List<StoneTTC> AllStoneTTC() {
    List<StoneTTC> result = new List<StoneTTC>(rootIncarnation.incarnationsStoneTTC.Count);
    foreach (var id in rootIncarnation.incarnationsStoneTTC.Keys) {
      result.Add(new StoneTTC(this, id));
    }
    return result;
  }
  public IEnumerator<StoneTTC> EnumAllStoneTTC() {
    foreach (var id in rootIncarnation.incarnationsStoneTTC.Keys) {
      yield return GetStoneTTC(id);
    }
  }
  public void CheckHasStoneTTC(StoneTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasStoneTTC(thing.id);
  }
  public void CheckHasStoneTTC(int id) {
    if (!rootIncarnation.incarnationsStoneTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid StoneTTC: " + id);
    }
  }
  public StoneTTC EffectStoneTTCCreate(
) {
    return TrustedEffectStoneTTCCreateWithId(NewId()
    );
  }
  public StoneTTC TrustedEffectStoneTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new StoneTTCIncarnation(

            );
    return EffectInternalCreateStoneTTC(id, rootIncarnation.version, incarnation);
  }
  public StoneTTC EffectInternalCreateStoneTTC(
      int id,
      int incarnationVersion,
      StoneTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new StoneTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsStoneTTC.Add(
        id,
        new VersionAndIncarnation<StoneTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new StoneTTC(this, id);
  }

  public void EffectStoneTTCDelete(int id) {
    CheckUnlocked();
    var effect = new StoneTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsStoneTTC[id];

    rootIncarnation.incarnationsStoneTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetStoneTTCHash(int id, int version, StoneTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public GrassTTCIncarnation GetGrassTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsGrassTTC[id].incarnation;
  }
  public bool GrassTTCExists(int id) {
    return rootIncarnation.incarnationsGrassTTC.ContainsKey(id);
  }
  public GrassTTC GetGrassTTC(int id) {
    CheckHasGrassTTC(id);
    return new GrassTTC(this, id);
  }
  public GrassTTC GetGrassTTCOrNull(int id) {
    if (GrassTTCExists(id)) {
      return new GrassTTC(this, id);
    } else {
      return new GrassTTC(this, 0);
    }
  }
  public List<GrassTTC> AllGrassTTC() {
    List<GrassTTC> result = new List<GrassTTC>(rootIncarnation.incarnationsGrassTTC.Count);
    foreach (var id in rootIncarnation.incarnationsGrassTTC.Keys) {
      result.Add(new GrassTTC(this, id));
    }
    return result;
  }
  public IEnumerator<GrassTTC> EnumAllGrassTTC() {
    foreach (var id in rootIncarnation.incarnationsGrassTTC.Keys) {
      yield return GetGrassTTC(id);
    }
  }
  public void CheckHasGrassTTC(GrassTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasGrassTTC(thing.id);
  }
  public void CheckHasGrassTTC(int id) {
    if (!rootIncarnation.incarnationsGrassTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid GrassTTC: " + id);
    }
  }
  public GrassTTC EffectGrassTTCCreate(
) {
    return TrustedEffectGrassTTCCreateWithId(NewId()
    );
  }
  public GrassTTC TrustedEffectGrassTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new GrassTTCIncarnation(

            );
    return EffectInternalCreateGrassTTC(id, rootIncarnation.version, incarnation);
  }
  public GrassTTC EffectInternalCreateGrassTTC(
      int id,
      int incarnationVersion,
      GrassTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new GrassTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsGrassTTC.Add(
        id,
        new VersionAndIncarnation<GrassTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new GrassTTC(this, id);
  }

  public void EffectGrassTTCDelete(int id) {
    CheckUnlocked();
    var effect = new GrassTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsGrassTTC[id];

    rootIncarnation.incarnationsGrassTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetGrassTTCHash(int id, int version, GrassTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public LevelIncarnation GetLevelIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsLevel[id].incarnation;
  }
  public bool LevelExists(int id) {
    return rootIncarnation.incarnationsLevel.ContainsKey(id);
  }
  public Level GetLevel(int id) {
    CheckHasLevel(id);
    return new Level(this, id);
  }
  public Level GetLevelOrNull(int id) {
    if (LevelExists(id)) {
      return new Level(this, id);
    } else {
      return new Level(this, 0);
    }
  }
  public List<Level> AllLevel() {
    List<Level> result = new List<Level>(rootIncarnation.incarnationsLevel.Count);
    foreach (var id in rootIncarnation.incarnationsLevel.Keys) {
      result.Add(new Level(this, id));
    }
    return result;
  }
  public IEnumerator<Level> EnumAllLevel() {
    foreach (var id in rootIncarnation.incarnationsLevel.Keys) {
      yield return GetLevel(id);
    }
  }
  public void CheckHasLevel(Level thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasLevel(thing.id);
  }
  public void CheckHasLevel(int id) {
    if (!rootIncarnation.incarnationsLevel.ContainsKey(id)) {
      throw new System.Exception("Invalid Level: " + id);
    }
  }
  public Level EffectLevelCreate(
      Vec3 cameraAngle,
      Terrain terrain,
      UnitMutSet units,
      ILevelController controller,
      int time) {
    CheckHasTerrain(terrain);
    CheckHasUnitMutSet(units);
    return TrustedEffectLevelCreateWithId(NewId()
            ,cameraAngle
            ,terrain.id
            ,units.id
            ,controller.id
            ,time    );
  }
  public Level TrustedEffectLevelCreateWithId(int id
,      Vec3 cameraAngle
,      int terrain
,      int units
,      int controller
,      int time) {
    CheckUnlocked();

    var incarnation =
        new LevelIncarnation(
            cameraAngle,
            terrain,
            units,
            controller,
            time
            );
    return EffectInternalCreateLevel(id, rootIncarnation.version, incarnation);
  }
  public Level EffectInternalCreateLevel(
      int id,
      int incarnationVersion,
      LevelIncarnation incarnation) {
    CheckUnlocked();
    var effect = new LevelCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsLevel.Add(
        id,
        new VersionAndIncarnation<LevelIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new Level(this, id);
  }

  public void EffectLevelDelete(int id) {
    CheckUnlocked();
    var effect = new LevelDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsLevel[id];

    rootIncarnation.incarnationsLevel.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetLevelHash(int id, int version, LevelIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.cameraAngle.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.terrain.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.units.GetDeterministicHashCode();
    if (!object.ReferenceEquals(incarnation.controller, null)) {
      result += id * version * 4 * incarnation.controller.GetDeterministicHashCode();
    }
    result += id * version * 5 * incarnation.time.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectLevelSetController(int id, ILevelController newValue) {
    CheckUnlocked();
    CheckHasLevel(id);
var effect = new LevelSetControllerEffect(id, newValue.id);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsLevel[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldId = oldIncarnationAndVersion.incarnation.controller;
      oldIncarnationAndVersion.incarnation.controller = newValue.id;

    } else {
      var newIncarnation =
          new LevelIncarnation(
              oldIncarnationAndVersion.incarnation.cameraAngle,
              oldIncarnationAndVersion.incarnation.terrain,
              oldIncarnationAndVersion.incarnation.units,
              newValue.id,
              oldIncarnationAndVersion.incarnation.time);
      rootIncarnation.incarnationsLevel[id] =
          new VersionAndIncarnation<LevelIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }

  public void EffectLevelSetTime(int id, int newValue) {
    CheckUnlocked();
    CheckHasLevel(id);
var effect = new LevelSetTimeEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsLevel[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.time;
      oldIncarnationAndVersion.incarnation.time = newValue;

    } else {
      var newIncarnation =
          new LevelIncarnation(
              oldIncarnationAndVersion.incarnation.cameraAngle,
              oldIncarnationAndVersion.incarnation.terrain,
              oldIncarnationAndVersion.incarnation.units,
              oldIncarnationAndVersion.incarnation.controller,
              newValue);
      rootIncarnation.incarnationsLevel[id] =
          new VersionAndIncarnation<LevelIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }
  public SpeedRingIncarnation GetSpeedRingIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsSpeedRing[id].incarnation;
  }
  public bool SpeedRingExists(int id) {
    return rootIncarnation.incarnationsSpeedRing.ContainsKey(id);
  }
  public SpeedRing GetSpeedRing(int id) {
    CheckHasSpeedRing(id);
    return new SpeedRing(this, id);
  }
  public SpeedRing GetSpeedRingOrNull(int id) {
    if (SpeedRingExists(id)) {
      return new SpeedRing(this, id);
    } else {
      return new SpeedRing(this, 0);
    }
  }
  public List<SpeedRing> AllSpeedRing() {
    List<SpeedRing> result = new List<SpeedRing>(rootIncarnation.incarnationsSpeedRing.Count);
    foreach (var id in rootIncarnation.incarnationsSpeedRing.Keys) {
      result.Add(new SpeedRing(this, id));
    }
    return result;
  }
  public IEnumerator<SpeedRing> EnumAllSpeedRing() {
    foreach (var id in rootIncarnation.incarnationsSpeedRing.Keys) {
      yield return GetSpeedRing(id);
    }
  }
  public void CheckHasSpeedRing(SpeedRing thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasSpeedRing(thing.id);
  }
  public void CheckHasSpeedRing(int id) {
    if (!rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      throw new System.Exception("Invalid SpeedRing: " + id);
    }
  }
  public SpeedRing EffectSpeedRingCreate(
) {
    return TrustedEffectSpeedRingCreateWithId(NewId()
    );
  }
  public SpeedRing TrustedEffectSpeedRingCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new SpeedRingIncarnation(

            );
    return EffectInternalCreateSpeedRing(id, rootIncarnation.version, incarnation);
  }
  public SpeedRing EffectInternalCreateSpeedRing(
      int id,
      int incarnationVersion,
      SpeedRingIncarnation incarnation) {
    CheckUnlocked();
    var effect = new SpeedRingCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsSpeedRing.Add(
        id,
        new VersionAndIncarnation<SpeedRingIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new SpeedRing(this, id);
  }

  public void EffectSpeedRingDelete(int id) {
    CheckUnlocked();
    var effect = new SpeedRingDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsSpeedRing[id];

    rootIncarnation.incarnationsSpeedRing.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetSpeedRingHash(int id, int version, SpeedRingIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public ManaPotionIncarnation GetManaPotionIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsManaPotion[id].incarnation;
  }
  public bool ManaPotionExists(int id) {
    return rootIncarnation.incarnationsManaPotion.ContainsKey(id);
  }
  public ManaPotion GetManaPotion(int id) {
    CheckHasManaPotion(id);
    return new ManaPotion(this, id);
  }
  public ManaPotion GetManaPotionOrNull(int id) {
    if (ManaPotionExists(id)) {
      return new ManaPotion(this, id);
    } else {
      return new ManaPotion(this, 0);
    }
  }
  public List<ManaPotion> AllManaPotion() {
    List<ManaPotion> result = new List<ManaPotion>(rootIncarnation.incarnationsManaPotion.Count);
    foreach (var id in rootIncarnation.incarnationsManaPotion.Keys) {
      result.Add(new ManaPotion(this, id));
    }
    return result;
  }
  public IEnumerator<ManaPotion> EnumAllManaPotion() {
    foreach (var id in rootIncarnation.incarnationsManaPotion.Keys) {
      yield return GetManaPotion(id);
    }
  }
  public void CheckHasManaPotion(ManaPotion thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasManaPotion(thing.id);
  }
  public void CheckHasManaPotion(int id) {
    if (!rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      throw new System.Exception("Invalid ManaPotion: " + id);
    }
  }
  public ManaPotion EffectManaPotionCreate(
) {
    return TrustedEffectManaPotionCreateWithId(NewId()
    );
  }
  public ManaPotion TrustedEffectManaPotionCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new ManaPotionIncarnation(

            );
    return EffectInternalCreateManaPotion(id, rootIncarnation.version, incarnation);
  }
  public ManaPotion EffectInternalCreateManaPotion(
      int id,
      int incarnationVersion,
      ManaPotionIncarnation incarnation) {
    CheckUnlocked();
    var effect = new ManaPotionCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsManaPotion.Add(
        id,
        new VersionAndIncarnation<ManaPotionIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new ManaPotion(this, id);
  }

  public void EffectManaPotionDelete(int id) {
    CheckUnlocked();
    var effect = new ManaPotionDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsManaPotion[id];

    rootIncarnation.incarnationsManaPotion.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetManaPotionHash(int id, int version, ManaPotionIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public WatIncarnation GetWatIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsWat[id].incarnation;
  }
  public bool WatExists(int id) {
    return rootIncarnation.incarnationsWat.ContainsKey(id);
  }
  public Wat GetWat(int id) {
    CheckHasWat(id);
    return new Wat(this, id);
  }
  public Wat GetWatOrNull(int id) {
    if (WatExists(id)) {
      return new Wat(this, id);
    } else {
      return new Wat(this, 0);
    }
  }
  public List<Wat> AllWat() {
    List<Wat> result = new List<Wat>(rootIncarnation.incarnationsWat.Count);
    foreach (var id in rootIncarnation.incarnationsWat.Keys) {
      result.Add(new Wat(this, id));
    }
    return result;
  }
  public IEnumerator<Wat> EnumAllWat() {
    foreach (var id in rootIncarnation.incarnationsWat.Keys) {
      yield return GetWat(id);
    }
  }
  public void CheckHasWat(Wat thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasWat(thing.id);
  }
  public void CheckHasWat(int id) {
    if (!rootIncarnation.incarnationsWat.ContainsKey(id)) {
      throw new System.Exception("Invalid Wat: " + id);
    }
  }
  public Wat EffectWatCreate(
      IItemStrongMutBunch items,
      IImpulseStrongMutBunch impulses,
      IPostActingUCWeakMutBunch blah,
      IPreActingUCWeakMutBunch bloop) {
    CheckHasIItemStrongMutBunch(items);
    CheckHasIImpulseStrongMutBunch(impulses);
    CheckHasIPostActingUCWeakMutBunch(blah);
    CheckHasIPreActingUCWeakMutBunch(bloop);
    return TrustedEffectWatCreateWithId(NewId()
            ,items.id
            ,impulses.id
            ,blah.id
            ,bloop.id    );
  }
  public Wat TrustedEffectWatCreateWithId(int id
,      int items
,      int impulses
,      int blah
,      int bloop) {
    CheckUnlocked();

    var incarnation =
        new WatIncarnation(
            items,
            impulses,
            blah,
            bloop
            );
    return EffectInternalCreateWat(id, rootIncarnation.version, incarnation);
  }
  public Wat EffectInternalCreateWat(
      int id,
      int incarnationVersion,
      WatIncarnation incarnation) {
    CheckUnlocked();
    var effect = new WatCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsWat.Add(
        id,
        new VersionAndIncarnation<WatIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new Wat(this, id);
  }

  public void EffectWatDelete(int id) {
    CheckUnlocked();
    var effect = new WatDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsWat[id];

    rootIncarnation.incarnationsWat.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetWatHash(int id, int version, WatIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.items.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.impulses.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.blah.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.bloop.GetDeterministicHashCode();
    return result;
  }
       public IPreActingUCWeakMutBunchIncarnation GetIPreActingUCWeakMutBunchIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsIPreActingUCWeakMutBunch[id].incarnation;
  }
  public bool IPreActingUCWeakMutBunchExists(int id) {
    return rootIncarnation.incarnationsIPreActingUCWeakMutBunch.ContainsKey(id);
  }
  public IPreActingUCWeakMutBunch GetIPreActingUCWeakMutBunch(int id) {
    CheckHasIPreActingUCWeakMutBunch(id);
    return new IPreActingUCWeakMutBunch(this, id);
  }
  public IPreActingUCWeakMutBunch GetIPreActingUCWeakMutBunchOrNull(int id) {
    if (IPreActingUCWeakMutBunchExists(id)) {
      return new IPreActingUCWeakMutBunch(this, id);
    } else {
      return new IPreActingUCWeakMutBunch(this, 0);
    }
  }
  public List<IPreActingUCWeakMutBunch> AllIPreActingUCWeakMutBunch() {
    List<IPreActingUCWeakMutBunch> result = new List<IPreActingUCWeakMutBunch>(rootIncarnation.incarnationsIPreActingUCWeakMutBunch.Count);
    foreach (var id in rootIncarnation.incarnationsIPreActingUCWeakMutBunch.Keys) {
      result.Add(new IPreActingUCWeakMutBunch(this, id));
    }
    return result;
  }
  public IEnumerator<IPreActingUCWeakMutBunch> EnumAllIPreActingUCWeakMutBunch() {
    foreach (var id in rootIncarnation.incarnationsIPreActingUCWeakMutBunch.Keys) {
      yield return GetIPreActingUCWeakMutBunch(id);
    }
  }
  public void CheckHasIPreActingUCWeakMutBunch(IPreActingUCWeakMutBunch thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasIPreActingUCWeakMutBunch(thing.id);
  }
  public void CheckHasIPreActingUCWeakMutBunch(int id) {
    if (!rootIncarnation.incarnationsIPreActingUCWeakMutBunch.ContainsKey(id)) {
      throw new System.Exception("Invalid IPreActingUCWeakMutBunch: " + id);
    }
  }
  public IPreActingUCWeakMutBunch EffectIPreActingUCWeakMutBunchCreate(
      DoomedUCWeakMutSet membersDoomedUCWeakMutSet,
      MiredUCWeakMutSet membersMiredUCWeakMutSet,
      InvincibilityUCWeakMutSet membersInvincibilityUCWeakMutSet,
      DefyingUCWeakMutSet membersDefyingUCWeakMutSet,
      CounteringUCWeakMutSet membersCounteringUCWeakMutSet,
      AttackAICapabilityUCWeakMutSet membersAttackAICapabilityUCWeakMutSet) {
    CheckHasDoomedUCWeakMutSet(membersDoomedUCWeakMutSet);
    CheckHasMiredUCWeakMutSet(membersMiredUCWeakMutSet);
    CheckHasInvincibilityUCWeakMutSet(membersInvincibilityUCWeakMutSet);
    CheckHasDefyingUCWeakMutSet(membersDefyingUCWeakMutSet);
    CheckHasCounteringUCWeakMutSet(membersCounteringUCWeakMutSet);
    CheckHasAttackAICapabilityUCWeakMutSet(membersAttackAICapabilityUCWeakMutSet);
    return TrustedEffectIPreActingUCWeakMutBunchCreateWithId(NewId()
            ,membersDoomedUCWeakMutSet.id
            ,membersMiredUCWeakMutSet.id
            ,membersInvincibilityUCWeakMutSet.id
            ,membersDefyingUCWeakMutSet.id
            ,membersCounteringUCWeakMutSet.id
            ,membersAttackAICapabilityUCWeakMutSet.id    );
  }
  public IPreActingUCWeakMutBunch TrustedEffectIPreActingUCWeakMutBunchCreateWithId(int id
,      int membersDoomedUCWeakMutSet
,      int membersMiredUCWeakMutSet
,      int membersInvincibilityUCWeakMutSet
,      int membersDefyingUCWeakMutSet
,      int membersCounteringUCWeakMutSet
,      int membersAttackAICapabilityUCWeakMutSet) {
    CheckUnlocked();

    var incarnation =
        new IPreActingUCWeakMutBunchIncarnation(
            membersDoomedUCWeakMutSet,
            membersMiredUCWeakMutSet,
            membersInvincibilityUCWeakMutSet,
            membersDefyingUCWeakMutSet,
            membersCounteringUCWeakMutSet,
            membersAttackAICapabilityUCWeakMutSet
            );
    return EffectInternalCreateIPreActingUCWeakMutBunch(id, rootIncarnation.version, incarnation);
  }
  public IPreActingUCWeakMutBunch EffectInternalCreateIPreActingUCWeakMutBunch(
      int id,
      int incarnationVersion,
      IPreActingUCWeakMutBunchIncarnation incarnation) {
    CheckUnlocked();
    var effect = new IPreActingUCWeakMutBunchCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsIPreActingUCWeakMutBunch.Add(
        id,
        new VersionAndIncarnation<IPreActingUCWeakMutBunchIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new IPreActingUCWeakMutBunch(this, id);
  }

  public void EffectIPreActingUCWeakMutBunchDelete(int id) {
    CheckUnlocked();
    var effect = new IPreActingUCWeakMutBunchDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsIPreActingUCWeakMutBunch[id];

    rootIncarnation.incarnationsIPreActingUCWeakMutBunch.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetIPreActingUCWeakMutBunchHash(int id, int version, IPreActingUCWeakMutBunchIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.membersDoomedUCWeakMutSet.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.membersMiredUCWeakMutSet.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.membersInvincibilityUCWeakMutSet.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.membersDefyingUCWeakMutSet.GetDeterministicHashCode();
    result += id * version * 5 * incarnation.membersCounteringUCWeakMutSet.GetDeterministicHashCode();
    result += id * version * 6 * incarnation.membersAttackAICapabilityUCWeakMutSet.GetDeterministicHashCode();
    return result;
  }
       public IPostActingUCWeakMutBunchIncarnation GetIPostActingUCWeakMutBunchIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsIPostActingUCWeakMutBunch[id].incarnation;
  }
  public bool IPostActingUCWeakMutBunchExists(int id) {
    return rootIncarnation.incarnationsIPostActingUCWeakMutBunch.ContainsKey(id);
  }
  public IPostActingUCWeakMutBunch GetIPostActingUCWeakMutBunch(int id) {
    CheckHasIPostActingUCWeakMutBunch(id);
    return new IPostActingUCWeakMutBunch(this, id);
  }
  public IPostActingUCWeakMutBunch GetIPostActingUCWeakMutBunchOrNull(int id) {
    if (IPostActingUCWeakMutBunchExists(id)) {
      return new IPostActingUCWeakMutBunch(this, id);
    } else {
      return new IPostActingUCWeakMutBunch(this, 0);
    }
  }
  public List<IPostActingUCWeakMutBunch> AllIPostActingUCWeakMutBunch() {
    List<IPostActingUCWeakMutBunch> result = new List<IPostActingUCWeakMutBunch>(rootIncarnation.incarnationsIPostActingUCWeakMutBunch.Count);
    foreach (var id in rootIncarnation.incarnationsIPostActingUCWeakMutBunch.Keys) {
      result.Add(new IPostActingUCWeakMutBunch(this, id));
    }
    return result;
  }
  public IEnumerator<IPostActingUCWeakMutBunch> EnumAllIPostActingUCWeakMutBunch() {
    foreach (var id in rootIncarnation.incarnationsIPostActingUCWeakMutBunch.Keys) {
      yield return GetIPostActingUCWeakMutBunch(id);
    }
  }
  public void CheckHasIPostActingUCWeakMutBunch(IPostActingUCWeakMutBunch thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasIPostActingUCWeakMutBunch(thing.id);
  }
  public void CheckHasIPostActingUCWeakMutBunch(int id) {
    if (!rootIncarnation.incarnationsIPostActingUCWeakMutBunch.ContainsKey(id)) {
      throw new System.Exception("Invalid IPostActingUCWeakMutBunch: " + id);
    }
  }
  public IPostActingUCWeakMutBunch EffectIPostActingUCWeakMutBunchCreate(
      LightningChargedUCWeakMutSet membersLightningChargedUCWeakMutSet,
      TimeCloneAICapabilityUCWeakMutSet membersTimeCloneAICapabilityUCWeakMutSet) {
    CheckHasLightningChargedUCWeakMutSet(membersLightningChargedUCWeakMutSet);
    CheckHasTimeCloneAICapabilityUCWeakMutSet(membersTimeCloneAICapabilityUCWeakMutSet);
    return TrustedEffectIPostActingUCWeakMutBunchCreateWithId(NewId()
            ,membersLightningChargedUCWeakMutSet.id
            ,membersTimeCloneAICapabilityUCWeakMutSet.id    );
  }
  public IPostActingUCWeakMutBunch TrustedEffectIPostActingUCWeakMutBunchCreateWithId(int id
,      int membersLightningChargedUCWeakMutSet
,      int membersTimeCloneAICapabilityUCWeakMutSet) {
    CheckUnlocked();

    var incarnation =
        new IPostActingUCWeakMutBunchIncarnation(
            membersLightningChargedUCWeakMutSet,
            membersTimeCloneAICapabilityUCWeakMutSet
            );
    return EffectInternalCreateIPostActingUCWeakMutBunch(id, rootIncarnation.version, incarnation);
  }
  public IPostActingUCWeakMutBunch EffectInternalCreateIPostActingUCWeakMutBunch(
      int id,
      int incarnationVersion,
      IPostActingUCWeakMutBunchIncarnation incarnation) {
    CheckUnlocked();
    var effect = new IPostActingUCWeakMutBunchCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsIPostActingUCWeakMutBunch.Add(
        id,
        new VersionAndIncarnation<IPostActingUCWeakMutBunchIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new IPostActingUCWeakMutBunch(this, id);
  }

  public void EffectIPostActingUCWeakMutBunchDelete(int id) {
    CheckUnlocked();
    var effect = new IPostActingUCWeakMutBunchDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsIPostActingUCWeakMutBunch[id];

    rootIncarnation.incarnationsIPostActingUCWeakMutBunch.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetIPostActingUCWeakMutBunchHash(int id, int version, IPostActingUCWeakMutBunchIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.membersLightningChargedUCWeakMutSet.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.membersTimeCloneAICapabilityUCWeakMutSet.GetDeterministicHashCode();
    return result;
  }
       public IImpulseStrongMutBunchIncarnation GetIImpulseStrongMutBunchIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsIImpulseStrongMutBunch[id].incarnation;
  }
  public bool IImpulseStrongMutBunchExists(int id) {
    return rootIncarnation.incarnationsIImpulseStrongMutBunch.ContainsKey(id);
  }
  public IImpulseStrongMutBunch GetIImpulseStrongMutBunch(int id) {
    CheckHasIImpulseStrongMutBunch(id);
    return new IImpulseStrongMutBunch(this, id);
  }
  public IImpulseStrongMutBunch GetIImpulseStrongMutBunchOrNull(int id) {
    if (IImpulseStrongMutBunchExists(id)) {
      return new IImpulseStrongMutBunch(this, id);
    } else {
      return new IImpulseStrongMutBunch(this, 0);
    }
  }
  public List<IImpulseStrongMutBunch> AllIImpulseStrongMutBunch() {
    List<IImpulseStrongMutBunch> result = new List<IImpulseStrongMutBunch>(rootIncarnation.incarnationsIImpulseStrongMutBunch.Count);
    foreach (var id in rootIncarnation.incarnationsIImpulseStrongMutBunch.Keys) {
      result.Add(new IImpulseStrongMutBunch(this, id));
    }
    return result;
  }
  public IEnumerator<IImpulseStrongMutBunch> EnumAllIImpulseStrongMutBunch() {
    foreach (var id in rootIncarnation.incarnationsIImpulseStrongMutBunch.Keys) {
      yield return GetIImpulseStrongMutBunch(id);
    }
  }
  public void CheckHasIImpulseStrongMutBunch(IImpulseStrongMutBunch thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasIImpulseStrongMutBunch(thing.id);
  }
  public void CheckHasIImpulseStrongMutBunch(int id) {
    if (!rootIncarnation.incarnationsIImpulseStrongMutBunch.ContainsKey(id)) {
      throw new System.Exception("Invalid IImpulseStrongMutBunch: " + id);
    }
  }
  public IImpulseStrongMutBunch EffectIImpulseStrongMutBunchCreate(
      HoldPositionImpulseStrongMutSet membersHoldPositionImpulseStrongMutSet,
      TemporaryCloneImpulseStrongMutSet membersTemporaryCloneImpulseStrongMutSet,
      SummonImpulseStrongMutSet membersSummonImpulseStrongMutSet,
      MireImpulseStrongMutSet membersMireImpulseStrongMutSet,
      EvaporateImpulseStrongMutSet membersEvaporateImpulseStrongMutSet,
      MoveImpulseStrongMutSet membersMoveImpulseStrongMutSet,
      KamikazeJumpImpulseStrongMutSet membersKamikazeJumpImpulseStrongMutSet,
      KamikazeTargetImpulseStrongMutSet membersKamikazeTargetImpulseStrongMutSet,
      NoImpulseStrongMutSet membersNoImpulseStrongMutSet,
      FireImpulseStrongMutSet membersFireImpulseStrongMutSet,
      DefyImpulseStrongMutSet membersDefyImpulseStrongMutSet,
      CounterImpulseStrongMutSet membersCounterImpulseStrongMutSet,
      UnleashBideImpulseStrongMutSet membersUnleashBideImpulseStrongMutSet,
      ContinueBidingImpulseStrongMutSet membersContinueBidingImpulseStrongMutSet,
      StartBidingImpulseStrongMutSet membersStartBidingImpulseStrongMutSet,
      AttackImpulseStrongMutSet membersAttackImpulseStrongMutSet,
      PursueImpulseStrongMutSet membersPursueImpulseStrongMutSet,
      FireBombImpulseStrongMutSet membersFireBombImpulseStrongMutSet) {
    CheckHasHoldPositionImpulseStrongMutSet(membersHoldPositionImpulseStrongMutSet);
    CheckHasTemporaryCloneImpulseStrongMutSet(membersTemporaryCloneImpulseStrongMutSet);
    CheckHasSummonImpulseStrongMutSet(membersSummonImpulseStrongMutSet);
    CheckHasMireImpulseStrongMutSet(membersMireImpulseStrongMutSet);
    CheckHasEvaporateImpulseStrongMutSet(membersEvaporateImpulseStrongMutSet);
    CheckHasMoveImpulseStrongMutSet(membersMoveImpulseStrongMutSet);
    CheckHasKamikazeJumpImpulseStrongMutSet(membersKamikazeJumpImpulseStrongMutSet);
    CheckHasKamikazeTargetImpulseStrongMutSet(membersKamikazeTargetImpulseStrongMutSet);
    CheckHasNoImpulseStrongMutSet(membersNoImpulseStrongMutSet);
    CheckHasFireImpulseStrongMutSet(membersFireImpulseStrongMutSet);
    CheckHasDefyImpulseStrongMutSet(membersDefyImpulseStrongMutSet);
    CheckHasCounterImpulseStrongMutSet(membersCounterImpulseStrongMutSet);
    CheckHasUnleashBideImpulseStrongMutSet(membersUnleashBideImpulseStrongMutSet);
    CheckHasContinueBidingImpulseStrongMutSet(membersContinueBidingImpulseStrongMutSet);
    CheckHasStartBidingImpulseStrongMutSet(membersStartBidingImpulseStrongMutSet);
    CheckHasAttackImpulseStrongMutSet(membersAttackImpulseStrongMutSet);
    CheckHasPursueImpulseStrongMutSet(membersPursueImpulseStrongMutSet);
    CheckHasFireBombImpulseStrongMutSet(membersFireBombImpulseStrongMutSet);
    return TrustedEffectIImpulseStrongMutBunchCreateWithId(NewId()
            ,membersHoldPositionImpulseStrongMutSet.id
            ,membersTemporaryCloneImpulseStrongMutSet.id
            ,membersSummonImpulseStrongMutSet.id
            ,membersMireImpulseStrongMutSet.id
            ,membersEvaporateImpulseStrongMutSet.id
            ,membersMoveImpulseStrongMutSet.id
            ,membersKamikazeJumpImpulseStrongMutSet.id
            ,membersKamikazeTargetImpulseStrongMutSet.id
            ,membersNoImpulseStrongMutSet.id
            ,membersFireImpulseStrongMutSet.id
            ,membersDefyImpulseStrongMutSet.id
            ,membersCounterImpulseStrongMutSet.id
            ,membersUnleashBideImpulseStrongMutSet.id
            ,membersContinueBidingImpulseStrongMutSet.id
            ,membersStartBidingImpulseStrongMutSet.id
            ,membersAttackImpulseStrongMutSet.id
            ,membersPursueImpulseStrongMutSet.id
            ,membersFireBombImpulseStrongMutSet.id    );
  }
  public IImpulseStrongMutBunch TrustedEffectIImpulseStrongMutBunchCreateWithId(int id
,      int membersHoldPositionImpulseStrongMutSet
,      int membersTemporaryCloneImpulseStrongMutSet
,      int membersSummonImpulseStrongMutSet
,      int membersMireImpulseStrongMutSet
,      int membersEvaporateImpulseStrongMutSet
,      int membersMoveImpulseStrongMutSet
,      int membersKamikazeJumpImpulseStrongMutSet
,      int membersKamikazeTargetImpulseStrongMutSet
,      int membersNoImpulseStrongMutSet
,      int membersFireImpulseStrongMutSet
,      int membersDefyImpulseStrongMutSet
,      int membersCounterImpulseStrongMutSet
,      int membersUnleashBideImpulseStrongMutSet
,      int membersContinueBidingImpulseStrongMutSet
,      int membersStartBidingImpulseStrongMutSet
,      int membersAttackImpulseStrongMutSet
,      int membersPursueImpulseStrongMutSet
,      int membersFireBombImpulseStrongMutSet) {
    CheckUnlocked();

    var incarnation =
        new IImpulseStrongMutBunchIncarnation(
            membersHoldPositionImpulseStrongMutSet,
            membersTemporaryCloneImpulseStrongMutSet,
            membersSummonImpulseStrongMutSet,
            membersMireImpulseStrongMutSet,
            membersEvaporateImpulseStrongMutSet,
            membersMoveImpulseStrongMutSet,
            membersKamikazeJumpImpulseStrongMutSet,
            membersKamikazeTargetImpulseStrongMutSet,
            membersNoImpulseStrongMutSet,
            membersFireImpulseStrongMutSet,
            membersDefyImpulseStrongMutSet,
            membersCounterImpulseStrongMutSet,
            membersUnleashBideImpulseStrongMutSet,
            membersContinueBidingImpulseStrongMutSet,
            membersStartBidingImpulseStrongMutSet,
            membersAttackImpulseStrongMutSet,
            membersPursueImpulseStrongMutSet,
            membersFireBombImpulseStrongMutSet
            );
    return EffectInternalCreateIImpulseStrongMutBunch(id, rootIncarnation.version, incarnation);
  }
  public IImpulseStrongMutBunch EffectInternalCreateIImpulseStrongMutBunch(
      int id,
      int incarnationVersion,
      IImpulseStrongMutBunchIncarnation incarnation) {
    CheckUnlocked();
    var effect = new IImpulseStrongMutBunchCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsIImpulseStrongMutBunch.Add(
        id,
        new VersionAndIncarnation<IImpulseStrongMutBunchIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new IImpulseStrongMutBunch(this, id);
  }

  public void EffectIImpulseStrongMutBunchDelete(int id) {
    CheckUnlocked();
    var effect = new IImpulseStrongMutBunchDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsIImpulseStrongMutBunch[id];

    rootIncarnation.incarnationsIImpulseStrongMutBunch.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetIImpulseStrongMutBunchHash(int id, int version, IImpulseStrongMutBunchIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.membersHoldPositionImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.membersTemporaryCloneImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.membersSummonImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.membersMireImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 5 * incarnation.membersEvaporateImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 6 * incarnation.membersMoveImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 7 * incarnation.membersKamikazeJumpImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 8 * incarnation.membersKamikazeTargetImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 9 * incarnation.membersNoImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 10 * incarnation.membersFireImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 11 * incarnation.membersDefyImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 12 * incarnation.membersCounterImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 13 * incarnation.membersUnleashBideImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 14 * incarnation.membersContinueBidingImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 15 * incarnation.membersStartBidingImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 16 * incarnation.membersAttackImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 17 * incarnation.membersPursueImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 18 * incarnation.membersFireBombImpulseStrongMutSet.GetDeterministicHashCode();
    return result;
  }
       public IItemStrongMutBunchIncarnation GetIItemStrongMutBunchIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsIItemStrongMutBunch[id].incarnation;
  }
  public bool IItemStrongMutBunchExists(int id) {
    return rootIncarnation.incarnationsIItemStrongMutBunch.ContainsKey(id);
  }
  public IItemStrongMutBunch GetIItemStrongMutBunch(int id) {
    CheckHasIItemStrongMutBunch(id);
    return new IItemStrongMutBunch(this, id);
  }
  public IItemStrongMutBunch GetIItemStrongMutBunchOrNull(int id) {
    if (IItemStrongMutBunchExists(id)) {
      return new IItemStrongMutBunch(this, id);
    } else {
      return new IItemStrongMutBunch(this, 0);
    }
  }
  public List<IItemStrongMutBunch> AllIItemStrongMutBunch() {
    List<IItemStrongMutBunch> result = new List<IItemStrongMutBunch>(rootIncarnation.incarnationsIItemStrongMutBunch.Count);
    foreach (var id in rootIncarnation.incarnationsIItemStrongMutBunch.Keys) {
      result.Add(new IItemStrongMutBunch(this, id));
    }
    return result;
  }
  public IEnumerator<IItemStrongMutBunch> EnumAllIItemStrongMutBunch() {
    foreach (var id in rootIncarnation.incarnationsIItemStrongMutBunch.Keys) {
      yield return GetIItemStrongMutBunch(id);
    }
  }
  public void CheckHasIItemStrongMutBunch(IItemStrongMutBunch thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasIItemStrongMutBunch(thing.id);
  }
  public void CheckHasIItemStrongMutBunch(int id) {
    if (!rootIncarnation.incarnationsIItemStrongMutBunch.ContainsKey(id)) {
      throw new System.Exception("Invalid IItemStrongMutBunch: " + id);
    }
  }
  public IItemStrongMutBunch EffectIItemStrongMutBunchCreate(
      ManaPotionStrongMutSet membersManaPotionStrongMutSet,
      HealthPotionStrongMutSet membersHealthPotionStrongMutSet,
      SpeedRingStrongMutSet membersSpeedRingStrongMutSet,
      GlaiveStrongMutSet membersGlaiveStrongMutSet,
      SlowRodStrongMutSet membersSlowRodStrongMutSet,
      BlastRodStrongMutSet membersBlastRodStrongMutSet,
      ArmorStrongMutSet membersArmorStrongMutSet) {
    CheckHasManaPotionStrongMutSet(membersManaPotionStrongMutSet);
    CheckHasHealthPotionStrongMutSet(membersHealthPotionStrongMutSet);
    CheckHasSpeedRingStrongMutSet(membersSpeedRingStrongMutSet);
    CheckHasGlaiveStrongMutSet(membersGlaiveStrongMutSet);
    CheckHasSlowRodStrongMutSet(membersSlowRodStrongMutSet);
    CheckHasBlastRodStrongMutSet(membersBlastRodStrongMutSet);
    CheckHasArmorStrongMutSet(membersArmorStrongMutSet);
    return TrustedEffectIItemStrongMutBunchCreateWithId(NewId()
            ,membersManaPotionStrongMutSet.id
            ,membersHealthPotionStrongMutSet.id
            ,membersSpeedRingStrongMutSet.id
            ,membersGlaiveStrongMutSet.id
            ,membersSlowRodStrongMutSet.id
            ,membersBlastRodStrongMutSet.id
            ,membersArmorStrongMutSet.id    );
  }
  public IItemStrongMutBunch TrustedEffectIItemStrongMutBunchCreateWithId(int id
,      int membersManaPotionStrongMutSet
,      int membersHealthPotionStrongMutSet
,      int membersSpeedRingStrongMutSet
,      int membersGlaiveStrongMutSet
,      int membersSlowRodStrongMutSet
,      int membersBlastRodStrongMutSet
,      int membersArmorStrongMutSet) {
    CheckUnlocked();

    var incarnation =
        new IItemStrongMutBunchIncarnation(
            membersManaPotionStrongMutSet,
            membersHealthPotionStrongMutSet,
            membersSpeedRingStrongMutSet,
            membersGlaiveStrongMutSet,
            membersSlowRodStrongMutSet,
            membersBlastRodStrongMutSet,
            membersArmorStrongMutSet
            );
    return EffectInternalCreateIItemStrongMutBunch(id, rootIncarnation.version, incarnation);
  }
  public IItemStrongMutBunch EffectInternalCreateIItemStrongMutBunch(
      int id,
      int incarnationVersion,
      IItemStrongMutBunchIncarnation incarnation) {
    CheckUnlocked();
    var effect = new IItemStrongMutBunchCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsIItemStrongMutBunch.Add(
        id,
        new VersionAndIncarnation<IItemStrongMutBunchIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new IItemStrongMutBunch(this, id);
  }

  public void EffectIItemStrongMutBunchDelete(int id) {
    CheckUnlocked();
    var effect = new IItemStrongMutBunchDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsIItemStrongMutBunch[id];

    rootIncarnation.incarnationsIItemStrongMutBunch.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetIItemStrongMutBunchHash(int id, int version, IItemStrongMutBunchIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.membersManaPotionStrongMutSet.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.membersHealthPotionStrongMutSet.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.membersSpeedRingStrongMutSet.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.membersGlaiveStrongMutSet.GetDeterministicHashCode();
    result += id * version * 5 * incarnation.membersSlowRodStrongMutSet.GetDeterministicHashCode();
    result += id * version * 6 * incarnation.membersBlastRodStrongMutSet.GetDeterministicHashCode();
    result += id * version * 7 * incarnation.membersArmorStrongMutSet.GetDeterministicHashCode();
    return result;
  }
       public ItemTTCIncarnation GetItemTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsItemTTC[id].incarnation;
  }
  public bool ItemTTCExists(int id) {
    return rootIncarnation.incarnationsItemTTC.ContainsKey(id);
  }
  public ItemTTC GetItemTTC(int id) {
    CheckHasItemTTC(id);
    return new ItemTTC(this, id);
  }
  public ItemTTC GetItemTTCOrNull(int id) {
    if (ItemTTCExists(id)) {
      return new ItemTTC(this, id);
    } else {
      return new ItemTTC(this, 0);
    }
  }
  public List<ItemTTC> AllItemTTC() {
    List<ItemTTC> result = new List<ItemTTC>(rootIncarnation.incarnationsItemTTC.Count);
    foreach (var id in rootIncarnation.incarnationsItemTTC.Keys) {
      result.Add(new ItemTTC(this, id));
    }
    return result;
  }
  public IEnumerator<ItemTTC> EnumAllItemTTC() {
    foreach (var id in rootIncarnation.incarnationsItemTTC.Keys) {
      yield return GetItemTTC(id);
    }
  }
  public void CheckHasItemTTC(ItemTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasItemTTC(thing.id);
  }
  public void CheckHasItemTTC(int id) {
    if (!rootIncarnation.incarnationsItemTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid ItemTTC: " + id);
    }
  }
  public ItemTTC EffectItemTTCCreate(
      IItem item) {
    CheckHasIItem(item);
    return TrustedEffectItemTTCCreateWithId(NewId()
            ,item.id    );
  }
  public ItemTTC TrustedEffectItemTTCCreateWithId(int id
,      int item) {
    CheckUnlocked();

    var incarnation =
        new ItemTTCIncarnation(
            item
            );
    return EffectInternalCreateItemTTC(id, rootIncarnation.version, incarnation);
  }
  public ItemTTC EffectInternalCreateItemTTC(
      int id,
      int incarnationVersion,
      ItemTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new ItemTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsItemTTC.Add(
        id,
        new VersionAndIncarnation<ItemTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new ItemTTC(this, id);
  }

  public void EffectItemTTCDelete(int id) {
    CheckUnlocked();
    var effect = new ItemTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsItemTTC[id];

    rootIncarnation.incarnationsItemTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetItemTTCHash(int id, int version, ItemTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.item.GetDeterministicHashCode();
    return result;
  }
       public HealthPotionIncarnation GetHealthPotionIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsHealthPotion[id].incarnation;
  }
  public bool HealthPotionExists(int id) {
    return rootIncarnation.incarnationsHealthPotion.ContainsKey(id);
  }
  public HealthPotion GetHealthPotion(int id) {
    CheckHasHealthPotion(id);
    return new HealthPotion(this, id);
  }
  public HealthPotion GetHealthPotionOrNull(int id) {
    if (HealthPotionExists(id)) {
      return new HealthPotion(this, id);
    } else {
      return new HealthPotion(this, 0);
    }
  }
  public List<HealthPotion> AllHealthPotion() {
    List<HealthPotion> result = new List<HealthPotion>(rootIncarnation.incarnationsHealthPotion.Count);
    foreach (var id in rootIncarnation.incarnationsHealthPotion.Keys) {
      result.Add(new HealthPotion(this, id));
    }
    return result;
  }
  public IEnumerator<HealthPotion> EnumAllHealthPotion() {
    foreach (var id in rootIncarnation.incarnationsHealthPotion.Keys) {
      yield return GetHealthPotion(id);
    }
  }
  public void CheckHasHealthPotion(HealthPotion thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasHealthPotion(thing.id);
  }
  public void CheckHasHealthPotion(int id) {
    if (!rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      throw new System.Exception("Invalid HealthPotion: " + id);
    }
  }
  public HealthPotion EffectHealthPotionCreate(
) {
    return TrustedEffectHealthPotionCreateWithId(NewId()
    );
  }
  public HealthPotion TrustedEffectHealthPotionCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new HealthPotionIncarnation(

            );
    return EffectInternalCreateHealthPotion(id, rootIncarnation.version, incarnation);
  }
  public HealthPotion EffectInternalCreateHealthPotion(
      int id,
      int incarnationVersion,
      HealthPotionIncarnation incarnation) {
    CheckUnlocked();
    var effect = new HealthPotionCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsHealthPotion.Add(
        id,
        new VersionAndIncarnation<HealthPotionIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new HealthPotion(this, id);
  }

  public void EffectHealthPotionDelete(int id) {
    CheckUnlocked();
    var effect = new HealthPotionDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsHealthPotion[id];

    rootIncarnation.incarnationsHealthPotion.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetHealthPotionHash(int id, int version, HealthPotionIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public GlaiveIncarnation GetGlaiveIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsGlaive[id].incarnation;
  }
  public bool GlaiveExists(int id) {
    return rootIncarnation.incarnationsGlaive.ContainsKey(id);
  }
  public Glaive GetGlaive(int id) {
    CheckHasGlaive(id);
    return new Glaive(this, id);
  }
  public Glaive GetGlaiveOrNull(int id) {
    if (GlaiveExists(id)) {
      return new Glaive(this, id);
    } else {
      return new Glaive(this, 0);
    }
  }
  public List<Glaive> AllGlaive() {
    List<Glaive> result = new List<Glaive>(rootIncarnation.incarnationsGlaive.Count);
    foreach (var id in rootIncarnation.incarnationsGlaive.Keys) {
      result.Add(new Glaive(this, id));
    }
    return result;
  }
  public IEnumerator<Glaive> EnumAllGlaive() {
    foreach (var id in rootIncarnation.incarnationsGlaive.Keys) {
      yield return GetGlaive(id);
    }
  }
  public void CheckHasGlaive(Glaive thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasGlaive(thing.id);
  }
  public void CheckHasGlaive(int id) {
    if (!rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      throw new System.Exception("Invalid Glaive: " + id);
    }
  }
  public Glaive EffectGlaiveCreate(
) {
    return TrustedEffectGlaiveCreateWithId(NewId()
    );
  }
  public Glaive TrustedEffectGlaiveCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new GlaiveIncarnation(

            );
    return EffectInternalCreateGlaive(id, rootIncarnation.version, incarnation);
  }
  public Glaive EffectInternalCreateGlaive(
      int id,
      int incarnationVersion,
      GlaiveIncarnation incarnation) {
    CheckUnlocked();
    var effect = new GlaiveCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsGlaive.Add(
        id,
        new VersionAndIncarnation<GlaiveIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new Glaive(this, id);
  }

  public void EffectGlaiveDelete(int id) {
    CheckUnlocked();
    var effect = new GlaiveDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsGlaive[id];

    rootIncarnation.incarnationsGlaive.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetGlaiveHash(int id, int version, GlaiveIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public SlowRodIncarnation GetSlowRodIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsSlowRod[id].incarnation;
  }
  public bool SlowRodExists(int id) {
    return rootIncarnation.incarnationsSlowRod.ContainsKey(id);
  }
  public SlowRod GetSlowRod(int id) {
    CheckHasSlowRod(id);
    return new SlowRod(this, id);
  }
  public SlowRod GetSlowRodOrNull(int id) {
    if (SlowRodExists(id)) {
      return new SlowRod(this, id);
    } else {
      return new SlowRod(this, 0);
    }
  }
  public List<SlowRod> AllSlowRod() {
    List<SlowRod> result = new List<SlowRod>(rootIncarnation.incarnationsSlowRod.Count);
    foreach (var id in rootIncarnation.incarnationsSlowRod.Keys) {
      result.Add(new SlowRod(this, id));
    }
    return result;
  }
  public IEnumerator<SlowRod> EnumAllSlowRod() {
    foreach (var id in rootIncarnation.incarnationsSlowRod.Keys) {
      yield return GetSlowRod(id);
    }
  }
  public void CheckHasSlowRod(SlowRod thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasSlowRod(thing.id);
  }
  public void CheckHasSlowRod(int id) {
    if (!rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      throw new System.Exception("Invalid SlowRod: " + id);
    }
  }
  public SlowRod EffectSlowRodCreate(
) {
    return TrustedEffectSlowRodCreateWithId(NewId()
    );
  }
  public SlowRod TrustedEffectSlowRodCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new SlowRodIncarnation(

            );
    return EffectInternalCreateSlowRod(id, rootIncarnation.version, incarnation);
  }
  public SlowRod EffectInternalCreateSlowRod(
      int id,
      int incarnationVersion,
      SlowRodIncarnation incarnation) {
    CheckUnlocked();
    var effect = new SlowRodCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsSlowRod.Add(
        id,
        new VersionAndIncarnation<SlowRodIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new SlowRod(this, id);
  }

  public void EffectSlowRodDelete(int id) {
    CheckUnlocked();
    var effect = new SlowRodDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsSlowRod[id];

    rootIncarnation.incarnationsSlowRod.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetSlowRodHash(int id, int version, SlowRodIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public BlastRodIncarnation GetBlastRodIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBlastRod[id].incarnation;
  }
  public bool BlastRodExists(int id) {
    return rootIncarnation.incarnationsBlastRod.ContainsKey(id);
  }
  public BlastRod GetBlastRod(int id) {
    CheckHasBlastRod(id);
    return new BlastRod(this, id);
  }
  public BlastRod GetBlastRodOrNull(int id) {
    if (BlastRodExists(id)) {
      return new BlastRod(this, id);
    } else {
      return new BlastRod(this, 0);
    }
  }
  public List<BlastRod> AllBlastRod() {
    List<BlastRod> result = new List<BlastRod>(rootIncarnation.incarnationsBlastRod.Count);
    foreach (var id in rootIncarnation.incarnationsBlastRod.Keys) {
      result.Add(new BlastRod(this, id));
    }
    return result;
  }
  public IEnumerator<BlastRod> EnumAllBlastRod() {
    foreach (var id in rootIncarnation.incarnationsBlastRod.Keys) {
      yield return GetBlastRod(id);
    }
  }
  public void CheckHasBlastRod(BlastRod thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBlastRod(thing.id);
  }
  public void CheckHasBlastRod(int id) {
    if (!rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      throw new System.Exception("Invalid BlastRod: " + id);
    }
  }
  public BlastRod EffectBlastRodCreate(
) {
    return TrustedEffectBlastRodCreateWithId(NewId()
    );
  }
  public BlastRod TrustedEffectBlastRodCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new BlastRodIncarnation(

            );
    return EffectInternalCreateBlastRod(id, rootIncarnation.version, incarnation);
  }
  public BlastRod EffectInternalCreateBlastRod(
      int id,
      int incarnationVersion,
      BlastRodIncarnation incarnation) {
    CheckUnlocked();
    var effect = new BlastRodCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsBlastRod.Add(
        id,
        new VersionAndIncarnation<BlastRodIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new BlastRod(this, id);
  }

  public void EffectBlastRodDelete(int id) {
    CheckUnlocked();
    var effect = new BlastRodDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBlastRod[id];

    rootIncarnation.incarnationsBlastRod.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetBlastRodHash(int id, int version, BlastRodIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public ArmorIncarnation GetArmorIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsArmor[id].incarnation;
  }
  public bool ArmorExists(int id) {
    return rootIncarnation.incarnationsArmor.ContainsKey(id);
  }
  public Armor GetArmor(int id) {
    CheckHasArmor(id);
    return new Armor(this, id);
  }
  public Armor GetArmorOrNull(int id) {
    if (ArmorExists(id)) {
      return new Armor(this, id);
    } else {
      return new Armor(this, 0);
    }
  }
  public List<Armor> AllArmor() {
    List<Armor> result = new List<Armor>(rootIncarnation.incarnationsArmor.Count);
    foreach (var id in rootIncarnation.incarnationsArmor.Keys) {
      result.Add(new Armor(this, id));
    }
    return result;
  }
  public IEnumerator<Armor> EnumAllArmor() {
    foreach (var id in rootIncarnation.incarnationsArmor.Keys) {
      yield return GetArmor(id);
    }
  }
  public void CheckHasArmor(Armor thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasArmor(thing.id);
  }
  public void CheckHasArmor(int id) {
    if (!rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      throw new System.Exception("Invalid Armor: " + id);
    }
  }
  public Armor EffectArmorCreate(
) {
    return TrustedEffectArmorCreateWithId(NewId()
    );
  }
  public Armor TrustedEffectArmorCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new ArmorIncarnation(

            );
    return EffectInternalCreateArmor(id, rootIncarnation.version, incarnation);
  }
  public Armor EffectInternalCreateArmor(
      int id,
      int incarnationVersion,
      ArmorIncarnation incarnation) {
    CheckUnlocked();
    var effect = new ArmorCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsArmor.Add(
        id,
        new VersionAndIncarnation<ArmorIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new Armor(this, id);
  }

  public void EffectArmorDelete(int id) {
    CheckUnlocked();
    var effect = new ArmorDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsArmor[id];

    rootIncarnation.incarnationsArmor.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetArmorHash(int id, int version, ArmorIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public SquareCaveLevelControllerIncarnation GetSquareCaveLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsSquareCaveLevelController[id].incarnation;
  }
  public bool SquareCaveLevelControllerExists(int id) {
    return rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(id);
  }
  public SquareCaveLevelController GetSquareCaveLevelController(int id) {
    CheckHasSquareCaveLevelController(id);
    return new SquareCaveLevelController(this, id);
  }
  public SquareCaveLevelController GetSquareCaveLevelControllerOrNull(int id) {
    if (SquareCaveLevelControllerExists(id)) {
      return new SquareCaveLevelController(this, id);
    } else {
      return new SquareCaveLevelController(this, 0);
    }
  }
  public List<SquareCaveLevelController> AllSquareCaveLevelController() {
    List<SquareCaveLevelController> result = new List<SquareCaveLevelController>(rootIncarnation.incarnationsSquareCaveLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsSquareCaveLevelController.Keys) {
      result.Add(new SquareCaveLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<SquareCaveLevelController> EnumAllSquareCaveLevelController() {
    foreach (var id in rootIncarnation.incarnationsSquareCaveLevelController.Keys) {
      yield return GetSquareCaveLevelController(id);
    }
  }
  public void CheckHasSquareCaveLevelController(SquareCaveLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasSquareCaveLevelController(thing.id);
  }
  public void CheckHasSquareCaveLevelController(int id) {
    if (!rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid SquareCaveLevelController: " + id);
    }
  }
  public SquareCaveLevelController EffectSquareCaveLevelControllerCreate(
      Level level,
      int depth) {
    CheckHasLevel(level);
    return TrustedEffectSquareCaveLevelControllerCreateWithId(NewId()
            ,level.id
            ,depth    );
  }
  public SquareCaveLevelController TrustedEffectSquareCaveLevelControllerCreateWithId(int id
,      int level
,      int depth) {
    CheckUnlocked();

    var incarnation =
        new SquareCaveLevelControllerIncarnation(
            level,
            depth
            );
    return EffectInternalCreateSquareCaveLevelController(id, rootIncarnation.version, incarnation);
  }
  public SquareCaveLevelController EffectInternalCreateSquareCaveLevelController(
      int id,
      int incarnationVersion,
      SquareCaveLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new SquareCaveLevelControllerCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsSquareCaveLevelController.Add(
        id,
        new VersionAndIncarnation<SquareCaveLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new SquareCaveLevelController(this, id);
  }

  public void EffectSquareCaveLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new SquareCaveLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsSquareCaveLevelController[id];

    rootIncarnation.incarnationsSquareCaveLevelController.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetSquareCaveLevelControllerHash(int id, int version, SquareCaveLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.depth.GetDeterministicHashCode();
    return result;
  }
       public RavashrikeLevelControllerIncarnation GetRavashrikeLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsRavashrikeLevelController[id].incarnation;
  }
  public bool RavashrikeLevelControllerExists(int id) {
    return rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(id);
  }
  public RavashrikeLevelController GetRavashrikeLevelController(int id) {
    CheckHasRavashrikeLevelController(id);
    return new RavashrikeLevelController(this, id);
  }
  public RavashrikeLevelController GetRavashrikeLevelControllerOrNull(int id) {
    if (RavashrikeLevelControllerExists(id)) {
      return new RavashrikeLevelController(this, id);
    } else {
      return new RavashrikeLevelController(this, 0);
    }
  }
  public List<RavashrikeLevelController> AllRavashrikeLevelController() {
    List<RavashrikeLevelController> result = new List<RavashrikeLevelController>(rootIncarnation.incarnationsRavashrikeLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsRavashrikeLevelController.Keys) {
      result.Add(new RavashrikeLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<RavashrikeLevelController> EnumAllRavashrikeLevelController() {
    foreach (var id in rootIncarnation.incarnationsRavashrikeLevelController.Keys) {
      yield return GetRavashrikeLevelController(id);
    }
  }
  public void CheckHasRavashrikeLevelController(RavashrikeLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasRavashrikeLevelController(thing.id);
  }
  public void CheckHasRavashrikeLevelController(int id) {
    if (!rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid RavashrikeLevelController: " + id);
    }
  }
  public RavashrikeLevelController EffectRavashrikeLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectRavashrikeLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public RavashrikeLevelController TrustedEffectRavashrikeLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new RavashrikeLevelControllerIncarnation(
            level
            );
    return EffectInternalCreateRavashrikeLevelController(id, rootIncarnation.version, incarnation);
  }
  public RavashrikeLevelController EffectInternalCreateRavashrikeLevelController(
      int id,
      int incarnationVersion,
      RavashrikeLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new RavashrikeLevelControllerCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsRavashrikeLevelController.Add(
        id,
        new VersionAndIncarnation<RavashrikeLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new RavashrikeLevelController(this, id);
  }

  public void EffectRavashrikeLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new RavashrikeLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsRavashrikeLevelController[id];

    rootIncarnation.incarnationsRavashrikeLevelController.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetRavashrikeLevelControllerHash(int id, int version, RavashrikeLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public PentagonalCaveLevelControllerIncarnation GetPentagonalCaveLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsPentagonalCaveLevelController[id].incarnation;
  }
  public bool PentagonalCaveLevelControllerExists(int id) {
    return rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(id);
  }
  public PentagonalCaveLevelController GetPentagonalCaveLevelController(int id) {
    CheckHasPentagonalCaveLevelController(id);
    return new PentagonalCaveLevelController(this, id);
  }
  public PentagonalCaveLevelController GetPentagonalCaveLevelControllerOrNull(int id) {
    if (PentagonalCaveLevelControllerExists(id)) {
      return new PentagonalCaveLevelController(this, id);
    } else {
      return new PentagonalCaveLevelController(this, 0);
    }
  }
  public List<PentagonalCaveLevelController> AllPentagonalCaveLevelController() {
    List<PentagonalCaveLevelController> result = new List<PentagonalCaveLevelController>(rootIncarnation.incarnationsPentagonalCaveLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsPentagonalCaveLevelController.Keys) {
      result.Add(new PentagonalCaveLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<PentagonalCaveLevelController> EnumAllPentagonalCaveLevelController() {
    foreach (var id in rootIncarnation.incarnationsPentagonalCaveLevelController.Keys) {
      yield return GetPentagonalCaveLevelController(id);
    }
  }
  public void CheckHasPentagonalCaveLevelController(PentagonalCaveLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasPentagonalCaveLevelController(thing.id);
  }
  public void CheckHasPentagonalCaveLevelController(int id) {
    if (!rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid PentagonalCaveLevelController: " + id);
    }
  }
  public PentagonalCaveLevelController EffectPentagonalCaveLevelControllerCreate(
      Level level,
      int depth) {
    CheckHasLevel(level);
    return TrustedEffectPentagonalCaveLevelControllerCreateWithId(NewId()
            ,level.id
            ,depth    );
  }
  public PentagonalCaveLevelController TrustedEffectPentagonalCaveLevelControllerCreateWithId(int id
,      int level
,      int depth) {
    CheckUnlocked();

    var incarnation =
        new PentagonalCaveLevelControllerIncarnation(
            level,
            depth
            );
    return EffectInternalCreatePentagonalCaveLevelController(id, rootIncarnation.version, incarnation);
  }
  public PentagonalCaveLevelController EffectInternalCreatePentagonalCaveLevelController(
      int id,
      int incarnationVersion,
      PentagonalCaveLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new PentagonalCaveLevelControllerCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsPentagonalCaveLevelController.Add(
        id,
        new VersionAndIncarnation<PentagonalCaveLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new PentagonalCaveLevelController(this, id);
  }

  public void EffectPentagonalCaveLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new PentagonalCaveLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsPentagonalCaveLevelController[id];

    rootIncarnation.incarnationsPentagonalCaveLevelController.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetPentagonalCaveLevelControllerHash(int id, int version, PentagonalCaveLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.depth.GetDeterministicHashCode();
    return result;
  }
       public IncendianFallsLevelLinkerTTCIncarnation GetIncendianFallsLevelLinkerTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC[id].incarnation;
  }
  public bool IncendianFallsLevelLinkerTTCExists(int id) {
    return rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(id);
  }
  public IncendianFallsLevelLinkerTTC GetIncendianFallsLevelLinkerTTC(int id) {
    CheckHasIncendianFallsLevelLinkerTTC(id);
    return new IncendianFallsLevelLinkerTTC(this, id);
  }
  public IncendianFallsLevelLinkerTTC GetIncendianFallsLevelLinkerTTCOrNull(int id) {
    if (IncendianFallsLevelLinkerTTCExists(id)) {
      return new IncendianFallsLevelLinkerTTC(this, id);
    } else {
      return new IncendianFallsLevelLinkerTTC(this, 0);
    }
  }
  public List<IncendianFallsLevelLinkerTTC> AllIncendianFallsLevelLinkerTTC() {
    List<IncendianFallsLevelLinkerTTC> result = new List<IncendianFallsLevelLinkerTTC>(rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.Count);
    foreach (var id in rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.Keys) {
      result.Add(new IncendianFallsLevelLinkerTTC(this, id));
    }
    return result;
  }
  public IEnumerator<IncendianFallsLevelLinkerTTC> EnumAllIncendianFallsLevelLinkerTTC() {
    foreach (var id in rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.Keys) {
      yield return GetIncendianFallsLevelLinkerTTC(id);
    }
  }
  public void CheckHasIncendianFallsLevelLinkerTTC(IncendianFallsLevelLinkerTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasIncendianFallsLevelLinkerTTC(thing.id);
  }
  public void CheckHasIncendianFallsLevelLinkerTTC(int id) {
    if (!rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid IncendianFallsLevelLinkerTTC: " + id);
    }
  }
  public IncendianFallsLevelLinkerTTC EffectIncendianFallsLevelLinkerTTCCreate(
      int thisLevelDepth) {
    return TrustedEffectIncendianFallsLevelLinkerTTCCreateWithId(NewId()
            ,thisLevelDepth    );
  }
  public IncendianFallsLevelLinkerTTC TrustedEffectIncendianFallsLevelLinkerTTCCreateWithId(int id
,      int thisLevelDepth) {
    CheckUnlocked();

    var incarnation =
        new IncendianFallsLevelLinkerTTCIncarnation(
            thisLevelDepth
            );
    return EffectInternalCreateIncendianFallsLevelLinkerTTC(id, rootIncarnation.version, incarnation);
  }
  public IncendianFallsLevelLinkerTTC EffectInternalCreateIncendianFallsLevelLinkerTTC(
      int id,
      int incarnationVersion,
      IncendianFallsLevelLinkerTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new IncendianFallsLevelLinkerTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.Add(
        id,
        new VersionAndIncarnation<IncendianFallsLevelLinkerTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new IncendianFallsLevelLinkerTTC(this, id);
  }

  public void EffectIncendianFallsLevelLinkerTTCDelete(int id) {
    CheckUnlocked();
    var effect = new IncendianFallsLevelLinkerTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC[id];

    rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetIncendianFallsLevelLinkerTTCHash(int id, int version, IncendianFallsLevelLinkerTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.thisLevelDepth.GetDeterministicHashCode();
    return result;
  }
       public CliffLevelControllerIncarnation GetCliffLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCliffLevelController[id].incarnation;
  }
  public bool CliffLevelControllerExists(int id) {
    return rootIncarnation.incarnationsCliffLevelController.ContainsKey(id);
  }
  public CliffLevelController GetCliffLevelController(int id) {
    CheckHasCliffLevelController(id);
    return new CliffLevelController(this, id);
  }
  public CliffLevelController GetCliffLevelControllerOrNull(int id) {
    if (CliffLevelControllerExists(id)) {
      return new CliffLevelController(this, id);
    } else {
      return new CliffLevelController(this, 0);
    }
  }
  public List<CliffLevelController> AllCliffLevelController() {
    List<CliffLevelController> result = new List<CliffLevelController>(rootIncarnation.incarnationsCliffLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsCliffLevelController.Keys) {
      result.Add(new CliffLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<CliffLevelController> EnumAllCliffLevelController() {
    foreach (var id in rootIncarnation.incarnationsCliffLevelController.Keys) {
      yield return GetCliffLevelController(id);
    }
  }
  public void CheckHasCliffLevelController(CliffLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCliffLevelController(thing.id);
  }
  public void CheckHasCliffLevelController(int id) {
    if (!rootIncarnation.incarnationsCliffLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid CliffLevelController: " + id);
    }
  }
  public CliffLevelController EffectCliffLevelControllerCreate(
      Level level,
      int depth) {
    CheckHasLevel(level);
    return TrustedEffectCliffLevelControllerCreateWithId(NewId()
            ,level.id
            ,depth    );
  }
  public CliffLevelController TrustedEffectCliffLevelControllerCreateWithId(int id
,      int level
,      int depth) {
    CheckUnlocked();

    var incarnation =
        new CliffLevelControllerIncarnation(
            level,
            depth
            );
    return EffectInternalCreateCliffLevelController(id, rootIncarnation.version, incarnation);
  }
  public CliffLevelController EffectInternalCreateCliffLevelController(
      int id,
      int incarnationVersion,
      CliffLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new CliffLevelControllerCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsCliffLevelController.Add(
        id,
        new VersionAndIncarnation<CliffLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new CliffLevelController(this, id);
  }

  public void EffectCliffLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new CliffLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCliffLevelController[id];

    rootIncarnation.incarnationsCliffLevelController.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetCliffLevelControllerHash(int id, int version, CliffLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.depth.GetDeterministicHashCode();
    return result;
  }
       public PreGauntletLevelControllerIncarnation GetPreGauntletLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsPreGauntletLevelController[id].incarnation;
  }
  public bool PreGauntletLevelControllerExists(int id) {
    return rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(id);
  }
  public PreGauntletLevelController GetPreGauntletLevelController(int id) {
    CheckHasPreGauntletLevelController(id);
    return new PreGauntletLevelController(this, id);
  }
  public PreGauntletLevelController GetPreGauntletLevelControllerOrNull(int id) {
    if (PreGauntletLevelControllerExists(id)) {
      return new PreGauntletLevelController(this, id);
    } else {
      return new PreGauntletLevelController(this, 0);
    }
  }
  public List<PreGauntletLevelController> AllPreGauntletLevelController() {
    List<PreGauntletLevelController> result = new List<PreGauntletLevelController>(rootIncarnation.incarnationsPreGauntletLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsPreGauntletLevelController.Keys) {
      result.Add(new PreGauntletLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<PreGauntletLevelController> EnumAllPreGauntletLevelController() {
    foreach (var id in rootIncarnation.incarnationsPreGauntletLevelController.Keys) {
      yield return GetPreGauntletLevelController(id);
    }
  }
  public void CheckHasPreGauntletLevelController(PreGauntletLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasPreGauntletLevelController(thing.id);
  }
  public void CheckHasPreGauntletLevelController(int id) {
    if (!rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid PreGauntletLevelController: " + id);
    }
  }
  public PreGauntletLevelController EffectPreGauntletLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectPreGauntletLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public PreGauntletLevelController TrustedEffectPreGauntletLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new PreGauntletLevelControllerIncarnation(
            level
            );
    return EffectInternalCreatePreGauntletLevelController(id, rootIncarnation.version, incarnation);
  }
  public PreGauntletLevelController EffectInternalCreatePreGauntletLevelController(
      int id,
      int incarnationVersion,
      PreGauntletLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new PreGauntletLevelControllerCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsPreGauntletLevelController.Add(
        id,
        new VersionAndIncarnation<PreGauntletLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new PreGauntletLevelController(this, id);
  }

  public void EffectPreGauntletLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new PreGauntletLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsPreGauntletLevelController[id];

    rootIncarnation.incarnationsPreGauntletLevelController.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetPreGauntletLevelControllerHash(int id, int version, PreGauntletLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public GauntletLevelControllerIncarnation GetGauntletLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsGauntletLevelController[id].incarnation;
  }
  public bool GauntletLevelControllerExists(int id) {
    return rootIncarnation.incarnationsGauntletLevelController.ContainsKey(id);
  }
  public GauntletLevelController GetGauntletLevelController(int id) {
    CheckHasGauntletLevelController(id);
    return new GauntletLevelController(this, id);
  }
  public GauntletLevelController GetGauntletLevelControllerOrNull(int id) {
    if (GauntletLevelControllerExists(id)) {
      return new GauntletLevelController(this, id);
    } else {
      return new GauntletLevelController(this, 0);
    }
  }
  public List<GauntletLevelController> AllGauntletLevelController() {
    List<GauntletLevelController> result = new List<GauntletLevelController>(rootIncarnation.incarnationsGauntletLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsGauntletLevelController.Keys) {
      result.Add(new GauntletLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<GauntletLevelController> EnumAllGauntletLevelController() {
    foreach (var id in rootIncarnation.incarnationsGauntletLevelController.Keys) {
      yield return GetGauntletLevelController(id);
    }
  }
  public void CheckHasGauntletLevelController(GauntletLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasGauntletLevelController(thing.id);
  }
  public void CheckHasGauntletLevelController(int id) {
    if (!rootIncarnation.incarnationsGauntletLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid GauntletLevelController: " + id);
    }
  }
  public GauntletLevelController EffectGauntletLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectGauntletLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public GauntletLevelController TrustedEffectGauntletLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new GauntletLevelControllerIncarnation(
            level
            );
    return EffectInternalCreateGauntletLevelController(id, rootIncarnation.version, incarnation);
  }
  public GauntletLevelController EffectInternalCreateGauntletLevelController(
      int id,
      int incarnationVersion,
      GauntletLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new GauntletLevelControllerCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsGauntletLevelController.Add(
        id,
        new VersionAndIncarnation<GauntletLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new GauntletLevelController(this, id);
  }

  public void EffectGauntletLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new GauntletLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsGauntletLevelController[id];

    rootIncarnation.incarnationsGauntletLevelController.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetGauntletLevelControllerHash(int id, int version, GauntletLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public CommIncarnation GetCommIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsComm[id].incarnation;
  }
  public bool CommExists(int id) {
    return rootIncarnation.incarnationsComm.ContainsKey(id);
  }
  public Comm GetComm(int id) {
    CheckHasComm(id);
    return new Comm(this, id);
  }
  public Comm GetCommOrNull(int id) {
    if (CommExists(id)) {
      return new Comm(this, id);
    } else {
      return new Comm(this, 0);
    }
  }
  public List<Comm> AllComm() {
    List<Comm> result = new List<Comm>(rootIncarnation.incarnationsComm.Count);
    foreach (var id in rootIncarnation.incarnationsComm.Keys) {
      result.Add(new Comm(this, id));
    }
    return result;
  }
  public IEnumerator<Comm> EnumAllComm() {
    foreach (var id in rootIncarnation.incarnationsComm.Keys) {
      yield return GetComm(id);
    }
  }
  public void CheckHasComm(Comm thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasComm(thing.id);
  }
  public void CheckHasComm(int id) {
    if (!rootIncarnation.incarnationsComm.ContainsKey(id)) {
      throw new System.Exception("Invalid Comm: " + id);
    }
  }
  public Comm EffectCommCreate(
      ICommTemplate template,
      CommActionImmList actions,
      CommTextImmList texts) {
    return TrustedEffectCommCreateWithId(NewId()
            ,template
            ,actions
            ,texts    );
  }
  public Comm TrustedEffectCommCreateWithId(int id
,      ICommTemplate template
,      CommActionImmList actions
,      CommTextImmList texts) {
    CheckUnlocked();

    var incarnation =
        new CommIncarnation(
            template,
            actions,
            texts
            );
    return EffectInternalCreateComm(id, rootIncarnation.version, incarnation);
  }
  public Comm EffectInternalCreateComm(
      int id,
      int incarnationVersion,
      CommIncarnation incarnation) {
    CheckUnlocked();
    var effect = new CommCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsComm.Add(
        id,
        new VersionAndIncarnation<CommIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new Comm(this, id);
  }

  public void EffectCommDelete(int id) {
    CheckUnlocked();
    var effect = new CommDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsComm[id];

    rootIncarnation.incarnationsComm.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetCommHash(int id, int version, CommIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.template.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.actions.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.texts.GetDeterministicHashCode();
    return result;
  }
       public GameIncarnation GetGameIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsGame[id].incarnation;
  }
  public bool GameExists(int id) {
    return rootIncarnation.incarnationsGame.ContainsKey(id);
  }
  public Game GetGame(int id) {
    CheckHasGame(id);
    return new Game(this, id);
  }
  public Game GetGameOrNull(int id) {
    if (GameExists(id)) {
      return new Game(this, id);
    } else {
      return new Game(this, 0);
    }
  }
  public List<Game> AllGame() {
    List<Game> result = new List<Game>(rootIncarnation.incarnationsGame.Count);
    foreach (var id in rootIncarnation.incarnationsGame.Keys) {
      result.Add(new Game(this, id));
    }
    return result;
  }
  public IEnumerator<Game> EnumAllGame() {
    foreach (var id in rootIncarnation.incarnationsGame.Keys) {
      yield return GetGame(id);
    }
  }
  public void CheckHasGame(Game thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasGame(thing.id);
  }
  public void CheckHasGame(int id) {
    if (!rootIncarnation.incarnationsGame.ContainsKey(id)) {
      throw new System.Exception("Invalid Game: " + id);
    }
  }
  public Game EffectGameCreate(
      Rand rand,
      bool squareLevelsOnly,
      LevelMutSet levels,
      Unit player,
      Level level,
      int time,
      Unit actingUnit,
      bool pauseBeforeNextUnit,
      int actionNum,
      string instructions,
      bool hideInput,
      IGameEvent evvent,
      CommMutList comms) {
    CheckHasRand(rand);
    CheckHasLevelMutSet(levels);
    CheckHasCommMutList(comms);
    return TrustedEffectGameCreateWithId(NewId()
            ,rand.id
            ,squareLevelsOnly
            ,levels.id
            ,player.id
            ,level.id
            ,time
            ,actingUnit.id
            ,pauseBeforeNextUnit
            ,actionNum
            ,instructions
            ,hideInput
            ,evvent
            ,comms.id    );
  }
  public Game TrustedEffectGameCreateWithId(int id
,      int rand
,      bool squareLevelsOnly
,      int levels
,      int player
,      int level
,      int time
,      int actingUnit
,      bool pauseBeforeNextUnit
,      int actionNum
,      string instructions
,      bool hideInput
,      IGameEvent evvent
,      int comms) {
    CheckUnlocked();

    var incarnation =
        new GameIncarnation(
            rand,
            squareLevelsOnly,
            levels,
            player,
            level,
            time,
            actingUnit,
            pauseBeforeNextUnit,
            actionNum,
            instructions,
            hideInput,
            evvent,
            comms
            );
    return EffectInternalCreateGame(id, rootIncarnation.version, incarnation);
  }
  public Game EffectInternalCreateGame(
      int id,
      int incarnationVersion,
      GameIncarnation incarnation) {
    CheckUnlocked();
    var effect = new GameCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsGame.Add(
        id,
        new VersionAndIncarnation<GameIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new Game(this, id);
  }

  public void EffectGameDelete(int id) {
    CheckUnlocked();
    var effect = new GameDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsGame[id];

    rootIncarnation.incarnationsGame.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetGameHash(int id, int version, GameIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.rand.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.squareLevelsOnly.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.levels.GetDeterministicHashCode();
    if (!object.ReferenceEquals(incarnation.player, null)) {
      result += id * version * 4 * incarnation.player.GetDeterministicHashCode();
    }
    if (!object.ReferenceEquals(incarnation.level, null)) {
      result += id * version * 5 * incarnation.level.GetDeterministicHashCode();
    }
    result += id * version * 6 * incarnation.time.GetDeterministicHashCode();
    if (!object.ReferenceEquals(incarnation.actingUnit, null)) {
      result += id * version * 7 * incarnation.actingUnit.GetDeterministicHashCode();
    }
    result += id * version * 8 * incarnation.pauseBeforeNextUnit.GetDeterministicHashCode();
    result += id * version * 9 * incarnation.actionNum.GetDeterministicHashCode();
    result += id * version * 10 * incarnation.instructions.GetDeterministicHashCode();
    result += id * version * 11 * incarnation.hideInput.GetDeterministicHashCode();
    if (!object.ReferenceEquals(incarnation.evvent, null)) {
      result += id * version * 12 * incarnation.evvent.GetDeterministicHashCode();
    }
    result += id * version * 13 * incarnation.comms.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectGameSetPlayer(int id, Unit newValue) {
    CheckUnlocked();
    CheckHasGame(id);
var effect = new GameSetPlayerEffect(id, newValue.id);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldId = oldIncarnationAndVersion.incarnation.player;
      oldIncarnationAndVersion.incarnation.player = newValue.id;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.levels,
              newValue.id,
              oldIncarnationAndVersion.incarnation.level,
              oldIncarnationAndVersion.incarnation.time,
              oldIncarnationAndVersion.incarnation.actingUnit,
              oldIncarnationAndVersion.incarnation.pauseBeforeNextUnit,
              oldIncarnationAndVersion.incarnation.actionNum,
              oldIncarnationAndVersion.incarnation.instructions,
              oldIncarnationAndVersion.incarnation.hideInput,
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.comms);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }

  public void EffectGameSetLevel(int id, Level newValue) {
    CheckUnlocked();
    CheckHasGame(id);
var effect = new GameSetLevelEffect(id, newValue.id);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldId = oldIncarnationAndVersion.incarnation.level;
      oldIncarnationAndVersion.incarnation.level = newValue.id;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.levels,
              oldIncarnationAndVersion.incarnation.player,
              newValue.id,
              oldIncarnationAndVersion.incarnation.time,
              oldIncarnationAndVersion.incarnation.actingUnit,
              oldIncarnationAndVersion.incarnation.pauseBeforeNextUnit,
              oldIncarnationAndVersion.incarnation.actionNum,
              oldIncarnationAndVersion.incarnation.instructions,
              oldIncarnationAndVersion.incarnation.hideInput,
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.comms);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }

  public void EffectGameSetTime(int id, int newValue) {
    CheckUnlocked();
    CheckHasGame(id);
var effect = new GameSetTimeEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.time;
      oldIncarnationAndVersion.incarnation.time = newValue;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.levels,
              oldIncarnationAndVersion.incarnation.player,
              oldIncarnationAndVersion.incarnation.level,
              newValue,
              oldIncarnationAndVersion.incarnation.actingUnit,
              oldIncarnationAndVersion.incarnation.pauseBeforeNextUnit,
              oldIncarnationAndVersion.incarnation.actionNum,
              oldIncarnationAndVersion.incarnation.instructions,
              oldIncarnationAndVersion.incarnation.hideInput,
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.comms);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }

  public void EffectGameSetActingUnit(int id, Unit newValue) {
    CheckUnlocked();
    CheckHasGame(id);
var effect = new GameSetActingUnitEffect(id, newValue.id);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldId = oldIncarnationAndVersion.incarnation.actingUnit;
      oldIncarnationAndVersion.incarnation.actingUnit = newValue.id;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.levels,
              oldIncarnationAndVersion.incarnation.player,
              oldIncarnationAndVersion.incarnation.level,
              oldIncarnationAndVersion.incarnation.time,
              newValue.id,
              oldIncarnationAndVersion.incarnation.pauseBeforeNextUnit,
              oldIncarnationAndVersion.incarnation.actionNum,
              oldIncarnationAndVersion.incarnation.instructions,
              oldIncarnationAndVersion.incarnation.hideInput,
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.comms);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }

  public void EffectGameSetPauseBeforeNextUnit(int id, bool newValue) {
    CheckUnlocked();
    CheckHasGame(id);
var effect = new GameSetPauseBeforeNextUnitEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.pauseBeforeNextUnit;
      oldIncarnationAndVersion.incarnation.pauseBeforeNextUnit = newValue;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.levels,
              oldIncarnationAndVersion.incarnation.player,
              oldIncarnationAndVersion.incarnation.level,
              oldIncarnationAndVersion.incarnation.time,
              oldIncarnationAndVersion.incarnation.actingUnit,
              newValue,
              oldIncarnationAndVersion.incarnation.actionNum,
              oldIncarnationAndVersion.incarnation.instructions,
              oldIncarnationAndVersion.incarnation.hideInput,
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.comms);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }

  public void EffectGameSetActionNum(int id, int newValue) {
    CheckUnlocked();
    CheckHasGame(id);
var effect = new GameSetActionNumEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.actionNum;
      oldIncarnationAndVersion.incarnation.actionNum = newValue;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.levels,
              oldIncarnationAndVersion.incarnation.player,
              oldIncarnationAndVersion.incarnation.level,
              oldIncarnationAndVersion.incarnation.time,
              oldIncarnationAndVersion.incarnation.actingUnit,
              oldIncarnationAndVersion.incarnation.pauseBeforeNextUnit,
              newValue,
              oldIncarnationAndVersion.incarnation.instructions,
              oldIncarnationAndVersion.incarnation.hideInput,
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.comms);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }

  public void EffectGameSetInstructions(int id, string newValue) {
    CheckUnlocked();
    CheckHasGame(id);
var effect = new GameSetInstructionsEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.instructions;
      oldIncarnationAndVersion.incarnation.instructions = newValue;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.levels,
              oldIncarnationAndVersion.incarnation.player,
              oldIncarnationAndVersion.incarnation.level,
              oldIncarnationAndVersion.incarnation.time,
              oldIncarnationAndVersion.incarnation.actingUnit,
              oldIncarnationAndVersion.incarnation.pauseBeforeNextUnit,
              oldIncarnationAndVersion.incarnation.actionNum,
              newValue,
              oldIncarnationAndVersion.incarnation.hideInput,
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.comms);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }

  public void EffectGameSetHideInput(int id, bool newValue) {
    CheckUnlocked();
    CheckHasGame(id);
var effect = new GameSetHideInputEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.hideInput;
      oldIncarnationAndVersion.incarnation.hideInput = newValue;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.levels,
              oldIncarnationAndVersion.incarnation.player,
              oldIncarnationAndVersion.incarnation.level,
              oldIncarnationAndVersion.incarnation.time,
              oldIncarnationAndVersion.incarnation.actingUnit,
              oldIncarnationAndVersion.incarnation.pauseBeforeNextUnit,
              oldIncarnationAndVersion.incarnation.actionNum,
              oldIncarnationAndVersion.incarnation.instructions,
              newValue,
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.comms);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }

  public void EffectGameSetEvvent(int id, IGameEvent newValue) {
    CheckUnlocked();
    CheckHasGame(id);
var effect = new GameSetEvventEffect(id, newValue);
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.evvent;
      oldIncarnationAndVersion.incarnation.evvent = newValue;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.levels,
              oldIncarnationAndVersion.incarnation.player,
              oldIncarnationAndVersion.incarnation.level,
              oldIncarnationAndVersion.incarnation.time,
              oldIncarnationAndVersion.incarnation.actingUnit,
              oldIncarnationAndVersion.incarnation.pauseBeforeNextUnit,
              oldIncarnationAndVersion.incarnation.actionNum,
              oldIncarnationAndVersion.incarnation.instructions,
              oldIncarnationAndVersion.incarnation.hideInput,
              newValue,
              oldIncarnationAndVersion.incarnation.comms);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

    NotifyEffect(effect);
  }
  public VolcaetusLevelControllerIncarnation GetVolcaetusLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsVolcaetusLevelController[id].incarnation;
  }
  public bool VolcaetusLevelControllerExists(int id) {
    return rootIncarnation.incarnationsVolcaetusLevelController.ContainsKey(id);
  }
  public VolcaetusLevelController GetVolcaetusLevelController(int id) {
    CheckHasVolcaetusLevelController(id);
    return new VolcaetusLevelController(this, id);
  }
  public VolcaetusLevelController GetVolcaetusLevelControllerOrNull(int id) {
    if (VolcaetusLevelControllerExists(id)) {
      return new VolcaetusLevelController(this, id);
    } else {
      return new VolcaetusLevelController(this, 0);
    }
  }
  public List<VolcaetusLevelController> AllVolcaetusLevelController() {
    List<VolcaetusLevelController> result = new List<VolcaetusLevelController>(rootIncarnation.incarnationsVolcaetusLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsVolcaetusLevelController.Keys) {
      result.Add(new VolcaetusLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<VolcaetusLevelController> EnumAllVolcaetusLevelController() {
    foreach (var id in rootIncarnation.incarnationsVolcaetusLevelController.Keys) {
      yield return GetVolcaetusLevelController(id);
    }
  }
  public void CheckHasVolcaetusLevelController(VolcaetusLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasVolcaetusLevelController(thing.id);
  }
  public void CheckHasVolcaetusLevelController(int id) {
    if (!rootIncarnation.incarnationsVolcaetusLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid VolcaetusLevelController: " + id);
    }
  }
  public VolcaetusLevelController EffectVolcaetusLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectVolcaetusLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public VolcaetusLevelController TrustedEffectVolcaetusLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new VolcaetusLevelControllerIncarnation(
            level
            );
    return EffectInternalCreateVolcaetusLevelController(id, rootIncarnation.version, incarnation);
  }
  public VolcaetusLevelController EffectInternalCreateVolcaetusLevelController(
      int id,
      int incarnationVersion,
      VolcaetusLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new VolcaetusLevelControllerCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsVolcaetusLevelController.Add(
        id,
        new VersionAndIncarnation<VolcaetusLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new VolcaetusLevelController(this, id);
  }

  public void EffectVolcaetusLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new VolcaetusLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsVolcaetusLevelController[id];

    rootIncarnation.incarnationsVolcaetusLevelController.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetVolcaetusLevelControllerHash(int id, int version, VolcaetusLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public Tutorial2LevelControllerIncarnation GetTutorial2LevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTutorial2LevelController[id].incarnation;
  }
  public bool Tutorial2LevelControllerExists(int id) {
    return rootIncarnation.incarnationsTutorial2LevelController.ContainsKey(id);
  }
  public Tutorial2LevelController GetTutorial2LevelController(int id) {
    CheckHasTutorial2LevelController(id);
    return new Tutorial2LevelController(this, id);
  }
  public Tutorial2LevelController GetTutorial2LevelControllerOrNull(int id) {
    if (Tutorial2LevelControllerExists(id)) {
      return new Tutorial2LevelController(this, id);
    } else {
      return new Tutorial2LevelController(this, 0);
    }
  }
  public List<Tutorial2LevelController> AllTutorial2LevelController() {
    List<Tutorial2LevelController> result = new List<Tutorial2LevelController>(rootIncarnation.incarnationsTutorial2LevelController.Count);
    foreach (var id in rootIncarnation.incarnationsTutorial2LevelController.Keys) {
      result.Add(new Tutorial2LevelController(this, id));
    }
    return result;
  }
  public IEnumerator<Tutorial2LevelController> EnumAllTutorial2LevelController() {
    foreach (var id in rootIncarnation.incarnationsTutorial2LevelController.Keys) {
      yield return GetTutorial2LevelController(id);
    }
  }
  public void CheckHasTutorial2LevelController(Tutorial2LevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTutorial2LevelController(thing.id);
  }
  public void CheckHasTutorial2LevelController(int id) {
    if (!rootIncarnation.incarnationsTutorial2LevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid Tutorial2LevelController: " + id);
    }
  }
  public Tutorial2LevelController EffectTutorial2LevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectTutorial2LevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public Tutorial2LevelController TrustedEffectTutorial2LevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new Tutorial2LevelControllerIncarnation(
            level
            );
    return EffectInternalCreateTutorial2LevelController(id, rootIncarnation.version, incarnation);
  }
  public Tutorial2LevelController EffectInternalCreateTutorial2LevelController(
      int id,
      int incarnationVersion,
      Tutorial2LevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new Tutorial2LevelControllerCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsTutorial2LevelController.Add(
        id,
        new VersionAndIncarnation<Tutorial2LevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new Tutorial2LevelController(this, id);
  }

  public void EffectTutorial2LevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new Tutorial2LevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTutorial2LevelController[id];

    rootIncarnation.incarnationsTutorial2LevelController.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetTutorial2LevelControllerHash(int id, int version, Tutorial2LevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public Tutorial1LevelControllerIncarnation GetTutorial1LevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTutorial1LevelController[id].incarnation;
  }
  public bool Tutorial1LevelControllerExists(int id) {
    return rootIncarnation.incarnationsTutorial1LevelController.ContainsKey(id);
  }
  public Tutorial1LevelController GetTutorial1LevelController(int id) {
    CheckHasTutorial1LevelController(id);
    return new Tutorial1LevelController(this, id);
  }
  public Tutorial1LevelController GetTutorial1LevelControllerOrNull(int id) {
    if (Tutorial1LevelControllerExists(id)) {
      return new Tutorial1LevelController(this, id);
    } else {
      return new Tutorial1LevelController(this, 0);
    }
  }
  public List<Tutorial1LevelController> AllTutorial1LevelController() {
    List<Tutorial1LevelController> result = new List<Tutorial1LevelController>(rootIncarnation.incarnationsTutorial1LevelController.Count);
    foreach (var id in rootIncarnation.incarnationsTutorial1LevelController.Keys) {
      result.Add(new Tutorial1LevelController(this, id));
    }
    return result;
  }
  public IEnumerator<Tutorial1LevelController> EnumAllTutorial1LevelController() {
    foreach (var id in rootIncarnation.incarnationsTutorial1LevelController.Keys) {
      yield return GetTutorial1LevelController(id);
    }
  }
  public void CheckHasTutorial1LevelController(Tutorial1LevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTutorial1LevelController(thing.id);
  }
  public void CheckHasTutorial1LevelController(int id) {
    if (!rootIncarnation.incarnationsTutorial1LevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid Tutorial1LevelController: " + id);
    }
  }
  public Tutorial1LevelController EffectTutorial1LevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectTutorial1LevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public Tutorial1LevelController TrustedEffectTutorial1LevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new Tutorial1LevelControllerIncarnation(
            level
            );
    return EffectInternalCreateTutorial1LevelController(id, rootIncarnation.version, incarnation);
  }
  public Tutorial1LevelController EffectInternalCreateTutorial1LevelController(
      int id,
      int incarnationVersion,
      Tutorial1LevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new Tutorial1LevelControllerCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsTutorial1LevelController.Add(
        id,
        new VersionAndIncarnation<Tutorial1LevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new Tutorial1LevelController(this, id);
  }

  public void EffectTutorial1LevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new Tutorial1LevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTutorial1LevelController[id];

    rootIncarnation.incarnationsTutorial1LevelController.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetTutorial1LevelControllerHash(int id, int version, Tutorial1LevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public RetreatLevelControllerIncarnation GetRetreatLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsRetreatLevelController[id].incarnation;
  }
  public bool RetreatLevelControllerExists(int id) {
    return rootIncarnation.incarnationsRetreatLevelController.ContainsKey(id);
  }
  public RetreatLevelController GetRetreatLevelController(int id) {
    CheckHasRetreatLevelController(id);
    return new RetreatLevelController(this, id);
  }
  public RetreatLevelController GetRetreatLevelControllerOrNull(int id) {
    if (RetreatLevelControllerExists(id)) {
      return new RetreatLevelController(this, id);
    } else {
      return new RetreatLevelController(this, 0);
    }
  }
  public List<RetreatLevelController> AllRetreatLevelController() {
    List<RetreatLevelController> result = new List<RetreatLevelController>(rootIncarnation.incarnationsRetreatLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsRetreatLevelController.Keys) {
      result.Add(new RetreatLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<RetreatLevelController> EnumAllRetreatLevelController() {
    foreach (var id in rootIncarnation.incarnationsRetreatLevelController.Keys) {
      yield return GetRetreatLevelController(id);
    }
  }
  public void CheckHasRetreatLevelController(RetreatLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasRetreatLevelController(thing.id);
  }
  public void CheckHasRetreatLevelController(int id) {
    if (!rootIncarnation.incarnationsRetreatLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid RetreatLevelController: " + id);
    }
  }
  public RetreatLevelController EffectRetreatLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectRetreatLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public RetreatLevelController TrustedEffectRetreatLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new RetreatLevelControllerIncarnation(
            level
            );
    return EffectInternalCreateRetreatLevelController(id, rootIncarnation.version, incarnation);
  }
  public RetreatLevelController EffectInternalCreateRetreatLevelController(
      int id,
      int incarnationVersion,
      RetreatLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new RetreatLevelControllerCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsRetreatLevelController.Add(
        id,
        new VersionAndIncarnation<RetreatLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new RetreatLevelController(this, id);
  }

  public void EffectRetreatLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new RetreatLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsRetreatLevelController[id];

    rootIncarnation.incarnationsRetreatLevelController.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetRetreatLevelControllerHash(int id, int version, RetreatLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public SotaventoLevelControllerIncarnation GetSotaventoLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsSotaventoLevelController[id].incarnation;
  }
  public bool SotaventoLevelControllerExists(int id) {
    return rootIncarnation.incarnationsSotaventoLevelController.ContainsKey(id);
  }
  public SotaventoLevelController GetSotaventoLevelController(int id) {
    CheckHasSotaventoLevelController(id);
    return new SotaventoLevelController(this, id);
  }
  public SotaventoLevelController GetSotaventoLevelControllerOrNull(int id) {
    if (SotaventoLevelControllerExists(id)) {
      return new SotaventoLevelController(this, id);
    } else {
      return new SotaventoLevelController(this, 0);
    }
  }
  public List<SotaventoLevelController> AllSotaventoLevelController() {
    List<SotaventoLevelController> result = new List<SotaventoLevelController>(rootIncarnation.incarnationsSotaventoLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsSotaventoLevelController.Keys) {
      result.Add(new SotaventoLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<SotaventoLevelController> EnumAllSotaventoLevelController() {
    foreach (var id in rootIncarnation.incarnationsSotaventoLevelController.Keys) {
      yield return GetSotaventoLevelController(id);
    }
  }
  public void CheckHasSotaventoLevelController(SotaventoLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasSotaventoLevelController(thing.id);
  }
  public void CheckHasSotaventoLevelController(int id) {
    if (!rootIncarnation.incarnationsSotaventoLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid SotaventoLevelController: " + id);
    }
  }
  public SotaventoLevelController EffectSotaventoLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectSotaventoLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public SotaventoLevelController TrustedEffectSotaventoLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new SotaventoLevelControllerIncarnation(
            level
            );
    return EffectInternalCreateSotaventoLevelController(id, rootIncarnation.version, incarnation);
  }
  public SotaventoLevelController EffectInternalCreateSotaventoLevelController(
      int id,
      int incarnationVersion,
      SotaventoLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new SotaventoLevelControllerCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsSotaventoLevelController.Add(
        id,
        new VersionAndIncarnation<SotaventoLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new SotaventoLevelController(this, id);
  }

  public void EffectSotaventoLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new SotaventoLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsSotaventoLevelController[id];

    rootIncarnation.incarnationsSotaventoLevelController.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetSotaventoLevelControllerHash(int id, int version, SotaventoLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public NestLevelControllerIncarnation GetNestLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsNestLevelController[id].incarnation;
  }
  public bool NestLevelControllerExists(int id) {
    return rootIncarnation.incarnationsNestLevelController.ContainsKey(id);
  }
  public NestLevelController GetNestLevelController(int id) {
    CheckHasNestLevelController(id);
    return new NestLevelController(this, id);
  }
  public NestLevelController GetNestLevelControllerOrNull(int id) {
    if (NestLevelControllerExists(id)) {
      return new NestLevelController(this, id);
    } else {
      return new NestLevelController(this, 0);
    }
  }
  public List<NestLevelController> AllNestLevelController() {
    List<NestLevelController> result = new List<NestLevelController>(rootIncarnation.incarnationsNestLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsNestLevelController.Keys) {
      result.Add(new NestLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<NestLevelController> EnumAllNestLevelController() {
    foreach (var id in rootIncarnation.incarnationsNestLevelController.Keys) {
      yield return GetNestLevelController(id);
    }
  }
  public void CheckHasNestLevelController(NestLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasNestLevelController(thing.id);
  }
  public void CheckHasNestLevelController(int id) {
    if (!rootIncarnation.incarnationsNestLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid NestLevelController: " + id);
    }
  }
  public NestLevelController EffectNestLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectNestLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public NestLevelController TrustedEffectNestLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new NestLevelControllerIncarnation(
            level
            );
    return EffectInternalCreateNestLevelController(id, rootIncarnation.version, incarnation);
  }
  public NestLevelController EffectInternalCreateNestLevelController(
      int id,
      int incarnationVersion,
      NestLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new NestLevelControllerCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsNestLevelController.Add(
        id,
        new VersionAndIncarnation<NestLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new NestLevelController(this, id);
  }

  public void EffectNestLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new NestLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsNestLevelController[id];

    rootIncarnation.incarnationsNestLevelController.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetNestLevelControllerHash(int id, int version, NestLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public LakeLevelControllerIncarnation GetLakeLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsLakeLevelController[id].incarnation;
  }
  public bool LakeLevelControllerExists(int id) {
    return rootIncarnation.incarnationsLakeLevelController.ContainsKey(id);
  }
  public LakeLevelController GetLakeLevelController(int id) {
    CheckHasLakeLevelController(id);
    return new LakeLevelController(this, id);
  }
  public LakeLevelController GetLakeLevelControllerOrNull(int id) {
    if (LakeLevelControllerExists(id)) {
      return new LakeLevelController(this, id);
    } else {
      return new LakeLevelController(this, 0);
    }
  }
  public List<LakeLevelController> AllLakeLevelController() {
    List<LakeLevelController> result = new List<LakeLevelController>(rootIncarnation.incarnationsLakeLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsLakeLevelController.Keys) {
      result.Add(new LakeLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<LakeLevelController> EnumAllLakeLevelController() {
    foreach (var id in rootIncarnation.incarnationsLakeLevelController.Keys) {
      yield return GetLakeLevelController(id);
    }
  }
  public void CheckHasLakeLevelController(LakeLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasLakeLevelController(thing.id);
  }
  public void CheckHasLakeLevelController(int id) {
    if (!rootIncarnation.incarnationsLakeLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid LakeLevelController: " + id);
    }
  }
  public LakeLevelController EffectLakeLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectLakeLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public LakeLevelController TrustedEffectLakeLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new LakeLevelControllerIncarnation(
            level
            );
    return EffectInternalCreateLakeLevelController(id, rootIncarnation.version, incarnation);
  }
  public LakeLevelController EffectInternalCreateLakeLevelController(
      int id,
      int incarnationVersion,
      LakeLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new LakeLevelControllerCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsLakeLevelController.Add(
        id,
        new VersionAndIncarnation<LakeLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new LakeLevelController(this, id);
  }

  public void EffectLakeLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new LakeLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsLakeLevelController[id];

    rootIncarnation.incarnationsLakeLevelController.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetLakeLevelControllerHash(int id, int version, LakeLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public EmberDeepLevelLinkerTTCIncarnation GetEmberDeepLevelLinkerTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsEmberDeepLevelLinkerTTC[id].incarnation;
  }
  public bool EmberDeepLevelLinkerTTCExists(int id) {
    return rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(id);
  }
  public EmberDeepLevelLinkerTTC GetEmberDeepLevelLinkerTTC(int id) {
    CheckHasEmberDeepLevelLinkerTTC(id);
    return new EmberDeepLevelLinkerTTC(this, id);
  }
  public EmberDeepLevelLinkerTTC GetEmberDeepLevelLinkerTTCOrNull(int id) {
    if (EmberDeepLevelLinkerTTCExists(id)) {
      return new EmberDeepLevelLinkerTTC(this, id);
    } else {
      return new EmberDeepLevelLinkerTTC(this, 0);
    }
  }
  public List<EmberDeepLevelLinkerTTC> AllEmberDeepLevelLinkerTTC() {
    List<EmberDeepLevelLinkerTTC> result = new List<EmberDeepLevelLinkerTTC>(rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.Count);
    foreach (var id in rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.Keys) {
      result.Add(new EmberDeepLevelLinkerTTC(this, id));
    }
    return result;
  }
  public IEnumerator<EmberDeepLevelLinkerTTC> EnumAllEmberDeepLevelLinkerTTC() {
    foreach (var id in rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.Keys) {
      yield return GetEmberDeepLevelLinkerTTC(id);
    }
  }
  public void CheckHasEmberDeepLevelLinkerTTC(EmberDeepLevelLinkerTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasEmberDeepLevelLinkerTTC(thing.id);
  }
  public void CheckHasEmberDeepLevelLinkerTTC(int id) {
    if (!rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid EmberDeepLevelLinkerTTC: " + id);
    }
  }
  public EmberDeepLevelLinkerTTC EffectEmberDeepLevelLinkerTTCCreate(
      int nextLevelDepth) {
    return TrustedEffectEmberDeepLevelLinkerTTCCreateWithId(NewId()
            ,nextLevelDepth    );
  }
  public EmberDeepLevelLinkerTTC TrustedEffectEmberDeepLevelLinkerTTCCreateWithId(int id
,      int nextLevelDepth) {
    CheckUnlocked();

    var incarnation =
        new EmberDeepLevelLinkerTTCIncarnation(
            nextLevelDepth
            );
    return EffectInternalCreateEmberDeepLevelLinkerTTC(id, rootIncarnation.version, incarnation);
  }
  public EmberDeepLevelLinkerTTC EffectInternalCreateEmberDeepLevelLinkerTTC(
      int id,
      int incarnationVersion,
      EmberDeepLevelLinkerTTCIncarnation incarnation) {
    CheckUnlocked();
    var effect = new EmberDeepLevelLinkerTTCCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.Add(
        id,
        new VersionAndIncarnation<EmberDeepLevelLinkerTTCIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new EmberDeepLevelLinkerTTC(this, id);
  }

  public void EffectEmberDeepLevelLinkerTTCDelete(int id) {
    CheckUnlocked();
    var effect = new EmberDeepLevelLinkerTTCDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsEmberDeepLevelLinkerTTC[id];

    rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetEmberDeepLevelLinkerTTCHash(int id, int version, EmberDeepLevelLinkerTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.nextLevelDepth.GetDeterministicHashCode();
    return result;
  }
       public DirtRoadLevelControllerIncarnation GetDirtRoadLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsDirtRoadLevelController[id].incarnation;
  }
  public bool DirtRoadLevelControllerExists(int id) {
    return rootIncarnation.incarnationsDirtRoadLevelController.ContainsKey(id);
  }
  public DirtRoadLevelController GetDirtRoadLevelController(int id) {
    CheckHasDirtRoadLevelController(id);
    return new DirtRoadLevelController(this, id);
  }
  public DirtRoadLevelController GetDirtRoadLevelControllerOrNull(int id) {
    if (DirtRoadLevelControllerExists(id)) {
      return new DirtRoadLevelController(this, id);
    } else {
      return new DirtRoadLevelController(this, 0);
    }
  }
  public List<DirtRoadLevelController> AllDirtRoadLevelController() {
    List<DirtRoadLevelController> result = new List<DirtRoadLevelController>(rootIncarnation.incarnationsDirtRoadLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsDirtRoadLevelController.Keys) {
      result.Add(new DirtRoadLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<DirtRoadLevelController> EnumAllDirtRoadLevelController() {
    foreach (var id in rootIncarnation.incarnationsDirtRoadLevelController.Keys) {
      yield return GetDirtRoadLevelController(id);
    }
  }
  public void CheckHasDirtRoadLevelController(DirtRoadLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasDirtRoadLevelController(thing.id);
  }
  public void CheckHasDirtRoadLevelController(int id) {
    if (!rootIncarnation.incarnationsDirtRoadLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid DirtRoadLevelController: " + id);
    }
  }
  public DirtRoadLevelController EffectDirtRoadLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectDirtRoadLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public DirtRoadLevelController TrustedEffectDirtRoadLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new DirtRoadLevelControllerIncarnation(
            level
            );
    return EffectInternalCreateDirtRoadLevelController(id, rootIncarnation.version, incarnation);
  }
  public DirtRoadLevelController EffectInternalCreateDirtRoadLevelController(
      int id,
      int incarnationVersion,
      DirtRoadLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new DirtRoadLevelControllerCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsDirtRoadLevelController.Add(
        id,
        new VersionAndIncarnation<DirtRoadLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new DirtRoadLevelController(this, id);
  }

  public void EffectDirtRoadLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new DirtRoadLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsDirtRoadLevelController[id];

    rootIncarnation.incarnationsDirtRoadLevelController.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetDirtRoadLevelControllerHash(int id, int version, DirtRoadLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public CaveLevelControllerIncarnation GetCaveLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCaveLevelController[id].incarnation;
  }
  public bool CaveLevelControllerExists(int id) {
    return rootIncarnation.incarnationsCaveLevelController.ContainsKey(id);
  }
  public CaveLevelController GetCaveLevelController(int id) {
    CheckHasCaveLevelController(id);
    return new CaveLevelController(this, id);
  }
  public CaveLevelController GetCaveLevelControllerOrNull(int id) {
    if (CaveLevelControllerExists(id)) {
      return new CaveLevelController(this, id);
    } else {
      return new CaveLevelController(this, 0);
    }
  }
  public List<CaveLevelController> AllCaveLevelController() {
    List<CaveLevelController> result = new List<CaveLevelController>(rootIncarnation.incarnationsCaveLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsCaveLevelController.Keys) {
      result.Add(new CaveLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<CaveLevelController> EnumAllCaveLevelController() {
    foreach (var id in rootIncarnation.incarnationsCaveLevelController.Keys) {
      yield return GetCaveLevelController(id);
    }
  }
  public void CheckHasCaveLevelController(CaveLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCaveLevelController(thing.id);
  }
  public void CheckHasCaveLevelController(int id) {
    if (!rootIncarnation.incarnationsCaveLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid CaveLevelController: " + id);
    }
  }
  public CaveLevelController EffectCaveLevelControllerCreate(
      Level level,
      int depth) {
    CheckHasLevel(level);
    return TrustedEffectCaveLevelControllerCreateWithId(NewId()
            ,level.id
            ,depth    );
  }
  public CaveLevelController TrustedEffectCaveLevelControllerCreateWithId(int id
,      int level
,      int depth) {
    CheckUnlocked();

    var incarnation =
        new CaveLevelControllerIncarnation(
            level,
            depth
            );
    return EffectInternalCreateCaveLevelController(id, rootIncarnation.version, incarnation);
  }
  public CaveLevelController EffectInternalCreateCaveLevelController(
      int id,
      int incarnationVersion,
      CaveLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new CaveLevelControllerCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsCaveLevelController.Add(
        id,
        new VersionAndIncarnation<CaveLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new CaveLevelController(this, id);
  }

  public void EffectCaveLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new CaveLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCaveLevelController[id];

    rootIncarnation.incarnationsCaveLevelController.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetCaveLevelControllerHash(int id, int version, CaveLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.depth.GetDeterministicHashCode();
    return result;
  }
       public BridgesLevelControllerIncarnation GetBridgesLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBridgesLevelController[id].incarnation;
  }
  public bool BridgesLevelControllerExists(int id) {
    return rootIncarnation.incarnationsBridgesLevelController.ContainsKey(id);
  }
  public BridgesLevelController GetBridgesLevelController(int id) {
    CheckHasBridgesLevelController(id);
    return new BridgesLevelController(this, id);
  }
  public BridgesLevelController GetBridgesLevelControllerOrNull(int id) {
    if (BridgesLevelControllerExists(id)) {
      return new BridgesLevelController(this, id);
    } else {
      return new BridgesLevelController(this, 0);
    }
  }
  public List<BridgesLevelController> AllBridgesLevelController() {
    List<BridgesLevelController> result = new List<BridgesLevelController>(rootIncarnation.incarnationsBridgesLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsBridgesLevelController.Keys) {
      result.Add(new BridgesLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<BridgesLevelController> EnumAllBridgesLevelController() {
    foreach (var id in rootIncarnation.incarnationsBridgesLevelController.Keys) {
      yield return GetBridgesLevelController(id);
    }
  }
  public void CheckHasBridgesLevelController(BridgesLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBridgesLevelController(thing.id);
  }
  public void CheckHasBridgesLevelController(int id) {
    if (!rootIncarnation.incarnationsBridgesLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid BridgesLevelController: " + id);
    }
  }
  public BridgesLevelController EffectBridgesLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectBridgesLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public BridgesLevelController TrustedEffectBridgesLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new BridgesLevelControllerIncarnation(
            level
            );
    return EffectInternalCreateBridgesLevelController(id, rootIncarnation.version, incarnation);
  }
  public BridgesLevelController EffectInternalCreateBridgesLevelController(
      int id,
      int incarnationVersion,
      BridgesLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new BridgesLevelControllerCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsBridgesLevelController.Add(
        id,
        new VersionAndIncarnation<BridgesLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new BridgesLevelController(this, id);
  }

  public void EffectBridgesLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new BridgesLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBridgesLevelController[id];

    rootIncarnation.incarnationsBridgesLevelController.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetBridgesLevelControllerHash(int id, int version, BridgesLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public AncientTownLevelControllerIncarnation GetAncientTownLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsAncientTownLevelController[id].incarnation;
  }
  public bool AncientTownLevelControllerExists(int id) {
    return rootIncarnation.incarnationsAncientTownLevelController.ContainsKey(id);
  }
  public AncientTownLevelController GetAncientTownLevelController(int id) {
    CheckHasAncientTownLevelController(id);
    return new AncientTownLevelController(this, id);
  }
  public AncientTownLevelController GetAncientTownLevelControllerOrNull(int id) {
    if (AncientTownLevelControllerExists(id)) {
      return new AncientTownLevelController(this, id);
    } else {
      return new AncientTownLevelController(this, 0);
    }
  }
  public List<AncientTownLevelController> AllAncientTownLevelController() {
    List<AncientTownLevelController> result = new List<AncientTownLevelController>(rootIncarnation.incarnationsAncientTownLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsAncientTownLevelController.Keys) {
      result.Add(new AncientTownLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<AncientTownLevelController> EnumAllAncientTownLevelController() {
    foreach (var id in rootIncarnation.incarnationsAncientTownLevelController.Keys) {
      yield return GetAncientTownLevelController(id);
    }
  }
  public void CheckHasAncientTownLevelController(AncientTownLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasAncientTownLevelController(thing.id);
  }
  public void CheckHasAncientTownLevelController(int id) {
    if (!rootIncarnation.incarnationsAncientTownLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid AncientTownLevelController: " + id);
    }
  }
  public AncientTownLevelController EffectAncientTownLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectAncientTownLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public AncientTownLevelController TrustedEffectAncientTownLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new AncientTownLevelControllerIncarnation(
            level
            );
    return EffectInternalCreateAncientTownLevelController(id, rootIncarnation.version, incarnation);
  }
  public AncientTownLevelController EffectInternalCreateAncientTownLevelController(
      int id,
      int incarnationVersion,
      AncientTownLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    var effect = new AncientTownLevelControllerCreateEffect(id, incarnation.Copy());
    rootIncarnation.incarnationsAncientTownLevelController.Add(
        id,
        new VersionAndIncarnation<AncientTownLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    NotifyEffect(effect);
    return new AncientTownLevelController(this, id);
  }

  public void EffectAncientTownLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = new AncientTownLevelControllerDeleteEffect(id);

    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsAncientTownLevelController[id];

    rootIncarnation.incarnationsAncientTownLevelController.Remove(id);
    NotifyEffect(effect);
  }

     
  public int GetAncientTownLevelControllerHash(int id, int version, AncientTownLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
     
  public IDeathPreReactor GetIDeathPreReactor(int id) {
    if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      return new KamikazeAICapabilityUCAsIDeathPreReactor(new KamikazeAICapabilityUC(this, id));
    }
    throw new Exception("Unknown IDeathPreReactor: " + id);
  }
  public IDeathPreReactor GetIDeathPreReactorOrNull(int id) {
    if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      return new KamikazeAICapabilityUCAsIDeathPreReactor(new KamikazeAICapabilityUC(this, id));
    }
    return NullIDeathPreReactor.Null;
  }
  public bool IDeathPreReactorExists(int id) {
    return GetIDeathPreReactorOrNull(id) != null;
  }
  public void CheckHasIDeathPreReactor(IDeathPreReactor thing) {
    GetIDeathPreReactor(thing.id);
  }
  public void CheckHasIDeathPreReactor(int id) {
    GetIDeathPreReactor(id);
  }

  public IImpulsePostReactor GetIImpulsePostReactor(int id) {
    if (rootIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(id)) {
      return new TutorialDefyCounterUCAsIImpulsePostReactor(new TutorialDefyCounterUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIImpulsePostReactor(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIImpulsePostReactor(new AttackAICapabilityUC(this, id));
    }
    throw new Exception("Unknown IImpulsePostReactor: " + id);
  }
  public IImpulsePostReactor GetIImpulsePostReactorOrNull(int id) {
    if (rootIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(id)) {
      return new TutorialDefyCounterUCAsIImpulsePostReactor(new TutorialDefyCounterUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIImpulsePostReactor(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIImpulsePostReactor(new AttackAICapabilityUC(this, id));
    }
    return NullIImpulsePostReactor.Null;
  }
  public bool IImpulsePostReactorExists(int id) {
    return GetIImpulsePostReactorOrNull(id) != null;
  }
  public void CheckHasIImpulsePostReactor(IImpulsePostReactor thing) {
    GetIImpulsePostReactor(thing.id);
  }
  public void CheckHasIImpulsePostReactor(int id) {
    GetIImpulsePostReactor(id);
  }

  public IImpulsePreReactor GetIImpulsePreReactor(int id) {
    if (rootIncarnation.incarnationsLightningChargingUC.ContainsKey(id)) {
      return new LightningChargingUCAsIImpulsePreReactor(new LightningChargingUC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      return new KamikazeAICapabilityUCAsIImpulsePreReactor(new KamikazeAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIImpulsePreReactor(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIImpulsePreReactor(new AttackAICapabilityUC(this, id));
    }
    throw new Exception("Unknown IImpulsePreReactor: " + id);
  }
  public IImpulsePreReactor GetIImpulsePreReactorOrNull(int id) {
    if (rootIncarnation.incarnationsLightningChargingUC.ContainsKey(id)) {
      return new LightningChargingUCAsIImpulsePreReactor(new LightningChargingUC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      return new KamikazeAICapabilityUCAsIImpulsePreReactor(new KamikazeAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIImpulsePreReactor(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIImpulsePreReactor(new AttackAICapabilityUC(this, id));
    }
    return NullIImpulsePreReactor.Null;
  }
  public bool IImpulsePreReactorExists(int id) {
    return GetIImpulsePreReactorOrNull(id) != null;
  }
  public void CheckHasIImpulsePreReactor(IImpulsePreReactor thing) {
    GetIImpulsePreReactor(thing.id);
  }
  public void CheckHasIImpulsePreReactor(int id) {
    GetIImpulsePreReactor(id);
  }

  public IAICapabilityUC GetIAICapabilityUC(int id) {
    if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      return new WanderAICapabilityUCAsIAICapabilityUC(new WanderAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(id)) {
      return new TemporaryCloneAICapabilityUCAsIAICapabilityUC(new TemporaryCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(id)) {
      return new SummonAICapabilityUCAsIAICapabilityUC(new SummonAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIAICapabilityUC(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      return new KamikazeAICapabilityUCAsIAICapabilityUC(new KamikazeAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(id)) {
      return new GuardAICapabilityUCAsIAICapabilityUC(new GuardAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIAICapabilityUC(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIAICapabilityUC(new AttackAICapabilityUC(this, id));
    }
    throw new Exception("Unknown IAICapabilityUC: " + id);
  }
  public IAICapabilityUC GetIAICapabilityUCOrNull(int id) {
    if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      return new WanderAICapabilityUCAsIAICapabilityUC(new WanderAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(id)) {
      return new TemporaryCloneAICapabilityUCAsIAICapabilityUC(new TemporaryCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(id)) {
      return new SummonAICapabilityUCAsIAICapabilityUC(new SummonAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIAICapabilityUC(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      return new KamikazeAICapabilityUCAsIAICapabilityUC(new KamikazeAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(id)) {
      return new GuardAICapabilityUCAsIAICapabilityUC(new GuardAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIAICapabilityUC(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIAICapabilityUC(new AttackAICapabilityUC(this, id));
    }
    return NullIAICapabilityUC.Null;
  }
  public bool IAICapabilityUCExists(int id) {
    return GetIAICapabilityUCOrNull(id) != null;
  }
  public void CheckHasIAICapabilityUC(IAICapabilityUC thing) {
    GetIAICapabilityUC(thing.id);
  }
  public void CheckHasIAICapabilityUC(int id) {
    GetIAICapabilityUC(id);
  }

  public IPostActingUC GetIPostActingUC(int id) {
    if (rootIncarnation.incarnationsLightningChargedUC.ContainsKey(id)) {
      return new LightningChargedUCAsIPostActingUC(new LightningChargedUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIPostActingUC(new TimeCloneAICapabilityUC(this, id));
    }
    throw new Exception("Unknown IPostActingUC: " + id);
  }
  public IPostActingUC GetIPostActingUCOrNull(int id) {
    if (rootIncarnation.incarnationsLightningChargedUC.ContainsKey(id)) {
      return new LightningChargedUCAsIPostActingUC(new LightningChargedUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIPostActingUC(new TimeCloneAICapabilityUC(this, id));
    }
    return NullIPostActingUC.Null;
  }
  public bool IPostActingUCExists(int id) {
    return GetIPostActingUCOrNull(id) != null;
  }
  public void CheckHasIPostActingUC(IPostActingUC thing) {
    GetIPostActingUC(thing.id);
  }
  public void CheckHasIPostActingUC(int id) {
    GetIPostActingUC(id);
  }

  public IPreActingUC GetIPreActingUC(int id) {
    if (rootIncarnation.incarnationsDoomedUC.ContainsKey(id)) {
      return new DoomedUCAsIPreActingUC(new DoomedUC(this, id));
    }
    if (rootIncarnation.incarnationsMiredUC.ContainsKey(id)) {
      return new MiredUCAsIPreActingUC(new MiredUC(this, id));
    }
    if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      return new InvincibilityUCAsIPreActingUC(new InvincibilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDefyingUC.ContainsKey(id)) {
      return new DefyingUCAsIPreActingUC(new DefyingUC(this, id));
    }
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIPreActingUC(new CounteringUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIPreActingUC(new AttackAICapabilityUC(this, id));
    }
    throw new Exception("Unknown IPreActingUC: " + id);
  }
  public IPreActingUC GetIPreActingUCOrNull(int id) {
    if (rootIncarnation.incarnationsDoomedUC.ContainsKey(id)) {
      return new DoomedUCAsIPreActingUC(new DoomedUC(this, id));
    }
    if (rootIncarnation.incarnationsMiredUC.ContainsKey(id)) {
      return new MiredUCAsIPreActingUC(new MiredUC(this, id));
    }
    if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      return new InvincibilityUCAsIPreActingUC(new InvincibilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDefyingUC.ContainsKey(id)) {
      return new DefyingUCAsIPreActingUC(new DefyingUC(this, id));
    }
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIPreActingUC(new CounteringUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIPreActingUC(new AttackAICapabilityUC(this, id));
    }
    return NullIPreActingUC.Null;
  }
  public bool IPreActingUCExists(int id) {
    return GetIPreActingUCOrNull(id) != null;
  }
  public void CheckHasIPreActingUC(IPreActingUC thing) {
    GetIPreActingUC(thing.id);
  }
  public void CheckHasIPreActingUC(int id) {
    GetIPreActingUC(id);
  }

  public IReactingToAttacksUC GetIReactingToAttacksUC(int id) {
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIReactingToAttacksUC(new CounteringUC(this, id));
    }
    throw new Exception("Unknown IReactingToAttacksUC: " + id);
  }
  public IReactingToAttacksUC GetIReactingToAttacksUCOrNull(int id) {
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIReactingToAttacksUC(new CounteringUC(this, id));
    }
    return NullIReactingToAttacksUC.Null;
  }
  public bool IReactingToAttacksUCExists(int id) {
    return GetIReactingToAttacksUCOrNull(id) != null;
  }
  public void CheckHasIReactingToAttacksUC(IReactingToAttacksUC thing) {
    GetIReactingToAttacksUC(thing.id);
  }
  public void CheckHasIReactingToAttacksUC(int id) {
    GetIReactingToAttacksUC(id);
  }

  public IUnitComponent GetIUnitComponent(int id) {
    if (rootIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(id)) {
      return new TutorialDefyCounterUCAsIUnitComponent(new TutorialDefyCounterUC(this, id));
    }
    if (rootIncarnation.incarnationsLightningChargingUC.ContainsKey(id)) {
      return new LightningChargingUCAsIUnitComponent(new LightningChargingUC(this, id));
    }
    if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      return new WanderAICapabilityUCAsIUnitComponent(new WanderAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(id)) {
      return new TemporaryCloneAICapabilityUCAsIUnitComponent(new TemporaryCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(id)) {
      return new SummonAICapabilityUCAsIUnitComponent(new SummonAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      return new KamikazeAICapabilityUCAsIUnitComponent(new KamikazeAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(id)) {
      return new GuardAICapabilityUCAsIUnitComponent(new GuardAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIUnitComponent(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDoomedUC.ContainsKey(id)) {
      return new DoomedUCAsIUnitComponent(new DoomedUC(this, id));
    }
    if (rootIncarnation.incarnationsMiredUC.ContainsKey(id)) {
      return new MiredUCAsIUnitComponent(new MiredUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIUnitComponent(new AttackAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIUnitComponent(new CounteringUC(this, id));
    }
    if (rootIncarnation.incarnationsLightningChargedUC.ContainsKey(id)) {
      return new LightningChargedUCAsIUnitComponent(new LightningChargedUC(this, id));
    }
    if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      return new InvincibilityUCAsIUnitComponent(new InvincibilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDefyingUC.ContainsKey(id)) {
      return new DefyingUCAsIUnitComponent(new DefyingUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIUnitComponent(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(id)) {
      return new BaseSightRangeUCAsIUnitComponent(new BaseSightRangeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(id)) {
      return new BaseMovementTimeUCAsIUnitComponent(new BaseMovementTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(id)) {
      return new BaseCombatTimeUCAsIUnitComponent(new BaseCombatTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIUnitComponent(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIUnitComponent(new HealthPotion(this, id));
    }
    if (rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      return new SpeedRingAsIUnitComponent(new SpeedRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIUnitComponent(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      return new SlowRodAsIUnitComponent(new SlowRod(this, id));
    }
    if (rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      return new BlastRodAsIUnitComponent(new BlastRod(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIUnitComponent(new Armor(this, id));
    }
    if (rootIncarnation.incarnationsSorcerousUC.ContainsKey(id)) {
      return new SorcerousUCAsIUnitComponent(new SorcerousUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(id)) {
      return new BaseOffenseUCAsIUnitComponent(new BaseOffenseUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(id)) {
      return new BaseDefenseUCAsIUnitComponent(new BaseDefenseUC(this, id));
    }
    throw new Exception("Unknown IUnitComponent: " + id);
  }
  public IUnitComponent GetIUnitComponentOrNull(int id) {
    if (rootIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(id)) {
      return new TutorialDefyCounterUCAsIUnitComponent(new TutorialDefyCounterUC(this, id));
    }
    if (rootIncarnation.incarnationsLightningChargingUC.ContainsKey(id)) {
      return new LightningChargingUCAsIUnitComponent(new LightningChargingUC(this, id));
    }
    if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      return new WanderAICapabilityUCAsIUnitComponent(new WanderAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(id)) {
      return new TemporaryCloneAICapabilityUCAsIUnitComponent(new TemporaryCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(id)) {
      return new SummonAICapabilityUCAsIUnitComponent(new SummonAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      return new KamikazeAICapabilityUCAsIUnitComponent(new KamikazeAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(id)) {
      return new GuardAICapabilityUCAsIUnitComponent(new GuardAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIUnitComponent(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDoomedUC.ContainsKey(id)) {
      return new DoomedUCAsIUnitComponent(new DoomedUC(this, id));
    }
    if (rootIncarnation.incarnationsMiredUC.ContainsKey(id)) {
      return new MiredUCAsIUnitComponent(new MiredUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIUnitComponent(new AttackAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIUnitComponent(new CounteringUC(this, id));
    }
    if (rootIncarnation.incarnationsLightningChargedUC.ContainsKey(id)) {
      return new LightningChargedUCAsIUnitComponent(new LightningChargedUC(this, id));
    }
    if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      return new InvincibilityUCAsIUnitComponent(new InvincibilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDefyingUC.ContainsKey(id)) {
      return new DefyingUCAsIUnitComponent(new DefyingUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIUnitComponent(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(id)) {
      return new BaseSightRangeUCAsIUnitComponent(new BaseSightRangeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(id)) {
      return new BaseMovementTimeUCAsIUnitComponent(new BaseMovementTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(id)) {
      return new BaseCombatTimeUCAsIUnitComponent(new BaseCombatTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIUnitComponent(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIUnitComponent(new HealthPotion(this, id));
    }
    if (rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      return new SpeedRingAsIUnitComponent(new SpeedRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIUnitComponent(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      return new SlowRodAsIUnitComponent(new SlowRod(this, id));
    }
    if (rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      return new BlastRodAsIUnitComponent(new BlastRod(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIUnitComponent(new Armor(this, id));
    }
    if (rootIncarnation.incarnationsSorcerousUC.ContainsKey(id)) {
      return new SorcerousUCAsIUnitComponent(new SorcerousUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(id)) {
      return new BaseOffenseUCAsIUnitComponent(new BaseOffenseUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(id)) {
      return new BaseDefenseUCAsIUnitComponent(new BaseDefenseUC(this, id));
    }
    return NullIUnitComponent.Null;
  }
  public bool IUnitComponentExists(int id) {
    return GetIUnitComponentOrNull(id) != null;
  }
  public void CheckHasIUnitComponent(IUnitComponent thing) {
    GetIUnitComponent(thing.id);
  }
  public void CheckHasIUnitComponent(int id) {
    GetIUnitComponent(id);
  }

  public IOffenseFactorUC GetIOffenseFactorUC(int id) {
    if (rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(id)) {
      return new BaseOffenseUCAsIOffenseFactorUC(new BaseOffenseUC(this, id));
    }
    if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      return new InvincibilityUCAsIOffenseFactorUC(new InvincibilityUC(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIOffenseFactorUC(new Glaive(this, id));
    }
    throw new Exception("Unknown IOffenseFactorUC: " + id);
  }
  public IOffenseFactorUC GetIOffenseFactorUCOrNull(int id) {
    if (rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(id)) {
      return new BaseOffenseUCAsIOffenseFactorUC(new BaseOffenseUC(this, id));
    }
    if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      return new InvincibilityUCAsIOffenseFactorUC(new InvincibilityUC(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIOffenseFactorUC(new Glaive(this, id));
    }
    return NullIOffenseFactorUC.Null;
  }
  public bool IOffenseFactorUCExists(int id) {
    return GetIOffenseFactorUCOrNull(id) != null;
  }
  public void CheckHasIOffenseFactorUC(IOffenseFactorUC thing) {
    GetIOffenseFactorUC(thing.id);
  }
  public void CheckHasIOffenseFactorUC(int id) {
    GetIOffenseFactorUC(id);
  }

  public ISightRangeFactorUC GetISightRangeFactorUC(int id) {
    if (rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(id)) {
      return new BaseSightRangeUCAsISightRangeFactorUC(new BaseSightRangeUC(this, id));
    }
    throw new Exception("Unknown ISightRangeFactorUC: " + id);
  }
  public ISightRangeFactorUC GetISightRangeFactorUCOrNull(int id) {
    if (rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(id)) {
      return new BaseSightRangeUCAsISightRangeFactorUC(new BaseSightRangeUC(this, id));
    }
    return NullISightRangeFactorUC.Null;
  }
  public bool ISightRangeFactorUCExists(int id) {
    return GetISightRangeFactorUCOrNull(id) != null;
  }
  public void CheckHasISightRangeFactorUC(ISightRangeFactorUC thing) {
    GetISightRangeFactorUC(thing.id);
  }
  public void CheckHasISightRangeFactorUC(int id) {
    GetISightRangeFactorUC(id);
  }

  public IMovementTimeFactorUC GetIMovementTimeFactorUC(int id) {
    if (rootIncarnation.incarnationsLightningChargedUC.ContainsKey(id)) {
      return new LightningChargedUCAsIMovementTimeFactorUC(new LightningChargedUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(id)) {
      return new BaseMovementTimeUCAsIMovementTimeFactorUC(new BaseMovementTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      return new SpeedRingAsIMovementTimeFactorUC(new SpeedRing(this, id));
    }
    throw new Exception("Unknown IMovementTimeFactorUC: " + id);
  }
  public IMovementTimeFactorUC GetIMovementTimeFactorUCOrNull(int id) {
    if (rootIncarnation.incarnationsLightningChargedUC.ContainsKey(id)) {
      return new LightningChargedUCAsIMovementTimeFactorUC(new LightningChargedUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(id)) {
      return new BaseMovementTimeUCAsIMovementTimeFactorUC(new BaseMovementTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      return new SpeedRingAsIMovementTimeFactorUC(new SpeedRing(this, id));
    }
    return NullIMovementTimeFactorUC.Null;
  }
  public bool IMovementTimeFactorUCExists(int id) {
    return GetIMovementTimeFactorUCOrNull(id) != null;
  }
  public void CheckHasIMovementTimeFactorUC(IMovementTimeFactorUC thing) {
    GetIMovementTimeFactorUC(thing.id);
  }
  public void CheckHasIMovementTimeFactorUC(int id) {
    GetIMovementTimeFactorUC(id);
  }

  public IDefenseFactorUC GetIDefenseFactorUC(int id) {
    if (rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(id)) {
      return new BaseDefenseUCAsIDefenseFactorUC(new BaseDefenseUC(this, id));
    }
    if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      return new InvincibilityUCAsIDefenseFactorUC(new InvincibilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDefyingUC.ContainsKey(id)) {
      return new DefyingUCAsIDefenseFactorUC(new DefyingUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIDefenseFactorUC(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIDefenseFactorUC(new Armor(this, id));
    }
    throw new Exception("Unknown IDefenseFactorUC: " + id);
  }
  public IDefenseFactorUC GetIDefenseFactorUCOrNull(int id) {
    if (rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(id)) {
      return new BaseDefenseUCAsIDefenseFactorUC(new BaseDefenseUC(this, id));
    }
    if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      return new InvincibilityUCAsIDefenseFactorUC(new InvincibilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDefyingUC.ContainsKey(id)) {
      return new DefyingUCAsIDefenseFactorUC(new DefyingUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIDefenseFactorUC(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIDefenseFactorUC(new Armor(this, id));
    }
    return NullIDefenseFactorUC.Null;
  }
  public bool IDefenseFactorUCExists(int id) {
    return GetIDefenseFactorUCOrNull(id) != null;
  }
  public void CheckHasIDefenseFactorUC(IDefenseFactorUC thing) {
    GetIDefenseFactorUC(thing.id);
  }
  public void CheckHasIDefenseFactorUC(int id) {
    GetIDefenseFactorUC(id);
  }

  public ICombatTimeFactorUC GetICombatTimeFactorUC(int id) {
    if (rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(id)) {
      return new BaseCombatTimeUCAsICombatTimeFactorUC(new BaseCombatTimeUC(this, id));
    }
    throw new Exception("Unknown ICombatTimeFactorUC: " + id);
  }
  public ICombatTimeFactorUC GetICombatTimeFactorUCOrNull(int id) {
    if (rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(id)) {
      return new BaseCombatTimeUCAsICombatTimeFactorUC(new BaseCombatTimeUC(this, id));
    }
    return NullICombatTimeFactorUC.Null;
  }
  public bool ICombatTimeFactorUCExists(int id) {
    return GetICombatTimeFactorUCOrNull(id) != null;
  }
  public void CheckHasICombatTimeFactorUC(ICombatTimeFactorUC thing) {
    GetICombatTimeFactorUC(thing.id);
  }
  public void CheckHasICombatTimeFactorUC(int id) {
    GetICombatTimeFactorUC(id);
  }

  public IImpulse GetIImpulse(int id) {
    if (rootIncarnation.incarnationsHoldPositionImpulse.ContainsKey(id)) {
      return new HoldPositionImpulseAsIImpulse(new HoldPositionImpulse(this, id));
    }
    if (rootIncarnation.incarnationsTemporaryCloneImpulse.ContainsKey(id)) {
      return new TemporaryCloneImpulseAsIImpulse(new TemporaryCloneImpulse(this, id));
    }
    if (rootIncarnation.incarnationsSummonImpulse.ContainsKey(id)) {
      return new SummonImpulseAsIImpulse(new SummonImpulse(this, id));
    }
    if (rootIncarnation.incarnationsMireImpulse.ContainsKey(id)) {
      return new MireImpulseAsIImpulse(new MireImpulse(this, id));
    }
    if (rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(id)) {
      return new EvaporateImpulseAsIImpulse(new EvaporateImpulse(this, id));
    }
    if (rootIncarnation.incarnationsMoveImpulse.ContainsKey(id)) {
      return new MoveImpulseAsIImpulse(new MoveImpulse(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeJumpImpulse.ContainsKey(id)) {
      return new KamikazeJumpImpulseAsIImpulse(new KamikazeJumpImpulse(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeTargetImpulse.ContainsKey(id)) {
      return new KamikazeTargetImpulseAsIImpulse(new KamikazeTargetImpulse(this, id));
    }
    if (rootIncarnation.incarnationsNoImpulse.ContainsKey(id)) {
      return new NoImpulseAsIImpulse(new NoImpulse(this, id));
    }
    if (rootIncarnation.incarnationsFireImpulse.ContainsKey(id)) {
      return new FireImpulseAsIImpulse(new FireImpulse(this, id));
    }
    if (rootIncarnation.incarnationsDefyImpulse.ContainsKey(id)) {
      return new DefyImpulseAsIImpulse(new DefyImpulse(this, id));
    }
    if (rootIncarnation.incarnationsCounterImpulse.ContainsKey(id)) {
      return new CounterImpulseAsIImpulse(new CounterImpulse(this, id));
    }
    if (rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(id)) {
      return new UnleashBideImpulseAsIImpulse(new UnleashBideImpulse(this, id));
    }
    if (rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(id)) {
      return new ContinueBidingImpulseAsIImpulse(new ContinueBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(id)) {
      return new StartBidingImpulseAsIImpulse(new StartBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsAttackImpulse.ContainsKey(id)) {
      return new AttackImpulseAsIImpulse(new AttackImpulse(this, id));
    }
    if (rootIncarnation.incarnationsPursueImpulse.ContainsKey(id)) {
      return new PursueImpulseAsIImpulse(new PursueImpulse(this, id));
    }
    if (rootIncarnation.incarnationsFireBombImpulse.ContainsKey(id)) {
      return new FireBombImpulseAsIImpulse(new FireBombImpulse(this, id));
    }
    throw new Exception("Unknown IImpulse: " + id);
  }
  public IImpulse GetIImpulseOrNull(int id) {
    if (rootIncarnation.incarnationsHoldPositionImpulse.ContainsKey(id)) {
      return new HoldPositionImpulseAsIImpulse(new HoldPositionImpulse(this, id));
    }
    if (rootIncarnation.incarnationsTemporaryCloneImpulse.ContainsKey(id)) {
      return new TemporaryCloneImpulseAsIImpulse(new TemporaryCloneImpulse(this, id));
    }
    if (rootIncarnation.incarnationsSummonImpulse.ContainsKey(id)) {
      return new SummonImpulseAsIImpulse(new SummonImpulse(this, id));
    }
    if (rootIncarnation.incarnationsMireImpulse.ContainsKey(id)) {
      return new MireImpulseAsIImpulse(new MireImpulse(this, id));
    }
    if (rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(id)) {
      return new EvaporateImpulseAsIImpulse(new EvaporateImpulse(this, id));
    }
    if (rootIncarnation.incarnationsMoveImpulse.ContainsKey(id)) {
      return new MoveImpulseAsIImpulse(new MoveImpulse(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeJumpImpulse.ContainsKey(id)) {
      return new KamikazeJumpImpulseAsIImpulse(new KamikazeJumpImpulse(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeTargetImpulse.ContainsKey(id)) {
      return new KamikazeTargetImpulseAsIImpulse(new KamikazeTargetImpulse(this, id));
    }
    if (rootIncarnation.incarnationsNoImpulse.ContainsKey(id)) {
      return new NoImpulseAsIImpulse(new NoImpulse(this, id));
    }
    if (rootIncarnation.incarnationsFireImpulse.ContainsKey(id)) {
      return new FireImpulseAsIImpulse(new FireImpulse(this, id));
    }
    if (rootIncarnation.incarnationsDefyImpulse.ContainsKey(id)) {
      return new DefyImpulseAsIImpulse(new DefyImpulse(this, id));
    }
    if (rootIncarnation.incarnationsCounterImpulse.ContainsKey(id)) {
      return new CounterImpulseAsIImpulse(new CounterImpulse(this, id));
    }
    if (rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(id)) {
      return new UnleashBideImpulseAsIImpulse(new UnleashBideImpulse(this, id));
    }
    if (rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(id)) {
      return new ContinueBidingImpulseAsIImpulse(new ContinueBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(id)) {
      return new StartBidingImpulseAsIImpulse(new StartBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsAttackImpulse.ContainsKey(id)) {
      return new AttackImpulseAsIImpulse(new AttackImpulse(this, id));
    }
    if (rootIncarnation.incarnationsPursueImpulse.ContainsKey(id)) {
      return new PursueImpulseAsIImpulse(new PursueImpulse(this, id));
    }
    if (rootIncarnation.incarnationsFireBombImpulse.ContainsKey(id)) {
      return new FireBombImpulseAsIImpulse(new FireBombImpulse(this, id));
    }
    return NullIImpulse.Null;
  }
  public bool IImpulseExists(int id) {
    return GetIImpulseOrNull(id) != null;
  }
  public void CheckHasIImpulse(IImpulse thing) {
    GetIImpulse(thing.id);
  }
  public void CheckHasIImpulse(int id) {
    GetIImpulse(id);
  }

  public IActingTTC GetIActingTTC(int id) {
    if (rootIncarnation.incarnationsFireBombTTC.ContainsKey(id)) {
      return new FireBombTTCAsIActingTTC(new FireBombTTC(this, id));
    }
    throw new Exception("Unknown IActingTTC: " + id);
  }
  public IActingTTC GetIActingTTCOrNull(int id) {
    if (rootIncarnation.incarnationsFireBombTTC.ContainsKey(id)) {
      return new FireBombTTCAsIActingTTC(new FireBombTTC(this, id));
    }
    return NullIActingTTC.Null;
  }
  public bool IActingTTCExists(int id) {
    return GetIActingTTCOrNull(id) != null;
  }
  public void CheckHasIActingTTC(IActingTTC thing) {
    GetIActingTTC(thing.id);
  }
  public void CheckHasIActingTTC(int id) {
    GetIActingTTC(id);
  }

  public IPresenceTriggerTTC GetIPresenceTriggerTTC(int id) {
    if (rootIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(id)) {
      return new SimplePresenceTriggerTTCAsIPresenceTriggerTTC(new SimplePresenceTriggerTTC(this, id));
    }
    throw new Exception("Unknown IPresenceTriggerTTC: " + id);
  }
  public IPresenceTriggerTTC GetIPresenceTriggerTTCOrNull(int id) {
    if (rootIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(id)) {
      return new SimplePresenceTriggerTTCAsIPresenceTriggerTTC(new SimplePresenceTriggerTTC(this, id));
    }
    return NullIPresenceTriggerTTC.Null;
  }
  public bool IPresenceTriggerTTCExists(int id) {
    return GetIPresenceTriggerTTCOrNull(id) != null;
  }
  public void CheckHasIPresenceTriggerTTC(IPresenceTriggerTTC thing) {
    GetIPresenceTriggerTTC(thing.id);
  }
  public void CheckHasIPresenceTriggerTTC(int id) {
    GetIPresenceTriggerTTC(id);
  }

  public IInteractableTTC GetIInteractableTTC(int id) {
    if (rootIncarnation.incarnationsWarperTTC.ContainsKey(id)) {
      return new WarperTTCAsIInteractableTTC(new WarperTTC(this, id));
    }
    if (rootIncarnation.incarnationsLevelLinkTTC.ContainsKey(id)) {
      return new LevelLinkTTCAsIInteractableTTC(new LevelLinkTTC(this, id));
    }
    if (rootIncarnation.incarnationsItemTTC.ContainsKey(id)) {
      return new ItemTTCAsIInteractableTTC(new ItemTTC(this, id));
    }
    if (rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(id)) {
      return new IncendianFallsLevelLinkerTTCAsIInteractableTTC(new IncendianFallsLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(id)) {
      return new EmberDeepLevelLinkerTTCAsIInteractableTTC(new EmberDeepLevelLinkerTTC(this, id));
    }
    throw new Exception("Unknown IInteractableTTC: " + id);
  }
  public IInteractableTTC GetIInteractableTTCOrNull(int id) {
    if (rootIncarnation.incarnationsWarperTTC.ContainsKey(id)) {
      return new WarperTTCAsIInteractableTTC(new WarperTTC(this, id));
    }
    if (rootIncarnation.incarnationsLevelLinkTTC.ContainsKey(id)) {
      return new LevelLinkTTCAsIInteractableTTC(new LevelLinkTTC(this, id));
    }
    if (rootIncarnation.incarnationsItemTTC.ContainsKey(id)) {
      return new ItemTTCAsIInteractableTTC(new ItemTTC(this, id));
    }
    if (rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(id)) {
      return new IncendianFallsLevelLinkerTTCAsIInteractableTTC(new IncendianFallsLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(id)) {
      return new EmberDeepLevelLinkerTTCAsIInteractableTTC(new EmberDeepLevelLinkerTTC(this, id));
    }
    return NullIInteractableTTC.Null;
  }
  public bool IInteractableTTCExists(int id) {
    return GetIInteractableTTCOrNull(id) != null;
  }
  public void CheckHasIInteractableTTC(IInteractableTTC thing) {
    GetIInteractableTTC(thing.id);
  }
  public void CheckHasIInteractableTTC(int id) {
    GetIInteractableTTC(id);
  }

  public IBlocksSightTTC GetIBlocksSightTTC(int id) {
    if (rootIncarnation.incarnationsTreeTTC.ContainsKey(id)) {
      return new TreeTTCAsIBlocksSightTTC(new TreeTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveWallTTC.ContainsKey(id)) {
      return new CaveWallTTCAsIBlocksSightTTC(new CaveWallTTC(this, id));
    }
    throw new Exception("Unknown IBlocksSightTTC: " + id);
  }
  public IBlocksSightTTC GetIBlocksSightTTCOrNull(int id) {
    if (rootIncarnation.incarnationsTreeTTC.ContainsKey(id)) {
      return new TreeTTCAsIBlocksSightTTC(new TreeTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveWallTTC.ContainsKey(id)) {
      return new CaveWallTTCAsIBlocksSightTTC(new CaveWallTTC(this, id));
    }
    return NullIBlocksSightTTC.Null;
  }
  public bool IBlocksSightTTCExists(int id) {
    return GetIBlocksSightTTCOrNull(id) != null;
  }
  public void CheckHasIBlocksSightTTC(IBlocksSightTTC thing) {
    GetIBlocksSightTTC(thing.id);
  }
  public void CheckHasIBlocksSightTTC(int id) {
    GetIBlocksSightTTC(id);
  }

  public IUnwalkableTTC GetIUnwalkableTTC(int id) {
    if (rootIncarnation.incarnationsTreeTTC.ContainsKey(id)) {
      return new TreeTTCAsIUnwalkableTTC(new TreeTTC(this, id));
    }
    if (rootIncarnation.incarnationsWaterTTC.ContainsKey(id)) {
      return new WaterTTCAsIUnwalkableTTC(new WaterTTC(this, id));
    }
    if (rootIncarnation.incarnationsFloorTTC.ContainsKey(id)) {
      return new FloorTTCAsIUnwalkableTTC(new FloorTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveWallTTC.ContainsKey(id)) {
      return new CaveWallTTCAsIUnwalkableTTC(new CaveWallTTC(this, id));
    }
    if (rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      return new FallsTTCAsIUnwalkableTTC(new FallsTTC(this, id));
    }
    if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      return new MagmaTTCAsIUnwalkableTTC(new MagmaTTC(this, id));
    }
    throw new Exception("Unknown IUnwalkableTTC: " + id);
  }
  public IUnwalkableTTC GetIUnwalkableTTCOrNull(int id) {
    if (rootIncarnation.incarnationsTreeTTC.ContainsKey(id)) {
      return new TreeTTCAsIUnwalkableTTC(new TreeTTC(this, id));
    }
    if (rootIncarnation.incarnationsWaterTTC.ContainsKey(id)) {
      return new WaterTTCAsIUnwalkableTTC(new WaterTTC(this, id));
    }
    if (rootIncarnation.incarnationsFloorTTC.ContainsKey(id)) {
      return new FloorTTCAsIUnwalkableTTC(new FloorTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveWallTTC.ContainsKey(id)) {
      return new CaveWallTTCAsIUnwalkableTTC(new CaveWallTTC(this, id));
    }
    if (rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      return new FallsTTCAsIUnwalkableTTC(new FallsTTC(this, id));
    }
    if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      return new MagmaTTCAsIUnwalkableTTC(new MagmaTTC(this, id));
    }
    return NullIUnwalkableTTC.Null;
  }
  public bool IUnwalkableTTCExists(int id) {
    return GetIUnwalkableTTCOrNull(id) != null;
  }
  public void CheckHasIUnwalkableTTC(IUnwalkableTTC thing) {
    GetIUnwalkableTTC(thing.id);
  }
  public void CheckHasIUnwalkableTTC(int id) {
    GetIUnwalkableTTC(id);
  }

  public ITerrainTileComponent GetITerrainTileComponent(int id) {
    if (rootIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(id)) {
      return new SimplePresenceTriggerTTCAsITerrainTileComponent(new SimplePresenceTriggerTTC(this, id));
    }
    if (rootIncarnation.incarnationsItemTTC.ContainsKey(id)) {
      return new ItemTTCAsITerrainTileComponent(new ItemTTC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeTargetTTC.ContainsKey(id)) {
      return new KamikazeTargetTTCAsITerrainTileComponent(new KamikazeTargetTTC(this, id));
    }
    if (rootIncarnation.incarnationsWarperTTC.ContainsKey(id)) {
      return new WarperTTCAsITerrainTileComponent(new WarperTTC(this, id));
    }
    if (rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(id)) {
      return new TimeAnchorTTCAsITerrainTileComponent(new TimeAnchorTTC(this, id));
    }
    if (rootIncarnation.incarnationsFireBombTTC.ContainsKey(id)) {
      return new FireBombTTCAsITerrainTileComponent(new FireBombTTC(this, id));
    }
    if (rootIncarnation.incarnationsMarkerTTC.ContainsKey(id)) {
      return new MarkerTTCAsITerrainTileComponent(new MarkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsLevelLinkTTC.ContainsKey(id)) {
      return new LevelLinkTTCAsITerrainTileComponent(new LevelLinkTTC(this, id));
    }
    if (rootIncarnation.incarnationsMudTTC.ContainsKey(id)) {
      return new MudTTCAsITerrainTileComponent(new MudTTC(this, id));
    }
    if (rootIncarnation.incarnationsDirtTTC.ContainsKey(id)) {
      return new DirtTTCAsITerrainTileComponent(new DirtTTC(this, id));
    }
    if (rootIncarnation.incarnationsObsidianTTC.ContainsKey(id)) {
      return new ObsidianTTCAsITerrainTileComponent(new ObsidianTTC(this, id));
    }
    if (rootIncarnation.incarnationsDownStairsTTC.ContainsKey(id)) {
      return new DownStairsTTCAsITerrainTileComponent(new DownStairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsUpStairsTTC.ContainsKey(id)) {
      return new UpStairsTTCAsITerrainTileComponent(new UpStairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsWallTTC.ContainsKey(id)) {
      return new WallTTCAsITerrainTileComponent(new WallTTC(this, id));
    }
    if (rootIncarnation.incarnationsBloodTTC.ContainsKey(id)) {
      return new BloodTTCAsITerrainTileComponent(new BloodTTC(this, id));
    }
    if (rootIncarnation.incarnationsRocksTTC.ContainsKey(id)) {
      return new RocksTTCAsITerrainTileComponent(new RocksTTC(this, id));
    }
    if (rootIncarnation.incarnationsTreeTTC.ContainsKey(id)) {
      return new TreeTTCAsITerrainTileComponent(new TreeTTC(this, id));
    }
    if (rootIncarnation.incarnationsWaterTTC.ContainsKey(id)) {
      return new WaterTTCAsITerrainTileComponent(new WaterTTC(this, id));
    }
    if (rootIncarnation.incarnationsFloorTTC.ContainsKey(id)) {
      return new FloorTTCAsITerrainTileComponent(new FloorTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveWallTTC.ContainsKey(id)) {
      return new CaveWallTTCAsITerrainTileComponent(new CaveWallTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveTTC.ContainsKey(id)) {
      return new CaveTTCAsITerrainTileComponent(new CaveTTC(this, id));
    }
    if (rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      return new FallsTTCAsITerrainTileComponent(new FallsTTC(this, id));
    }
    if (rootIncarnation.incarnationsFireTTC.ContainsKey(id)) {
      return new FireTTCAsITerrainTileComponent(new FireTTC(this, id));
    }
    if (rootIncarnation.incarnationsObsidianFloorTTC.ContainsKey(id)) {
      return new ObsidianFloorTTCAsITerrainTileComponent(new ObsidianFloorTTC(this, id));
    }
    if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      return new MagmaTTCAsITerrainTileComponent(new MagmaTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffTTC.ContainsKey(id)) {
      return new CliffTTCAsITerrainTileComponent(new CliffTTC(this, id));
    }
    if (rootIncarnation.incarnationsRavaNestTTC.ContainsKey(id)) {
      return new RavaNestTTCAsITerrainTileComponent(new RavaNestTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(id)) {
      return new CliffLandingTTCAsITerrainTileComponent(new CliffLandingTTC(this, id));
    }
    if (rootIncarnation.incarnationsStoneTTC.ContainsKey(id)) {
      return new StoneTTCAsITerrainTileComponent(new StoneTTC(this, id));
    }
    if (rootIncarnation.incarnationsGrassTTC.ContainsKey(id)) {
      return new GrassTTCAsITerrainTileComponent(new GrassTTC(this, id));
    }
    if (rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(id)) {
      return new IncendianFallsLevelLinkerTTCAsITerrainTileComponent(new IncendianFallsLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(id)) {
      return new EmberDeepLevelLinkerTTCAsITerrainTileComponent(new EmberDeepLevelLinkerTTC(this, id));
    }
    throw new Exception("Unknown ITerrainTileComponent: " + id);
  }
  public ITerrainTileComponent GetITerrainTileComponentOrNull(int id) {
    if (rootIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(id)) {
      return new SimplePresenceTriggerTTCAsITerrainTileComponent(new SimplePresenceTriggerTTC(this, id));
    }
    if (rootIncarnation.incarnationsItemTTC.ContainsKey(id)) {
      return new ItemTTCAsITerrainTileComponent(new ItemTTC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeTargetTTC.ContainsKey(id)) {
      return new KamikazeTargetTTCAsITerrainTileComponent(new KamikazeTargetTTC(this, id));
    }
    if (rootIncarnation.incarnationsWarperTTC.ContainsKey(id)) {
      return new WarperTTCAsITerrainTileComponent(new WarperTTC(this, id));
    }
    if (rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(id)) {
      return new TimeAnchorTTCAsITerrainTileComponent(new TimeAnchorTTC(this, id));
    }
    if (rootIncarnation.incarnationsFireBombTTC.ContainsKey(id)) {
      return new FireBombTTCAsITerrainTileComponent(new FireBombTTC(this, id));
    }
    if (rootIncarnation.incarnationsMarkerTTC.ContainsKey(id)) {
      return new MarkerTTCAsITerrainTileComponent(new MarkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsLevelLinkTTC.ContainsKey(id)) {
      return new LevelLinkTTCAsITerrainTileComponent(new LevelLinkTTC(this, id));
    }
    if (rootIncarnation.incarnationsMudTTC.ContainsKey(id)) {
      return new MudTTCAsITerrainTileComponent(new MudTTC(this, id));
    }
    if (rootIncarnation.incarnationsDirtTTC.ContainsKey(id)) {
      return new DirtTTCAsITerrainTileComponent(new DirtTTC(this, id));
    }
    if (rootIncarnation.incarnationsObsidianTTC.ContainsKey(id)) {
      return new ObsidianTTCAsITerrainTileComponent(new ObsidianTTC(this, id));
    }
    if (rootIncarnation.incarnationsDownStairsTTC.ContainsKey(id)) {
      return new DownStairsTTCAsITerrainTileComponent(new DownStairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsUpStairsTTC.ContainsKey(id)) {
      return new UpStairsTTCAsITerrainTileComponent(new UpStairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsWallTTC.ContainsKey(id)) {
      return new WallTTCAsITerrainTileComponent(new WallTTC(this, id));
    }
    if (rootIncarnation.incarnationsBloodTTC.ContainsKey(id)) {
      return new BloodTTCAsITerrainTileComponent(new BloodTTC(this, id));
    }
    if (rootIncarnation.incarnationsRocksTTC.ContainsKey(id)) {
      return new RocksTTCAsITerrainTileComponent(new RocksTTC(this, id));
    }
    if (rootIncarnation.incarnationsTreeTTC.ContainsKey(id)) {
      return new TreeTTCAsITerrainTileComponent(new TreeTTC(this, id));
    }
    if (rootIncarnation.incarnationsWaterTTC.ContainsKey(id)) {
      return new WaterTTCAsITerrainTileComponent(new WaterTTC(this, id));
    }
    if (rootIncarnation.incarnationsFloorTTC.ContainsKey(id)) {
      return new FloorTTCAsITerrainTileComponent(new FloorTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveWallTTC.ContainsKey(id)) {
      return new CaveWallTTCAsITerrainTileComponent(new CaveWallTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveTTC.ContainsKey(id)) {
      return new CaveTTCAsITerrainTileComponent(new CaveTTC(this, id));
    }
    if (rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      return new FallsTTCAsITerrainTileComponent(new FallsTTC(this, id));
    }
    if (rootIncarnation.incarnationsFireTTC.ContainsKey(id)) {
      return new FireTTCAsITerrainTileComponent(new FireTTC(this, id));
    }
    if (rootIncarnation.incarnationsObsidianFloorTTC.ContainsKey(id)) {
      return new ObsidianFloorTTCAsITerrainTileComponent(new ObsidianFloorTTC(this, id));
    }
    if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      return new MagmaTTCAsITerrainTileComponent(new MagmaTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffTTC.ContainsKey(id)) {
      return new CliffTTCAsITerrainTileComponent(new CliffTTC(this, id));
    }
    if (rootIncarnation.incarnationsRavaNestTTC.ContainsKey(id)) {
      return new RavaNestTTCAsITerrainTileComponent(new RavaNestTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(id)) {
      return new CliffLandingTTCAsITerrainTileComponent(new CliffLandingTTC(this, id));
    }
    if (rootIncarnation.incarnationsStoneTTC.ContainsKey(id)) {
      return new StoneTTCAsITerrainTileComponent(new StoneTTC(this, id));
    }
    if (rootIncarnation.incarnationsGrassTTC.ContainsKey(id)) {
      return new GrassTTCAsITerrainTileComponent(new GrassTTC(this, id));
    }
    if (rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(id)) {
      return new IncendianFallsLevelLinkerTTCAsITerrainTileComponent(new IncendianFallsLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(id)) {
      return new EmberDeepLevelLinkerTTCAsITerrainTileComponent(new EmberDeepLevelLinkerTTC(this, id));
    }
    return NullITerrainTileComponent.Null;
  }
  public bool ITerrainTileComponentExists(int id) {
    return GetITerrainTileComponentOrNull(id) != null;
  }
  public void CheckHasITerrainTileComponent(ITerrainTileComponent thing) {
    GetITerrainTileComponent(thing.id);
  }
  public void CheckHasITerrainTileComponent(int id) {
    GetITerrainTileComponent(id);
  }

  public ILevelController GetILevelController(int id) {
    if (rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(id)) {
      return new SquareCaveLevelControllerAsILevelController(new SquareCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(id)) {
      return new RavashrikeLevelControllerAsILevelController(new RavashrikeLevelController(this, id));
    }
    if (rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(id)) {
      return new PentagonalCaveLevelControllerAsILevelController(new PentagonalCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsCliffLevelController.ContainsKey(id)) {
      return new CliffLevelControllerAsILevelController(new CliffLevelController(this, id));
    }
    if (rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(id)) {
      return new PreGauntletLevelControllerAsILevelController(new PreGauntletLevelController(this, id));
    }
    if (rootIncarnation.incarnationsGauntletLevelController.ContainsKey(id)) {
      return new GauntletLevelControllerAsILevelController(new GauntletLevelController(this, id));
    }
    if (rootIncarnation.incarnationsVolcaetusLevelController.ContainsKey(id)) {
      return new VolcaetusLevelControllerAsILevelController(new VolcaetusLevelController(this, id));
    }
    if (rootIncarnation.incarnationsTutorial2LevelController.ContainsKey(id)) {
      return new Tutorial2LevelControllerAsILevelController(new Tutorial2LevelController(this, id));
    }
    if (rootIncarnation.incarnationsTutorial1LevelController.ContainsKey(id)) {
      return new Tutorial1LevelControllerAsILevelController(new Tutorial1LevelController(this, id));
    }
    if (rootIncarnation.incarnationsRetreatLevelController.ContainsKey(id)) {
      return new RetreatLevelControllerAsILevelController(new RetreatLevelController(this, id));
    }
    if (rootIncarnation.incarnationsSotaventoLevelController.ContainsKey(id)) {
      return new SotaventoLevelControllerAsILevelController(new SotaventoLevelController(this, id));
    }
    if (rootIncarnation.incarnationsNestLevelController.ContainsKey(id)) {
      return new NestLevelControllerAsILevelController(new NestLevelController(this, id));
    }
    if (rootIncarnation.incarnationsLakeLevelController.ContainsKey(id)) {
      return new LakeLevelControllerAsILevelController(new LakeLevelController(this, id));
    }
    if (rootIncarnation.incarnationsDirtRoadLevelController.ContainsKey(id)) {
      return new DirtRoadLevelControllerAsILevelController(new DirtRoadLevelController(this, id));
    }
    if (rootIncarnation.incarnationsCaveLevelController.ContainsKey(id)) {
      return new CaveLevelControllerAsILevelController(new CaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsBridgesLevelController.ContainsKey(id)) {
      return new BridgesLevelControllerAsILevelController(new BridgesLevelController(this, id));
    }
    if (rootIncarnation.incarnationsAncientTownLevelController.ContainsKey(id)) {
      return new AncientTownLevelControllerAsILevelController(new AncientTownLevelController(this, id));
    }
    throw new Exception("Unknown ILevelController: " + id);
  }
  public ILevelController GetILevelControllerOrNull(int id) {
    if (rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(id)) {
      return new SquareCaveLevelControllerAsILevelController(new SquareCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(id)) {
      return new RavashrikeLevelControllerAsILevelController(new RavashrikeLevelController(this, id));
    }
    if (rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(id)) {
      return new PentagonalCaveLevelControllerAsILevelController(new PentagonalCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsCliffLevelController.ContainsKey(id)) {
      return new CliffLevelControllerAsILevelController(new CliffLevelController(this, id));
    }
    if (rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(id)) {
      return new PreGauntletLevelControllerAsILevelController(new PreGauntletLevelController(this, id));
    }
    if (rootIncarnation.incarnationsGauntletLevelController.ContainsKey(id)) {
      return new GauntletLevelControllerAsILevelController(new GauntletLevelController(this, id));
    }
    if (rootIncarnation.incarnationsVolcaetusLevelController.ContainsKey(id)) {
      return new VolcaetusLevelControllerAsILevelController(new VolcaetusLevelController(this, id));
    }
    if (rootIncarnation.incarnationsTutorial2LevelController.ContainsKey(id)) {
      return new Tutorial2LevelControllerAsILevelController(new Tutorial2LevelController(this, id));
    }
    if (rootIncarnation.incarnationsTutorial1LevelController.ContainsKey(id)) {
      return new Tutorial1LevelControllerAsILevelController(new Tutorial1LevelController(this, id));
    }
    if (rootIncarnation.incarnationsRetreatLevelController.ContainsKey(id)) {
      return new RetreatLevelControllerAsILevelController(new RetreatLevelController(this, id));
    }
    if (rootIncarnation.incarnationsSotaventoLevelController.ContainsKey(id)) {
      return new SotaventoLevelControllerAsILevelController(new SotaventoLevelController(this, id));
    }
    if (rootIncarnation.incarnationsNestLevelController.ContainsKey(id)) {
      return new NestLevelControllerAsILevelController(new NestLevelController(this, id));
    }
    if (rootIncarnation.incarnationsLakeLevelController.ContainsKey(id)) {
      return new LakeLevelControllerAsILevelController(new LakeLevelController(this, id));
    }
    if (rootIncarnation.incarnationsDirtRoadLevelController.ContainsKey(id)) {
      return new DirtRoadLevelControllerAsILevelController(new DirtRoadLevelController(this, id));
    }
    if (rootIncarnation.incarnationsCaveLevelController.ContainsKey(id)) {
      return new CaveLevelControllerAsILevelController(new CaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsBridgesLevelController.ContainsKey(id)) {
      return new BridgesLevelControllerAsILevelController(new BridgesLevelController(this, id));
    }
    if (rootIncarnation.incarnationsAncientTownLevelController.ContainsKey(id)) {
      return new AncientTownLevelControllerAsILevelController(new AncientTownLevelController(this, id));
    }
    return NullILevelController.Null;
  }
  public bool ILevelControllerExists(int id) {
    return GetILevelControllerOrNull(id) != null;
  }
  public void CheckHasILevelController(ILevelController thing) {
    GetILevelController(thing.id);
  }
  public void CheckHasILevelController(int id) {
    GetILevelController(id);
  }

  public IPickUpReactorItem GetIPickUpReactorItem(int id) {
    if (rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      return new SlowRodAsIPickUpReactorItem(new SlowRod(this, id));
    }
    if (rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      return new BlastRodAsIPickUpReactorItem(new BlastRod(this, id));
    }
    throw new Exception("Unknown IPickUpReactorItem: " + id);
  }
  public IPickUpReactorItem GetIPickUpReactorItemOrNull(int id) {
    if (rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      return new SlowRodAsIPickUpReactorItem(new SlowRod(this, id));
    }
    if (rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      return new BlastRodAsIPickUpReactorItem(new BlastRod(this, id));
    }
    return NullIPickUpReactorItem.Null;
  }
  public bool IPickUpReactorItemExists(int id) {
    return GetIPickUpReactorItemOrNull(id) != null;
  }
  public void CheckHasIPickUpReactorItem(IPickUpReactorItem thing) {
    GetIPickUpReactorItem(thing.id);
  }
  public void CheckHasIPickUpReactorItem(int id) {
    GetIPickUpReactorItem(id);
  }

  public IImmediatelyUseItem GetIImmediatelyUseItem(int id) {
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIImmediatelyUseItem(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIImmediatelyUseItem(new HealthPotion(this, id));
    }
    throw new Exception("Unknown IImmediatelyUseItem: " + id);
  }
  public IImmediatelyUseItem GetIImmediatelyUseItemOrNull(int id) {
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIImmediatelyUseItem(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIImmediatelyUseItem(new HealthPotion(this, id));
    }
    return NullIImmediatelyUseItem.Null;
  }
  public bool IImmediatelyUseItemExists(int id) {
    return GetIImmediatelyUseItemOrNull(id) != null;
  }
  public void CheckHasIImmediatelyUseItem(IImmediatelyUseItem thing) {
    GetIImmediatelyUseItem(thing.id);
  }
  public void CheckHasIImmediatelyUseItem(int id) {
    GetIImmediatelyUseItem(id);
  }

  public IUsableItem GetIUsableItem(int id) {
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIUsableItem(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIUsableItem(new HealthPotion(this, id));
    }
    throw new Exception("Unknown IUsableItem: " + id);
  }
  public IUsableItem GetIUsableItemOrNull(int id) {
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIUsableItem(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIUsableItem(new HealthPotion(this, id));
    }
    return NullIUsableItem.Null;
  }
  public bool IUsableItemExists(int id) {
    return GetIUsableItemOrNull(id) != null;
  }
  public void CheckHasIUsableItem(IUsableItem thing) {
    GetIUsableItem(thing.id);
  }
  public void CheckHasIUsableItem(int id) {
    GetIUsableItem(id);
  }

  public ICloneableUC GetICloneableUC(int id) {
    if (rootIncarnation.incarnationsSorcerousUC.ContainsKey(id)) {
      return new SorcerousUCAsICloneableUC(new SorcerousUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(id)) {
      return new BaseOffenseUCAsICloneableUC(new BaseOffenseUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(id)) {
      return new BaseSightRangeUCAsICloneableUC(new BaseSightRangeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(id)) {
      return new BaseMovementTimeUCAsICloneableUC(new BaseMovementTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(id)) {
      return new BaseDefenseUCAsICloneableUC(new BaseDefenseUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(id)) {
      return new BaseCombatTimeUCAsICloneableUC(new BaseCombatTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      return new SpeedRingAsICloneableUC(new SpeedRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsICloneableUC(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      return new SlowRodAsICloneableUC(new SlowRod(this, id));
    }
    if (rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      return new BlastRodAsICloneableUC(new BlastRod(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsICloneableUC(new Armor(this, id));
    }
    throw new Exception("Unknown ICloneableUC: " + id);
  }
  public ICloneableUC GetICloneableUCOrNull(int id) {
    if (rootIncarnation.incarnationsSorcerousUC.ContainsKey(id)) {
      return new SorcerousUCAsICloneableUC(new SorcerousUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(id)) {
      return new BaseOffenseUCAsICloneableUC(new BaseOffenseUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(id)) {
      return new BaseSightRangeUCAsICloneableUC(new BaseSightRangeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(id)) {
      return new BaseMovementTimeUCAsICloneableUC(new BaseMovementTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(id)) {
      return new BaseDefenseUCAsICloneableUC(new BaseDefenseUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(id)) {
      return new BaseCombatTimeUCAsICloneableUC(new BaseCombatTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      return new SpeedRingAsICloneableUC(new SpeedRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsICloneableUC(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      return new SlowRodAsICloneableUC(new SlowRod(this, id));
    }
    if (rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      return new BlastRodAsICloneableUC(new BlastRod(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsICloneableUC(new Armor(this, id));
    }
    return NullICloneableUC.Null;
  }
  public bool ICloneableUCExists(int id) {
    return GetICloneableUCOrNull(id) != null;
  }
  public void CheckHasICloneableUC(ICloneableUC thing) {
    GetICloneableUC(thing.id);
  }
  public void CheckHasICloneableUC(int id) {
    GetICloneableUC(id);
  }

  public IItem GetIItem(int id) {
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIItem(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIItem(new HealthPotion(this, id));
    }
    if (rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      return new SpeedRingAsIItem(new SpeedRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIItem(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      return new SlowRodAsIItem(new SlowRod(this, id));
    }
    if (rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      return new BlastRodAsIItem(new BlastRod(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIItem(new Armor(this, id));
    }
    throw new Exception("Unknown IItem: " + id);
  }
  public IItem GetIItemOrNull(int id) {
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIItem(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIItem(new HealthPotion(this, id));
    }
    if (rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      return new SpeedRingAsIItem(new SpeedRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIItem(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      return new SlowRodAsIItem(new SlowRod(this, id));
    }
    if (rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      return new BlastRodAsIItem(new BlastRod(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIItem(new Armor(this, id));
    }
    return NullIItem.Null;
  }
  public bool IItemExists(int id) {
    return GetIItemOrNull(id) != null;
  }
  public void CheckHasIItem(IItem thing) {
    GetIItem(thing.id);
  }
  public void CheckHasIItem(int id) {
    GetIItem(id);
  }

  public IDestructible GetIDestructible(int id) {
    if (rootIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(id)) {
      return new TutorialDefyCounterUCAsIDestructible(new TutorialDefyCounterUC(this, id));
    }
    if (rootIncarnation.incarnationsLightningChargingUC.ContainsKey(id)) {
      return new LightningChargingUCAsIDestructible(new LightningChargingUC(this, id));
    }
    if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      return new WanderAICapabilityUCAsIDestructible(new WanderAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(id)) {
      return new TemporaryCloneAICapabilityUCAsIDestructible(new TemporaryCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(id)) {
      return new SummonAICapabilityUCAsIDestructible(new SummonAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      return new KamikazeAICapabilityUCAsIDestructible(new KamikazeAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(id)) {
      return new GuardAICapabilityUCAsIDestructible(new GuardAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIDestructible(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDoomedUC.ContainsKey(id)) {
      return new DoomedUCAsIDestructible(new DoomedUC(this, id));
    }
    if (rootIncarnation.incarnationsMiredUC.ContainsKey(id)) {
      return new MiredUCAsIDestructible(new MiredUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIDestructible(new AttackAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIDestructible(new CounteringUC(this, id));
    }
    if (rootIncarnation.incarnationsLightningChargedUC.ContainsKey(id)) {
      return new LightningChargedUCAsIDestructible(new LightningChargedUC(this, id));
    }
    if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      return new InvincibilityUCAsIDestructible(new InvincibilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDefyingUC.ContainsKey(id)) {
      return new DefyingUCAsIDestructible(new DefyingUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIDestructible(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(id)) {
      return new BaseSightRangeUCAsIDestructible(new BaseSightRangeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(id)) {
      return new BaseMovementTimeUCAsIDestructible(new BaseMovementTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(id)) {
      return new BaseCombatTimeUCAsIDestructible(new BaseCombatTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIDestructible(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIDestructible(new HealthPotion(this, id));
    }
    if (rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      return new SpeedRingAsIDestructible(new SpeedRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIDestructible(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      return new SlowRodAsIDestructible(new SlowRod(this, id));
    }
    if (rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      return new BlastRodAsIDestructible(new BlastRod(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIDestructible(new Armor(this, id));
    }
    if (rootIncarnation.incarnationsSorcerousUC.ContainsKey(id)) {
      return new SorcerousUCAsIDestructible(new SorcerousUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(id)) {
      return new BaseOffenseUCAsIDestructible(new BaseOffenseUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(id)) {
      return new BaseDefenseUCAsIDestructible(new BaseDefenseUC(this, id));
    }
    if (rootIncarnation.incarnationsHoldPositionImpulse.ContainsKey(id)) {
      return new HoldPositionImpulseAsIDestructible(new HoldPositionImpulse(this, id));
    }
    if (rootIncarnation.incarnationsTemporaryCloneImpulse.ContainsKey(id)) {
      return new TemporaryCloneImpulseAsIDestructible(new TemporaryCloneImpulse(this, id));
    }
    if (rootIncarnation.incarnationsSummonImpulse.ContainsKey(id)) {
      return new SummonImpulseAsIDestructible(new SummonImpulse(this, id));
    }
    if (rootIncarnation.incarnationsMireImpulse.ContainsKey(id)) {
      return new MireImpulseAsIDestructible(new MireImpulse(this, id));
    }
    if (rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(id)) {
      return new EvaporateImpulseAsIDestructible(new EvaporateImpulse(this, id));
    }
    if (rootIncarnation.incarnationsMoveImpulse.ContainsKey(id)) {
      return new MoveImpulseAsIDestructible(new MoveImpulse(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeJumpImpulse.ContainsKey(id)) {
      return new KamikazeJumpImpulseAsIDestructible(new KamikazeJumpImpulse(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeTargetImpulse.ContainsKey(id)) {
      return new KamikazeTargetImpulseAsIDestructible(new KamikazeTargetImpulse(this, id));
    }
    if (rootIncarnation.incarnationsNoImpulse.ContainsKey(id)) {
      return new NoImpulseAsIDestructible(new NoImpulse(this, id));
    }
    if (rootIncarnation.incarnationsFireImpulse.ContainsKey(id)) {
      return new FireImpulseAsIDestructible(new FireImpulse(this, id));
    }
    if (rootIncarnation.incarnationsDefyImpulse.ContainsKey(id)) {
      return new DefyImpulseAsIDestructible(new DefyImpulse(this, id));
    }
    if (rootIncarnation.incarnationsCounterImpulse.ContainsKey(id)) {
      return new CounterImpulseAsIDestructible(new CounterImpulse(this, id));
    }
    if (rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(id)) {
      return new UnleashBideImpulseAsIDestructible(new UnleashBideImpulse(this, id));
    }
    if (rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(id)) {
      return new ContinueBidingImpulseAsIDestructible(new ContinueBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(id)) {
      return new StartBidingImpulseAsIDestructible(new StartBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsAttackImpulse.ContainsKey(id)) {
      return new AttackImpulseAsIDestructible(new AttackImpulse(this, id));
    }
    if (rootIncarnation.incarnationsPursueImpulse.ContainsKey(id)) {
      return new PursueImpulseAsIDestructible(new PursueImpulse(this, id));
    }
    if (rootIncarnation.incarnationsFireBombImpulse.ContainsKey(id)) {
      return new FireBombImpulseAsIDestructible(new FireBombImpulse(this, id));
    }
    if (rootIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(id)) {
      return new SimplePresenceTriggerTTCAsIDestructible(new SimplePresenceTriggerTTC(this, id));
    }
    if (rootIncarnation.incarnationsItemTTC.ContainsKey(id)) {
      return new ItemTTCAsIDestructible(new ItemTTC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeTargetTTC.ContainsKey(id)) {
      return new KamikazeTargetTTCAsIDestructible(new KamikazeTargetTTC(this, id));
    }
    if (rootIncarnation.incarnationsWarperTTC.ContainsKey(id)) {
      return new WarperTTCAsIDestructible(new WarperTTC(this, id));
    }
    if (rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(id)) {
      return new TimeAnchorTTCAsIDestructible(new TimeAnchorTTC(this, id));
    }
    if (rootIncarnation.incarnationsFireBombTTC.ContainsKey(id)) {
      return new FireBombTTCAsIDestructible(new FireBombTTC(this, id));
    }
    if (rootIncarnation.incarnationsMarkerTTC.ContainsKey(id)) {
      return new MarkerTTCAsIDestructible(new MarkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsLevelLinkTTC.ContainsKey(id)) {
      return new LevelLinkTTCAsIDestructible(new LevelLinkTTC(this, id));
    }
    if (rootIncarnation.incarnationsMudTTC.ContainsKey(id)) {
      return new MudTTCAsIDestructible(new MudTTC(this, id));
    }
    if (rootIncarnation.incarnationsDirtTTC.ContainsKey(id)) {
      return new DirtTTCAsIDestructible(new DirtTTC(this, id));
    }
    if (rootIncarnation.incarnationsObsidianTTC.ContainsKey(id)) {
      return new ObsidianTTCAsIDestructible(new ObsidianTTC(this, id));
    }
    if (rootIncarnation.incarnationsDownStairsTTC.ContainsKey(id)) {
      return new DownStairsTTCAsIDestructible(new DownStairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsUpStairsTTC.ContainsKey(id)) {
      return new UpStairsTTCAsIDestructible(new UpStairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsWallTTC.ContainsKey(id)) {
      return new WallTTCAsIDestructible(new WallTTC(this, id));
    }
    if (rootIncarnation.incarnationsBloodTTC.ContainsKey(id)) {
      return new BloodTTCAsIDestructible(new BloodTTC(this, id));
    }
    if (rootIncarnation.incarnationsRocksTTC.ContainsKey(id)) {
      return new RocksTTCAsIDestructible(new RocksTTC(this, id));
    }
    if (rootIncarnation.incarnationsTreeTTC.ContainsKey(id)) {
      return new TreeTTCAsIDestructible(new TreeTTC(this, id));
    }
    if (rootIncarnation.incarnationsWaterTTC.ContainsKey(id)) {
      return new WaterTTCAsIDestructible(new WaterTTC(this, id));
    }
    if (rootIncarnation.incarnationsFloorTTC.ContainsKey(id)) {
      return new FloorTTCAsIDestructible(new FloorTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveWallTTC.ContainsKey(id)) {
      return new CaveWallTTCAsIDestructible(new CaveWallTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveTTC.ContainsKey(id)) {
      return new CaveTTCAsIDestructible(new CaveTTC(this, id));
    }
    if (rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      return new FallsTTCAsIDestructible(new FallsTTC(this, id));
    }
    if (rootIncarnation.incarnationsFireTTC.ContainsKey(id)) {
      return new FireTTCAsIDestructible(new FireTTC(this, id));
    }
    if (rootIncarnation.incarnationsObsidianFloorTTC.ContainsKey(id)) {
      return new ObsidianFloorTTCAsIDestructible(new ObsidianFloorTTC(this, id));
    }
    if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      return new MagmaTTCAsIDestructible(new MagmaTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffTTC.ContainsKey(id)) {
      return new CliffTTCAsIDestructible(new CliffTTC(this, id));
    }
    if (rootIncarnation.incarnationsRavaNestTTC.ContainsKey(id)) {
      return new RavaNestTTCAsIDestructible(new RavaNestTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(id)) {
      return new CliffLandingTTCAsIDestructible(new CliffLandingTTC(this, id));
    }
    if (rootIncarnation.incarnationsStoneTTC.ContainsKey(id)) {
      return new StoneTTCAsIDestructible(new StoneTTC(this, id));
    }
    if (rootIncarnation.incarnationsGrassTTC.ContainsKey(id)) {
      return new GrassTTCAsIDestructible(new GrassTTC(this, id));
    }
    if (rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(id)) {
      return new IncendianFallsLevelLinkerTTCAsIDestructible(new IncendianFallsLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(id)) {
      return new EmberDeepLevelLinkerTTCAsIDestructible(new EmberDeepLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(id)) {
      return new SquareCaveLevelControllerAsIDestructible(new SquareCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(id)) {
      return new RavashrikeLevelControllerAsIDestructible(new RavashrikeLevelController(this, id));
    }
    if (rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(id)) {
      return new PentagonalCaveLevelControllerAsIDestructible(new PentagonalCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsCliffLevelController.ContainsKey(id)) {
      return new CliffLevelControllerAsIDestructible(new CliffLevelController(this, id));
    }
    if (rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(id)) {
      return new PreGauntletLevelControllerAsIDestructible(new PreGauntletLevelController(this, id));
    }
    if (rootIncarnation.incarnationsGauntletLevelController.ContainsKey(id)) {
      return new GauntletLevelControllerAsIDestructible(new GauntletLevelController(this, id));
    }
    if (rootIncarnation.incarnationsVolcaetusLevelController.ContainsKey(id)) {
      return new VolcaetusLevelControllerAsIDestructible(new VolcaetusLevelController(this, id));
    }
    if (rootIncarnation.incarnationsTutorial2LevelController.ContainsKey(id)) {
      return new Tutorial2LevelControllerAsIDestructible(new Tutorial2LevelController(this, id));
    }
    if (rootIncarnation.incarnationsTutorial1LevelController.ContainsKey(id)) {
      return new Tutorial1LevelControllerAsIDestructible(new Tutorial1LevelController(this, id));
    }
    if (rootIncarnation.incarnationsRetreatLevelController.ContainsKey(id)) {
      return new RetreatLevelControllerAsIDestructible(new RetreatLevelController(this, id));
    }
    if (rootIncarnation.incarnationsSotaventoLevelController.ContainsKey(id)) {
      return new SotaventoLevelControllerAsIDestructible(new SotaventoLevelController(this, id));
    }
    if (rootIncarnation.incarnationsNestLevelController.ContainsKey(id)) {
      return new NestLevelControllerAsIDestructible(new NestLevelController(this, id));
    }
    if (rootIncarnation.incarnationsLakeLevelController.ContainsKey(id)) {
      return new LakeLevelControllerAsIDestructible(new LakeLevelController(this, id));
    }
    if (rootIncarnation.incarnationsDirtRoadLevelController.ContainsKey(id)) {
      return new DirtRoadLevelControllerAsIDestructible(new DirtRoadLevelController(this, id));
    }
    if (rootIncarnation.incarnationsCaveLevelController.ContainsKey(id)) {
      return new CaveLevelControllerAsIDestructible(new CaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsBridgesLevelController.ContainsKey(id)) {
      return new BridgesLevelControllerAsIDestructible(new BridgesLevelController(this, id));
    }
    if (rootIncarnation.incarnationsAncientTownLevelController.ContainsKey(id)) {
      return new AncientTownLevelControllerAsIDestructible(new AncientTownLevelController(this, id));
    }
    if (rootIncarnation.incarnationsUnit.ContainsKey(id)) {
      return new UnitAsIDestructible(new Unit(this, id));
    }
    throw new Exception("Unknown IDestructible: " + id);
  }
  public IDestructible GetIDestructibleOrNull(int id) {
    if (rootIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(id)) {
      return new TutorialDefyCounterUCAsIDestructible(new TutorialDefyCounterUC(this, id));
    }
    if (rootIncarnation.incarnationsLightningChargingUC.ContainsKey(id)) {
      return new LightningChargingUCAsIDestructible(new LightningChargingUC(this, id));
    }
    if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      return new WanderAICapabilityUCAsIDestructible(new WanderAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(id)) {
      return new TemporaryCloneAICapabilityUCAsIDestructible(new TemporaryCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(id)) {
      return new SummonAICapabilityUCAsIDestructible(new SummonAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      return new KamikazeAICapabilityUCAsIDestructible(new KamikazeAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(id)) {
      return new GuardAICapabilityUCAsIDestructible(new GuardAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIDestructible(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDoomedUC.ContainsKey(id)) {
      return new DoomedUCAsIDestructible(new DoomedUC(this, id));
    }
    if (rootIncarnation.incarnationsMiredUC.ContainsKey(id)) {
      return new MiredUCAsIDestructible(new MiredUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIDestructible(new AttackAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIDestructible(new CounteringUC(this, id));
    }
    if (rootIncarnation.incarnationsLightningChargedUC.ContainsKey(id)) {
      return new LightningChargedUCAsIDestructible(new LightningChargedUC(this, id));
    }
    if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      return new InvincibilityUCAsIDestructible(new InvincibilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDefyingUC.ContainsKey(id)) {
      return new DefyingUCAsIDestructible(new DefyingUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIDestructible(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(id)) {
      return new BaseSightRangeUCAsIDestructible(new BaseSightRangeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(id)) {
      return new BaseMovementTimeUCAsIDestructible(new BaseMovementTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(id)) {
      return new BaseCombatTimeUCAsIDestructible(new BaseCombatTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIDestructible(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIDestructible(new HealthPotion(this, id));
    }
    if (rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      return new SpeedRingAsIDestructible(new SpeedRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIDestructible(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      return new SlowRodAsIDestructible(new SlowRod(this, id));
    }
    if (rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      return new BlastRodAsIDestructible(new BlastRod(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIDestructible(new Armor(this, id));
    }
    if (rootIncarnation.incarnationsSorcerousUC.ContainsKey(id)) {
      return new SorcerousUCAsIDestructible(new SorcerousUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(id)) {
      return new BaseOffenseUCAsIDestructible(new BaseOffenseUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(id)) {
      return new BaseDefenseUCAsIDestructible(new BaseDefenseUC(this, id));
    }
    if (rootIncarnation.incarnationsHoldPositionImpulse.ContainsKey(id)) {
      return new HoldPositionImpulseAsIDestructible(new HoldPositionImpulse(this, id));
    }
    if (rootIncarnation.incarnationsTemporaryCloneImpulse.ContainsKey(id)) {
      return new TemporaryCloneImpulseAsIDestructible(new TemporaryCloneImpulse(this, id));
    }
    if (rootIncarnation.incarnationsSummonImpulse.ContainsKey(id)) {
      return new SummonImpulseAsIDestructible(new SummonImpulse(this, id));
    }
    if (rootIncarnation.incarnationsMireImpulse.ContainsKey(id)) {
      return new MireImpulseAsIDestructible(new MireImpulse(this, id));
    }
    if (rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(id)) {
      return new EvaporateImpulseAsIDestructible(new EvaporateImpulse(this, id));
    }
    if (rootIncarnation.incarnationsMoveImpulse.ContainsKey(id)) {
      return new MoveImpulseAsIDestructible(new MoveImpulse(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeJumpImpulse.ContainsKey(id)) {
      return new KamikazeJumpImpulseAsIDestructible(new KamikazeJumpImpulse(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeTargetImpulse.ContainsKey(id)) {
      return new KamikazeTargetImpulseAsIDestructible(new KamikazeTargetImpulse(this, id));
    }
    if (rootIncarnation.incarnationsNoImpulse.ContainsKey(id)) {
      return new NoImpulseAsIDestructible(new NoImpulse(this, id));
    }
    if (rootIncarnation.incarnationsFireImpulse.ContainsKey(id)) {
      return new FireImpulseAsIDestructible(new FireImpulse(this, id));
    }
    if (rootIncarnation.incarnationsDefyImpulse.ContainsKey(id)) {
      return new DefyImpulseAsIDestructible(new DefyImpulse(this, id));
    }
    if (rootIncarnation.incarnationsCounterImpulse.ContainsKey(id)) {
      return new CounterImpulseAsIDestructible(new CounterImpulse(this, id));
    }
    if (rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(id)) {
      return new UnleashBideImpulseAsIDestructible(new UnleashBideImpulse(this, id));
    }
    if (rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(id)) {
      return new ContinueBidingImpulseAsIDestructible(new ContinueBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(id)) {
      return new StartBidingImpulseAsIDestructible(new StartBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsAttackImpulse.ContainsKey(id)) {
      return new AttackImpulseAsIDestructible(new AttackImpulse(this, id));
    }
    if (rootIncarnation.incarnationsPursueImpulse.ContainsKey(id)) {
      return new PursueImpulseAsIDestructible(new PursueImpulse(this, id));
    }
    if (rootIncarnation.incarnationsFireBombImpulse.ContainsKey(id)) {
      return new FireBombImpulseAsIDestructible(new FireBombImpulse(this, id));
    }
    if (rootIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(id)) {
      return new SimplePresenceTriggerTTCAsIDestructible(new SimplePresenceTriggerTTC(this, id));
    }
    if (rootIncarnation.incarnationsItemTTC.ContainsKey(id)) {
      return new ItemTTCAsIDestructible(new ItemTTC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeTargetTTC.ContainsKey(id)) {
      return new KamikazeTargetTTCAsIDestructible(new KamikazeTargetTTC(this, id));
    }
    if (rootIncarnation.incarnationsWarperTTC.ContainsKey(id)) {
      return new WarperTTCAsIDestructible(new WarperTTC(this, id));
    }
    if (rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(id)) {
      return new TimeAnchorTTCAsIDestructible(new TimeAnchorTTC(this, id));
    }
    if (rootIncarnation.incarnationsFireBombTTC.ContainsKey(id)) {
      return new FireBombTTCAsIDestructible(new FireBombTTC(this, id));
    }
    if (rootIncarnation.incarnationsMarkerTTC.ContainsKey(id)) {
      return new MarkerTTCAsIDestructible(new MarkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsLevelLinkTTC.ContainsKey(id)) {
      return new LevelLinkTTCAsIDestructible(new LevelLinkTTC(this, id));
    }
    if (rootIncarnation.incarnationsMudTTC.ContainsKey(id)) {
      return new MudTTCAsIDestructible(new MudTTC(this, id));
    }
    if (rootIncarnation.incarnationsDirtTTC.ContainsKey(id)) {
      return new DirtTTCAsIDestructible(new DirtTTC(this, id));
    }
    if (rootIncarnation.incarnationsObsidianTTC.ContainsKey(id)) {
      return new ObsidianTTCAsIDestructible(new ObsidianTTC(this, id));
    }
    if (rootIncarnation.incarnationsDownStairsTTC.ContainsKey(id)) {
      return new DownStairsTTCAsIDestructible(new DownStairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsUpStairsTTC.ContainsKey(id)) {
      return new UpStairsTTCAsIDestructible(new UpStairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsWallTTC.ContainsKey(id)) {
      return new WallTTCAsIDestructible(new WallTTC(this, id));
    }
    if (rootIncarnation.incarnationsBloodTTC.ContainsKey(id)) {
      return new BloodTTCAsIDestructible(new BloodTTC(this, id));
    }
    if (rootIncarnation.incarnationsRocksTTC.ContainsKey(id)) {
      return new RocksTTCAsIDestructible(new RocksTTC(this, id));
    }
    if (rootIncarnation.incarnationsTreeTTC.ContainsKey(id)) {
      return new TreeTTCAsIDestructible(new TreeTTC(this, id));
    }
    if (rootIncarnation.incarnationsWaterTTC.ContainsKey(id)) {
      return new WaterTTCAsIDestructible(new WaterTTC(this, id));
    }
    if (rootIncarnation.incarnationsFloorTTC.ContainsKey(id)) {
      return new FloorTTCAsIDestructible(new FloorTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveWallTTC.ContainsKey(id)) {
      return new CaveWallTTCAsIDestructible(new CaveWallTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveTTC.ContainsKey(id)) {
      return new CaveTTCAsIDestructible(new CaveTTC(this, id));
    }
    if (rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      return new FallsTTCAsIDestructible(new FallsTTC(this, id));
    }
    if (rootIncarnation.incarnationsFireTTC.ContainsKey(id)) {
      return new FireTTCAsIDestructible(new FireTTC(this, id));
    }
    if (rootIncarnation.incarnationsObsidianFloorTTC.ContainsKey(id)) {
      return new ObsidianFloorTTCAsIDestructible(new ObsidianFloorTTC(this, id));
    }
    if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      return new MagmaTTCAsIDestructible(new MagmaTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffTTC.ContainsKey(id)) {
      return new CliffTTCAsIDestructible(new CliffTTC(this, id));
    }
    if (rootIncarnation.incarnationsRavaNestTTC.ContainsKey(id)) {
      return new RavaNestTTCAsIDestructible(new RavaNestTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(id)) {
      return new CliffLandingTTCAsIDestructible(new CliffLandingTTC(this, id));
    }
    if (rootIncarnation.incarnationsStoneTTC.ContainsKey(id)) {
      return new StoneTTCAsIDestructible(new StoneTTC(this, id));
    }
    if (rootIncarnation.incarnationsGrassTTC.ContainsKey(id)) {
      return new GrassTTCAsIDestructible(new GrassTTC(this, id));
    }
    if (rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(id)) {
      return new IncendianFallsLevelLinkerTTCAsIDestructible(new IncendianFallsLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(id)) {
      return new EmberDeepLevelLinkerTTCAsIDestructible(new EmberDeepLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(id)) {
      return new SquareCaveLevelControllerAsIDestructible(new SquareCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(id)) {
      return new RavashrikeLevelControllerAsIDestructible(new RavashrikeLevelController(this, id));
    }
    if (rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(id)) {
      return new PentagonalCaveLevelControllerAsIDestructible(new PentagonalCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsCliffLevelController.ContainsKey(id)) {
      return new CliffLevelControllerAsIDestructible(new CliffLevelController(this, id));
    }
    if (rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(id)) {
      return new PreGauntletLevelControllerAsIDestructible(new PreGauntletLevelController(this, id));
    }
    if (rootIncarnation.incarnationsGauntletLevelController.ContainsKey(id)) {
      return new GauntletLevelControllerAsIDestructible(new GauntletLevelController(this, id));
    }
    if (rootIncarnation.incarnationsVolcaetusLevelController.ContainsKey(id)) {
      return new VolcaetusLevelControllerAsIDestructible(new VolcaetusLevelController(this, id));
    }
    if (rootIncarnation.incarnationsTutorial2LevelController.ContainsKey(id)) {
      return new Tutorial2LevelControllerAsIDestructible(new Tutorial2LevelController(this, id));
    }
    if (rootIncarnation.incarnationsTutorial1LevelController.ContainsKey(id)) {
      return new Tutorial1LevelControllerAsIDestructible(new Tutorial1LevelController(this, id));
    }
    if (rootIncarnation.incarnationsRetreatLevelController.ContainsKey(id)) {
      return new RetreatLevelControllerAsIDestructible(new RetreatLevelController(this, id));
    }
    if (rootIncarnation.incarnationsSotaventoLevelController.ContainsKey(id)) {
      return new SotaventoLevelControllerAsIDestructible(new SotaventoLevelController(this, id));
    }
    if (rootIncarnation.incarnationsNestLevelController.ContainsKey(id)) {
      return new NestLevelControllerAsIDestructible(new NestLevelController(this, id));
    }
    if (rootIncarnation.incarnationsLakeLevelController.ContainsKey(id)) {
      return new LakeLevelControllerAsIDestructible(new LakeLevelController(this, id));
    }
    if (rootIncarnation.incarnationsDirtRoadLevelController.ContainsKey(id)) {
      return new DirtRoadLevelControllerAsIDestructible(new DirtRoadLevelController(this, id));
    }
    if (rootIncarnation.incarnationsCaveLevelController.ContainsKey(id)) {
      return new CaveLevelControllerAsIDestructible(new CaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsBridgesLevelController.ContainsKey(id)) {
      return new BridgesLevelControllerAsIDestructible(new BridgesLevelController(this, id));
    }
    if (rootIncarnation.incarnationsAncientTownLevelController.ContainsKey(id)) {
      return new AncientTownLevelControllerAsIDestructible(new AncientTownLevelController(this, id));
    }
    if (rootIncarnation.incarnationsUnit.ContainsKey(id)) {
      return new UnitAsIDestructible(new Unit(this, id));
    }
    return NullIDestructible.Null;
  }
  public bool IDestructibleExists(int id) {
    return GetIDestructibleOrNull(id) != null;
  }
  public void CheckHasIDestructible(IDestructible thing) {
    GetIDestructible(thing.id);
  }
  public void CheckHasIDestructible(int id) {
    GetIDestructible(id);
  }

    public int GetCommMutListHash(int id, int version, CommMutListIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.list) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CommMutListIncarnation GetCommMutListIncarnation(int id) {
      return rootIncarnation.incarnationsCommMutList[id].incarnation;
    }
    public CommMutList GetCommMutList(int id) {
      CheckHasCommMutList(id);
      return new CommMutList(this, id);
    }
    public CommMutList GetCommMutListOrNull(int id) {
      if (CommMutListExists(id)) {
        return new CommMutList(this, id);
      } else {
        return new CommMutList(this, 0);
      }
    }
    public List<CommMutList> AllCommMutList() {
      List<CommMutList> result = new List<CommMutList>(rootIncarnation.incarnationsCommMutList.Count);
      foreach (var id in rootIncarnation.incarnationsCommMutList.Keys) {
        result.Add(new CommMutList(this, id));
      }
      return result;
    }
    public bool CommMutListExists(int id) {
      return rootIncarnation.incarnationsCommMutList.ContainsKey(id);
    }
    public void CheckHasCommMutList(CommMutList thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCommMutList(thing.id);
    }
    public void CheckHasCommMutList(int id) {
      if (!rootIncarnation.incarnationsCommMutList.ContainsKey(id)) {
        throw new System.Exception("Invalid CommMutList}: " + id);
      }
    }
    public CommMutList EffectCommMutListCreate() {
      return TrustedEffectCommMutListCreateWithId(NewId());
    }
    public CommMutList TrustedEffectCommMutListCreateWithId(int id) {
      CheckUnlocked();
      Asserts.Assert(!rootIncarnation.incarnationsCommMutList.ContainsKey(id));
      EffectInternalCreateCommMutList(id, rootIncarnation.version, new CommMutListIncarnation(new List<int>()));
      return new CommMutList(this, id);
    }
    public CommMutList EffectCommMutListCreate(IEnumerable<Comm> elements) {
      var list = EffectCommMutListCreate();
      foreach (var element in elements) {
        list.Add(element);
      }
      return list;
    }
    public void EffectInternalCreateCommMutList(int id, int incarnationVersion, CommMutListIncarnation incarnation) {
      var effect = new CommMutListCreateEffect(id);
      rootIncarnation.incarnationsCommMutList
          .Add(
              id,
              new VersionAndIncarnation<CommMutListIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectCommMutListDelete(int id) {
      CheckUnlocked();
      var effect = new CommMutListDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsCommMutList[id];
      rootIncarnation.incarnationsCommMutList.Remove(id);
    }
    public void EffectCommMutListAdd(int listId, int addIndex, int element) {
      CheckUnlocked();
      CheckHasCommMutList(listId);

          CheckHasComm(element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCommMutList[listId];
      var effect = new CommMutListAddEffect(listId, addIndex, element);

      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.list.Insert(addIndex, element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.list;
        var newMap = new List<int>(oldMap);
        newMap.Insert(addIndex, element);
        var newIncarnation = new CommMutListIncarnation(newMap);
        rootIncarnation.incarnationsCommMutList[listId] =
            new VersionAndIncarnation<CommMutListIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectCommMutListRemoveAt(int listId, int index) {
      CheckUnlocked();
      CheckHasCommMutList(listId);

      var effect = new CommMutListRemoveEffect(listId, index);


      var oldIncarnationAndVersion = rootIncarnation.incarnationsCommMutList[listId];
      // Check that its there
      var oldElement = oldIncarnationAndVersion.incarnation.list[index];

      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.list.RemoveAt(index);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.list;
        var newMap = new List<int>(oldMap);
        newMap.RemoveAt(index);
        var newIncarnation = new CommMutListIncarnation(newMap);
        rootIncarnation.incarnationsCommMutList[listId] =
            new VersionAndIncarnation<CommMutListIncarnation>(
                rootIncarnation.version, newIncarnation);

      }
      NotifyEffect(effect);
    }
       
    public int GetLocationMutListHash(int id, int version, LocationMutListIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.list) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public LocationMutListIncarnation GetLocationMutListIncarnation(int id) {
      return rootIncarnation.incarnationsLocationMutList[id].incarnation;
    }
    public LocationMutList GetLocationMutList(int id) {
      CheckHasLocationMutList(id);
      return new LocationMutList(this, id);
    }
    public LocationMutList GetLocationMutListOrNull(int id) {
      if (LocationMutListExists(id)) {
        return new LocationMutList(this, id);
      } else {
        return new LocationMutList(this, 0);
      }
    }
    public List<LocationMutList> AllLocationMutList() {
      List<LocationMutList> result = new List<LocationMutList>(rootIncarnation.incarnationsLocationMutList.Count);
      foreach (var id in rootIncarnation.incarnationsLocationMutList.Keys) {
        result.Add(new LocationMutList(this, id));
      }
      return result;
    }
    public bool LocationMutListExists(int id) {
      return rootIncarnation.incarnationsLocationMutList.ContainsKey(id);
    }
    public void CheckHasLocationMutList(LocationMutList thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasLocationMutList(thing.id);
    }
    public void CheckHasLocationMutList(int id) {
      if (!rootIncarnation.incarnationsLocationMutList.ContainsKey(id)) {
        throw new System.Exception("Invalid LocationMutList}: " + id);
      }
    }
    public LocationMutList EffectLocationMutListCreate() {
      return TrustedEffectLocationMutListCreateWithId(NewId());
    }
    public LocationMutList TrustedEffectLocationMutListCreateWithId(int id) {
      CheckUnlocked();
      Asserts.Assert(!rootIncarnation.incarnationsLocationMutList.ContainsKey(id));
      EffectInternalCreateLocationMutList(id, rootIncarnation.version, new LocationMutListIncarnation(new List<Location>()));
      return new LocationMutList(this, id);
    }
    public LocationMutList EffectLocationMutListCreate(IEnumerable<Location> elements) {
      var list = EffectLocationMutListCreate();
      foreach (var element in elements) {
        list.Add(element);
      }
      return list;
    }
    public void EffectInternalCreateLocationMutList(int id, int incarnationVersion, LocationMutListIncarnation incarnation) {
      var effect = new LocationMutListCreateEffect(id);
      rootIncarnation.incarnationsLocationMutList
          .Add(
              id,
              new VersionAndIncarnation<LocationMutListIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectLocationMutListDelete(int id) {
      CheckUnlocked();
      var effect = new LocationMutListDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsLocationMutList[id];
      rootIncarnation.incarnationsLocationMutList.Remove(id);
    }
    public void EffectLocationMutListAdd(int listId, int addIndex, Location element) {
      CheckUnlocked();
      CheckHasLocationMutList(listId);

    

      var oldIncarnationAndVersion = rootIncarnation.incarnationsLocationMutList[listId];
      var effect = new LocationMutListAddEffect(listId, addIndex, element);

      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.list.Insert(addIndex, element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.list;
        var newMap = new List<Location>(oldMap);
        newMap.Insert(addIndex, element);
        var newIncarnation = new LocationMutListIncarnation(newMap);
        rootIncarnation.incarnationsLocationMutList[listId] =
            new VersionAndIncarnation<LocationMutListIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectLocationMutListRemoveAt(int listId, int index) {
      CheckUnlocked();
      CheckHasLocationMutList(listId);

      var effect = new LocationMutListRemoveEffect(listId, index);


      var oldIncarnationAndVersion = rootIncarnation.incarnationsLocationMutList[listId];
      // Check that its there
      var oldElement = oldIncarnationAndVersion.incarnation.list[index];

      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.list.RemoveAt(index);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.list;
        var newMap = new List<Location>(oldMap);
        newMap.RemoveAt(index);
        var newIncarnation = new LocationMutListIncarnation(newMap);
        rootIncarnation.incarnationsLocationMutList[listId] =
            new VersionAndIncarnation<LocationMutListIncarnation>(
                rootIncarnation.version, newIncarnation);

      }
      NotifyEffect(effect);
    }
       
    public int GetIRequestMutListHash(int id, int version, IRequestMutListIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.list) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public IRequestMutListIncarnation GetIRequestMutListIncarnation(int id) {
      return rootIncarnation.incarnationsIRequestMutList[id].incarnation;
    }
    public IRequestMutList GetIRequestMutList(int id) {
      CheckHasIRequestMutList(id);
      return new IRequestMutList(this, id);
    }
    public IRequestMutList GetIRequestMutListOrNull(int id) {
      if (IRequestMutListExists(id)) {
        return new IRequestMutList(this, id);
      } else {
        return new IRequestMutList(this, 0);
      }
    }
    public List<IRequestMutList> AllIRequestMutList() {
      List<IRequestMutList> result = new List<IRequestMutList>(rootIncarnation.incarnationsIRequestMutList.Count);
      foreach (var id in rootIncarnation.incarnationsIRequestMutList.Keys) {
        result.Add(new IRequestMutList(this, id));
      }
      return result;
    }
    public bool IRequestMutListExists(int id) {
      return rootIncarnation.incarnationsIRequestMutList.ContainsKey(id);
    }
    public void CheckHasIRequestMutList(IRequestMutList thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasIRequestMutList(thing.id);
    }
    public void CheckHasIRequestMutList(int id) {
      if (!rootIncarnation.incarnationsIRequestMutList.ContainsKey(id)) {
        throw new System.Exception("Invalid IRequestMutList}: " + id);
      }
    }
    public IRequestMutList EffectIRequestMutListCreate() {
      return TrustedEffectIRequestMutListCreateWithId(NewId());
    }
    public IRequestMutList TrustedEffectIRequestMutListCreateWithId(int id) {
      CheckUnlocked();
      Asserts.Assert(!rootIncarnation.incarnationsIRequestMutList.ContainsKey(id));
      EffectInternalCreateIRequestMutList(id, rootIncarnation.version, new IRequestMutListIncarnation(new List<IRequest>()));
      return new IRequestMutList(this, id);
    }
    public IRequestMutList EffectIRequestMutListCreate(IEnumerable<IRequest> elements) {
      var list = EffectIRequestMutListCreate();
      foreach (var element in elements) {
        list.Add(element);
      }
      return list;
    }
    public void EffectInternalCreateIRequestMutList(int id, int incarnationVersion, IRequestMutListIncarnation incarnation) {
      var effect = new IRequestMutListCreateEffect(id);
      rootIncarnation.incarnationsIRequestMutList
          .Add(
              id,
              new VersionAndIncarnation<IRequestMutListIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectIRequestMutListDelete(int id) {
      CheckUnlocked();
      var effect = new IRequestMutListDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsIRequestMutList[id];
      rootIncarnation.incarnationsIRequestMutList.Remove(id);
    }
    public void EffectIRequestMutListAdd(int listId, int addIndex, IRequest element) {
      CheckUnlocked();
      CheckHasIRequestMutList(listId);

    

      var oldIncarnationAndVersion = rootIncarnation.incarnationsIRequestMutList[listId];
      var effect = new IRequestMutListAddEffect(listId, addIndex, element);

      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.list.Insert(addIndex, element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.list;
        var newMap = new List<IRequest>(oldMap);
        newMap.Insert(addIndex, element);
        var newIncarnation = new IRequestMutListIncarnation(newMap);
        rootIncarnation.incarnationsIRequestMutList[listId] =
            new VersionAndIncarnation<IRequestMutListIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectIRequestMutListRemoveAt(int listId, int index) {
      CheckUnlocked();
      CheckHasIRequestMutList(listId);

      var effect = new IRequestMutListRemoveEffect(listId, index);


      var oldIncarnationAndVersion = rootIncarnation.incarnationsIRequestMutList[listId];
      // Check that its there
      var oldElement = oldIncarnationAndVersion.incarnation.list[index];

      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.list.RemoveAt(index);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.list;
        var newMap = new List<IRequest>(oldMap);
        newMap.RemoveAt(index);
        var newIncarnation = new IRequestMutListIncarnation(newMap);
        rootIncarnation.incarnationsIRequestMutList[listId] =
            new VersionAndIncarnation<IRequestMutListIncarnation>(
                rootIncarnation.version, newIncarnation);

      }
      NotifyEffect(effect);
    }
       
    public int GetLevelMutSetHash(int id, int version, LevelMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public LevelMutSetIncarnation GetLevelMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsLevelMutSet[id].incarnation;
    }
    public LevelMutSet GetLevelMutSet(int id) {
      return new LevelMutSet(this, id);
    }
    public List<LevelMutSet> AllLevelMutSet() {
      List<LevelMutSet> result = new List<LevelMutSet>(rootIncarnation.incarnationsLevelMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsLevelMutSet.Keys) {
        result.Add(new LevelMutSet(this, id));
      }
      return result;
    }
    public bool LevelMutSetExists(int id) {
      return rootIncarnation.incarnationsLevelMutSet.ContainsKey(id);
    }
    public void CheckHasLevelMutSet(LevelMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasLevelMutSet(thing.id);
    }
    public void CheckHasLevelMutSet(int id) {
      if (!rootIncarnation.incarnationsLevelMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid LevelMutSet}: " + id);
      }
    }
    public LevelMutSet EffectLevelMutSetCreate() {
      return TrustedEffectLevelMutSetCreateWithId(NewId());
    }
    public LevelMutSet TrustedEffectLevelMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new LevelMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateLevelMutSet(id, rootIncarnation.version, incarnation);
      return new LevelMutSet(this, id);
    }
    public void EffectInternalCreateLevelMutSet(int id, int incarnationVersion, LevelMutSetIncarnation incarnation) {
      var effect = new LevelMutSetCreateEffect(id);
      rootIncarnation.incarnationsLevelMutSet
          .Add(
              id,
              new VersionAndIncarnation<LevelMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectLevelMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new LevelMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsLevelMutSet[id];
      rootIncarnation.incarnationsLevelMutSet.Remove(id);
    }

       
    public void EffectLevelMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasLevelMutSet(setId);
      CheckHasLevel(element);

      var effect = new LevelMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsLevelMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new LevelMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLevelMutSet[setId] =
            new VersionAndIncarnation<LevelMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectLevelMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasLevelMutSet(setId);

        CheckHasLevel(elementId);


      var effect = new LevelMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsLevelMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new LevelMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLevelMutSet[setId] =
            new VersionAndIncarnation<LevelMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetManaPotionStrongMutSetHash(int id, int version, ManaPotionStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ManaPotionStrongMutSetIncarnation GetManaPotionStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsManaPotionStrongMutSet[id].incarnation;
    }
    public ManaPotionStrongMutSet GetManaPotionStrongMutSet(int id) {
      return new ManaPotionStrongMutSet(this, id);
    }
    public List<ManaPotionStrongMutSet> AllManaPotionStrongMutSet() {
      List<ManaPotionStrongMutSet> result = new List<ManaPotionStrongMutSet>(rootIncarnation.incarnationsManaPotionStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsManaPotionStrongMutSet.Keys) {
        result.Add(new ManaPotionStrongMutSet(this, id));
      }
      return result;
    }
    public bool ManaPotionStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsManaPotionStrongMutSet.ContainsKey(id);
    }
    public void CheckHasManaPotionStrongMutSet(ManaPotionStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasManaPotionStrongMutSet(thing.id);
    }
    public void CheckHasManaPotionStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsManaPotionStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ManaPotionStrongMutSet}: " + id);
      }
    }
    public ManaPotionStrongMutSet EffectManaPotionStrongMutSetCreate() {
      return TrustedEffectManaPotionStrongMutSetCreateWithId(NewId());
    }
    public ManaPotionStrongMutSet TrustedEffectManaPotionStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new ManaPotionStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateManaPotionStrongMutSet(id, rootIncarnation.version, incarnation);
      return new ManaPotionStrongMutSet(this, id);
    }
    public void EffectInternalCreateManaPotionStrongMutSet(int id, int incarnationVersion, ManaPotionStrongMutSetIncarnation incarnation) {
      var effect = new ManaPotionStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsManaPotionStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<ManaPotionStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectManaPotionStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new ManaPotionStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsManaPotionStrongMutSet[id];
      rootIncarnation.incarnationsManaPotionStrongMutSet.Remove(id);
    }

       
    public void EffectManaPotionStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasManaPotionStrongMutSet(setId);
      CheckHasManaPotion(element);

      var effect = new ManaPotionStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsManaPotionStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new ManaPotionStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsManaPotionStrongMutSet[setId] =
            new VersionAndIncarnation<ManaPotionStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectManaPotionStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasManaPotionStrongMutSet(setId);

        CheckHasManaPotion(elementId);


      var effect = new ManaPotionStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsManaPotionStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ManaPotionStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsManaPotionStrongMutSet[setId] =
            new VersionAndIncarnation<ManaPotionStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetHealthPotionStrongMutSetHash(int id, int version, HealthPotionStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public HealthPotionStrongMutSetIncarnation GetHealthPotionStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsHealthPotionStrongMutSet[id].incarnation;
    }
    public HealthPotionStrongMutSet GetHealthPotionStrongMutSet(int id) {
      return new HealthPotionStrongMutSet(this, id);
    }
    public List<HealthPotionStrongMutSet> AllHealthPotionStrongMutSet() {
      List<HealthPotionStrongMutSet> result = new List<HealthPotionStrongMutSet>(rootIncarnation.incarnationsHealthPotionStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsHealthPotionStrongMutSet.Keys) {
        result.Add(new HealthPotionStrongMutSet(this, id));
      }
      return result;
    }
    public bool HealthPotionStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsHealthPotionStrongMutSet.ContainsKey(id);
    }
    public void CheckHasHealthPotionStrongMutSet(HealthPotionStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasHealthPotionStrongMutSet(thing.id);
    }
    public void CheckHasHealthPotionStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsHealthPotionStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid HealthPotionStrongMutSet}: " + id);
      }
    }
    public HealthPotionStrongMutSet EffectHealthPotionStrongMutSetCreate() {
      return TrustedEffectHealthPotionStrongMutSetCreateWithId(NewId());
    }
    public HealthPotionStrongMutSet TrustedEffectHealthPotionStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new HealthPotionStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateHealthPotionStrongMutSet(id, rootIncarnation.version, incarnation);
      return new HealthPotionStrongMutSet(this, id);
    }
    public void EffectInternalCreateHealthPotionStrongMutSet(int id, int incarnationVersion, HealthPotionStrongMutSetIncarnation incarnation) {
      var effect = new HealthPotionStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsHealthPotionStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<HealthPotionStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectHealthPotionStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new HealthPotionStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsHealthPotionStrongMutSet[id];
      rootIncarnation.incarnationsHealthPotionStrongMutSet.Remove(id);
    }

       
    public void EffectHealthPotionStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasHealthPotionStrongMutSet(setId);
      CheckHasHealthPotion(element);

      var effect = new HealthPotionStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsHealthPotionStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new HealthPotionStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsHealthPotionStrongMutSet[setId] =
            new VersionAndIncarnation<HealthPotionStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectHealthPotionStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasHealthPotionStrongMutSet(setId);

        CheckHasHealthPotion(elementId);


      var effect = new HealthPotionStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsHealthPotionStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new HealthPotionStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsHealthPotionStrongMutSet[setId] =
            new VersionAndIncarnation<HealthPotionStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetSpeedRingStrongMutSetHash(int id, int version, SpeedRingStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public SpeedRingStrongMutSetIncarnation GetSpeedRingStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsSpeedRingStrongMutSet[id].incarnation;
    }
    public SpeedRingStrongMutSet GetSpeedRingStrongMutSet(int id) {
      return new SpeedRingStrongMutSet(this, id);
    }
    public List<SpeedRingStrongMutSet> AllSpeedRingStrongMutSet() {
      List<SpeedRingStrongMutSet> result = new List<SpeedRingStrongMutSet>(rootIncarnation.incarnationsSpeedRingStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsSpeedRingStrongMutSet.Keys) {
        result.Add(new SpeedRingStrongMutSet(this, id));
      }
      return result;
    }
    public bool SpeedRingStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsSpeedRingStrongMutSet.ContainsKey(id);
    }
    public void CheckHasSpeedRingStrongMutSet(SpeedRingStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasSpeedRingStrongMutSet(thing.id);
    }
    public void CheckHasSpeedRingStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsSpeedRingStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid SpeedRingStrongMutSet}: " + id);
      }
    }
    public SpeedRingStrongMutSet EffectSpeedRingStrongMutSetCreate() {
      return TrustedEffectSpeedRingStrongMutSetCreateWithId(NewId());
    }
    public SpeedRingStrongMutSet TrustedEffectSpeedRingStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new SpeedRingStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateSpeedRingStrongMutSet(id, rootIncarnation.version, incarnation);
      return new SpeedRingStrongMutSet(this, id);
    }
    public void EffectInternalCreateSpeedRingStrongMutSet(int id, int incarnationVersion, SpeedRingStrongMutSetIncarnation incarnation) {
      var effect = new SpeedRingStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsSpeedRingStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<SpeedRingStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectSpeedRingStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new SpeedRingStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsSpeedRingStrongMutSet[id];
      rootIncarnation.incarnationsSpeedRingStrongMutSet.Remove(id);
    }

       
    public void EffectSpeedRingStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasSpeedRingStrongMutSet(setId);
      CheckHasSpeedRing(element);

      var effect = new SpeedRingStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsSpeedRingStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new SpeedRingStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSpeedRingStrongMutSet[setId] =
            new VersionAndIncarnation<SpeedRingStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectSpeedRingStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasSpeedRingStrongMutSet(setId);

        CheckHasSpeedRing(elementId);


      var effect = new SpeedRingStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsSpeedRingStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new SpeedRingStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSpeedRingStrongMutSet[setId] =
            new VersionAndIncarnation<SpeedRingStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetGlaiveStrongMutSetHash(int id, int version, GlaiveStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public GlaiveStrongMutSetIncarnation GetGlaiveStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsGlaiveStrongMutSet[id].incarnation;
    }
    public GlaiveStrongMutSet GetGlaiveStrongMutSet(int id) {
      return new GlaiveStrongMutSet(this, id);
    }
    public List<GlaiveStrongMutSet> AllGlaiveStrongMutSet() {
      List<GlaiveStrongMutSet> result = new List<GlaiveStrongMutSet>(rootIncarnation.incarnationsGlaiveStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsGlaiveStrongMutSet.Keys) {
        result.Add(new GlaiveStrongMutSet(this, id));
      }
      return result;
    }
    public bool GlaiveStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsGlaiveStrongMutSet.ContainsKey(id);
    }
    public void CheckHasGlaiveStrongMutSet(GlaiveStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasGlaiveStrongMutSet(thing.id);
    }
    public void CheckHasGlaiveStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsGlaiveStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid GlaiveStrongMutSet}: " + id);
      }
    }
    public GlaiveStrongMutSet EffectGlaiveStrongMutSetCreate() {
      return TrustedEffectGlaiveStrongMutSetCreateWithId(NewId());
    }
    public GlaiveStrongMutSet TrustedEffectGlaiveStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new GlaiveStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateGlaiveStrongMutSet(id, rootIncarnation.version, incarnation);
      return new GlaiveStrongMutSet(this, id);
    }
    public void EffectInternalCreateGlaiveStrongMutSet(int id, int incarnationVersion, GlaiveStrongMutSetIncarnation incarnation) {
      var effect = new GlaiveStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsGlaiveStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<GlaiveStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectGlaiveStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new GlaiveStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsGlaiveStrongMutSet[id];
      rootIncarnation.incarnationsGlaiveStrongMutSet.Remove(id);
    }

       
    public void EffectGlaiveStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasGlaiveStrongMutSet(setId);
      CheckHasGlaive(element);

      var effect = new GlaiveStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsGlaiveStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new GlaiveStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsGlaiveStrongMutSet[setId] =
            new VersionAndIncarnation<GlaiveStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectGlaiveStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasGlaiveStrongMutSet(setId);

        CheckHasGlaive(elementId);


      var effect = new GlaiveStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsGlaiveStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new GlaiveStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsGlaiveStrongMutSet[setId] =
            new VersionAndIncarnation<GlaiveStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetSlowRodStrongMutSetHash(int id, int version, SlowRodStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public SlowRodStrongMutSetIncarnation GetSlowRodStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsSlowRodStrongMutSet[id].incarnation;
    }
    public SlowRodStrongMutSet GetSlowRodStrongMutSet(int id) {
      return new SlowRodStrongMutSet(this, id);
    }
    public List<SlowRodStrongMutSet> AllSlowRodStrongMutSet() {
      List<SlowRodStrongMutSet> result = new List<SlowRodStrongMutSet>(rootIncarnation.incarnationsSlowRodStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsSlowRodStrongMutSet.Keys) {
        result.Add(new SlowRodStrongMutSet(this, id));
      }
      return result;
    }
    public bool SlowRodStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsSlowRodStrongMutSet.ContainsKey(id);
    }
    public void CheckHasSlowRodStrongMutSet(SlowRodStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasSlowRodStrongMutSet(thing.id);
    }
    public void CheckHasSlowRodStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsSlowRodStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid SlowRodStrongMutSet}: " + id);
      }
    }
    public SlowRodStrongMutSet EffectSlowRodStrongMutSetCreate() {
      return TrustedEffectSlowRodStrongMutSetCreateWithId(NewId());
    }
    public SlowRodStrongMutSet TrustedEffectSlowRodStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new SlowRodStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateSlowRodStrongMutSet(id, rootIncarnation.version, incarnation);
      return new SlowRodStrongMutSet(this, id);
    }
    public void EffectInternalCreateSlowRodStrongMutSet(int id, int incarnationVersion, SlowRodStrongMutSetIncarnation incarnation) {
      var effect = new SlowRodStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsSlowRodStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<SlowRodStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectSlowRodStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new SlowRodStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsSlowRodStrongMutSet[id];
      rootIncarnation.incarnationsSlowRodStrongMutSet.Remove(id);
    }

       
    public void EffectSlowRodStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasSlowRodStrongMutSet(setId);
      CheckHasSlowRod(element);

      var effect = new SlowRodStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsSlowRodStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new SlowRodStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSlowRodStrongMutSet[setId] =
            new VersionAndIncarnation<SlowRodStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectSlowRodStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasSlowRodStrongMutSet(setId);

        CheckHasSlowRod(elementId);


      var effect = new SlowRodStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsSlowRodStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new SlowRodStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSlowRodStrongMutSet[setId] =
            new VersionAndIncarnation<SlowRodStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetBlastRodStrongMutSetHash(int id, int version, BlastRodStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BlastRodStrongMutSetIncarnation GetBlastRodStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBlastRodStrongMutSet[id].incarnation;
    }
    public BlastRodStrongMutSet GetBlastRodStrongMutSet(int id) {
      return new BlastRodStrongMutSet(this, id);
    }
    public List<BlastRodStrongMutSet> AllBlastRodStrongMutSet() {
      List<BlastRodStrongMutSet> result = new List<BlastRodStrongMutSet>(rootIncarnation.incarnationsBlastRodStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBlastRodStrongMutSet.Keys) {
        result.Add(new BlastRodStrongMutSet(this, id));
      }
      return result;
    }
    public bool BlastRodStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsBlastRodStrongMutSet.ContainsKey(id);
    }
    public void CheckHasBlastRodStrongMutSet(BlastRodStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBlastRodStrongMutSet(thing.id);
    }
    public void CheckHasBlastRodStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsBlastRodStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BlastRodStrongMutSet}: " + id);
      }
    }
    public BlastRodStrongMutSet EffectBlastRodStrongMutSetCreate() {
      return TrustedEffectBlastRodStrongMutSetCreateWithId(NewId());
    }
    public BlastRodStrongMutSet TrustedEffectBlastRodStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BlastRodStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateBlastRodStrongMutSet(id, rootIncarnation.version, incarnation);
      return new BlastRodStrongMutSet(this, id);
    }
    public void EffectInternalCreateBlastRodStrongMutSet(int id, int incarnationVersion, BlastRodStrongMutSetIncarnation incarnation) {
      var effect = new BlastRodStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsBlastRodStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<BlastRodStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectBlastRodStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new BlastRodStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsBlastRodStrongMutSet[id];
      rootIncarnation.incarnationsBlastRodStrongMutSet.Remove(id);
    }

       
    public void EffectBlastRodStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasBlastRodStrongMutSet(setId);
      CheckHasBlastRod(element);

      var effect = new BlastRodStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBlastRodStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BlastRodStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBlastRodStrongMutSet[setId] =
            new VersionAndIncarnation<BlastRodStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectBlastRodStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasBlastRodStrongMutSet(setId);

        CheckHasBlastRod(elementId);


      var effect = new BlastRodStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBlastRodStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BlastRodStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBlastRodStrongMutSet[setId] =
            new VersionAndIncarnation<BlastRodStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetArmorStrongMutSetHash(int id, int version, ArmorStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ArmorStrongMutSetIncarnation GetArmorStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsArmorStrongMutSet[id].incarnation;
    }
    public ArmorStrongMutSet GetArmorStrongMutSet(int id) {
      return new ArmorStrongMutSet(this, id);
    }
    public List<ArmorStrongMutSet> AllArmorStrongMutSet() {
      List<ArmorStrongMutSet> result = new List<ArmorStrongMutSet>(rootIncarnation.incarnationsArmorStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsArmorStrongMutSet.Keys) {
        result.Add(new ArmorStrongMutSet(this, id));
      }
      return result;
    }
    public bool ArmorStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsArmorStrongMutSet.ContainsKey(id);
    }
    public void CheckHasArmorStrongMutSet(ArmorStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasArmorStrongMutSet(thing.id);
    }
    public void CheckHasArmorStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsArmorStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ArmorStrongMutSet}: " + id);
      }
    }
    public ArmorStrongMutSet EffectArmorStrongMutSetCreate() {
      return TrustedEffectArmorStrongMutSetCreateWithId(NewId());
    }
    public ArmorStrongMutSet TrustedEffectArmorStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new ArmorStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateArmorStrongMutSet(id, rootIncarnation.version, incarnation);
      return new ArmorStrongMutSet(this, id);
    }
    public void EffectInternalCreateArmorStrongMutSet(int id, int incarnationVersion, ArmorStrongMutSetIncarnation incarnation) {
      var effect = new ArmorStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsArmorStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<ArmorStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectArmorStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new ArmorStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsArmorStrongMutSet[id];
      rootIncarnation.incarnationsArmorStrongMutSet.Remove(id);
    }

       
    public void EffectArmorStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasArmorStrongMutSet(setId);
      CheckHasArmor(element);

      var effect = new ArmorStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsArmorStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new ArmorStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsArmorStrongMutSet[setId] =
            new VersionAndIncarnation<ArmorStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectArmorStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasArmorStrongMutSet(setId);

        CheckHasArmor(elementId);


      var effect = new ArmorStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsArmorStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ArmorStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsArmorStrongMutSet[setId] =
            new VersionAndIncarnation<ArmorStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetHoldPositionImpulseStrongMutSetHash(int id, int version, HoldPositionImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public HoldPositionImpulseStrongMutSetIncarnation GetHoldPositionImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet[id].incarnation;
    }
    public HoldPositionImpulseStrongMutSet GetHoldPositionImpulseStrongMutSet(int id) {
      return new HoldPositionImpulseStrongMutSet(this, id);
    }
    public List<HoldPositionImpulseStrongMutSet> AllHoldPositionImpulseStrongMutSet() {
      List<HoldPositionImpulseStrongMutSet> result = new List<HoldPositionImpulseStrongMutSet>(rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet.Keys) {
        result.Add(new HoldPositionImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool HoldPositionImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasHoldPositionImpulseStrongMutSet(HoldPositionImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasHoldPositionImpulseStrongMutSet(thing.id);
    }
    public void CheckHasHoldPositionImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid HoldPositionImpulseStrongMutSet}: " + id);
      }
    }
    public HoldPositionImpulseStrongMutSet EffectHoldPositionImpulseStrongMutSetCreate() {
      return TrustedEffectHoldPositionImpulseStrongMutSetCreateWithId(NewId());
    }
    public HoldPositionImpulseStrongMutSet TrustedEffectHoldPositionImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new HoldPositionImpulseStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateHoldPositionImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      return new HoldPositionImpulseStrongMutSet(this, id);
    }
    public void EffectInternalCreateHoldPositionImpulseStrongMutSet(int id, int incarnationVersion, HoldPositionImpulseStrongMutSetIncarnation incarnation) {
      var effect = new HoldPositionImpulseStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<HoldPositionImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectHoldPositionImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new HoldPositionImpulseStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet[id];
      rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet.Remove(id);
    }

       
    public void EffectHoldPositionImpulseStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasHoldPositionImpulseStrongMutSet(setId);
      CheckHasHoldPositionImpulse(element);

      var effect = new HoldPositionImpulseStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new HoldPositionImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<HoldPositionImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectHoldPositionImpulseStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasHoldPositionImpulseStrongMutSet(setId);

        CheckHasHoldPositionImpulse(elementId);


      var effect = new HoldPositionImpulseStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new HoldPositionImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<HoldPositionImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetTemporaryCloneImpulseStrongMutSetHash(int id, int version, TemporaryCloneImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public TemporaryCloneImpulseStrongMutSetIncarnation GetTemporaryCloneImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet[id].incarnation;
    }
    public TemporaryCloneImpulseStrongMutSet GetTemporaryCloneImpulseStrongMutSet(int id) {
      return new TemporaryCloneImpulseStrongMutSet(this, id);
    }
    public List<TemporaryCloneImpulseStrongMutSet> AllTemporaryCloneImpulseStrongMutSet() {
      List<TemporaryCloneImpulseStrongMutSet> result = new List<TemporaryCloneImpulseStrongMutSet>(rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet.Keys) {
        result.Add(new TemporaryCloneImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool TemporaryCloneImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasTemporaryCloneImpulseStrongMutSet(TemporaryCloneImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasTemporaryCloneImpulseStrongMutSet(thing.id);
    }
    public void CheckHasTemporaryCloneImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid TemporaryCloneImpulseStrongMutSet}: " + id);
      }
    }
    public TemporaryCloneImpulseStrongMutSet EffectTemporaryCloneImpulseStrongMutSetCreate() {
      return TrustedEffectTemporaryCloneImpulseStrongMutSetCreateWithId(NewId());
    }
    public TemporaryCloneImpulseStrongMutSet TrustedEffectTemporaryCloneImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new TemporaryCloneImpulseStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateTemporaryCloneImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      return new TemporaryCloneImpulseStrongMutSet(this, id);
    }
    public void EffectInternalCreateTemporaryCloneImpulseStrongMutSet(int id, int incarnationVersion, TemporaryCloneImpulseStrongMutSetIncarnation incarnation) {
      var effect = new TemporaryCloneImpulseStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<TemporaryCloneImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectTemporaryCloneImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new TemporaryCloneImpulseStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet[id];
      rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet.Remove(id);
    }

       
    public void EffectTemporaryCloneImpulseStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasTemporaryCloneImpulseStrongMutSet(setId);
      CheckHasTemporaryCloneImpulse(element);

      var effect = new TemporaryCloneImpulseStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new TemporaryCloneImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<TemporaryCloneImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectTemporaryCloneImpulseStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasTemporaryCloneImpulseStrongMutSet(setId);

        CheckHasTemporaryCloneImpulse(elementId);


      var effect = new TemporaryCloneImpulseStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new TemporaryCloneImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<TemporaryCloneImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetSummonImpulseStrongMutSetHash(int id, int version, SummonImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public SummonImpulseStrongMutSetIncarnation GetSummonImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsSummonImpulseStrongMutSet[id].incarnation;
    }
    public SummonImpulseStrongMutSet GetSummonImpulseStrongMutSet(int id) {
      return new SummonImpulseStrongMutSet(this, id);
    }
    public List<SummonImpulseStrongMutSet> AllSummonImpulseStrongMutSet() {
      List<SummonImpulseStrongMutSet> result = new List<SummonImpulseStrongMutSet>(rootIncarnation.incarnationsSummonImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsSummonImpulseStrongMutSet.Keys) {
        result.Add(new SummonImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool SummonImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsSummonImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasSummonImpulseStrongMutSet(SummonImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasSummonImpulseStrongMutSet(thing.id);
    }
    public void CheckHasSummonImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsSummonImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid SummonImpulseStrongMutSet}: " + id);
      }
    }
    public SummonImpulseStrongMutSet EffectSummonImpulseStrongMutSetCreate() {
      return TrustedEffectSummonImpulseStrongMutSetCreateWithId(NewId());
    }
    public SummonImpulseStrongMutSet TrustedEffectSummonImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new SummonImpulseStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateSummonImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      return new SummonImpulseStrongMutSet(this, id);
    }
    public void EffectInternalCreateSummonImpulseStrongMutSet(int id, int incarnationVersion, SummonImpulseStrongMutSetIncarnation incarnation) {
      var effect = new SummonImpulseStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsSummonImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<SummonImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectSummonImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new SummonImpulseStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsSummonImpulseStrongMutSet[id];
      rootIncarnation.incarnationsSummonImpulseStrongMutSet.Remove(id);
    }

       
    public void EffectSummonImpulseStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasSummonImpulseStrongMutSet(setId);
      CheckHasSummonImpulse(element);

      var effect = new SummonImpulseStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsSummonImpulseStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new SummonImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSummonImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<SummonImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectSummonImpulseStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasSummonImpulseStrongMutSet(setId);

        CheckHasSummonImpulse(elementId);


      var effect = new SummonImpulseStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsSummonImpulseStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new SummonImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSummonImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<SummonImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetMireImpulseStrongMutSetHash(int id, int version, MireImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public MireImpulseStrongMutSetIncarnation GetMireImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsMireImpulseStrongMutSet[id].incarnation;
    }
    public MireImpulseStrongMutSet GetMireImpulseStrongMutSet(int id) {
      return new MireImpulseStrongMutSet(this, id);
    }
    public List<MireImpulseStrongMutSet> AllMireImpulseStrongMutSet() {
      List<MireImpulseStrongMutSet> result = new List<MireImpulseStrongMutSet>(rootIncarnation.incarnationsMireImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsMireImpulseStrongMutSet.Keys) {
        result.Add(new MireImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool MireImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsMireImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasMireImpulseStrongMutSet(MireImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasMireImpulseStrongMutSet(thing.id);
    }
    public void CheckHasMireImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsMireImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid MireImpulseStrongMutSet}: " + id);
      }
    }
    public MireImpulseStrongMutSet EffectMireImpulseStrongMutSetCreate() {
      return TrustedEffectMireImpulseStrongMutSetCreateWithId(NewId());
    }
    public MireImpulseStrongMutSet TrustedEffectMireImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new MireImpulseStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateMireImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      return new MireImpulseStrongMutSet(this, id);
    }
    public void EffectInternalCreateMireImpulseStrongMutSet(int id, int incarnationVersion, MireImpulseStrongMutSetIncarnation incarnation) {
      var effect = new MireImpulseStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsMireImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<MireImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectMireImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new MireImpulseStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsMireImpulseStrongMutSet[id];
      rootIncarnation.incarnationsMireImpulseStrongMutSet.Remove(id);
    }

       
    public void EffectMireImpulseStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasMireImpulseStrongMutSet(setId);
      CheckHasMireImpulse(element);

      var effect = new MireImpulseStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsMireImpulseStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new MireImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMireImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<MireImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectMireImpulseStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasMireImpulseStrongMutSet(setId);

        CheckHasMireImpulse(elementId);


      var effect = new MireImpulseStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsMireImpulseStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new MireImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMireImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<MireImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetEvaporateImpulseStrongMutSetHash(int id, int version, EvaporateImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public EvaporateImpulseStrongMutSetIncarnation GetEvaporateImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsEvaporateImpulseStrongMutSet[id].incarnation;
    }
    public EvaporateImpulseStrongMutSet GetEvaporateImpulseStrongMutSet(int id) {
      return new EvaporateImpulseStrongMutSet(this, id);
    }
    public List<EvaporateImpulseStrongMutSet> AllEvaporateImpulseStrongMutSet() {
      List<EvaporateImpulseStrongMutSet> result = new List<EvaporateImpulseStrongMutSet>(rootIncarnation.incarnationsEvaporateImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsEvaporateImpulseStrongMutSet.Keys) {
        result.Add(new EvaporateImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool EvaporateImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsEvaporateImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasEvaporateImpulseStrongMutSet(EvaporateImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasEvaporateImpulseStrongMutSet(thing.id);
    }
    public void CheckHasEvaporateImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsEvaporateImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid EvaporateImpulseStrongMutSet}: " + id);
      }
    }
    public EvaporateImpulseStrongMutSet EffectEvaporateImpulseStrongMutSetCreate() {
      return TrustedEffectEvaporateImpulseStrongMutSetCreateWithId(NewId());
    }
    public EvaporateImpulseStrongMutSet TrustedEffectEvaporateImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new EvaporateImpulseStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateEvaporateImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      return new EvaporateImpulseStrongMutSet(this, id);
    }
    public void EffectInternalCreateEvaporateImpulseStrongMutSet(int id, int incarnationVersion, EvaporateImpulseStrongMutSetIncarnation incarnation) {
      var effect = new EvaporateImpulseStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsEvaporateImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<EvaporateImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectEvaporateImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new EvaporateImpulseStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsEvaporateImpulseStrongMutSet[id];
      rootIncarnation.incarnationsEvaporateImpulseStrongMutSet.Remove(id);
    }

       
    public void EffectEvaporateImpulseStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasEvaporateImpulseStrongMutSet(setId);
      CheckHasEvaporateImpulse(element);

      var effect = new EvaporateImpulseStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsEvaporateImpulseStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new EvaporateImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsEvaporateImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<EvaporateImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectEvaporateImpulseStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasEvaporateImpulseStrongMutSet(setId);

        CheckHasEvaporateImpulse(elementId);


      var effect = new EvaporateImpulseStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsEvaporateImpulseStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new EvaporateImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsEvaporateImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<EvaporateImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetMoveImpulseStrongMutSetHash(int id, int version, MoveImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public MoveImpulseStrongMutSetIncarnation GetMoveImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsMoveImpulseStrongMutSet[id].incarnation;
    }
    public MoveImpulseStrongMutSet GetMoveImpulseStrongMutSet(int id) {
      return new MoveImpulseStrongMutSet(this, id);
    }
    public List<MoveImpulseStrongMutSet> AllMoveImpulseStrongMutSet() {
      List<MoveImpulseStrongMutSet> result = new List<MoveImpulseStrongMutSet>(rootIncarnation.incarnationsMoveImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsMoveImpulseStrongMutSet.Keys) {
        result.Add(new MoveImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool MoveImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsMoveImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasMoveImpulseStrongMutSet(MoveImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasMoveImpulseStrongMutSet(thing.id);
    }
    public void CheckHasMoveImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsMoveImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid MoveImpulseStrongMutSet}: " + id);
      }
    }
    public MoveImpulseStrongMutSet EffectMoveImpulseStrongMutSetCreate() {
      return TrustedEffectMoveImpulseStrongMutSetCreateWithId(NewId());
    }
    public MoveImpulseStrongMutSet TrustedEffectMoveImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new MoveImpulseStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateMoveImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      return new MoveImpulseStrongMutSet(this, id);
    }
    public void EffectInternalCreateMoveImpulseStrongMutSet(int id, int incarnationVersion, MoveImpulseStrongMutSetIncarnation incarnation) {
      var effect = new MoveImpulseStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsMoveImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<MoveImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectMoveImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new MoveImpulseStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsMoveImpulseStrongMutSet[id];
      rootIncarnation.incarnationsMoveImpulseStrongMutSet.Remove(id);
    }

       
    public void EffectMoveImpulseStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasMoveImpulseStrongMutSet(setId);
      CheckHasMoveImpulse(element);

      var effect = new MoveImpulseStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsMoveImpulseStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new MoveImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMoveImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<MoveImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectMoveImpulseStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasMoveImpulseStrongMutSet(setId);

        CheckHasMoveImpulse(elementId);


      var effect = new MoveImpulseStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsMoveImpulseStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new MoveImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMoveImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<MoveImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetKamikazeJumpImpulseStrongMutSetHash(int id, int version, KamikazeJumpImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public KamikazeJumpImpulseStrongMutSetIncarnation GetKamikazeJumpImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet[id].incarnation;
    }
    public KamikazeJumpImpulseStrongMutSet GetKamikazeJumpImpulseStrongMutSet(int id) {
      return new KamikazeJumpImpulseStrongMutSet(this, id);
    }
    public List<KamikazeJumpImpulseStrongMutSet> AllKamikazeJumpImpulseStrongMutSet() {
      List<KamikazeJumpImpulseStrongMutSet> result = new List<KamikazeJumpImpulseStrongMutSet>(rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet.Keys) {
        result.Add(new KamikazeJumpImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool KamikazeJumpImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasKamikazeJumpImpulseStrongMutSet(KamikazeJumpImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasKamikazeJumpImpulseStrongMutSet(thing.id);
    }
    public void CheckHasKamikazeJumpImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid KamikazeJumpImpulseStrongMutSet}: " + id);
      }
    }
    public KamikazeJumpImpulseStrongMutSet EffectKamikazeJumpImpulseStrongMutSetCreate() {
      return TrustedEffectKamikazeJumpImpulseStrongMutSetCreateWithId(NewId());
    }
    public KamikazeJumpImpulseStrongMutSet TrustedEffectKamikazeJumpImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new KamikazeJumpImpulseStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateKamikazeJumpImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      return new KamikazeJumpImpulseStrongMutSet(this, id);
    }
    public void EffectInternalCreateKamikazeJumpImpulseStrongMutSet(int id, int incarnationVersion, KamikazeJumpImpulseStrongMutSetIncarnation incarnation) {
      var effect = new KamikazeJumpImpulseStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<KamikazeJumpImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectKamikazeJumpImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new KamikazeJumpImpulseStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet[id];
      rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet.Remove(id);
    }

       
    public void EffectKamikazeJumpImpulseStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasKamikazeJumpImpulseStrongMutSet(setId);
      CheckHasKamikazeJumpImpulse(element);

      var effect = new KamikazeJumpImpulseStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new KamikazeJumpImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<KamikazeJumpImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectKamikazeJumpImpulseStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasKamikazeJumpImpulseStrongMutSet(setId);

        CheckHasKamikazeJumpImpulse(elementId);


      var effect = new KamikazeJumpImpulseStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new KamikazeJumpImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<KamikazeJumpImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetKamikazeTargetImpulseStrongMutSetHash(int id, int version, KamikazeTargetImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public KamikazeTargetImpulseStrongMutSetIncarnation GetKamikazeTargetImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet[id].incarnation;
    }
    public KamikazeTargetImpulseStrongMutSet GetKamikazeTargetImpulseStrongMutSet(int id) {
      return new KamikazeTargetImpulseStrongMutSet(this, id);
    }
    public List<KamikazeTargetImpulseStrongMutSet> AllKamikazeTargetImpulseStrongMutSet() {
      List<KamikazeTargetImpulseStrongMutSet> result = new List<KamikazeTargetImpulseStrongMutSet>(rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet.Keys) {
        result.Add(new KamikazeTargetImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool KamikazeTargetImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasKamikazeTargetImpulseStrongMutSet(KamikazeTargetImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasKamikazeTargetImpulseStrongMutSet(thing.id);
    }
    public void CheckHasKamikazeTargetImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid KamikazeTargetImpulseStrongMutSet}: " + id);
      }
    }
    public KamikazeTargetImpulseStrongMutSet EffectKamikazeTargetImpulseStrongMutSetCreate() {
      return TrustedEffectKamikazeTargetImpulseStrongMutSetCreateWithId(NewId());
    }
    public KamikazeTargetImpulseStrongMutSet TrustedEffectKamikazeTargetImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new KamikazeTargetImpulseStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateKamikazeTargetImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      return new KamikazeTargetImpulseStrongMutSet(this, id);
    }
    public void EffectInternalCreateKamikazeTargetImpulseStrongMutSet(int id, int incarnationVersion, KamikazeTargetImpulseStrongMutSetIncarnation incarnation) {
      var effect = new KamikazeTargetImpulseStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<KamikazeTargetImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectKamikazeTargetImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new KamikazeTargetImpulseStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet[id];
      rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet.Remove(id);
    }

       
    public void EffectKamikazeTargetImpulseStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasKamikazeTargetImpulseStrongMutSet(setId);
      CheckHasKamikazeTargetImpulse(element);

      var effect = new KamikazeTargetImpulseStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new KamikazeTargetImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<KamikazeTargetImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectKamikazeTargetImpulseStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasKamikazeTargetImpulseStrongMutSet(setId);

        CheckHasKamikazeTargetImpulse(elementId);


      var effect = new KamikazeTargetImpulseStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new KamikazeTargetImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<KamikazeTargetImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetNoImpulseStrongMutSetHash(int id, int version, NoImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public NoImpulseStrongMutSetIncarnation GetNoImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsNoImpulseStrongMutSet[id].incarnation;
    }
    public NoImpulseStrongMutSet GetNoImpulseStrongMutSet(int id) {
      return new NoImpulseStrongMutSet(this, id);
    }
    public List<NoImpulseStrongMutSet> AllNoImpulseStrongMutSet() {
      List<NoImpulseStrongMutSet> result = new List<NoImpulseStrongMutSet>(rootIncarnation.incarnationsNoImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsNoImpulseStrongMutSet.Keys) {
        result.Add(new NoImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool NoImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsNoImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasNoImpulseStrongMutSet(NoImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasNoImpulseStrongMutSet(thing.id);
    }
    public void CheckHasNoImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsNoImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid NoImpulseStrongMutSet}: " + id);
      }
    }
    public NoImpulseStrongMutSet EffectNoImpulseStrongMutSetCreate() {
      return TrustedEffectNoImpulseStrongMutSetCreateWithId(NewId());
    }
    public NoImpulseStrongMutSet TrustedEffectNoImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new NoImpulseStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateNoImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      return new NoImpulseStrongMutSet(this, id);
    }
    public void EffectInternalCreateNoImpulseStrongMutSet(int id, int incarnationVersion, NoImpulseStrongMutSetIncarnation incarnation) {
      var effect = new NoImpulseStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsNoImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<NoImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectNoImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new NoImpulseStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsNoImpulseStrongMutSet[id];
      rootIncarnation.incarnationsNoImpulseStrongMutSet.Remove(id);
    }

       
    public void EffectNoImpulseStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasNoImpulseStrongMutSet(setId);
      CheckHasNoImpulse(element);

      var effect = new NoImpulseStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsNoImpulseStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new NoImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsNoImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<NoImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectNoImpulseStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasNoImpulseStrongMutSet(setId);

        CheckHasNoImpulse(elementId);


      var effect = new NoImpulseStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsNoImpulseStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new NoImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsNoImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<NoImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetFireImpulseStrongMutSetHash(int id, int version, FireImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public FireImpulseStrongMutSetIncarnation GetFireImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsFireImpulseStrongMutSet[id].incarnation;
    }
    public FireImpulseStrongMutSet GetFireImpulseStrongMutSet(int id) {
      return new FireImpulseStrongMutSet(this, id);
    }
    public List<FireImpulseStrongMutSet> AllFireImpulseStrongMutSet() {
      List<FireImpulseStrongMutSet> result = new List<FireImpulseStrongMutSet>(rootIncarnation.incarnationsFireImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsFireImpulseStrongMutSet.Keys) {
        result.Add(new FireImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool FireImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsFireImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasFireImpulseStrongMutSet(FireImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasFireImpulseStrongMutSet(thing.id);
    }
    public void CheckHasFireImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsFireImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid FireImpulseStrongMutSet}: " + id);
      }
    }
    public FireImpulseStrongMutSet EffectFireImpulseStrongMutSetCreate() {
      return TrustedEffectFireImpulseStrongMutSetCreateWithId(NewId());
    }
    public FireImpulseStrongMutSet TrustedEffectFireImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new FireImpulseStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateFireImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      return new FireImpulseStrongMutSet(this, id);
    }
    public void EffectInternalCreateFireImpulseStrongMutSet(int id, int incarnationVersion, FireImpulseStrongMutSetIncarnation incarnation) {
      var effect = new FireImpulseStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsFireImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<FireImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectFireImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new FireImpulseStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsFireImpulseStrongMutSet[id];
      rootIncarnation.incarnationsFireImpulseStrongMutSet.Remove(id);
    }

       
    public void EffectFireImpulseStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasFireImpulseStrongMutSet(setId);
      CheckHasFireImpulse(element);

      var effect = new FireImpulseStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsFireImpulseStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new FireImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFireImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<FireImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectFireImpulseStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasFireImpulseStrongMutSet(setId);

        CheckHasFireImpulse(elementId);


      var effect = new FireImpulseStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsFireImpulseStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new FireImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFireImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<FireImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetDefyImpulseStrongMutSetHash(int id, int version, DefyImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public DefyImpulseStrongMutSetIncarnation GetDefyImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsDefyImpulseStrongMutSet[id].incarnation;
    }
    public DefyImpulseStrongMutSet GetDefyImpulseStrongMutSet(int id) {
      return new DefyImpulseStrongMutSet(this, id);
    }
    public List<DefyImpulseStrongMutSet> AllDefyImpulseStrongMutSet() {
      List<DefyImpulseStrongMutSet> result = new List<DefyImpulseStrongMutSet>(rootIncarnation.incarnationsDefyImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsDefyImpulseStrongMutSet.Keys) {
        result.Add(new DefyImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool DefyImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsDefyImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasDefyImpulseStrongMutSet(DefyImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasDefyImpulseStrongMutSet(thing.id);
    }
    public void CheckHasDefyImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsDefyImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid DefyImpulseStrongMutSet}: " + id);
      }
    }
    public DefyImpulseStrongMutSet EffectDefyImpulseStrongMutSetCreate() {
      return TrustedEffectDefyImpulseStrongMutSetCreateWithId(NewId());
    }
    public DefyImpulseStrongMutSet TrustedEffectDefyImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new DefyImpulseStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateDefyImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      return new DefyImpulseStrongMutSet(this, id);
    }
    public void EffectInternalCreateDefyImpulseStrongMutSet(int id, int incarnationVersion, DefyImpulseStrongMutSetIncarnation incarnation) {
      var effect = new DefyImpulseStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsDefyImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<DefyImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectDefyImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new DefyImpulseStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsDefyImpulseStrongMutSet[id];
      rootIncarnation.incarnationsDefyImpulseStrongMutSet.Remove(id);
    }

       
    public void EffectDefyImpulseStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasDefyImpulseStrongMutSet(setId);
      CheckHasDefyImpulse(element);

      var effect = new DefyImpulseStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsDefyImpulseStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new DefyImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDefyImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<DefyImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectDefyImpulseStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasDefyImpulseStrongMutSet(setId);

        CheckHasDefyImpulse(elementId);


      var effect = new DefyImpulseStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsDefyImpulseStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new DefyImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDefyImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<DefyImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetCounterImpulseStrongMutSetHash(int id, int version, CounterImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CounterImpulseStrongMutSetIncarnation GetCounterImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsCounterImpulseStrongMutSet[id].incarnation;
    }
    public CounterImpulseStrongMutSet GetCounterImpulseStrongMutSet(int id) {
      return new CounterImpulseStrongMutSet(this, id);
    }
    public List<CounterImpulseStrongMutSet> AllCounterImpulseStrongMutSet() {
      List<CounterImpulseStrongMutSet> result = new List<CounterImpulseStrongMutSet>(rootIncarnation.incarnationsCounterImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsCounterImpulseStrongMutSet.Keys) {
        result.Add(new CounterImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool CounterImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsCounterImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasCounterImpulseStrongMutSet(CounterImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCounterImpulseStrongMutSet(thing.id);
    }
    public void CheckHasCounterImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsCounterImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid CounterImpulseStrongMutSet}: " + id);
      }
    }
    public CounterImpulseStrongMutSet EffectCounterImpulseStrongMutSetCreate() {
      return TrustedEffectCounterImpulseStrongMutSetCreateWithId(NewId());
    }
    public CounterImpulseStrongMutSet TrustedEffectCounterImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new CounterImpulseStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateCounterImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      return new CounterImpulseStrongMutSet(this, id);
    }
    public void EffectInternalCreateCounterImpulseStrongMutSet(int id, int incarnationVersion, CounterImpulseStrongMutSetIncarnation incarnation) {
      var effect = new CounterImpulseStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsCounterImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<CounterImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectCounterImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new CounterImpulseStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsCounterImpulseStrongMutSet[id];
      rootIncarnation.incarnationsCounterImpulseStrongMutSet.Remove(id);
    }

       
    public void EffectCounterImpulseStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasCounterImpulseStrongMutSet(setId);
      CheckHasCounterImpulse(element);

      var effect = new CounterImpulseStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCounterImpulseStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new CounterImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCounterImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<CounterImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectCounterImpulseStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasCounterImpulseStrongMutSet(setId);

        CheckHasCounterImpulse(elementId);


      var effect = new CounterImpulseStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCounterImpulseStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new CounterImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCounterImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<CounterImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetUnleashBideImpulseStrongMutSetHash(int id, int version, UnleashBideImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public UnleashBideImpulseStrongMutSetIncarnation GetUnleashBideImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet[id].incarnation;
    }
    public UnleashBideImpulseStrongMutSet GetUnleashBideImpulseStrongMutSet(int id) {
      return new UnleashBideImpulseStrongMutSet(this, id);
    }
    public List<UnleashBideImpulseStrongMutSet> AllUnleashBideImpulseStrongMutSet() {
      List<UnleashBideImpulseStrongMutSet> result = new List<UnleashBideImpulseStrongMutSet>(rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet.Keys) {
        result.Add(new UnleashBideImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool UnleashBideImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasUnleashBideImpulseStrongMutSet(UnleashBideImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasUnleashBideImpulseStrongMutSet(thing.id);
    }
    public void CheckHasUnleashBideImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid UnleashBideImpulseStrongMutSet}: " + id);
      }
    }
    public UnleashBideImpulseStrongMutSet EffectUnleashBideImpulseStrongMutSetCreate() {
      return TrustedEffectUnleashBideImpulseStrongMutSetCreateWithId(NewId());
    }
    public UnleashBideImpulseStrongMutSet TrustedEffectUnleashBideImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new UnleashBideImpulseStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateUnleashBideImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      return new UnleashBideImpulseStrongMutSet(this, id);
    }
    public void EffectInternalCreateUnleashBideImpulseStrongMutSet(int id, int incarnationVersion, UnleashBideImpulseStrongMutSetIncarnation incarnation) {
      var effect = new UnleashBideImpulseStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<UnleashBideImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectUnleashBideImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new UnleashBideImpulseStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet[id];
      rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet.Remove(id);
    }

       
    public void EffectUnleashBideImpulseStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasUnleashBideImpulseStrongMutSet(setId);
      CheckHasUnleashBideImpulse(element);

      var effect = new UnleashBideImpulseStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new UnleashBideImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<UnleashBideImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectUnleashBideImpulseStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasUnleashBideImpulseStrongMutSet(setId);

        CheckHasUnleashBideImpulse(elementId);


      var effect = new UnleashBideImpulseStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new UnleashBideImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<UnleashBideImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetContinueBidingImpulseStrongMutSetHash(int id, int version, ContinueBidingImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ContinueBidingImpulseStrongMutSetIncarnation GetContinueBidingImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet[id].incarnation;
    }
    public ContinueBidingImpulseStrongMutSet GetContinueBidingImpulseStrongMutSet(int id) {
      return new ContinueBidingImpulseStrongMutSet(this, id);
    }
    public List<ContinueBidingImpulseStrongMutSet> AllContinueBidingImpulseStrongMutSet() {
      List<ContinueBidingImpulseStrongMutSet> result = new List<ContinueBidingImpulseStrongMutSet>(rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet.Keys) {
        result.Add(new ContinueBidingImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool ContinueBidingImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasContinueBidingImpulseStrongMutSet(ContinueBidingImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasContinueBidingImpulseStrongMutSet(thing.id);
    }
    public void CheckHasContinueBidingImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ContinueBidingImpulseStrongMutSet}: " + id);
      }
    }
    public ContinueBidingImpulseStrongMutSet EffectContinueBidingImpulseStrongMutSetCreate() {
      return TrustedEffectContinueBidingImpulseStrongMutSetCreateWithId(NewId());
    }
    public ContinueBidingImpulseStrongMutSet TrustedEffectContinueBidingImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new ContinueBidingImpulseStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateContinueBidingImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      return new ContinueBidingImpulseStrongMutSet(this, id);
    }
    public void EffectInternalCreateContinueBidingImpulseStrongMutSet(int id, int incarnationVersion, ContinueBidingImpulseStrongMutSetIncarnation incarnation) {
      var effect = new ContinueBidingImpulseStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<ContinueBidingImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectContinueBidingImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new ContinueBidingImpulseStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet[id];
      rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet.Remove(id);
    }

       
    public void EffectContinueBidingImpulseStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasContinueBidingImpulseStrongMutSet(setId);
      CheckHasContinueBidingImpulse(element);

      var effect = new ContinueBidingImpulseStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new ContinueBidingImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<ContinueBidingImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectContinueBidingImpulseStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasContinueBidingImpulseStrongMutSet(setId);

        CheckHasContinueBidingImpulse(elementId);


      var effect = new ContinueBidingImpulseStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ContinueBidingImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<ContinueBidingImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetStartBidingImpulseStrongMutSetHash(int id, int version, StartBidingImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public StartBidingImpulseStrongMutSetIncarnation GetStartBidingImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsStartBidingImpulseStrongMutSet[id].incarnation;
    }
    public StartBidingImpulseStrongMutSet GetStartBidingImpulseStrongMutSet(int id) {
      return new StartBidingImpulseStrongMutSet(this, id);
    }
    public List<StartBidingImpulseStrongMutSet> AllStartBidingImpulseStrongMutSet() {
      List<StartBidingImpulseStrongMutSet> result = new List<StartBidingImpulseStrongMutSet>(rootIncarnation.incarnationsStartBidingImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsStartBidingImpulseStrongMutSet.Keys) {
        result.Add(new StartBidingImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool StartBidingImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsStartBidingImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasStartBidingImpulseStrongMutSet(StartBidingImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasStartBidingImpulseStrongMutSet(thing.id);
    }
    public void CheckHasStartBidingImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsStartBidingImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid StartBidingImpulseStrongMutSet}: " + id);
      }
    }
    public StartBidingImpulseStrongMutSet EffectStartBidingImpulseStrongMutSetCreate() {
      return TrustedEffectStartBidingImpulseStrongMutSetCreateWithId(NewId());
    }
    public StartBidingImpulseStrongMutSet TrustedEffectStartBidingImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new StartBidingImpulseStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateStartBidingImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      return new StartBidingImpulseStrongMutSet(this, id);
    }
    public void EffectInternalCreateStartBidingImpulseStrongMutSet(int id, int incarnationVersion, StartBidingImpulseStrongMutSetIncarnation incarnation) {
      var effect = new StartBidingImpulseStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsStartBidingImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<StartBidingImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectStartBidingImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new StartBidingImpulseStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsStartBidingImpulseStrongMutSet[id];
      rootIncarnation.incarnationsStartBidingImpulseStrongMutSet.Remove(id);
    }

       
    public void EffectStartBidingImpulseStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasStartBidingImpulseStrongMutSet(setId);
      CheckHasStartBidingImpulse(element);

      var effect = new StartBidingImpulseStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsStartBidingImpulseStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new StartBidingImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsStartBidingImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<StartBidingImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectStartBidingImpulseStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasStartBidingImpulseStrongMutSet(setId);

        CheckHasStartBidingImpulse(elementId);


      var effect = new StartBidingImpulseStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsStartBidingImpulseStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new StartBidingImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsStartBidingImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<StartBidingImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetAttackImpulseStrongMutSetHash(int id, int version, AttackImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public AttackImpulseStrongMutSetIncarnation GetAttackImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsAttackImpulseStrongMutSet[id].incarnation;
    }
    public AttackImpulseStrongMutSet GetAttackImpulseStrongMutSet(int id) {
      return new AttackImpulseStrongMutSet(this, id);
    }
    public List<AttackImpulseStrongMutSet> AllAttackImpulseStrongMutSet() {
      List<AttackImpulseStrongMutSet> result = new List<AttackImpulseStrongMutSet>(rootIncarnation.incarnationsAttackImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsAttackImpulseStrongMutSet.Keys) {
        result.Add(new AttackImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool AttackImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsAttackImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasAttackImpulseStrongMutSet(AttackImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasAttackImpulseStrongMutSet(thing.id);
    }
    public void CheckHasAttackImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsAttackImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid AttackImpulseStrongMutSet}: " + id);
      }
    }
    public AttackImpulseStrongMutSet EffectAttackImpulseStrongMutSetCreate() {
      return TrustedEffectAttackImpulseStrongMutSetCreateWithId(NewId());
    }
    public AttackImpulseStrongMutSet TrustedEffectAttackImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new AttackImpulseStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateAttackImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      return new AttackImpulseStrongMutSet(this, id);
    }
    public void EffectInternalCreateAttackImpulseStrongMutSet(int id, int incarnationVersion, AttackImpulseStrongMutSetIncarnation incarnation) {
      var effect = new AttackImpulseStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsAttackImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<AttackImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectAttackImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new AttackImpulseStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsAttackImpulseStrongMutSet[id];
      rootIncarnation.incarnationsAttackImpulseStrongMutSet.Remove(id);
    }

       
    public void EffectAttackImpulseStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasAttackImpulseStrongMutSet(setId);
      CheckHasAttackImpulse(element);

      var effect = new AttackImpulseStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsAttackImpulseStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new AttackImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsAttackImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<AttackImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectAttackImpulseStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasAttackImpulseStrongMutSet(setId);

        CheckHasAttackImpulse(elementId);


      var effect = new AttackImpulseStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsAttackImpulseStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new AttackImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsAttackImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<AttackImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetPursueImpulseStrongMutSetHash(int id, int version, PursueImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public PursueImpulseStrongMutSetIncarnation GetPursueImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsPursueImpulseStrongMutSet[id].incarnation;
    }
    public PursueImpulseStrongMutSet GetPursueImpulseStrongMutSet(int id) {
      return new PursueImpulseStrongMutSet(this, id);
    }
    public List<PursueImpulseStrongMutSet> AllPursueImpulseStrongMutSet() {
      List<PursueImpulseStrongMutSet> result = new List<PursueImpulseStrongMutSet>(rootIncarnation.incarnationsPursueImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsPursueImpulseStrongMutSet.Keys) {
        result.Add(new PursueImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool PursueImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsPursueImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasPursueImpulseStrongMutSet(PursueImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasPursueImpulseStrongMutSet(thing.id);
    }
    public void CheckHasPursueImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsPursueImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid PursueImpulseStrongMutSet}: " + id);
      }
    }
    public PursueImpulseStrongMutSet EffectPursueImpulseStrongMutSetCreate() {
      return TrustedEffectPursueImpulseStrongMutSetCreateWithId(NewId());
    }
    public PursueImpulseStrongMutSet TrustedEffectPursueImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new PursueImpulseStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreatePursueImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      return new PursueImpulseStrongMutSet(this, id);
    }
    public void EffectInternalCreatePursueImpulseStrongMutSet(int id, int incarnationVersion, PursueImpulseStrongMutSetIncarnation incarnation) {
      var effect = new PursueImpulseStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsPursueImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<PursueImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectPursueImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new PursueImpulseStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsPursueImpulseStrongMutSet[id];
      rootIncarnation.incarnationsPursueImpulseStrongMutSet.Remove(id);
    }

       
    public void EffectPursueImpulseStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasPursueImpulseStrongMutSet(setId);
      CheckHasPursueImpulse(element);

      var effect = new PursueImpulseStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsPursueImpulseStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new PursueImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsPursueImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<PursueImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectPursueImpulseStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasPursueImpulseStrongMutSet(setId);

        CheckHasPursueImpulse(elementId);


      var effect = new PursueImpulseStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsPursueImpulseStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new PursueImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsPursueImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<PursueImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetFireBombImpulseStrongMutSetHash(int id, int version, FireBombImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public FireBombImpulseStrongMutSetIncarnation GetFireBombImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsFireBombImpulseStrongMutSet[id].incarnation;
    }
    public FireBombImpulseStrongMutSet GetFireBombImpulseStrongMutSet(int id) {
      return new FireBombImpulseStrongMutSet(this, id);
    }
    public List<FireBombImpulseStrongMutSet> AllFireBombImpulseStrongMutSet() {
      List<FireBombImpulseStrongMutSet> result = new List<FireBombImpulseStrongMutSet>(rootIncarnation.incarnationsFireBombImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsFireBombImpulseStrongMutSet.Keys) {
        result.Add(new FireBombImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool FireBombImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsFireBombImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasFireBombImpulseStrongMutSet(FireBombImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasFireBombImpulseStrongMutSet(thing.id);
    }
    public void CheckHasFireBombImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsFireBombImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid FireBombImpulseStrongMutSet}: " + id);
      }
    }
    public FireBombImpulseStrongMutSet EffectFireBombImpulseStrongMutSetCreate() {
      return TrustedEffectFireBombImpulseStrongMutSetCreateWithId(NewId());
    }
    public FireBombImpulseStrongMutSet TrustedEffectFireBombImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new FireBombImpulseStrongMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateFireBombImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      return new FireBombImpulseStrongMutSet(this, id);
    }
    public void EffectInternalCreateFireBombImpulseStrongMutSet(int id, int incarnationVersion, FireBombImpulseStrongMutSetIncarnation incarnation) {
      var effect = new FireBombImpulseStrongMutSetCreateEffect(id);
      rootIncarnation.incarnationsFireBombImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<FireBombImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectFireBombImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new FireBombImpulseStrongMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsFireBombImpulseStrongMutSet[id];
      rootIncarnation.incarnationsFireBombImpulseStrongMutSet.Remove(id);
    }

       
    public void EffectFireBombImpulseStrongMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasFireBombImpulseStrongMutSet(setId);
      CheckHasFireBombImpulse(element);

      var effect = new FireBombImpulseStrongMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsFireBombImpulseStrongMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new FireBombImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFireBombImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<FireBombImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectFireBombImpulseStrongMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasFireBombImpulseStrongMutSet(setId);

        CheckHasFireBombImpulse(elementId);


      var effect = new FireBombImpulseStrongMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsFireBombImpulseStrongMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new FireBombImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFireBombImpulseStrongMutSet[setId] =
            new VersionAndIncarnation<FireBombImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetLightningChargedUCWeakMutSetHash(int id, int version, LightningChargedUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public LightningChargedUCWeakMutSetIncarnation GetLightningChargedUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsLightningChargedUCWeakMutSet[id].incarnation;
    }
    public LightningChargedUCWeakMutSet GetLightningChargedUCWeakMutSet(int id) {
      return new LightningChargedUCWeakMutSet(this, id);
    }
    public List<LightningChargedUCWeakMutSet> AllLightningChargedUCWeakMutSet() {
      List<LightningChargedUCWeakMutSet> result = new List<LightningChargedUCWeakMutSet>(rootIncarnation.incarnationsLightningChargedUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsLightningChargedUCWeakMutSet.Keys) {
        result.Add(new LightningChargedUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool LightningChargedUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsLightningChargedUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasLightningChargedUCWeakMutSet(LightningChargedUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasLightningChargedUCWeakMutSet(thing.id);
    }
    public void CheckHasLightningChargedUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsLightningChargedUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid LightningChargedUCWeakMutSet}: " + id);
      }
    }
    public LightningChargedUCWeakMutSet EffectLightningChargedUCWeakMutSetCreate() {
      return TrustedEffectLightningChargedUCWeakMutSetCreateWithId(NewId());
    }
    public LightningChargedUCWeakMutSet TrustedEffectLightningChargedUCWeakMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new LightningChargedUCWeakMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateLightningChargedUCWeakMutSet(id, rootIncarnation.version, incarnation);
      return new LightningChargedUCWeakMutSet(this, id);
    }
    public void EffectInternalCreateLightningChargedUCWeakMutSet(int id, int incarnationVersion, LightningChargedUCWeakMutSetIncarnation incarnation) {
      var effect = new LightningChargedUCWeakMutSetCreateEffect(id);
      rootIncarnation.incarnationsLightningChargedUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<LightningChargedUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectLightningChargedUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new LightningChargedUCWeakMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsLightningChargedUCWeakMutSet[id];
      rootIncarnation.incarnationsLightningChargedUCWeakMutSet.Remove(id);
    }

       
    public void EffectLightningChargedUCWeakMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasLightningChargedUCWeakMutSet(setId);
      CheckHasLightningChargedUC(element);

      var effect = new LightningChargedUCWeakMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsLightningChargedUCWeakMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new LightningChargedUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLightningChargedUCWeakMutSet[setId] =
            new VersionAndIncarnation<LightningChargedUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectLightningChargedUCWeakMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasLightningChargedUCWeakMutSet(setId);


      var effect = new LightningChargedUCWeakMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsLightningChargedUCWeakMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new LightningChargedUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLightningChargedUCWeakMutSet[setId] =
            new VersionAndIncarnation<LightningChargedUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetTimeCloneAICapabilityUCWeakMutSetHash(int id, int version, TimeCloneAICapabilityUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public TimeCloneAICapabilityUCWeakMutSetIncarnation GetTimeCloneAICapabilityUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[id].incarnation;
    }
    public TimeCloneAICapabilityUCWeakMutSet GetTimeCloneAICapabilityUCWeakMutSet(int id) {
      return new TimeCloneAICapabilityUCWeakMutSet(this, id);
    }
    public List<TimeCloneAICapabilityUCWeakMutSet> AllTimeCloneAICapabilityUCWeakMutSet() {
      List<TimeCloneAICapabilityUCWeakMutSet> result = new List<TimeCloneAICapabilityUCWeakMutSet>(rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.Keys) {
        result.Add(new TimeCloneAICapabilityUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool TimeCloneAICapabilityUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasTimeCloneAICapabilityUCWeakMutSet(TimeCloneAICapabilityUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasTimeCloneAICapabilityUCWeakMutSet(thing.id);
    }
    public void CheckHasTimeCloneAICapabilityUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid TimeCloneAICapabilityUCWeakMutSet}: " + id);
      }
    }
    public TimeCloneAICapabilityUCWeakMutSet EffectTimeCloneAICapabilityUCWeakMutSetCreate() {
      return TrustedEffectTimeCloneAICapabilityUCWeakMutSetCreateWithId(NewId());
    }
    public TimeCloneAICapabilityUCWeakMutSet TrustedEffectTimeCloneAICapabilityUCWeakMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new TimeCloneAICapabilityUCWeakMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateTimeCloneAICapabilityUCWeakMutSet(id, rootIncarnation.version, incarnation);
      return new TimeCloneAICapabilityUCWeakMutSet(this, id);
    }
    public void EffectInternalCreateTimeCloneAICapabilityUCWeakMutSet(int id, int incarnationVersion, TimeCloneAICapabilityUCWeakMutSetIncarnation incarnation) {
      var effect = new TimeCloneAICapabilityUCWeakMutSetCreateEffect(id);
      rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<TimeCloneAICapabilityUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectTimeCloneAICapabilityUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new TimeCloneAICapabilityUCWeakMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[id];
      rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.Remove(id);
    }

       
    public void EffectTimeCloneAICapabilityUCWeakMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasTimeCloneAICapabilityUCWeakMutSet(setId);
      CheckHasTimeCloneAICapabilityUC(element);

      var effect = new TimeCloneAICapabilityUCWeakMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new TimeCloneAICapabilityUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[setId] =
            new VersionAndIncarnation<TimeCloneAICapabilityUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectTimeCloneAICapabilityUCWeakMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasTimeCloneAICapabilityUCWeakMutSet(setId);


      var effect = new TimeCloneAICapabilityUCWeakMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new TimeCloneAICapabilityUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[setId] =
            new VersionAndIncarnation<TimeCloneAICapabilityUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetDoomedUCWeakMutSetHash(int id, int version, DoomedUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public DoomedUCWeakMutSetIncarnation GetDoomedUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsDoomedUCWeakMutSet[id].incarnation;
    }
    public DoomedUCWeakMutSet GetDoomedUCWeakMutSet(int id) {
      return new DoomedUCWeakMutSet(this, id);
    }
    public List<DoomedUCWeakMutSet> AllDoomedUCWeakMutSet() {
      List<DoomedUCWeakMutSet> result = new List<DoomedUCWeakMutSet>(rootIncarnation.incarnationsDoomedUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsDoomedUCWeakMutSet.Keys) {
        result.Add(new DoomedUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool DoomedUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsDoomedUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasDoomedUCWeakMutSet(DoomedUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasDoomedUCWeakMutSet(thing.id);
    }
    public void CheckHasDoomedUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsDoomedUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid DoomedUCWeakMutSet}: " + id);
      }
    }
    public DoomedUCWeakMutSet EffectDoomedUCWeakMutSetCreate() {
      return TrustedEffectDoomedUCWeakMutSetCreateWithId(NewId());
    }
    public DoomedUCWeakMutSet TrustedEffectDoomedUCWeakMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new DoomedUCWeakMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateDoomedUCWeakMutSet(id, rootIncarnation.version, incarnation);
      return new DoomedUCWeakMutSet(this, id);
    }
    public void EffectInternalCreateDoomedUCWeakMutSet(int id, int incarnationVersion, DoomedUCWeakMutSetIncarnation incarnation) {
      var effect = new DoomedUCWeakMutSetCreateEffect(id);
      rootIncarnation.incarnationsDoomedUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<DoomedUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectDoomedUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new DoomedUCWeakMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsDoomedUCWeakMutSet[id];
      rootIncarnation.incarnationsDoomedUCWeakMutSet.Remove(id);
    }

       
    public void EffectDoomedUCWeakMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasDoomedUCWeakMutSet(setId);
      CheckHasDoomedUC(element);

      var effect = new DoomedUCWeakMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsDoomedUCWeakMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new DoomedUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDoomedUCWeakMutSet[setId] =
            new VersionAndIncarnation<DoomedUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectDoomedUCWeakMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasDoomedUCWeakMutSet(setId);


      var effect = new DoomedUCWeakMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsDoomedUCWeakMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new DoomedUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDoomedUCWeakMutSet[setId] =
            new VersionAndIncarnation<DoomedUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetMiredUCWeakMutSetHash(int id, int version, MiredUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public MiredUCWeakMutSetIncarnation GetMiredUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsMiredUCWeakMutSet[id].incarnation;
    }
    public MiredUCWeakMutSet GetMiredUCWeakMutSet(int id) {
      return new MiredUCWeakMutSet(this, id);
    }
    public List<MiredUCWeakMutSet> AllMiredUCWeakMutSet() {
      List<MiredUCWeakMutSet> result = new List<MiredUCWeakMutSet>(rootIncarnation.incarnationsMiredUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsMiredUCWeakMutSet.Keys) {
        result.Add(new MiredUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool MiredUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsMiredUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasMiredUCWeakMutSet(MiredUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasMiredUCWeakMutSet(thing.id);
    }
    public void CheckHasMiredUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsMiredUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid MiredUCWeakMutSet}: " + id);
      }
    }
    public MiredUCWeakMutSet EffectMiredUCWeakMutSetCreate() {
      return TrustedEffectMiredUCWeakMutSetCreateWithId(NewId());
    }
    public MiredUCWeakMutSet TrustedEffectMiredUCWeakMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new MiredUCWeakMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateMiredUCWeakMutSet(id, rootIncarnation.version, incarnation);
      return new MiredUCWeakMutSet(this, id);
    }
    public void EffectInternalCreateMiredUCWeakMutSet(int id, int incarnationVersion, MiredUCWeakMutSetIncarnation incarnation) {
      var effect = new MiredUCWeakMutSetCreateEffect(id);
      rootIncarnation.incarnationsMiredUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<MiredUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectMiredUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new MiredUCWeakMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsMiredUCWeakMutSet[id];
      rootIncarnation.incarnationsMiredUCWeakMutSet.Remove(id);
    }

       
    public void EffectMiredUCWeakMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasMiredUCWeakMutSet(setId);
      CheckHasMiredUC(element);

      var effect = new MiredUCWeakMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsMiredUCWeakMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new MiredUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMiredUCWeakMutSet[setId] =
            new VersionAndIncarnation<MiredUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectMiredUCWeakMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasMiredUCWeakMutSet(setId);


      var effect = new MiredUCWeakMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsMiredUCWeakMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new MiredUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMiredUCWeakMutSet[setId] =
            new VersionAndIncarnation<MiredUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetInvincibilityUCWeakMutSetHash(int id, int version, InvincibilityUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public InvincibilityUCWeakMutSetIncarnation GetInvincibilityUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsInvincibilityUCWeakMutSet[id].incarnation;
    }
    public InvincibilityUCWeakMutSet GetInvincibilityUCWeakMutSet(int id) {
      return new InvincibilityUCWeakMutSet(this, id);
    }
    public List<InvincibilityUCWeakMutSet> AllInvincibilityUCWeakMutSet() {
      List<InvincibilityUCWeakMutSet> result = new List<InvincibilityUCWeakMutSet>(rootIncarnation.incarnationsInvincibilityUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsInvincibilityUCWeakMutSet.Keys) {
        result.Add(new InvincibilityUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool InvincibilityUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsInvincibilityUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasInvincibilityUCWeakMutSet(InvincibilityUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasInvincibilityUCWeakMutSet(thing.id);
    }
    public void CheckHasInvincibilityUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsInvincibilityUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid InvincibilityUCWeakMutSet}: " + id);
      }
    }
    public InvincibilityUCWeakMutSet EffectInvincibilityUCWeakMutSetCreate() {
      return TrustedEffectInvincibilityUCWeakMutSetCreateWithId(NewId());
    }
    public InvincibilityUCWeakMutSet TrustedEffectInvincibilityUCWeakMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new InvincibilityUCWeakMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateInvincibilityUCWeakMutSet(id, rootIncarnation.version, incarnation);
      return new InvincibilityUCWeakMutSet(this, id);
    }
    public void EffectInternalCreateInvincibilityUCWeakMutSet(int id, int incarnationVersion, InvincibilityUCWeakMutSetIncarnation incarnation) {
      var effect = new InvincibilityUCWeakMutSetCreateEffect(id);
      rootIncarnation.incarnationsInvincibilityUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<InvincibilityUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectInvincibilityUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new InvincibilityUCWeakMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsInvincibilityUCWeakMutSet[id];
      rootIncarnation.incarnationsInvincibilityUCWeakMutSet.Remove(id);
    }

       
    public void EffectInvincibilityUCWeakMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasInvincibilityUCWeakMutSet(setId);
      CheckHasInvincibilityUC(element);

      var effect = new InvincibilityUCWeakMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsInvincibilityUCWeakMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new InvincibilityUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsInvincibilityUCWeakMutSet[setId] =
            new VersionAndIncarnation<InvincibilityUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectInvincibilityUCWeakMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasInvincibilityUCWeakMutSet(setId);


      var effect = new InvincibilityUCWeakMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsInvincibilityUCWeakMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new InvincibilityUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsInvincibilityUCWeakMutSet[setId] =
            new VersionAndIncarnation<InvincibilityUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetDefyingUCWeakMutSetHash(int id, int version, DefyingUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public DefyingUCWeakMutSetIncarnation GetDefyingUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsDefyingUCWeakMutSet[id].incarnation;
    }
    public DefyingUCWeakMutSet GetDefyingUCWeakMutSet(int id) {
      return new DefyingUCWeakMutSet(this, id);
    }
    public List<DefyingUCWeakMutSet> AllDefyingUCWeakMutSet() {
      List<DefyingUCWeakMutSet> result = new List<DefyingUCWeakMutSet>(rootIncarnation.incarnationsDefyingUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsDefyingUCWeakMutSet.Keys) {
        result.Add(new DefyingUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool DefyingUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsDefyingUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasDefyingUCWeakMutSet(DefyingUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasDefyingUCWeakMutSet(thing.id);
    }
    public void CheckHasDefyingUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsDefyingUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid DefyingUCWeakMutSet}: " + id);
      }
    }
    public DefyingUCWeakMutSet EffectDefyingUCWeakMutSetCreate() {
      return TrustedEffectDefyingUCWeakMutSetCreateWithId(NewId());
    }
    public DefyingUCWeakMutSet TrustedEffectDefyingUCWeakMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new DefyingUCWeakMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateDefyingUCWeakMutSet(id, rootIncarnation.version, incarnation);
      return new DefyingUCWeakMutSet(this, id);
    }
    public void EffectInternalCreateDefyingUCWeakMutSet(int id, int incarnationVersion, DefyingUCWeakMutSetIncarnation incarnation) {
      var effect = new DefyingUCWeakMutSetCreateEffect(id);
      rootIncarnation.incarnationsDefyingUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<DefyingUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectDefyingUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new DefyingUCWeakMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsDefyingUCWeakMutSet[id];
      rootIncarnation.incarnationsDefyingUCWeakMutSet.Remove(id);
    }

       
    public void EffectDefyingUCWeakMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasDefyingUCWeakMutSet(setId);
      CheckHasDefyingUC(element);

      var effect = new DefyingUCWeakMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsDefyingUCWeakMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new DefyingUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDefyingUCWeakMutSet[setId] =
            new VersionAndIncarnation<DefyingUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectDefyingUCWeakMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasDefyingUCWeakMutSet(setId);


      var effect = new DefyingUCWeakMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsDefyingUCWeakMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new DefyingUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDefyingUCWeakMutSet[setId] =
            new VersionAndIncarnation<DefyingUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetCounteringUCWeakMutSetHash(int id, int version, CounteringUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CounteringUCWeakMutSetIncarnation GetCounteringUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsCounteringUCWeakMutSet[id].incarnation;
    }
    public CounteringUCWeakMutSet GetCounteringUCWeakMutSet(int id) {
      return new CounteringUCWeakMutSet(this, id);
    }
    public List<CounteringUCWeakMutSet> AllCounteringUCWeakMutSet() {
      List<CounteringUCWeakMutSet> result = new List<CounteringUCWeakMutSet>(rootIncarnation.incarnationsCounteringUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsCounteringUCWeakMutSet.Keys) {
        result.Add(new CounteringUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool CounteringUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsCounteringUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasCounteringUCWeakMutSet(CounteringUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCounteringUCWeakMutSet(thing.id);
    }
    public void CheckHasCounteringUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsCounteringUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid CounteringUCWeakMutSet}: " + id);
      }
    }
    public CounteringUCWeakMutSet EffectCounteringUCWeakMutSetCreate() {
      return TrustedEffectCounteringUCWeakMutSetCreateWithId(NewId());
    }
    public CounteringUCWeakMutSet TrustedEffectCounteringUCWeakMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new CounteringUCWeakMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateCounteringUCWeakMutSet(id, rootIncarnation.version, incarnation);
      return new CounteringUCWeakMutSet(this, id);
    }
    public void EffectInternalCreateCounteringUCWeakMutSet(int id, int incarnationVersion, CounteringUCWeakMutSetIncarnation incarnation) {
      var effect = new CounteringUCWeakMutSetCreateEffect(id);
      rootIncarnation.incarnationsCounteringUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<CounteringUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectCounteringUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new CounteringUCWeakMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsCounteringUCWeakMutSet[id];
      rootIncarnation.incarnationsCounteringUCWeakMutSet.Remove(id);
    }

       
    public void EffectCounteringUCWeakMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasCounteringUCWeakMutSet(setId);
      CheckHasCounteringUC(element);

      var effect = new CounteringUCWeakMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCounteringUCWeakMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new CounteringUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCounteringUCWeakMutSet[setId] =
            new VersionAndIncarnation<CounteringUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectCounteringUCWeakMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasCounteringUCWeakMutSet(setId);


      var effect = new CounteringUCWeakMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCounteringUCWeakMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new CounteringUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCounteringUCWeakMutSet[setId] =
            new VersionAndIncarnation<CounteringUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetAttackAICapabilityUCWeakMutSetHash(int id, int version, AttackAICapabilityUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public AttackAICapabilityUCWeakMutSetIncarnation GetAttackAICapabilityUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[id].incarnation;
    }
    public AttackAICapabilityUCWeakMutSet GetAttackAICapabilityUCWeakMutSet(int id) {
      return new AttackAICapabilityUCWeakMutSet(this, id);
    }
    public List<AttackAICapabilityUCWeakMutSet> AllAttackAICapabilityUCWeakMutSet() {
      List<AttackAICapabilityUCWeakMutSet> result = new List<AttackAICapabilityUCWeakMutSet>(rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.Keys) {
        result.Add(new AttackAICapabilityUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool AttackAICapabilityUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasAttackAICapabilityUCWeakMutSet(AttackAICapabilityUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasAttackAICapabilityUCWeakMutSet(thing.id);
    }
    public void CheckHasAttackAICapabilityUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid AttackAICapabilityUCWeakMutSet}: " + id);
      }
    }
    public AttackAICapabilityUCWeakMutSet EffectAttackAICapabilityUCWeakMutSetCreate() {
      return TrustedEffectAttackAICapabilityUCWeakMutSetCreateWithId(NewId());
    }
    public AttackAICapabilityUCWeakMutSet TrustedEffectAttackAICapabilityUCWeakMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new AttackAICapabilityUCWeakMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateAttackAICapabilityUCWeakMutSet(id, rootIncarnation.version, incarnation);
      return new AttackAICapabilityUCWeakMutSet(this, id);
    }
    public void EffectInternalCreateAttackAICapabilityUCWeakMutSet(int id, int incarnationVersion, AttackAICapabilityUCWeakMutSetIncarnation incarnation) {
      var effect = new AttackAICapabilityUCWeakMutSetCreateEffect(id);
      rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<AttackAICapabilityUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectAttackAICapabilityUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new AttackAICapabilityUCWeakMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[id];
      rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.Remove(id);
    }

       
    public void EffectAttackAICapabilityUCWeakMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasAttackAICapabilityUCWeakMutSet(setId);
      CheckHasAttackAICapabilityUC(element);

      var effect = new AttackAICapabilityUCWeakMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new AttackAICapabilityUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[setId] =
            new VersionAndIncarnation<AttackAICapabilityUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectAttackAICapabilityUCWeakMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasAttackAICapabilityUCWeakMutSet(setId);


      var effect = new AttackAICapabilityUCWeakMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new AttackAICapabilityUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[setId] =
            new VersionAndIncarnation<AttackAICapabilityUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetUnitMutSetHash(int id, int version, UnitMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public UnitMutSetIncarnation GetUnitMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsUnitMutSet[id].incarnation;
    }
    public UnitMutSet GetUnitMutSet(int id) {
      return new UnitMutSet(this, id);
    }
    public List<UnitMutSet> AllUnitMutSet() {
      List<UnitMutSet> result = new List<UnitMutSet>(rootIncarnation.incarnationsUnitMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsUnitMutSet.Keys) {
        result.Add(new UnitMutSet(this, id));
      }
      return result;
    }
    public bool UnitMutSetExists(int id) {
      return rootIncarnation.incarnationsUnitMutSet.ContainsKey(id);
    }
    public void CheckHasUnitMutSet(UnitMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasUnitMutSet(thing.id);
    }
    public void CheckHasUnitMutSet(int id) {
      if (!rootIncarnation.incarnationsUnitMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid UnitMutSet}: " + id);
      }
    }
    public UnitMutSet EffectUnitMutSetCreate() {
      return TrustedEffectUnitMutSetCreateWithId(NewId());
    }
    public UnitMutSet TrustedEffectUnitMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new UnitMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateUnitMutSet(id, rootIncarnation.version, incarnation);
      return new UnitMutSet(this, id);
    }
    public void EffectInternalCreateUnitMutSet(int id, int incarnationVersion, UnitMutSetIncarnation incarnation) {
      var effect = new UnitMutSetCreateEffect(id);
      rootIncarnation.incarnationsUnitMutSet
          .Add(
              id,
              new VersionAndIncarnation<UnitMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectUnitMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new UnitMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsUnitMutSet[id];
      rootIncarnation.incarnationsUnitMutSet.Remove(id);
    }

       
    public void EffectUnitMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasUnitMutSet(setId);
      CheckHasUnit(element);

      var effect = new UnitMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsUnitMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new UnitMutSetIncarnation(newMap);
        rootIncarnation.incarnationsUnitMutSet[setId] =
            new VersionAndIncarnation<UnitMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectUnitMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasUnitMutSet(setId);

        CheckHasUnit(elementId);


      var effect = new UnitMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsUnitMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new UnitMutSetIncarnation(newMap);
        rootIncarnation.incarnationsUnitMutSet[setId] =
            new VersionAndIncarnation<UnitMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetSimplePresenceTriggerTTCMutSetHash(int id, int version, SimplePresenceTriggerTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public SimplePresenceTriggerTTCMutSetIncarnation GetSimplePresenceTriggerTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet[id].incarnation;
    }
    public SimplePresenceTriggerTTCMutSet GetSimplePresenceTriggerTTCMutSet(int id) {
      return new SimplePresenceTriggerTTCMutSet(this, id);
    }
    public List<SimplePresenceTriggerTTCMutSet> AllSimplePresenceTriggerTTCMutSet() {
      List<SimplePresenceTriggerTTCMutSet> result = new List<SimplePresenceTriggerTTCMutSet>(rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet.Keys) {
        result.Add(new SimplePresenceTriggerTTCMutSet(this, id));
      }
      return result;
    }
    public bool SimplePresenceTriggerTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet.ContainsKey(id);
    }
    public void CheckHasSimplePresenceTriggerTTCMutSet(SimplePresenceTriggerTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasSimplePresenceTriggerTTCMutSet(thing.id);
    }
    public void CheckHasSimplePresenceTriggerTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid SimplePresenceTriggerTTCMutSet}: " + id);
      }
    }
    public SimplePresenceTriggerTTCMutSet EffectSimplePresenceTriggerTTCMutSetCreate() {
      return TrustedEffectSimplePresenceTriggerTTCMutSetCreateWithId(NewId());
    }
    public SimplePresenceTriggerTTCMutSet TrustedEffectSimplePresenceTriggerTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new SimplePresenceTriggerTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateSimplePresenceTriggerTTCMutSet(id, rootIncarnation.version, incarnation);
      return new SimplePresenceTriggerTTCMutSet(this, id);
    }
    public void EffectInternalCreateSimplePresenceTriggerTTCMutSet(int id, int incarnationVersion, SimplePresenceTriggerTTCMutSetIncarnation incarnation) {
      var effect = new SimplePresenceTriggerTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<SimplePresenceTriggerTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectSimplePresenceTriggerTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new SimplePresenceTriggerTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet[id];
      rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet.Remove(id);
    }

       
    public void EffectSimplePresenceTriggerTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasSimplePresenceTriggerTTCMutSet(setId);
      CheckHasSimplePresenceTriggerTTC(element);

      var effect = new SimplePresenceTriggerTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new SimplePresenceTriggerTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet[setId] =
            new VersionAndIncarnation<SimplePresenceTriggerTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectSimplePresenceTriggerTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasSimplePresenceTriggerTTCMutSet(setId);

        CheckHasSimplePresenceTriggerTTC(elementId);


      var effect = new SimplePresenceTriggerTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new SimplePresenceTriggerTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet[setId] =
            new VersionAndIncarnation<SimplePresenceTriggerTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetItemTTCMutSetHash(int id, int version, ItemTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ItemTTCMutSetIncarnation GetItemTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsItemTTCMutSet[id].incarnation;
    }
    public ItemTTCMutSet GetItemTTCMutSet(int id) {
      return new ItemTTCMutSet(this, id);
    }
    public List<ItemTTCMutSet> AllItemTTCMutSet() {
      List<ItemTTCMutSet> result = new List<ItemTTCMutSet>(rootIncarnation.incarnationsItemTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsItemTTCMutSet.Keys) {
        result.Add(new ItemTTCMutSet(this, id));
      }
      return result;
    }
    public bool ItemTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsItemTTCMutSet.ContainsKey(id);
    }
    public void CheckHasItemTTCMutSet(ItemTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasItemTTCMutSet(thing.id);
    }
    public void CheckHasItemTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsItemTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ItemTTCMutSet}: " + id);
      }
    }
    public ItemTTCMutSet EffectItemTTCMutSetCreate() {
      return TrustedEffectItemTTCMutSetCreateWithId(NewId());
    }
    public ItemTTCMutSet TrustedEffectItemTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new ItemTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateItemTTCMutSet(id, rootIncarnation.version, incarnation);
      return new ItemTTCMutSet(this, id);
    }
    public void EffectInternalCreateItemTTCMutSet(int id, int incarnationVersion, ItemTTCMutSetIncarnation incarnation) {
      var effect = new ItemTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsItemTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<ItemTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectItemTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new ItemTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsItemTTCMutSet[id];
      rootIncarnation.incarnationsItemTTCMutSet.Remove(id);
    }

       
    public void EffectItemTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasItemTTCMutSet(setId);
      CheckHasItemTTC(element);

      var effect = new ItemTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsItemTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new ItemTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsItemTTCMutSet[setId] =
            new VersionAndIncarnation<ItemTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectItemTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasItemTTCMutSet(setId);

        CheckHasItemTTC(elementId);


      var effect = new ItemTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsItemTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ItemTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsItemTTCMutSet[setId] =
            new VersionAndIncarnation<ItemTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetKamikazeTargetTTCMutSetHash(int id, int version, KamikazeTargetTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public KamikazeTargetTTCMutSetIncarnation GetKamikazeTargetTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsKamikazeTargetTTCMutSet[id].incarnation;
    }
    public KamikazeTargetTTCMutSet GetKamikazeTargetTTCMutSet(int id) {
      return new KamikazeTargetTTCMutSet(this, id);
    }
    public List<KamikazeTargetTTCMutSet> AllKamikazeTargetTTCMutSet() {
      List<KamikazeTargetTTCMutSet> result = new List<KamikazeTargetTTCMutSet>(rootIncarnation.incarnationsKamikazeTargetTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsKamikazeTargetTTCMutSet.Keys) {
        result.Add(new KamikazeTargetTTCMutSet(this, id));
      }
      return result;
    }
    public bool KamikazeTargetTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsKamikazeTargetTTCMutSet.ContainsKey(id);
    }
    public void CheckHasKamikazeTargetTTCMutSet(KamikazeTargetTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasKamikazeTargetTTCMutSet(thing.id);
    }
    public void CheckHasKamikazeTargetTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsKamikazeTargetTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid KamikazeTargetTTCMutSet}: " + id);
      }
    }
    public KamikazeTargetTTCMutSet EffectKamikazeTargetTTCMutSetCreate() {
      return TrustedEffectKamikazeTargetTTCMutSetCreateWithId(NewId());
    }
    public KamikazeTargetTTCMutSet TrustedEffectKamikazeTargetTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new KamikazeTargetTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateKamikazeTargetTTCMutSet(id, rootIncarnation.version, incarnation);
      return new KamikazeTargetTTCMutSet(this, id);
    }
    public void EffectInternalCreateKamikazeTargetTTCMutSet(int id, int incarnationVersion, KamikazeTargetTTCMutSetIncarnation incarnation) {
      var effect = new KamikazeTargetTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsKamikazeTargetTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<KamikazeTargetTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectKamikazeTargetTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new KamikazeTargetTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsKamikazeTargetTTCMutSet[id];
      rootIncarnation.incarnationsKamikazeTargetTTCMutSet.Remove(id);
    }

       
    public void EffectKamikazeTargetTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasKamikazeTargetTTCMutSet(setId);
      CheckHasKamikazeTargetTTC(element);

      var effect = new KamikazeTargetTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeTargetTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new KamikazeTargetTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsKamikazeTargetTTCMutSet[setId] =
            new VersionAndIncarnation<KamikazeTargetTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectKamikazeTargetTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasKamikazeTargetTTCMutSet(setId);

        CheckHasKamikazeTargetTTC(elementId);


      var effect = new KamikazeTargetTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeTargetTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new KamikazeTargetTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsKamikazeTargetTTCMutSet[setId] =
            new VersionAndIncarnation<KamikazeTargetTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetWarperTTCMutSetHash(int id, int version, WarperTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public WarperTTCMutSetIncarnation GetWarperTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsWarperTTCMutSet[id].incarnation;
    }
    public WarperTTCMutSet GetWarperTTCMutSet(int id) {
      return new WarperTTCMutSet(this, id);
    }
    public List<WarperTTCMutSet> AllWarperTTCMutSet() {
      List<WarperTTCMutSet> result = new List<WarperTTCMutSet>(rootIncarnation.incarnationsWarperTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsWarperTTCMutSet.Keys) {
        result.Add(new WarperTTCMutSet(this, id));
      }
      return result;
    }
    public bool WarperTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsWarperTTCMutSet.ContainsKey(id);
    }
    public void CheckHasWarperTTCMutSet(WarperTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasWarperTTCMutSet(thing.id);
    }
    public void CheckHasWarperTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsWarperTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid WarperTTCMutSet}: " + id);
      }
    }
    public WarperTTCMutSet EffectWarperTTCMutSetCreate() {
      return TrustedEffectWarperTTCMutSetCreateWithId(NewId());
    }
    public WarperTTCMutSet TrustedEffectWarperTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new WarperTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateWarperTTCMutSet(id, rootIncarnation.version, incarnation);
      return new WarperTTCMutSet(this, id);
    }
    public void EffectInternalCreateWarperTTCMutSet(int id, int incarnationVersion, WarperTTCMutSetIncarnation incarnation) {
      var effect = new WarperTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsWarperTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<WarperTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectWarperTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new WarperTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsWarperTTCMutSet[id];
      rootIncarnation.incarnationsWarperTTCMutSet.Remove(id);
    }

       
    public void EffectWarperTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasWarperTTCMutSet(setId);
      CheckHasWarperTTC(element);

      var effect = new WarperTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsWarperTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new WarperTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsWarperTTCMutSet[setId] =
            new VersionAndIncarnation<WarperTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectWarperTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasWarperTTCMutSet(setId);

        CheckHasWarperTTC(elementId);


      var effect = new WarperTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsWarperTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new WarperTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsWarperTTCMutSet[setId] =
            new VersionAndIncarnation<WarperTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetTimeAnchorTTCMutSetHash(int id, int version, TimeAnchorTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public TimeAnchorTTCMutSetIncarnation GetTimeAnchorTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsTimeAnchorTTCMutSet[id].incarnation;
    }
    public TimeAnchorTTCMutSet GetTimeAnchorTTCMutSet(int id) {
      return new TimeAnchorTTCMutSet(this, id);
    }
    public List<TimeAnchorTTCMutSet> AllTimeAnchorTTCMutSet() {
      List<TimeAnchorTTCMutSet> result = new List<TimeAnchorTTCMutSet>(rootIncarnation.incarnationsTimeAnchorTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsTimeAnchorTTCMutSet.Keys) {
        result.Add(new TimeAnchorTTCMutSet(this, id));
      }
      return result;
    }
    public bool TimeAnchorTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsTimeAnchorTTCMutSet.ContainsKey(id);
    }
    public void CheckHasTimeAnchorTTCMutSet(TimeAnchorTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasTimeAnchorTTCMutSet(thing.id);
    }
    public void CheckHasTimeAnchorTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsTimeAnchorTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid TimeAnchorTTCMutSet}: " + id);
      }
    }
    public TimeAnchorTTCMutSet EffectTimeAnchorTTCMutSetCreate() {
      return TrustedEffectTimeAnchorTTCMutSetCreateWithId(NewId());
    }
    public TimeAnchorTTCMutSet TrustedEffectTimeAnchorTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new TimeAnchorTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateTimeAnchorTTCMutSet(id, rootIncarnation.version, incarnation);
      return new TimeAnchorTTCMutSet(this, id);
    }
    public void EffectInternalCreateTimeAnchorTTCMutSet(int id, int incarnationVersion, TimeAnchorTTCMutSetIncarnation incarnation) {
      var effect = new TimeAnchorTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsTimeAnchorTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<TimeAnchorTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectTimeAnchorTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new TimeAnchorTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsTimeAnchorTTCMutSet[id];
      rootIncarnation.incarnationsTimeAnchorTTCMutSet.Remove(id);
    }

       
    public void EffectTimeAnchorTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasTimeAnchorTTCMutSet(setId);
      CheckHasTimeAnchorTTC(element);

      var effect = new TimeAnchorTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTimeAnchorTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new TimeAnchorTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTimeAnchorTTCMutSet[setId] =
            new VersionAndIncarnation<TimeAnchorTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectTimeAnchorTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasTimeAnchorTTCMutSet(setId);

        CheckHasTimeAnchorTTC(elementId);


      var effect = new TimeAnchorTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTimeAnchorTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new TimeAnchorTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTimeAnchorTTCMutSet[setId] =
            new VersionAndIncarnation<TimeAnchorTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetFireBombTTCMutSetHash(int id, int version, FireBombTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public FireBombTTCMutSetIncarnation GetFireBombTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsFireBombTTCMutSet[id].incarnation;
    }
    public FireBombTTCMutSet GetFireBombTTCMutSet(int id) {
      return new FireBombTTCMutSet(this, id);
    }
    public List<FireBombTTCMutSet> AllFireBombTTCMutSet() {
      List<FireBombTTCMutSet> result = new List<FireBombTTCMutSet>(rootIncarnation.incarnationsFireBombTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsFireBombTTCMutSet.Keys) {
        result.Add(new FireBombTTCMutSet(this, id));
      }
      return result;
    }
    public bool FireBombTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsFireBombTTCMutSet.ContainsKey(id);
    }
    public void CheckHasFireBombTTCMutSet(FireBombTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasFireBombTTCMutSet(thing.id);
    }
    public void CheckHasFireBombTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsFireBombTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid FireBombTTCMutSet}: " + id);
      }
    }
    public FireBombTTCMutSet EffectFireBombTTCMutSetCreate() {
      return TrustedEffectFireBombTTCMutSetCreateWithId(NewId());
    }
    public FireBombTTCMutSet TrustedEffectFireBombTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new FireBombTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateFireBombTTCMutSet(id, rootIncarnation.version, incarnation);
      return new FireBombTTCMutSet(this, id);
    }
    public void EffectInternalCreateFireBombTTCMutSet(int id, int incarnationVersion, FireBombTTCMutSetIncarnation incarnation) {
      var effect = new FireBombTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsFireBombTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<FireBombTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectFireBombTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new FireBombTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsFireBombTTCMutSet[id];
      rootIncarnation.incarnationsFireBombTTCMutSet.Remove(id);
    }

       
    public void EffectFireBombTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasFireBombTTCMutSet(setId);
      CheckHasFireBombTTC(element);

      var effect = new FireBombTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsFireBombTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new FireBombTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFireBombTTCMutSet[setId] =
            new VersionAndIncarnation<FireBombTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectFireBombTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasFireBombTTCMutSet(setId);

        CheckHasFireBombTTC(elementId);


      var effect = new FireBombTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsFireBombTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new FireBombTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFireBombTTCMutSet[setId] =
            new VersionAndIncarnation<FireBombTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetMarkerTTCMutSetHash(int id, int version, MarkerTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public MarkerTTCMutSetIncarnation GetMarkerTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsMarkerTTCMutSet[id].incarnation;
    }
    public MarkerTTCMutSet GetMarkerTTCMutSet(int id) {
      return new MarkerTTCMutSet(this, id);
    }
    public List<MarkerTTCMutSet> AllMarkerTTCMutSet() {
      List<MarkerTTCMutSet> result = new List<MarkerTTCMutSet>(rootIncarnation.incarnationsMarkerTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsMarkerTTCMutSet.Keys) {
        result.Add(new MarkerTTCMutSet(this, id));
      }
      return result;
    }
    public bool MarkerTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsMarkerTTCMutSet.ContainsKey(id);
    }
    public void CheckHasMarkerTTCMutSet(MarkerTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasMarkerTTCMutSet(thing.id);
    }
    public void CheckHasMarkerTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsMarkerTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid MarkerTTCMutSet}: " + id);
      }
    }
    public MarkerTTCMutSet EffectMarkerTTCMutSetCreate() {
      return TrustedEffectMarkerTTCMutSetCreateWithId(NewId());
    }
    public MarkerTTCMutSet TrustedEffectMarkerTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new MarkerTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateMarkerTTCMutSet(id, rootIncarnation.version, incarnation);
      return new MarkerTTCMutSet(this, id);
    }
    public void EffectInternalCreateMarkerTTCMutSet(int id, int incarnationVersion, MarkerTTCMutSetIncarnation incarnation) {
      var effect = new MarkerTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsMarkerTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<MarkerTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectMarkerTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new MarkerTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsMarkerTTCMutSet[id];
      rootIncarnation.incarnationsMarkerTTCMutSet.Remove(id);
    }

       
    public void EffectMarkerTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasMarkerTTCMutSet(setId);
      CheckHasMarkerTTC(element);

      var effect = new MarkerTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsMarkerTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new MarkerTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMarkerTTCMutSet[setId] =
            new VersionAndIncarnation<MarkerTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectMarkerTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasMarkerTTCMutSet(setId);

        CheckHasMarkerTTC(elementId);


      var effect = new MarkerTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsMarkerTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new MarkerTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMarkerTTCMutSet[setId] =
            new VersionAndIncarnation<MarkerTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetLevelLinkTTCMutSetHash(int id, int version, LevelLinkTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public LevelLinkTTCMutSetIncarnation GetLevelLinkTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsLevelLinkTTCMutSet[id].incarnation;
    }
    public LevelLinkTTCMutSet GetLevelLinkTTCMutSet(int id) {
      return new LevelLinkTTCMutSet(this, id);
    }
    public List<LevelLinkTTCMutSet> AllLevelLinkTTCMutSet() {
      List<LevelLinkTTCMutSet> result = new List<LevelLinkTTCMutSet>(rootIncarnation.incarnationsLevelLinkTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsLevelLinkTTCMutSet.Keys) {
        result.Add(new LevelLinkTTCMutSet(this, id));
      }
      return result;
    }
    public bool LevelLinkTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsLevelLinkTTCMutSet.ContainsKey(id);
    }
    public void CheckHasLevelLinkTTCMutSet(LevelLinkTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasLevelLinkTTCMutSet(thing.id);
    }
    public void CheckHasLevelLinkTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsLevelLinkTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid LevelLinkTTCMutSet}: " + id);
      }
    }
    public LevelLinkTTCMutSet EffectLevelLinkTTCMutSetCreate() {
      return TrustedEffectLevelLinkTTCMutSetCreateWithId(NewId());
    }
    public LevelLinkTTCMutSet TrustedEffectLevelLinkTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new LevelLinkTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateLevelLinkTTCMutSet(id, rootIncarnation.version, incarnation);
      return new LevelLinkTTCMutSet(this, id);
    }
    public void EffectInternalCreateLevelLinkTTCMutSet(int id, int incarnationVersion, LevelLinkTTCMutSetIncarnation incarnation) {
      var effect = new LevelLinkTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsLevelLinkTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<LevelLinkTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectLevelLinkTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new LevelLinkTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsLevelLinkTTCMutSet[id];
      rootIncarnation.incarnationsLevelLinkTTCMutSet.Remove(id);
    }

       
    public void EffectLevelLinkTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasLevelLinkTTCMutSet(setId);
      CheckHasLevelLinkTTC(element);

      var effect = new LevelLinkTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsLevelLinkTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new LevelLinkTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLevelLinkTTCMutSet[setId] =
            new VersionAndIncarnation<LevelLinkTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectLevelLinkTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasLevelLinkTTCMutSet(setId);

        CheckHasLevelLinkTTC(elementId);


      var effect = new LevelLinkTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsLevelLinkTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new LevelLinkTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLevelLinkTTCMutSet[setId] =
            new VersionAndIncarnation<LevelLinkTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetMudTTCMutSetHash(int id, int version, MudTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public MudTTCMutSetIncarnation GetMudTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsMudTTCMutSet[id].incarnation;
    }
    public MudTTCMutSet GetMudTTCMutSet(int id) {
      return new MudTTCMutSet(this, id);
    }
    public List<MudTTCMutSet> AllMudTTCMutSet() {
      List<MudTTCMutSet> result = new List<MudTTCMutSet>(rootIncarnation.incarnationsMudTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsMudTTCMutSet.Keys) {
        result.Add(new MudTTCMutSet(this, id));
      }
      return result;
    }
    public bool MudTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsMudTTCMutSet.ContainsKey(id);
    }
    public void CheckHasMudTTCMutSet(MudTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasMudTTCMutSet(thing.id);
    }
    public void CheckHasMudTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsMudTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid MudTTCMutSet}: " + id);
      }
    }
    public MudTTCMutSet EffectMudTTCMutSetCreate() {
      return TrustedEffectMudTTCMutSetCreateWithId(NewId());
    }
    public MudTTCMutSet TrustedEffectMudTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new MudTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateMudTTCMutSet(id, rootIncarnation.version, incarnation);
      return new MudTTCMutSet(this, id);
    }
    public void EffectInternalCreateMudTTCMutSet(int id, int incarnationVersion, MudTTCMutSetIncarnation incarnation) {
      var effect = new MudTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsMudTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<MudTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectMudTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new MudTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsMudTTCMutSet[id];
      rootIncarnation.incarnationsMudTTCMutSet.Remove(id);
    }

       
    public void EffectMudTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasMudTTCMutSet(setId);
      CheckHasMudTTC(element);

      var effect = new MudTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsMudTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new MudTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMudTTCMutSet[setId] =
            new VersionAndIncarnation<MudTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectMudTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasMudTTCMutSet(setId);

        CheckHasMudTTC(elementId);


      var effect = new MudTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsMudTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new MudTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMudTTCMutSet[setId] =
            new VersionAndIncarnation<MudTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetDirtTTCMutSetHash(int id, int version, DirtTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public DirtTTCMutSetIncarnation GetDirtTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsDirtTTCMutSet[id].incarnation;
    }
    public DirtTTCMutSet GetDirtTTCMutSet(int id) {
      return new DirtTTCMutSet(this, id);
    }
    public List<DirtTTCMutSet> AllDirtTTCMutSet() {
      List<DirtTTCMutSet> result = new List<DirtTTCMutSet>(rootIncarnation.incarnationsDirtTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsDirtTTCMutSet.Keys) {
        result.Add(new DirtTTCMutSet(this, id));
      }
      return result;
    }
    public bool DirtTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsDirtTTCMutSet.ContainsKey(id);
    }
    public void CheckHasDirtTTCMutSet(DirtTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasDirtTTCMutSet(thing.id);
    }
    public void CheckHasDirtTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsDirtTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid DirtTTCMutSet}: " + id);
      }
    }
    public DirtTTCMutSet EffectDirtTTCMutSetCreate() {
      return TrustedEffectDirtTTCMutSetCreateWithId(NewId());
    }
    public DirtTTCMutSet TrustedEffectDirtTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new DirtTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateDirtTTCMutSet(id, rootIncarnation.version, incarnation);
      return new DirtTTCMutSet(this, id);
    }
    public void EffectInternalCreateDirtTTCMutSet(int id, int incarnationVersion, DirtTTCMutSetIncarnation incarnation) {
      var effect = new DirtTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsDirtTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<DirtTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectDirtTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new DirtTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsDirtTTCMutSet[id];
      rootIncarnation.incarnationsDirtTTCMutSet.Remove(id);
    }

       
    public void EffectDirtTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasDirtTTCMutSet(setId);
      CheckHasDirtTTC(element);

      var effect = new DirtTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsDirtTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new DirtTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDirtTTCMutSet[setId] =
            new VersionAndIncarnation<DirtTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectDirtTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasDirtTTCMutSet(setId);

        CheckHasDirtTTC(elementId);


      var effect = new DirtTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsDirtTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new DirtTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDirtTTCMutSet[setId] =
            new VersionAndIncarnation<DirtTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetObsidianTTCMutSetHash(int id, int version, ObsidianTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ObsidianTTCMutSetIncarnation GetObsidianTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsObsidianTTCMutSet[id].incarnation;
    }
    public ObsidianTTCMutSet GetObsidianTTCMutSet(int id) {
      return new ObsidianTTCMutSet(this, id);
    }
    public List<ObsidianTTCMutSet> AllObsidianTTCMutSet() {
      List<ObsidianTTCMutSet> result = new List<ObsidianTTCMutSet>(rootIncarnation.incarnationsObsidianTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsObsidianTTCMutSet.Keys) {
        result.Add(new ObsidianTTCMutSet(this, id));
      }
      return result;
    }
    public bool ObsidianTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsObsidianTTCMutSet.ContainsKey(id);
    }
    public void CheckHasObsidianTTCMutSet(ObsidianTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasObsidianTTCMutSet(thing.id);
    }
    public void CheckHasObsidianTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsObsidianTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ObsidianTTCMutSet}: " + id);
      }
    }
    public ObsidianTTCMutSet EffectObsidianTTCMutSetCreate() {
      return TrustedEffectObsidianTTCMutSetCreateWithId(NewId());
    }
    public ObsidianTTCMutSet TrustedEffectObsidianTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new ObsidianTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateObsidianTTCMutSet(id, rootIncarnation.version, incarnation);
      return new ObsidianTTCMutSet(this, id);
    }
    public void EffectInternalCreateObsidianTTCMutSet(int id, int incarnationVersion, ObsidianTTCMutSetIncarnation incarnation) {
      var effect = new ObsidianTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsObsidianTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<ObsidianTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectObsidianTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new ObsidianTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsObsidianTTCMutSet[id];
      rootIncarnation.incarnationsObsidianTTCMutSet.Remove(id);
    }

       
    public void EffectObsidianTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasObsidianTTCMutSet(setId);
      CheckHasObsidianTTC(element);

      var effect = new ObsidianTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsObsidianTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new ObsidianTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsObsidianTTCMutSet[setId] =
            new VersionAndIncarnation<ObsidianTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectObsidianTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasObsidianTTCMutSet(setId);

        CheckHasObsidianTTC(elementId);


      var effect = new ObsidianTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsObsidianTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ObsidianTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsObsidianTTCMutSet[setId] =
            new VersionAndIncarnation<ObsidianTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetDownStairsTTCMutSetHash(int id, int version, DownStairsTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public DownStairsTTCMutSetIncarnation GetDownStairsTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsDownStairsTTCMutSet[id].incarnation;
    }
    public DownStairsTTCMutSet GetDownStairsTTCMutSet(int id) {
      return new DownStairsTTCMutSet(this, id);
    }
    public List<DownStairsTTCMutSet> AllDownStairsTTCMutSet() {
      List<DownStairsTTCMutSet> result = new List<DownStairsTTCMutSet>(rootIncarnation.incarnationsDownStairsTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsDownStairsTTCMutSet.Keys) {
        result.Add(new DownStairsTTCMutSet(this, id));
      }
      return result;
    }
    public bool DownStairsTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsDownStairsTTCMutSet.ContainsKey(id);
    }
    public void CheckHasDownStairsTTCMutSet(DownStairsTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasDownStairsTTCMutSet(thing.id);
    }
    public void CheckHasDownStairsTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsDownStairsTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid DownStairsTTCMutSet}: " + id);
      }
    }
    public DownStairsTTCMutSet EffectDownStairsTTCMutSetCreate() {
      return TrustedEffectDownStairsTTCMutSetCreateWithId(NewId());
    }
    public DownStairsTTCMutSet TrustedEffectDownStairsTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new DownStairsTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateDownStairsTTCMutSet(id, rootIncarnation.version, incarnation);
      return new DownStairsTTCMutSet(this, id);
    }
    public void EffectInternalCreateDownStairsTTCMutSet(int id, int incarnationVersion, DownStairsTTCMutSetIncarnation incarnation) {
      var effect = new DownStairsTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsDownStairsTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<DownStairsTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectDownStairsTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new DownStairsTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsDownStairsTTCMutSet[id];
      rootIncarnation.incarnationsDownStairsTTCMutSet.Remove(id);
    }

       
    public void EffectDownStairsTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasDownStairsTTCMutSet(setId);
      CheckHasDownStairsTTC(element);

      var effect = new DownStairsTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsDownStairsTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new DownStairsTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDownStairsTTCMutSet[setId] =
            new VersionAndIncarnation<DownStairsTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectDownStairsTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasDownStairsTTCMutSet(setId);

        CheckHasDownStairsTTC(elementId);


      var effect = new DownStairsTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsDownStairsTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new DownStairsTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDownStairsTTCMutSet[setId] =
            new VersionAndIncarnation<DownStairsTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetUpStairsTTCMutSetHash(int id, int version, UpStairsTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public UpStairsTTCMutSetIncarnation GetUpStairsTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsUpStairsTTCMutSet[id].incarnation;
    }
    public UpStairsTTCMutSet GetUpStairsTTCMutSet(int id) {
      return new UpStairsTTCMutSet(this, id);
    }
    public List<UpStairsTTCMutSet> AllUpStairsTTCMutSet() {
      List<UpStairsTTCMutSet> result = new List<UpStairsTTCMutSet>(rootIncarnation.incarnationsUpStairsTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsUpStairsTTCMutSet.Keys) {
        result.Add(new UpStairsTTCMutSet(this, id));
      }
      return result;
    }
    public bool UpStairsTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsUpStairsTTCMutSet.ContainsKey(id);
    }
    public void CheckHasUpStairsTTCMutSet(UpStairsTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasUpStairsTTCMutSet(thing.id);
    }
    public void CheckHasUpStairsTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsUpStairsTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid UpStairsTTCMutSet}: " + id);
      }
    }
    public UpStairsTTCMutSet EffectUpStairsTTCMutSetCreate() {
      return TrustedEffectUpStairsTTCMutSetCreateWithId(NewId());
    }
    public UpStairsTTCMutSet TrustedEffectUpStairsTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new UpStairsTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateUpStairsTTCMutSet(id, rootIncarnation.version, incarnation);
      return new UpStairsTTCMutSet(this, id);
    }
    public void EffectInternalCreateUpStairsTTCMutSet(int id, int incarnationVersion, UpStairsTTCMutSetIncarnation incarnation) {
      var effect = new UpStairsTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsUpStairsTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<UpStairsTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectUpStairsTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new UpStairsTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsUpStairsTTCMutSet[id];
      rootIncarnation.incarnationsUpStairsTTCMutSet.Remove(id);
    }

       
    public void EffectUpStairsTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasUpStairsTTCMutSet(setId);
      CheckHasUpStairsTTC(element);

      var effect = new UpStairsTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsUpStairsTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new UpStairsTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsUpStairsTTCMutSet[setId] =
            new VersionAndIncarnation<UpStairsTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectUpStairsTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasUpStairsTTCMutSet(setId);

        CheckHasUpStairsTTC(elementId);


      var effect = new UpStairsTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsUpStairsTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new UpStairsTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsUpStairsTTCMutSet[setId] =
            new VersionAndIncarnation<UpStairsTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetWallTTCMutSetHash(int id, int version, WallTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public WallTTCMutSetIncarnation GetWallTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsWallTTCMutSet[id].incarnation;
    }
    public WallTTCMutSet GetWallTTCMutSet(int id) {
      return new WallTTCMutSet(this, id);
    }
    public List<WallTTCMutSet> AllWallTTCMutSet() {
      List<WallTTCMutSet> result = new List<WallTTCMutSet>(rootIncarnation.incarnationsWallTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsWallTTCMutSet.Keys) {
        result.Add(new WallTTCMutSet(this, id));
      }
      return result;
    }
    public bool WallTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsWallTTCMutSet.ContainsKey(id);
    }
    public void CheckHasWallTTCMutSet(WallTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasWallTTCMutSet(thing.id);
    }
    public void CheckHasWallTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsWallTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid WallTTCMutSet}: " + id);
      }
    }
    public WallTTCMutSet EffectWallTTCMutSetCreate() {
      return TrustedEffectWallTTCMutSetCreateWithId(NewId());
    }
    public WallTTCMutSet TrustedEffectWallTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new WallTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateWallTTCMutSet(id, rootIncarnation.version, incarnation);
      return new WallTTCMutSet(this, id);
    }
    public void EffectInternalCreateWallTTCMutSet(int id, int incarnationVersion, WallTTCMutSetIncarnation incarnation) {
      var effect = new WallTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsWallTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<WallTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectWallTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new WallTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsWallTTCMutSet[id];
      rootIncarnation.incarnationsWallTTCMutSet.Remove(id);
    }

       
    public void EffectWallTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasWallTTCMutSet(setId);
      CheckHasWallTTC(element);

      var effect = new WallTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsWallTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new WallTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsWallTTCMutSet[setId] =
            new VersionAndIncarnation<WallTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectWallTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasWallTTCMutSet(setId);

        CheckHasWallTTC(elementId);


      var effect = new WallTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsWallTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new WallTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsWallTTCMutSet[setId] =
            new VersionAndIncarnation<WallTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetBloodTTCMutSetHash(int id, int version, BloodTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BloodTTCMutSetIncarnation GetBloodTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBloodTTCMutSet[id].incarnation;
    }
    public BloodTTCMutSet GetBloodTTCMutSet(int id) {
      return new BloodTTCMutSet(this, id);
    }
    public List<BloodTTCMutSet> AllBloodTTCMutSet() {
      List<BloodTTCMutSet> result = new List<BloodTTCMutSet>(rootIncarnation.incarnationsBloodTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBloodTTCMutSet.Keys) {
        result.Add(new BloodTTCMutSet(this, id));
      }
      return result;
    }
    public bool BloodTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsBloodTTCMutSet.ContainsKey(id);
    }
    public void CheckHasBloodTTCMutSet(BloodTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBloodTTCMutSet(thing.id);
    }
    public void CheckHasBloodTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsBloodTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BloodTTCMutSet}: " + id);
      }
    }
    public BloodTTCMutSet EffectBloodTTCMutSetCreate() {
      return TrustedEffectBloodTTCMutSetCreateWithId(NewId());
    }
    public BloodTTCMutSet TrustedEffectBloodTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BloodTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateBloodTTCMutSet(id, rootIncarnation.version, incarnation);
      return new BloodTTCMutSet(this, id);
    }
    public void EffectInternalCreateBloodTTCMutSet(int id, int incarnationVersion, BloodTTCMutSetIncarnation incarnation) {
      var effect = new BloodTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsBloodTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<BloodTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectBloodTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new BloodTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsBloodTTCMutSet[id];
      rootIncarnation.incarnationsBloodTTCMutSet.Remove(id);
    }

       
    public void EffectBloodTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasBloodTTCMutSet(setId);
      CheckHasBloodTTC(element);

      var effect = new BloodTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBloodTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BloodTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBloodTTCMutSet[setId] =
            new VersionAndIncarnation<BloodTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectBloodTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasBloodTTCMutSet(setId);

        CheckHasBloodTTC(elementId);


      var effect = new BloodTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBloodTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BloodTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBloodTTCMutSet[setId] =
            new VersionAndIncarnation<BloodTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetRocksTTCMutSetHash(int id, int version, RocksTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public RocksTTCMutSetIncarnation GetRocksTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsRocksTTCMutSet[id].incarnation;
    }
    public RocksTTCMutSet GetRocksTTCMutSet(int id) {
      return new RocksTTCMutSet(this, id);
    }
    public List<RocksTTCMutSet> AllRocksTTCMutSet() {
      List<RocksTTCMutSet> result = new List<RocksTTCMutSet>(rootIncarnation.incarnationsRocksTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsRocksTTCMutSet.Keys) {
        result.Add(new RocksTTCMutSet(this, id));
      }
      return result;
    }
    public bool RocksTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsRocksTTCMutSet.ContainsKey(id);
    }
    public void CheckHasRocksTTCMutSet(RocksTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasRocksTTCMutSet(thing.id);
    }
    public void CheckHasRocksTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsRocksTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid RocksTTCMutSet}: " + id);
      }
    }
    public RocksTTCMutSet EffectRocksTTCMutSetCreate() {
      return TrustedEffectRocksTTCMutSetCreateWithId(NewId());
    }
    public RocksTTCMutSet TrustedEffectRocksTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new RocksTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateRocksTTCMutSet(id, rootIncarnation.version, incarnation);
      return new RocksTTCMutSet(this, id);
    }
    public void EffectInternalCreateRocksTTCMutSet(int id, int incarnationVersion, RocksTTCMutSetIncarnation incarnation) {
      var effect = new RocksTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsRocksTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<RocksTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectRocksTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new RocksTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsRocksTTCMutSet[id];
      rootIncarnation.incarnationsRocksTTCMutSet.Remove(id);
    }

       
    public void EffectRocksTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasRocksTTCMutSet(setId);
      CheckHasRocksTTC(element);

      var effect = new RocksTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsRocksTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new RocksTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsRocksTTCMutSet[setId] =
            new VersionAndIncarnation<RocksTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectRocksTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasRocksTTCMutSet(setId);

        CheckHasRocksTTC(elementId);


      var effect = new RocksTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsRocksTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new RocksTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsRocksTTCMutSet[setId] =
            new VersionAndIncarnation<RocksTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetTreeTTCMutSetHash(int id, int version, TreeTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public TreeTTCMutSetIncarnation GetTreeTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsTreeTTCMutSet[id].incarnation;
    }
    public TreeTTCMutSet GetTreeTTCMutSet(int id) {
      return new TreeTTCMutSet(this, id);
    }
    public List<TreeTTCMutSet> AllTreeTTCMutSet() {
      List<TreeTTCMutSet> result = new List<TreeTTCMutSet>(rootIncarnation.incarnationsTreeTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsTreeTTCMutSet.Keys) {
        result.Add(new TreeTTCMutSet(this, id));
      }
      return result;
    }
    public bool TreeTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsTreeTTCMutSet.ContainsKey(id);
    }
    public void CheckHasTreeTTCMutSet(TreeTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasTreeTTCMutSet(thing.id);
    }
    public void CheckHasTreeTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsTreeTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid TreeTTCMutSet}: " + id);
      }
    }
    public TreeTTCMutSet EffectTreeTTCMutSetCreate() {
      return TrustedEffectTreeTTCMutSetCreateWithId(NewId());
    }
    public TreeTTCMutSet TrustedEffectTreeTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new TreeTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateTreeTTCMutSet(id, rootIncarnation.version, incarnation);
      return new TreeTTCMutSet(this, id);
    }
    public void EffectInternalCreateTreeTTCMutSet(int id, int incarnationVersion, TreeTTCMutSetIncarnation incarnation) {
      var effect = new TreeTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsTreeTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<TreeTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectTreeTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new TreeTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsTreeTTCMutSet[id];
      rootIncarnation.incarnationsTreeTTCMutSet.Remove(id);
    }

       
    public void EffectTreeTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasTreeTTCMutSet(setId);
      CheckHasTreeTTC(element);

      var effect = new TreeTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTreeTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new TreeTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTreeTTCMutSet[setId] =
            new VersionAndIncarnation<TreeTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectTreeTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasTreeTTCMutSet(setId);

        CheckHasTreeTTC(elementId);


      var effect = new TreeTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTreeTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new TreeTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTreeTTCMutSet[setId] =
            new VersionAndIncarnation<TreeTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetWaterTTCMutSetHash(int id, int version, WaterTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public WaterTTCMutSetIncarnation GetWaterTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsWaterTTCMutSet[id].incarnation;
    }
    public WaterTTCMutSet GetWaterTTCMutSet(int id) {
      return new WaterTTCMutSet(this, id);
    }
    public List<WaterTTCMutSet> AllWaterTTCMutSet() {
      List<WaterTTCMutSet> result = new List<WaterTTCMutSet>(rootIncarnation.incarnationsWaterTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsWaterTTCMutSet.Keys) {
        result.Add(new WaterTTCMutSet(this, id));
      }
      return result;
    }
    public bool WaterTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsWaterTTCMutSet.ContainsKey(id);
    }
    public void CheckHasWaterTTCMutSet(WaterTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasWaterTTCMutSet(thing.id);
    }
    public void CheckHasWaterTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsWaterTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid WaterTTCMutSet}: " + id);
      }
    }
    public WaterTTCMutSet EffectWaterTTCMutSetCreate() {
      return TrustedEffectWaterTTCMutSetCreateWithId(NewId());
    }
    public WaterTTCMutSet TrustedEffectWaterTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new WaterTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateWaterTTCMutSet(id, rootIncarnation.version, incarnation);
      return new WaterTTCMutSet(this, id);
    }
    public void EffectInternalCreateWaterTTCMutSet(int id, int incarnationVersion, WaterTTCMutSetIncarnation incarnation) {
      var effect = new WaterTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsWaterTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<WaterTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectWaterTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new WaterTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsWaterTTCMutSet[id];
      rootIncarnation.incarnationsWaterTTCMutSet.Remove(id);
    }

       
    public void EffectWaterTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasWaterTTCMutSet(setId);
      CheckHasWaterTTC(element);

      var effect = new WaterTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsWaterTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new WaterTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsWaterTTCMutSet[setId] =
            new VersionAndIncarnation<WaterTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectWaterTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasWaterTTCMutSet(setId);

        CheckHasWaterTTC(elementId);


      var effect = new WaterTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsWaterTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new WaterTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsWaterTTCMutSet[setId] =
            new VersionAndIncarnation<WaterTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetFloorTTCMutSetHash(int id, int version, FloorTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public FloorTTCMutSetIncarnation GetFloorTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsFloorTTCMutSet[id].incarnation;
    }
    public FloorTTCMutSet GetFloorTTCMutSet(int id) {
      return new FloorTTCMutSet(this, id);
    }
    public List<FloorTTCMutSet> AllFloorTTCMutSet() {
      List<FloorTTCMutSet> result = new List<FloorTTCMutSet>(rootIncarnation.incarnationsFloorTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsFloorTTCMutSet.Keys) {
        result.Add(new FloorTTCMutSet(this, id));
      }
      return result;
    }
    public bool FloorTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsFloorTTCMutSet.ContainsKey(id);
    }
    public void CheckHasFloorTTCMutSet(FloorTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasFloorTTCMutSet(thing.id);
    }
    public void CheckHasFloorTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsFloorTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid FloorTTCMutSet}: " + id);
      }
    }
    public FloorTTCMutSet EffectFloorTTCMutSetCreate() {
      return TrustedEffectFloorTTCMutSetCreateWithId(NewId());
    }
    public FloorTTCMutSet TrustedEffectFloorTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new FloorTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateFloorTTCMutSet(id, rootIncarnation.version, incarnation);
      return new FloorTTCMutSet(this, id);
    }
    public void EffectInternalCreateFloorTTCMutSet(int id, int incarnationVersion, FloorTTCMutSetIncarnation incarnation) {
      var effect = new FloorTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsFloorTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<FloorTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectFloorTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new FloorTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsFloorTTCMutSet[id];
      rootIncarnation.incarnationsFloorTTCMutSet.Remove(id);
    }

       
    public void EffectFloorTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasFloorTTCMutSet(setId);
      CheckHasFloorTTC(element);

      var effect = new FloorTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsFloorTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new FloorTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFloorTTCMutSet[setId] =
            new VersionAndIncarnation<FloorTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectFloorTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasFloorTTCMutSet(setId);

        CheckHasFloorTTC(elementId);


      var effect = new FloorTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsFloorTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new FloorTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFloorTTCMutSet[setId] =
            new VersionAndIncarnation<FloorTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetCaveWallTTCMutSetHash(int id, int version, CaveWallTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CaveWallTTCMutSetIncarnation GetCaveWallTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsCaveWallTTCMutSet[id].incarnation;
    }
    public CaveWallTTCMutSet GetCaveWallTTCMutSet(int id) {
      return new CaveWallTTCMutSet(this, id);
    }
    public List<CaveWallTTCMutSet> AllCaveWallTTCMutSet() {
      List<CaveWallTTCMutSet> result = new List<CaveWallTTCMutSet>(rootIncarnation.incarnationsCaveWallTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsCaveWallTTCMutSet.Keys) {
        result.Add(new CaveWallTTCMutSet(this, id));
      }
      return result;
    }
    public bool CaveWallTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsCaveWallTTCMutSet.ContainsKey(id);
    }
    public void CheckHasCaveWallTTCMutSet(CaveWallTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCaveWallTTCMutSet(thing.id);
    }
    public void CheckHasCaveWallTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsCaveWallTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid CaveWallTTCMutSet}: " + id);
      }
    }
    public CaveWallTTCMutSet EffectCaveWallTTCMutSetCreate() {
      return TrustedEffectCaveWallTTCMutSetCreateWithId(NewId());
    }
    public CaveWallTTCMutSet TrustedEffectCaveWallTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new CaveWallTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateCaveWallTTCMutSet(id, rootIncarnation.version, incarnation);
      return new CaveWallTTCMutSet(this, id);
    }
    public void EffectInternalCreateCaveWallTTCMutSet(int id, int incarnationVersion, CaveWallTTCMutSetIncarnation incarnation) {
      var effect = new CaveWallTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsCaveWallTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<CaveWallTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectCaveWallTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new CaveWallTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsCaveWallTTCMutSet[id];
      rootIncarnation.incarnationsCaveWallTTCMutSet.Remove(id);
    }

       
    public void EffectCaveWallTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasCaveWallTTCMutSet(setId);
      CheckHasCaveWallTTC(element);

      var effect = new CaveWallTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCaveWallTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new CaveWallTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCaveWallTTCMutSet[setId] =
            new VersionAndIncarnation<CaveWallTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectCaveWallTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasCaveWallTTCMutSet(setId);

        CheckHasCaveWallTTC(elementId);


      var effect = new CaveWallTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCaveWallTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new CaveWallTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCaveWallTTCMutSet[setId] =
            new VersionAndIncarnation<CaveWallTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetCaveTTCMutSetHash(int id, int version, CaveTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CaveTTCMutSetIncarnation GetCaveTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsCaveTTCMutSet[id].incarnation;
    }
    public CaveTTCMutSet GetCaveTTCMutSet(int id) {
      return new CaveTTCMutSet(this, id);
    }
    public List<CaveTTCMutSet> AllCaveTTCMutSet() {
      List<CaveTTCMutSet> result = new List<CaveTTCMutSet>(rootIncarnation.incarnationsCaveTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsCaveTTCMutSet.Keys) {
        result.Add(new CaveTTCMutSet(this, id));
      }
      return result;
    }
    public bool CaveTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsCaveTTCMutSet.ContainsKey(id);
    }
    public void CheckHasCaveTTCMutSet(CaveTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCaveTTCMutSet(thing.id);
    }
    public void CheckHasCaveTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsCaveTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid CaveTTCMutSet}: " + id);
      }
    }
    public CaveTTCMutSet EffectCaveTTCMutSetCreate() {
      return TrustedEffectCaveTTCMutSetCreateWithId(NewId());
    }
    public CaveTTCMutSet TrustedEffectCaveTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new CaveTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateCaveTTCMutSet(id, rootIncarnation.version, incarnation);
      return new CaveTTCMutSet(this, id);
    }
    public void EffectInternalCreateCaveTTCMutSet(int id, int incarnationVersion, CaveTTCMutSetIncarnation incarnation) {
      var effect = new CaveTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsCaveTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<CaveTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectCaveTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new CaveTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsCaveTTCMutSet[id];
      rootIncarnation.incarnationsCaveTTCMutSet.Remove(id);
    }

       
    public void EffectCaveTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasCaveTTCMutSet(setId);
      CheckHasCaveTTC(element);

      var effect = new CaveTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCaveTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new CaveTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCaveTTCMutSet[setId] =
            new VersionAndIncarnation<CaveTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectCaveTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasCaveTTCMutSet(setId);

        CheckHasCaveTTC(elementId);


      var effect = new CaveTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCaveTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new CaveTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCaveTTCMutSet[setId] =
            new VersionAndIncarnation<CaveTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetFallsTTCMutSetHash(int id, int version, FallsTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public FallsTTCMutSetIncarnation GetFallsTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsFallsTTCMutSet[id].incarnation;
    }
    public FallsTTCMutSet GetFallsTTCMutSet(int id) {
      return new FallsTTCMutSet(this, id);
    }
    public List<FallsTTCMutSet> AllFallsTTCMutSet() {
      List<FallsTTCMutSet> result = new List<FallsTTCMutSet>(rootIncarnation.incarnationsFallsTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsFallsTTCMutSet.Keys) {
        result.Add(new FallsTTCMutSet(this, id));
      }
      return result;
    }
    public bool FallsTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsFallsTTCMutSet.ContainsKey(id);
    }
    public void CheckHasFallsTTCMutSet(FallsTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasFallsTTCMutSet(thing.id);
    }
    public void CheckHasFallsTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsFallsTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid FallsTTCMutSet}: " + id);
      }
    }
    public FallsTTCMutSet EffectFallsTTCMutSetCreate() {
      return TrustedEffectFallsTTCMutSetCreateWithId(NewId());
    }
    public FallsTTCMutSet TrustedEffectFallsTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new FallsTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateFallsTTCMutSet(id, rootIncarnation.version, incarnation);
      return new FallsTTCMutSet(this, id);
    }
    public void EffectInternalCreateFallsTTCMutSet(int id, int incarnationVersion, FallsTTCMutSetIncarnation incarnation) {
      var effect = new FallsTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsFallsTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<FallsTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectFallsTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new FallsTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsFallsTTCMutSet[id];
      rootIncarnation.incarnationsFallsTTCMutSet.Remove(id);
    }

       
    public void EffectFallsTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasFallsTTCMutSet(setId);
      CheckHasFallsTTC(element);

      var effect = new FallsTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsFallsTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new FallsTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFallsTTCMutSet[setId] =
            new VersionAndIncarnation<FallsTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectFallsTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasFallsTTCMutSet(setId);

        CheckHasFallsTTC(elementId);


      var effect = new FallsTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsFallsTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new FallsTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFallsTTCMutSet[setId] =
            new VersionAndIncarnation<FallsTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetFireTTCMutSetHash(int id, int version, FireTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public FireTTCMutSetIncarnation GetFireTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsFireTTCMutSet[id].incarnation;
    }
    public FireTTCMutSet GetFireTTCMutSet(int id) {
      return new FireTTCMutSet(this, id);
    }
    public List<FireTTCMutSet> AllFireTTCMutSet() {
      List<FireTTCMutSet> result = new List<FireTTCMutSet>(rootIncarnation.incarnationsFireTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsFireTTCMutSet.Keys) {
        result.Add(new FireTTCMutSet(this, id));
      }
      return result;
    }
    public bool FireTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsFireTTCMutSet.ContainsKey(id);
    }
    public void CheckHasFireTTCMutSet(FireTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasFireTTCMutSet(thing.id);
    }
    public void CheckHasFireTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsFireTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid FireTTCMutSet}: " + id);
      }
    }
    public FireTTCMutSet EffectFireTTCMutSetCreate() {
      return TrustedEffectFireTTCMutSetCreateWithId(NewId());
    }
    public FireTTCMutSet TrustedEffectFireTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new FireTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateFireTTCMutSet(id, rootIncarnation.version, incarnation);
      return new FireTTCMutSet(this, id);
    }
    public void EffectInternalCreateFireTTCMutSet(int id, int incarnationVersion, FireTTCMutSetIncarnation incarnation) {
      var effect = new FireTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsFireTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<FireTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectFireTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new FireTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsFireTTCMutSet[id];
      rootIncarnation.incarnationsFireTTCMutSet.Remove(id);
    }

       
    public void EffectFireTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasFireTTCMutSet(setId);
      CheckHasFireTTC(element);

      var effect = new FireTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsFireTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new FireTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFireTTCMutSet[setId] =
            new VersionAndIncarnation<FireTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectFireTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasFireTTCMutSet(setId);

        CheckHasFireTTC(elementId);


      var effect = new FireTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsFireTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new FireTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFireTTCMutSet[setId] =
            new VersionAndIncarnation<FireTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetObsidianFloorTTCMutSetHash(int id, int version, ObsidianFloorTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ObsidianFloorTTCMutSetIncarnation GetObsidianFloorTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsObsidianFloorTTCMutSet[id].incarnation;
    }
    public ObsidianFloorTTCMutSet GetObsidianFloorTTCMutSet(int id) {
      return new ObsidianFloorTTCMutSet(this, id);
    }
    public List<ObsidianFloorTTCMutSet> AllObsidianFloorTTCMutSet() {
      List<ObsidianFloorTTCMutSet> result = new List<ObsidianFloorTTCMutSet>(rootIncarnation.incarnationsObsidianFloorTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsObsidianFloorTTCMutSet.Keys) {
        result.Add(new ObsidianFloorTTCMutSet(this, id));
      }
      return result;
    }
    public bool ObsidianFloorTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsObsidianFloorTTCMutSet.ContainsKey(id);
    }
    public void CheckHasObsidianFloorTTCMutSet(ObsidianFloorTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasObsidianFloorTTCMutSet(thing.id);
    }
    public void CheckHasObsidianFloorTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsObsidianFloorTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ObsidianFloorTTCMutSet}: " + id);
      }
    }
    public ObsidianFloorTTCMutSet EffectObsidianFloorTTCMutSetCreate() {
      return TrustedEffectObsidianFloorTTCMutSetCreateWithId(NewId());
    }
    public ObsidianFloorTTCMutSet TrustedEffectObsidianFloorTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new ObsidianFloorTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateObsidianFloorTTCMutSet(id, rootIncarnation.version, incarnation);
      return new ObsidianFloorTTCMutSet(this, id);
    }
    public void EffectInternalCreateObsidianFloorTTCMutSet(int id, int incarnationVersion, ObsidianFloorTTCMutSetIncarnation incarnation) {
      var effect = new ObsidianFloorTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsObsidianFloorTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<ObsidianFloorTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectObsidianFloorTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new ObsidianFloorTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsObsidianFloorTTCMutSet[id];
      rootIncarnation.incarnationsObsidianFloorTTCMutSet.Remove(id);
    }

       
    public void EffectObsidianFloorTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasObsidianFloorTTCMutSet(setId);
      CheckHasObsidianFloorTTC(element);

      var effect = new ObsidianFloorTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsObsidianFloorTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new ObsidianFloorTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsObsidianFloorTTCMutSet[setId] =
            new VersionAndIncarnation<ObsidianFloorTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectObsidianFloorTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasObsidianFloorTTCMutSet(setId);

        CheckHasObsidianFloorTTC(elementId);


      var effect = new ObsidianFloorTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsObsidianFloorTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ObsidianFloorTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsObsidianFloorTTCMutSet[setId] =
            new VersionAndIncarnation<ObsidianFloorTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetMagmaTTCMutSetHash(int id, int version, MagmaTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public MagmaTTCMutSetIncarnation GetMagmaTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsMagmaTTCMutSet[id].incarnation;
    }
    public MagmaTTCMutSet GetMagmaTTCMutSet(int id) {
      return new MagmaTTCMutSet(this, id);
    }
    public List<MagmaTTCMutSet> AllMagmaTTCMutSet() {
      List<MagmaTTCMutSet> result = new List<MagmaTTCMutSet>(rootIncarnation.incarnationsMagmaTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsMagmaTTCMutSet.Keys) {
        result.Add(new MagmaTTCMutSet(this, id));
      }
      return result;
    }
    public bool MagmaTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsMagmaTTCMutSet.ContainsKey(id);
    }
    public void CheckHasMagmaTTCMutSet(MagmaTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasMagmaTTCMutSet(thing.id);
    }
    public void CheckHasMagmaTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsMagmaTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid MagmaTTCMutSet}: " + id);
      }
    }
    public MagmaTTCMutSet EffectMagmaTTCMutSetCreate() {
      return TrustedEffectMagmaTTCMutSetCreateWithId(NewId());
    }
    public MagmaTTCMutSet TrustedEffectMagmaTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new MagmaTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateMagmaTTCMutSet(id, rootIncarnation.version, incarnation);
      return new MagmaTTCMutSet(this, id);
    }
    public void EffectInternalCreateMagmaTTCMutSet(int id, int incarnationVersion, MagmaTTCMutSetIncarnation incarnation) {
      var effect = new MagmaTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsMagmaTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<MagmaTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectMagmaTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new MagmaTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsMagmaTTCMutSet[id];
      rootIncarnation.incarnationsMagmaTTCMutSet.Remove(id);
    }

       
    public void EffectMagmaTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasMagmaTTCMutSet(setId);
      CheckHasMagmaTTC(element);

      var effect = new MagmaTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsMagmaTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new MagmaTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMagmaTTCMutSet[setId] =
            new VersionAndIncarnation<MagmaTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectMagmaTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasMagmaTTCMutSet(setId);

        CheckHasMagmaTTC(elementId);


      var effect = new MagmaTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsMagmaTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new MagmaTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMagmaTTCMutSet[setId] =
            new VersionAndIncarnation<MagmaTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetCliffTTCMutSetHash(int id, int version, CliffTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CliffTTCMutSetIncarnation GetCliffTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsCliffTTCMutSet[id].incarnation;
    }
    public CliffTTCMutSet GetCliffTTCMutSet(int id) {
      return new CliffTTCMutSet(this, id);
    }
    public List<CliffTTCMutSet> AllCliffTTCMutSet() {
      List<CliffTTCMutSet> result = new List<CliffTTCMutSet>(rootIncarnation.incarnationsCliffTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsCliffTTCMutSet.Keys) {
        result.Add(new CliffTTCMutSet(this, id));
      }
      return result;
    }
    public bool CliffTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsCliffTTCMutSet.ContainsKey(id);
    }
    public void CheckHasCliffTTCMutSet(CliffTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCliffTTCMutSet(thing.id);
    }
    public void CheckHasCliffTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsCliffTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid CliffTTCMutSet}: " + id);
      }
    }
    public CliffTTCMutSet EffectCliffTTCMutSetCreate() {
      return TrustedEffectCliffTTCMutSetCreateWithId(NewId());
    }
    public CliffTTCMutSet TrustedEffectCliffTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new CliffTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateCliffTTCMutSet(id, rootIncarnation.version, incarnation);
      return new CliffTTCMutSet(this, id);
    }
    public void EffectInternalCreateCliffTTCMutSet(int id, int incarnationVersion, CliffTTCMutSetIncarnation incarnation) {
      var effect = new CliffTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsCliffTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<CliffTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectCliffTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new CliffTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsCliffTTCMutSet[id];
      rootIncarnation.incarnationsCliffTTCMutSet.Remove(id);
    }

       
    public void EffectCliffTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasCliffTTCMutSet(setId);
      CheckHasCliffTTC(element);

      var effect = new CliffTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCliffTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new CliffTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCliffTTCMutSet[setId] =
            new VersionAndIncarnation<CliffTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectCliffTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasCliffTTCMutSet(setId);

        CheckHasCliffTTC(elementId);


      var effect = new CliffTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCliffTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new CliffTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCliffTTCMutSet[setId] =
            new VersionAndIncarnation<CliffTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetRavaNestTTCMutSetHash(int id, int version, RavaNestTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public RavaNestTTCMutSetIncarnation GetRavaNestTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsRavaNestTTCMutSet[id].incarnation;
    }
    public RavaNestTTCMutSet GetRavaNestTTCMutSet(int id) {
      return new RavaNestTTCMutSet(this, id);
    }
    public List<RavaNestTTCMutSet> AllRavaNestTTCMutSet() {
      List<RavaNestTTCMutSet> result = new List<RavaNestTTCMutSet>(rootIncarnation.incarnationsRavaNestTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsRavaNestTTCMutSet.Keys) {
        result.Add(new RavaNestTTCMutSet(this, id));
      }
      return result;
    }
    public bool RavaNestTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsRavaNestTTCMutSet.ContainsKey(id);
    }
    public void CheckHasRavaNestTTCMutSet(RavaNestTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasRavaNestTTCMutSet(thing.id);
    }
    public void CheckHasRavaNestTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsRavaNestTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid RavaNestTTCMutSet}: " + id);
      }
    }
    public RavaNestTTCMutSet EffectRavaNestTTCMutSetCreate() {
      return TrustedEffectRavaNestTTCMutSetCreateWithId(NewId());
    }
    public RavaNestTTCMutSet TrustedEffectRavaNestTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new RavaNestTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateRavaNestTTCMutSet(id, rootIncarnation.version, incarnation);
      return new RavaNestTTCMutSet(this, id);
    }
    public void EffectInternalCreateRavaNestTTCMutSet(int id, int incarnationVersion, RavaNestTTCMutSetIncarnation incarnation) {
      var effect = new RavaNestTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsRavaNestTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<RavaNestTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectRavaNestTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new RavaNestTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsRavaNestTTCMutSet[id];
      rootIncarnation.incarnationsRavaNestTTCMutSet.Remove(id);
    }

       
    public void EffectRavaNestTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasRavaNestTTCMutSet(setId);
      CheckHasRavaNestTTC(element);

      var effect = new RavaNestTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsRavaNestTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new RavaNestTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsRavaNestTTCMutSet[setId] =
            new VersionAndIncarnation<RavaNestTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectRavaNestTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasRavaNestTTCMutSet(setId);

        CheckHasRavaNestTTC(elementId);


      var effect = new RavaNestTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsRavaNestTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new RavaNestTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsRavaNestTTCMutSet[setId] =
            new VersionAndIncarnation<RavaNestTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetCliffLandingTTCMutSetHash(int id, int version, CliffLandingTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CliffLandingTTCMutSetIncarnation GetCliffLandingTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsCliffLandingTTCMutSet[id].incarnation;
    }
    public CliffLandingTTCMutSet GetCliffLandingTTCMutSet(int id) {
      return new CliffLandingTTCMutSet(this, id);
    }
    public List<CliffLandingTTCMutSet> AllCliffLandingTTCMutSet() {
      List<CliffLandingTTCMutSet> result = new List<CliffLandingTTCMutSet>(rootIncarnation.incarnationsCliffLandingTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsCliffLandingTTCMutSet.Keys) {
        result.Add(new CliffLandingTTCMutSet(this, id));
      }
      return result;
    }
    public bool CliffLandingTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsCliffLandingTTCMutSet.ContainsKey(id);
    }
    public void CheckHasCliffLandingTTCMutSet(CliffLandingTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCliffLandingTTCMutSet(thing.id);
    }
    public void CheckHasCliffLandingTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsCliffLandingTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid CliffLandingTTCMutSet}: " + id);
      }
    }
    public CliffLandingTTCMutSet EffectCliffLandingTTCMutSetCreate() {
      return TrustedEffectCliffLandingTTCMutSetCreateWithId(NewId());
    }
    public CliffLandingTTCMutSet TrustedEffectCliffLandingTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new CliffLandingTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateCliffLandingTTCMutSet(id, rootIncarnation.version, incarnation);
      return new CliffLandingTTCMutSet(this, id);
    }
    public void EffectInternalCreateCliffLandingTTCMutSet(int id, int incarnationVersion, CliffLandingTTCMutSetIncarnation incarnation) {
      var effect = new CliffLandingTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsCliffLandingTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<CliffLandingTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectCliffLandingTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new CliffLandingTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsCliffLandingTTCMutSet[id];
      rootIncarnation.incarnationsCliffLandingTTCMutSet.Remove(id);
    }

       
    public void EffectCliffLandingTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasCliffLandingTTCMutSet(setId);
      CheckHasCliffLandingTTC(element);

      var effect = new CliffLandingTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCliffLandingTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new CliffLandingTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCliffLandingTTCMutSet[setId] =
            new VersionAndIncarnation<CliffLandingTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectCliffLandingTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasCliffLandingTTCMutSet(setId);

        CheckHasCliffLandingTTC(elementId);


      var effect = new CliffLandingTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCliffLandingTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new CliffLandingTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCliffLandingTTCMutSet[setId] =
            new VersionAndIncarnation<CliffLandingTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetStoneTTCMutSetHash(int id, int version, StoneTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public StoneTTCMutSetIncarnation GetStoneTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsStoneTTCMutSet[id].incarnation;
    }
    public StoneTTCMutSet GetStoneTTCMutSet(int id) {
      return new StoneTTCMutSet(this, id);
    }
    public List<StoneTTCMutSet> AllStoneTTCMutSet() {
      List<StoneTTCMutSet> result = new List<StoneTTCMutSet>(rootIncarnation.incarnationsStoneTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsStoneTTCMutSet.Keys) {
        result.Add(new StoneTTCMutSet(this, id));
      }
      return result;
    }
    public bool StoneTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsStoneTTCMutSet.ContainsKey(id);
    }
    public void CheckHasStoneTTCMutSet(StoneTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasStoneTTCMutSet(thing.id);
    }
    public void CheckHasStoneTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsStoneTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid StoneTTCMutSet}: " + id);
      }
    }
    public StoneTTCMutSet EffectStoneTTCMutSetCreate() {
      return TrustedEffectStoneTTCMutSetCreateWithId(NewId());
    }
    public StoneTTCMutSet TrustedEffectStoneTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new StoneTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateStoneTTCMutSet(id, rootIncarnation.version, incarnation);
      return new StoneTTCMutSet(this, id);
    }
    public void EffectInternalCreateStoneTTCMutSet(int id, int incarnationVersion, StoneTTCMutSetIncarnation incarnation) {
      var effect = new StoneTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsStoneTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<StoneTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectStoneTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new StoneTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsStoneTTCMutSet[id];
      rootIncarnation.incarnationsStoneTTCMutSet.Remove(id);
    }

       
    public void EffectStoneTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasStoneTTCMutSet(setId);
      CheckHasStoneTTC(element);

      var effect = new StoneTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsStoneTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new StoneTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsStoneTTCMutSet[setId] =
            new VersionAndIncarnation<StoneTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectStoneTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasStoneTTCMutSet(setId);

        CheckHasStoneTTC(elementId);


      var effect = new StoneTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsStoneTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new StoneTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsStoneTTCMutSet[setId] =
            new VersionAndIncarnation<StoneTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetGrassTTCMutSetHash(int id, int version, GrassTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public GrassTTCMutSetIncarnation GetGrassTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsGrassTTCMutSet[id].incarnation;
    }
    public GrassTTCMutSet GetGrassTTCMutSet(int id) {
      return new GrassTTCMutSet(this, id);
    }
    public List<GrassTTCMutSet> AllGrassTTCMutSet() {
      List<GrassTTCMutSet> result = new List<GrassTTCMutSet>(rootIncarnation.incarnationsGrassTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsGrassTTCMutSet.Keys) {
        result.Add(new GrassTTCMutSet(this, id));
      }
      return result;
    }
    public bool GrassTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsGrassTTCMutSet.ContainsKey(id);
    }
    public void CheckHasGrassTTCMutSet(GrassTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasGrassTTCMutSet(thing.id);
    }
    public void CheckHasGrassTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsGrassTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid GrassTTCMutSet}: " + id);
      }
    }
    public GrassTTCMutSet EffectGrassTTCMutSetCreate() {
      return TrustedEffectGrassTTCMutSetCreateWithId(NewId());
    }
    public GrassTTCMutSet TrustedEffectGrassTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new GrassTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateGrassTTCMutSet(id, rootIncarnation.version, incarnation);
      return new GrassTTCMutSet(this, id);
    }
    public void EffectInternalCreateGrassTTCMutSet(int id, int incarnationVersion, GrassTTCMutSetIncarnation incarnation) {
      var effect = new GrassTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsGrassTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<GrassTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectGrassTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new GrassTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsGrassTTCMutSet[id];
      rootIncarnation.incarnationsGrassTTCMutSet.Remove(id);
    }

       
    public void EffectGrassTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasGrassTTCMutSet(setId);
      CheckHasGrassTTC(element);

      var effect = new GrassTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsGrassTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new GrassTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsGrassTTCMutSet[setId] =
            new VersionAndIncarnation<GrassTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectGrassTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasGrassTTCMutSet(setId);

        CheckHasGrassTTC(elementId);


      var effect = new GrassTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsGrassTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new GrassTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsGrassTTCMutSet[setId] =
            new VersionAndIncarnation<GrassTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetIncendianFallsLevelLinkerTTCMutSetHash(int id, int version, IncendianFallsLevelLinkerTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public IncendianFallsLevelLinkerTTCMutSetIncarnation GetIncendianFallsLevelLinkerTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet[id].incarnation;
    }
    public IncendianFallsLevelLinkerTTCMutSet GetIncendianFallsLevelLinkerTTCMutSet(int id) {
      return new IncendianFallsLevelLinkerTTCMutSet(this, id);
    }
    public List<IncendianFallsLevelLinkerTTCMutSet> AllIncendianFallsLevelLinkerTTCMutSet() {
      List<IncendianFallsLevelLinkerTTCMutSet> result = new List<IncendianFallsLevelLinkerTTCMutSet>(rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet.Keys) {
        result.Add(new IncendianFallsLevelLinkerTTCMutSet(this, id));
      }
      return result;
    }
    public bool IncendianFallsLevelLinkerTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet.ContainsKey(id);
    }
    public void CheckHasIncendianFallsLevelLinkerTTCMutSet(IncendianFallsLevelLinkerTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasIncendianFallsLevelLinkerTTCMutSet(thing.id);
    }
    public void CheckHasIncendianFallsLevelLinkerTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid IncendianFallsLevelLinkerTTCMutSet}: " + id);
      }
    }
    public IncendianFallsLevelLinkerTTCMutSet EffectIncendianFallsLevelLinkerTTCMutSetCreate() {
      return TrustedEffectIncendianFallsLevelLinkerTTCMutSetCreateWithId(NewId());
    }
    public IncendianFallsLevelLinkerTTCMutSet TrustedEffectIncendianFallsLevelLinkerTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new IncendianFallsLevelLinkerTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateIncendianFallsLevelLinkerTTCMutSet(id, rootIncarnation.version, incarnation);
      return new IncendianFallsLevelLinkerTTCMutSet(this, id);
    }
    public void EffectInternalCreateIncendianFallsLevelLinkerTTCMutSet(int id, int incarnationVersion, IncendianFallsLevelLinkerTTCMutSetIncarnation incarnation) {
      var effect = new IncendianFallsLevelLinkerTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<IncendianFallsLevelLinkerTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectIncendianFallsLevelLinkerTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new IncendianFallsLevelLinkerTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet[id];
      rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet.Remove(id);
    }

       
    public void EffectIncendianFallsLevelLinkerTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasIncendianFallsLevelLinkerTTCMutSet(setId);
      CheckHasIncendianFallsLevelLinkerTTC(element);

      var effect = new IncendianFallsLevelLinkerTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new IncendianFallsLevelLinkerTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet[setId] =
            new VersionAndIncarnation<IncendianFallsLevelLinkerTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectIncendianFallsLevelLinkerTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasIncendianFallsLevelLinkerTTCMutSet(setId);

        CheckHasIncendianFallsLevelLinkerTTC(elementId);


      var effect = new IncendianFallsLevelLinkerTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new IncendianFallsLevelLinkerTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet[setId] =
            new VersionAndIncarnation<IncendianFallsLevelLinkerTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetEmberDeepLevelLinkerTTCMutSetHash(int id, int version, EmberDeepLevelLinkerTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public EmberDeepLevelLinkerTTCMutSetIncarnation GetEmberDeepLevelLinkerTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet[id].incarnation;
    }
    public EmberDeepLevelLinkerTTCMutSet GetEmberDeepLevelLinkerTTCMutSet(int id) {
      return new EmberDeepLevelLinkerTTCMutSet(this, id);
    }
    public List<EmberDeepLevelLinkerTTCMutSet> AllEmberDeepLevelLinkerTTCMutSet() {
      List<EmberDeepLevelLinkerTTCMutSet> result = new List<EmberDeepLevelLinkerTTCMutSet>(rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet.Keys) {
        result.Add(new EmberDeepLevelLinkerTTCMutSet(this, id));
      }
      return result;
    }
    public bool EmberDeepLevelLinkerTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet.ContainsKey(id);
    }
    public void CheckHasEmberDeepLevelLinkerTTCMutSet(EmberDeepLevelLinkerTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasEmberDeepLevelLinkerTTCMutSet(thing.id);
    }
    public void CheckHasEmberDeepLevelLinkerTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid EmberDeepLevelLinkerTTCMutSet}: " + id);
      }
    }
    public EmberDeepLevelLinkerTTCMutSet EffectEmberDeepLevelLinkerTTCMutSetCreate() {
      return TrustedEffectEmberDeepLevelLinkerTTCMutSetCreateWithId(NewId());
    }
    public EmberDeepLevelLinkerTTCMutSet TrustedEffectEmberDeepLevelLinkerTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new EmberDeepLevelLinkerTTCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateEmberDeepLevelLinkerTTCMutSet(id, rootIncarnation.version, incarnation);
      return new EmberDeepLevelLinkerTTCMutSet(this, id);
    }
    public void EffectInternalCreateEmberDeepLevelLinkerTTCMutSet(int id, int incarnationVersion, EmberDeepLevelLinkerTTCMutSetIncarnation incarnation) {
      var effect = new EmberDeepLevelLinkerTTCMutSetCreateEffect(id);
      rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<EmberDeepLevelLinkerTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectEmberDeepLevelLinkerTTCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new EmberDeepLevelLinkerTTCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet[id];
      rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet.Remove(id);
    }

       
    public void EffectEmberDeepLevelLinkerTTCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasEmberDeepLevelLinkerTTCMutSet(setId);
      CheckHasEmberDeepLevelLinkerTTC(element);

      var effect = new EmberDeepLevelLinkerTTCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new EmberDeepLevelLinkerTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet[setId] =
            new VersionAndIncarnation<EmberDeepLevelLinkerTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectEmberDeepLevelLinkerTTCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasEmberDeepLevelLinkerTTCMutSet(setId);

        CheckHasEmberDeepLevelLinkerTTC(elementId);


      var effect = new EmberDeepLevelLinkerTTCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new EmberDeepLevelLinkerTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet[setId] =
            new VersionAndIncarnation<EmberDeepLevelLinkerTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetTutorialDefyCounterUCMutSetHash(int id, int version, TutorialDefyCounterUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public TutorialDefyCounterUCMutSetIncarnation GetTutorialDefyCounterUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsTutorialDefyCounterUCMutSet[id].incarnation;
    }
    public TutorialDefyCounterUCMutSet GetTutorialDefyCounterUCMutSet(int id) {
      return new TutorialDefyCounterUCMutSet(this, id);
    }
    public List<TutorialDefyCounterUCMutSet> AllTutorialDefyCounterUCMutSet() {
      List<TutorialDefyCounterUCMutSet> result = new List<TutorialDefyCounterUCMutSet>(rootIncarnation.incarnationsTutorialDefyCounterUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsTutorialDefyCounterUCMutSet.Keys) {
        result.Add(new TutorialDefyCounterUCMutSet(this, id));
      }
      return result;
    }
    public bool TutorialDefyCounterUCMutSetExists(int id) {
      return rootIncarnation.incarnationsTutorialDefyCounterUCMutSet.ContainsKey(id);
    }
    public void CheckHasTutorialDefyCounterUCMutSet(TutorialDefyCounterUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasTutorialDefyCounterUCMutSet(thing.id);
    }
    public void CheckHasTutorialDefyCounterUCMutSet(int id) {
      if (!rootIncarnation.incarnationsTutorialDefyCounterUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid TutorialDefyCounterUCMutSet}: " + id);
      }
    }
    public TutorialDefyCounterUCMutSet EffectTutorialDefyCounterUCMutSetCreate() {
      return TrustedEffectTutorialDefyCounterUCMutSetCreateWithId(NewId());
    }
    public TutorialDefyCounterUCMutSet TrustedEffectTutorialDefyCounterUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new TutorialDefyCounterUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateTutorialDefyCounterUCMutSet(id, rootIncarnation.version, incarnation);
      return new TutorialDefyCounterUCMutSet(this, id);
    }
    public void EffectInternalCreateTutorialDefyCounterUCMutSet(int id, int incarnationVersion, TutorialDefyCounterUCMutSetIncarnation incarnation) {
      var effect = new TutorialDefyCounterUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsTutorialDefyCounterUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<TutorialDefyCounterUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectTutorialDefyCounterUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new TutorialDefyCounterUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsTutorialDefyCounterUCMutSet[id];
      rootIncarnation.incarnationsTutorialDefyCounterUCMutSet.Remove(id);
    }

       
    public void EffectTutorialDefyCounterUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasTutorialDefyCounterUCMutSet(setId);
      CheckHasTutorialDefyCounterUC(element);

      var effect = new TutorialDefyCounterUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTutorialDefyCounterUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new TutorialDefyCounterUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTutorialDefyCounterUCMutSet[setId] =
            new VersionAndIncarnation<TutorialDefyCounterUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectTutorialDefyCounterUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasTutorialDefyCounterUCMutSet(setId);

        CheckHasTutorialDefyCounterUC(elementId);


      var effect = new TutorialDefyCounterUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTutorialDefyCounterUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new TutorialDefyCounterUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTutorialDefyCounterUCMutSet[setId] =
            new VersionAndIncarnation<TutorialDefyCounterUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetLightningChargingUCMutSetHash(int id, int version, LightningChargingUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public LightningChargingUCMutSetIncarnation GetLightningChargingUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsLightningChargingUCMutSet[id].incarnation;
    }
    public LightningChargingUCMutSet GetLightningChargingUCMutSet(int id) {
      return new LightningChargingUCMutSet(this, id);
    }
    public List<LightningChargingUCMutSet> AllLightningChargingUCMutSet() {
      List<LightningChargingUCMutSet> result = new List<LightningChargingUCMutSet>(rootIncarnation.incarnationsLightningChargingUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsLightningChargingUCMutSet.Keys) {
        result.Add(new LightningChargingUCMutSet(this, id));
      }
      return result;
    }
    public bool LightningChargingUCMutSetExists(int id) {
      return rootIncarnation.incarnationsLightningChargingUCMutSet.ContainsKey(id);
    }
    public void CheckHasLightningChargingUCMutSet(LightningChargingUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasLightningChargingUCMutSet(thing.id);
    }
    public void CheckHasLightningChargingUCMutSet(int id) {
      if (!rootIncarnation.incarnationsLightningChargingUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid LightningChargingUCMutSet}: " + id);
      }
    }
    public LightningChargingUCMutSet EffectLightningChargingUCMutSetCreate() {
      return TrustedEffectLightningChargingUCMutSetCreateWithId(NewId());
    }
    public LightningChargingUCMutSet TrustedEffectLightningChargingUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new LightningChargingUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateLightningChargingUCMutSet(id, rootIncarnation.version, incarnation);
      return new LightningChargingUCMutSet(this, id);
    }
    public void EffectInternalCreateLightningChargingUCMutSet(int id, int incarnationVersion, LightningChargingUCMutSetIncarnation incarnation) {
      var effect = new LightningChargingUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsLightningChargingUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<LightningChargingUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectLightningChargingUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new LightningChargingUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsLightningChargingUCMutSet[id];
      rootIncarnation.incarnationsLightningChargingUCMutSet.Remove(id);
    }

       
    public void EffectLightningChargingUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasLightningChargingUCMutSet(setId);
      CheckHasLightningChargingUC(element);

      var effect = new LightningChargingUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsLightningChargingUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new LightningChargingUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLightningChargingUCMutSet[setId] =
            new VersionAndIncarnation<LightningChargingUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectLightningChargingUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasLightningChargingUCMutSet(setId);

        CheckHasLightningChargingUC(elementId);


      var effect = new LightningChargingUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsLightningChargingUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new LightningChargingUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLightningChargingUCMutSet[setId] =
            new VersionAndIncarnation<LightningChargingUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetWanderAICapabilityUCMutSetHash(int id, int version, WanderAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public WanderAICapabilityUCMutSetIncarnation GetWanderAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsWanderAICapabilityUCMutSet[id].incarnation;
    }
    public WanderAICapabilityUCMutSet GetWanderAICapabilityUCMutSet(int id) {
      return new WanderAICapabilityUCMutSet(this, id);
    }
    public List<WanderAICapabilityUCMutSet> AllWanderAICapabilityUCMutSet() {
      List<WanderAICapabilityUCMutSet> result = new List<WanderAICapabilityUCMutSet>(rootIncarnation.incarnationsWanderAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsWanderAICapabilityUCMutSet.Keys) {
        result.Add(new WanderAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool WanderAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsWanderAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasWanderAICapabilityUCMutSet(WanderAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasWanderAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasWanderAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsWanderAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid WanderAICapabilityUCMutSet}: " + id);
      }
    }
    public WanderAICapabilityUCMutSet EffectWanderAICapabilityUCMutSetCreate() {
      return TrustedEffectWanderAICapabilityUCMutSetCreateWithId(NewId());
    }
    public WanderAICapabilityUCMutSet TrustedEffectWanderAICapabilityUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new WanderAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateWanderAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      return new WanderAICapabilityUCMutSet(this, id);
    }
    public void EffectInternalCreateWanderAICapabilityUCMutSet(int id, int incarnationVersion, WanderAICapabilityUCMutSetIncarnation incarnation) {
      var effect = new WanderAICapabilityUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsWanderAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<WanderAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectWanderAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new WanderAICapabilityUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsWanderAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsWanderAICapabilityUCMutSet.Remove(id);
    }

       
    public void EffectWanderAICapabilityUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasWanderAICapabilityUCMutSet(setId);
      CheckHasWanderAICapabilityUC(element);

      var effect = new WanderAICapabilityUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsWanderAICapabilityUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new WanderAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsWanderAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<WanderAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectWanderAICapabilityUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasWanderAICapabilityUCMutSet(setId);

        CheckHasWanderAICapabilityUC(elementId);


      var effect = new WanderAICapabilityUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsWanderAICapabilityUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new WanderAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsWanderAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<WanderAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetTemporaryCloneAICapabilityUCMutSetHash(int id, int version, TemporaryCloneAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public TemporaryCloneAICapabilityUCMutSetIncarnation GetTemporaryCloneAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet[id].incarnation;
    }
    public TemporaryCloneAICapabilityUCMutSet GetTemporaryCloneAICapabilityUCMutSet(int id) {
      return new TemporaryCloneAICapabilityUCMutSet(this, id);
    }
    public List<TemporaryCloneAICapabilityUCMutSet> AllTemporaryCloneAICapabilityUCMutSet() {
      List<TemporaryCloneAICapabilityUCMutSet> result = new List<TemporaryCloneAICapabilityUCMutSet>(rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet.Keys) {
        result.Add(new TemporaryCloneAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool TemporaryCloneAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasTemporaryCloneAICapabilityUCMutSet(TemporaryCloneAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasTemporaryCloneAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasTemporaryCloneAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid TemporaryCloneAICapabilityUCMutSet}: " + id);
      }
    }
    public TemporaryCloneAICapabilityUCMutSet EffectTemporaryCloneAICapabilityUCMutSetCreate() {
      return TrustedEffectTemporaryCloneAICapabilityUCMutSetCreateWithId(NewId());
    }
    public TemporaryCloneAICapabilityUCMutSet TrustedEffectTemporaryCloneAICapabilityUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new TemporaryCloneAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateTemporaryCloneAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      return new TemporaryCloneAICapabilityUCMutSet(this, id);
    }
    public void EffectInternalCreateTemporaryCloneAICapabilityUCMutSet(int id, int incarnationVersion, TemporaryCloneAICapabilityUCMutSetIncarnation incarnation) {
      var effect = new TemporaryCloneAICapabilityUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<TemporaryCloneAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectTemporaryCloneAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new TemporaryCloneAICapabilityUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet.Remove(id);
    }

       
    public void EffectTemporaryCloneAICapabilityUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasTemporaryCloneAICapabilityUCMutSet(setId);
      CheckHasTemporaryCloneAICapabilityUC(element);

      var effect = new TemporaryCloneAICapabilityUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new TemporaryCloneAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<TemporaryCloneAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectTemporaryCloneAICapabilityUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasTemporaryCloneAICapabilityUCMutSet(setId);

        CheckHasTemporaryCloneAICapabilityUC(elementId);


      var effect = new TemporaryCloneAICapabilityUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new TemporaryCloneAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<TemporaryCloneAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetSummonAICapabilityUCMutSetHash(int id, int version, SummonAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public SummonAICapabilityUCMutSetIncarnation GetSummonAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsSummonAICapabilityUCMutSet[id].incarnation;
    }
    public SummonAICapabilityUCMutSet GetSummonAICapabilityUCMutSet(int id) {
      return new SummonAICapabilityUCMutSet(this, id);
    }
    public List<SummonAICapabilityUCMutSet> AllSummonAICapabilityUCMutSet() {
      List<SummonAICapabilityUCMutSet> result = new List<SummonAICapabilityUCMutSet>(rootIncarnation.incarnationsSummonAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsSummonAICapabilityUCMutSet.Keys) {
        result.Add(new SummonAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool SummonAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsSummonAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasSummonAICapabilityUCMutSet(SummonAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasSummonAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasSummonAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsSummonAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid SummonAICapabilityUCMutSet}: " + id);
      }
    }
    public SummonAICapabilityUCMutSet EffectSummonAICapabilityUCMutSetCreate() {
      return TrustedEffectSummonAICapabilityUCMutSetCreateWithId(NewId());
    }
    public SummonAICapabilityUCMutSet TrustedEffectSummonAICapabilityUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new SummonAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateSummonAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      return new SummonAICapabilityUCMutSet(this, id);
    }
    public void EffectInternalCreateSummonAICapabilityUCMutSet(int id, int incarnationVersion, SummonAICapabilityUCMutSetIncarnation incarnation) {
      var effect = new SummonAICapabilityUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsSummonAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<SummonAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectSummonAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new SummonAICapabilityUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsSummonAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsSummonAICapabilityUCMutSet.Remove(id);
    }

       
    public void EffectSummonAICapabilityUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasSummonAICapabilityUCMutSet(setId);
      CheckHasSummonAICapabilityUC(element);

      var effect = new SummonAICapabilityUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsSummonAICapabilityUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new SummonAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSummonAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<SummonAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectSummonAICapabilityUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasSummonAICapabilityUCMutSet(setId);

        CheckHasSummonAICapabilityUC(elementId);


      var effect = new SummonAICapabilityUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsSummonAICapabilityUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new SummonAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSummonAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<SummonAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetKamikazeAICapabilityUCMutSetHash(int id, int version, KamikazeAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public KamikazeAICapabilityUCMutSetIncarnation GetKamikazeAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet[id].incarnation;
    }
    public KamikazeAICapabilityUCMutSet GetKamikazeAICapabilityUCMutSet(int id) {
      return new KamikazeAICapabilityUCMutSet(this, id);
    }
    public List<KamikazeAICapabilityUCMutSet> AllKamikazeAICapabilityUCMutSet() {
      List<KamikazeAICapabilityUCMutSet> result = new List<KamikazeAICapabilityUCMutSet>(rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet.Keys) {
        result.Add(new KamikazeAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool KamikazeAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasKamikazeAICapabilityUCMutSet(KamikazeAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasKamikazeAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasKamikazeAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid KamikazeAICapabilityUCMutSet}: " + id);
      }
    }
    public KamikazeAICapabilityUCMutSet EffectKamikazeAICapabilityUCMutSetCreate() {
      return TrustedEffectKamikazeAICapabilityUCMutSetCreateWithId(NewId());
    }
    public KamikazeAICapabilityUCMutSet TrustedEffectKamikazeAICapabilityUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new KamikazeAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateKamikazeAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      return new KamikazeAICapabilityUCMutSet(this, id);
    }
    public void EffectInternalCreateKamikazeAICapabilityUCMutSet(int id, int incarnationVersion, KamikazeAICapabilityUCMutSetIncarnation incarnation) {
      var effect = new KamikazeAICapabilityUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<KamikazeAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectKamikazeAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new KamikazeAICapabilityUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet.Remove(id);
    }

       
    public void EffectKamikazeAICapabilityUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasKamikazeAICapabilityUCMutSet(setId);
      CheckHasKamikazeAICapabilityUC(element);

      var effect = new KamikazeAICapabilityUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new KamikazeAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<KamikazeAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectKamikazeAICapabilityUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasKamikazeAICapabilityUCMutSet(setId);

        CheckHasKamikazeAICapabilityUC(elementId);


      var effect = new KamikazeAICapabilityUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new KamikazeAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<KamikazeAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetGuardAICapabilityUCMutSetHash(int id, int version, GuardAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public GuardAICapabilityUCMutSetIncarnation GetGuardAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsGuardAICapabilityUCMutSet[id].incarnation;
    }
    public GuardAICapabilityUCMutSet GetGuardAICapabilityUCMutSet(int id) {
      return new GuardAICapabilityUCMutSet(this, id);
    }
    public List<GuardAICapabilityUCMutSet> AllGuardAICapabilityUCMutSet() {
      List<GuardAICapabilityUCMutSet> result = new List<GuardAICapabilityUCMutSet>(rootIncarnation.incarnationsGuardAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsGuardAICapabilityUCMutSet.Keys) {
        result.Add(new GuardAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool GuardAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsGuardAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasGuardAICapabilityUCMutSet(GuardAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasGuardAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasGuardAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsGuardAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid GuardAICapabilityUCMutSet}: " + id);
      }
    }
    public GuardAICapabilityUCMutSet EffectGuardAICapabilityUCMutSetCreate() {
      return TrustedEffectGuardAICapabilityUCMutSetCreateWithId(NewId());
    }
    public GuardAICapabilityUCMutSet TrustedEffectGuardAICapabilityUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new GuardAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateGuardAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      return new GuardAICapabilityUCMutSet(this, id);
    }
    public void EffectInternalCreateGuardAICapabilityUCMutSet(int id, int incarnationVersion, GuardAICapabilityUCMutSetIncarnation incarnation) {
      var effect = new GuardAICapabilityUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsGuardAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<GuardAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectGuardAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new GuardAICapabilityUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsGuardAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsGuardAICapabilityUCMutSet.Remove(id);
    }

       
    public void EffectGuardAICapabilityUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasGuardAICapabilityUCMutSet(setId);
      CheckHasGuardAICapabilityUC(element);

      var effect = new GuardAICapabilityUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsGuardAICapabilityUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new GuardAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsGuardAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<GuardAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectGuardAICapabilityUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasGuardAICapabilityUCMutSet(setId);

        CheckHasGuardAICapabilityUC(elementId);


      var effect = new GuardAICapabilityUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsGuardAICapabilityUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new GuardAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsGuardAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<GuardAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetTimeCloneAICapabilityUCMutSetHash(int id, int version, TimeCloneAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public TimeCloneAICapabilityUCMutSetIncarnation GetTimeCloneAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[id].incarnation;
    }
    public TimeCloneAICapabilityUCMutSet GetTimeCloneAICapabilityUCMutSet(int id) {
      return new TimeCloneAICapabilityUCMutSet(this, id);
    }
    public List<TimeCloneAICapabilityUCMutSet> AllTimeCloneAICapabilityUCMutSet() {
      List<TimeCloneAICapabilityUCMutSet> result = new List<TimeCloneAICapabilityUCMutSet>(rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.Keys) {
        result.Add(new TimeCloneAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool TimeCloneAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasTimeCloneAICapabilityUCMutSet(TimeCloneAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasTimeCloneAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasTimeCloneAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid TimeCloneAICapabilityUCMutSet}: " + id);
      }
    }
    public TimeCloneAICapabilityUCMutSet EffectTimeCloneAICapabilityUCMutSetCreate() {
      return TrustedEffectTimeCloneAICapabilityUCMutSetCreateWithId(NewId());
    }
    public TimeCloneAICapabilityUCMutSet TrustedEffectTimeCloneAICapabilityUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new TimeCloneAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateTimeCloneAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      return new TimeCloneAICapabilityUCMutSet(this, id);
    }
    public void EffectInternalCreateTimeCloneAICapabilityUCMutSet(int id, int incarnationVersion, TimeCloneAICapabilityUCMutSetIncarnation incarnation) {
      var effect = new TimeCloneAICapabilityUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<TimeCloneAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectTimeCloneAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new TimeCloneAICapabilityUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.Remove(id);
    }

       
    public void EffectTimeCloneAICapabilityUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasTimeCloneAICapabilityUCMutSet(setId);
      CheckHasTimeCloneAICapabilityUC(element);

      var effect = new TimeCloneAICapabilityUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new TimeCloneAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<TimeCloneAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectTimeCloneAICapabilityUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasTimeCloneAICapabilityUCMutSet(setId);

        CheckHasTimeCloneAICapabilityUC(elementId);


      var effect = new TimeCloneAICapabilityUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new TimeCloneAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<TimeCloneAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetDoomedUCMutSetHash(int id, int version, DoomedUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public DoomedUCMutSetIncarnation GetDoomedUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsDoomedUCMutSet[id].incarnation;
    }
    public DoomedUCMutSet GetDoomedUCMutSet(int id) {
      return new DoomedUCMutSet(this, id);
    }
    public List<DoomedUCMutSet> AllDoomedUCMutSet() {
      List<DoomedUCMutSet> result = new List<DoomedUCMutSet>(rootIncarnation.incarnationsDoomedUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsDoomedUCMutSet.Keys) {
        result.Add(new DoomedUCMutSet(this, id));
      }
      return result;
    }
    public bool DoomedUCMutSetExists(int id) {
      return rootIncarnation.incarnationsDoomedUCMutSet.ContainsKey(id);
    }
    public void CheckHasDoomedUCMutSet(DoomedUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasDoomedUCMutSet(thing.id);
    }
    public void CheckHasDoomedUCMutSet(int id) {
      if (!rootIncarnation.incarnationsDoomedUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid DoomedUCMutSet}: " + id);
      }
    }
    public DoomedUCMutSet EffectDoomedUCMutSetCreate() {
      return TrustedEffectDoomedUCMutSetCreateWithId(NewId());
    }
    public DoomedUCMutSet TrustedEffectDoomedUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new DoomedUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateDoomedUCMutSet(id, rootIncarnation.version, incarnation);
      return new DoomedUCMutSet(this, id);
    }
    public void EffectInternalCreateDoomedUCMutSet(int id, int incarnationVersion, DoomedUCMutSetIncarnation incarnation) {
      var effect = new DoomedUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsDoomedUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<DoomedUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectDoomedUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new DoomedUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsDoomedUCMutSet[id];
      rootIncarnation.incarnationsDoomedUCMutSet.Remove(id);
    }

       
    public void EffectDoomedUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasDoomedUCMutSet(setId);
      CheckHasDoomedUC(element);

      var effect = new DoomedUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsDoomedUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new DoomedUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDoomedUCMutSet[setId] =
            new VersionAndIncarnation<DoomedUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectDoomedUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasDoomedUCMutSet(setId);

        CheckHasDoomedUC(elementId);


      var effect = new DoomedUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsDoomedUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new DoomedUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDoomedUCMutSet[setId] =
            new VersionAndIncarnation<DoomedUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetMiredUCMutSetHash(int id, int version, MiredUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public MiredUCMutSetIncarnation GetMiredUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsMiredUCMutSet[id].incarnation;
    }
    public MiredUCMutSet GetMiredUCMutSet(int id) {
      return new MiredUCMutSet(this, id);
    }
    public List<MiredUCMutSet> AllMiredUCMutSet() {
      List<MiredUCMutSet> result = new List<MiredUCMutSet>(rootIncarnation.incarnationsMiredUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsMiredUCMutSet.Keys) {
        result.Add(new MiredUCMutSet(this, id));
      }
      return result;
    }
    public bool MiredUCMutSetExists(int id) {
      return rootIncarnation.incarnationsMiredUCMutSet.ContainsKey(id);
    }
    public void CheckHasMiredUCMutSet(MiredUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasMiredUCMutSet(thing.id);
    }
    public void CheckHasMiredUCMutSet(int id) {
      if (!rootIncarnation.incarnationsMiredUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid MiredUCMutSet}: " + id);
      }
    }
    public MiredUCMutSet EffectMiredUCMutSetCreate() {
      return TrustedEffectMiredUCMutSetCreateWithId(NewId());
    }
    public MiredUCMutSet TrustedEffectMiredUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new MiredUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateMiredUCMutSet(id, rootIncarnation.version, incarnation);
      return new MiredUCMutSet(this, id);
    }
    public void EffectInternalCreateMiredUCMutSet(int id, int incarnationVersion, MiredUCMutSetIncarnation incarnation) {
      var effect = new MiredUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsMiredUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<MiredUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectMiredUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new MiredUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsMiredUCMutSet[id];
      rootIncarnation.incarnationsMiredUCMutSet.Remove(id);
    }

       
    public void EffectMiredUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasMiredUCMutSet(setId);
      CheckHasMiredUC(element);

      var effect = new MiredUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsMiredUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new MiredUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMiredUCMutSet[setId] =
            new VersionAndIncarnation<MiredUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectMiredUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasMiredUCMutSet(setId);

        CheckHasMiredUC(elementId);


      var effect = new MiredUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsMiredUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new MiredUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMiredUCMutSet[setId] =
            new VersionAndIncarnation<MiredUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetAttackAICapabilityUCMutSetHash(int id, int version, AttackAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public AttackAICapabilityUCMutSetIncarnation GetAttackAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsAttackAICapabilityUCMutSet[id].incarnation;
    }
    public AttackAICapabilityUCMutSet GetAttackAICapabilityUCMutSet(int id) {
      return new AttackAICapabilityUCMutSet(this, id);
    }
    public List<AttackAICapabilityUCMutSet> AllAttackAICapabilityUCMutSet() {
      List<AttackAICapabilityUCMutSet> result = new List<AttackAICapabilityUCMutSet>(rootIncarnation.incarnationsAttackAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsAttackAICapabilityUCMutSet.Keys) {
        result.Add(new AttackAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool AttackAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsAttackAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasAttackAICapabilityUCMutSet(AttackAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasAttackAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasAttackAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsAttackAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid AttackAICapabilityUCMutSet}: " + id);
      }
    }
    public AttackAICapabilityUCMutSet EffectAttackAICapabilityUCMutSetCreate() {
      return TrustedEffectAttackAICapabilityUCMutSetCreateWithId(NewId());
    }
    public AttackAICapabilityUCMutSet TrustedEffectAttackAICapabilityUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new AttackAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateAttackAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      return new AttackAICapabilityUCMutSet(this, id);
    }
    public void EffectInternalCreateAttackAICapabilityUCMutSet(int id, int incarnationVersion, AttackAICapabilityUCMutSetIncarnation incarnation) {
      var effect = new AttackAICapabilityUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsAttackAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<AttackAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectAttackAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new AttackAICapabilityUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsAttackAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsAttackAICapabilityUCMutSet.Remove(id);
    }

       
    public void EffectAttackAICapabilityUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasAttackAICapabilityUCMutSet(setId);
      CheckHasAttackAICapabilityUC(element);

      var effect = new AttackAICapabilityUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsAttackAICapabilityUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new AttackAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsAttackAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<AttackAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectAttackAICapabilityUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasAttackAICapabilityUCMutSet(setId);

        CheckHasAttackAICapabilityUC(elementId);


      var effect = new AttackAICapabilityUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsAttackAICapabilityUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new AttackAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsAttackAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<AttackAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetCounteringUCMutSetHash(int id, int version, CounteringUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CounteringUCMutSetIncarnation GetCounteringUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsCounteringUCMutSet[id].incarnation;
    }
    public CounteringUCMutSet GetCounteringUCMutSet(int id) {
      return new CounteringUCMutSet(this, id);
    }
    public List<CounteringUCMutSet> AllCounteringUCMutSet() {
      List<CounteringUCMutSet> result = new List<CounteringUCMutSet>(rootIncarnation.incarnationsCounteringUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsCounteringUCMutSet.Keys) {
        result.Add(new CounteringUCMutSet(this, id));
      }
      return result;
    }
    public bool CounteringUCMutSetExists(int id) {
      return rootIncarnation.incarnationsCounteringUCMutSet.ContainsKey(id);
    }
    public void CheckHasCounteringUCMutSet(CounteringUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCounteringUCMutSet(thing.id);
    }
    public void CheckHasCounteringUCMutSet(int id) {
      if (!rootIncarnation.incarnationsCounteringUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid CounteringUCMutSet}: " + id);
      }
    }
    public CounteringUCMutSet EffectCounteringUCMutSetCreate() {
      return TrustedEffectCounteringUCMutSetCreateWithId(NewId());
    }
    public CounteringUCMutSet TrustedEffectCounteringUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new CounteringUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateCounteringUCMutSet(id, rootIncarnation.version, incarnation);
      return new CounteringUCMutSet(this, id);
    }
    public void EffectInternalCreateCounteringUCMutSet(int id, int incarnationVersion, CounteringUCMutSetIncarnation incarnation) {
      var effect = new CounteringUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsCounteringUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<CounteringUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectCounteringUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new CounteringUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsCounteringUCMutSet[id];
      rootIncarnation.incarnationsCounteringUCMutSet.Remove(id);
    }

       
    public void EffectCounteringUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasCounteringUCMutSet(setId);
      CheckHasCounteringUC(element);

      var effect = new CounteringUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCounteringUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new CounteringUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCounteringUCMutSet[setId] =
            new VersionAndIncarnation<CounteringUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectCounteringUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasCounteringUCMutSet(setId);

        CheckHasCounteringUC(elementId);


      var effect = new CounteringUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsCounteringUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new CounteringUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCounteringUCMutSet[setId] =
            new VersionAndIncarnation<CounteringUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetLightningChargedUCMutSetHash(int id, int version, LightningChargedUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public LightningChargedUCMutSetIncarnation GetLightningChargedUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsLightningChargedUCMutSet[id].incarnation;
    }
    public LightningChargedUCMutSet GetLightningChargedUCMutSet(int id) {
      return new LightningChargedUCMutSet(this, id);
    }
    public List<LightningChargedUCMutSet> AllLightningChargedUCMutSet() {
      List<LightningChargedUCMutSet> result = new List<LightningChargedUCMutSet>(rootIncarnation.incarnationsLightningChargedUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsLightningChargedUCMutSet.Keys) {
        result.Add(new LightningChargedUCMutSet(this, id));
      }
      return result;
    }
    public bool LightningChargedUCMutSetExists(int id) {
      return rootIncarnation.incarnationsLightningChargedUCMutSet.ContainsKey(id);
    }
    public void CheckHasLightningChargedUCMutSet(LightningChargedUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasLightningChargedUCMutSet(thing.id);
    }
    public void CheckHasLightningChargedUCMutSet(int id) {
      if (!rootIncarnation.incarnationsLightningChargedUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid LightningChargedUCMutSet}: " + id);
      }
    }
    public LightningChargedUCMutSet EffectLightningChargedUCMutSetCreate() {
      return TrustedEffectLightningChargedUCMutSetCreateWithId(NewId());
    }
    public LightningChargedUCMutSet TrustedEffectLightningChargedUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new LightningChargedUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateLightningChargedUCMutSet(id, rootIncarnation.version, incarnation);
      return new LightningChargedUCMutSet(this, id);
    }
    public void EffectInternalCreateLightningChargedUCMutSet(int id, int incarnationVersion, LightningChargedUCMutSetIncarnation incarnation) {
      var effect = new LightningChargedUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsLightningChargedUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<LightningChargedUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectLightningChargedUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new LightningChargedUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsLightningChargedUCMutSet[id];
      rootIncarnation.incarnationsLightningChargedUCMutSet.Remove(id);
    }

       
    public void EffectLightningChargedUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasLightningChargedUCMutSet(setId);
      CheckHasLightningChargedUC(element);

      var effect = new LightningChargedUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsLightningChargedUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new LightningChargedUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLightningChargedUCMutSet[setId] =
            new VersionAndIncarnation<LightningChargedUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectLightningChargedUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasLightningChargedUCMutSet(setId);

        CheckHasLightningChargedUC(elementId);


      var effect = new LightningChargedUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsLightningChargedUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new LightningChargedUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLightningChargedUCMutSet[setId] =
            new VersionAndIncarnation<LightningChargedUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetInvincibilityUCMutSetHash(int id, int version, InvincibilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public InvincibilityUCMutSetIncarnation GetInvincibilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsInvincibilityUCMutSet[id].incarnation;
    }
    public InvincibilityUCMutSet GetInvincibilityUCMutSet(int id) {
      return new InvincibilityUCMutSet(this, id);
    }
    public List<InvincibilityUCMutSet> AllInvincibilityUCMutSet() {
      List<InvincibilityUCMutSet> result = new List<InvincibilityUCMutSet>(rootIncarnation.incarnationsInvincibilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsInvincibilityUCMutSet.Keys) {
        result.Add(new InvincibilityUCMutSet(this, id));
      }
      return result;
    }
    public bool InvincibilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsInvincibilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasInvincibilityUCMutSet(InvincibilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasInvincibilityUCMutSet(thing.id);
    }
    public void CheckHasInvincibilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsInvincibilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid InvincibilityUCMutSet}: " + id);
      }
    }
    public InvincibilityUCMutSet EffectInvincibilityUCMutSetCreate() {
      return TrustedEffectInvincibilityUCMutSetCreateWithId(NewId());
    }
    public InvincibilityUCMutSet TrustedEffectInvincibilityUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new InvincibilityUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateInvincibilityUCMutSet(id, rootIncarnation.version, incarnation);
      return new InvincibilityUCMutSet(this, id);
    }
    public void EffectInternalCreateInvincibilityUCMutSet(int id, int incarnationVersion, InvincibilityUCMutSetIncarnation incarnation) {
      var effect = new InvincibilityUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsInvincibilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<InvincibilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectInvincibilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new InvincibilityUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsInvincibilityUCMutSet[id];
      rootIncarnation.incarnationsInvincibilityUCMutSet.Remove(id);
    }

       
    public void EffectInvincibilityUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasInvincibilityUCMutSet(setId);
      CheckHasInvincibilityUC(element);

      var effect = new InvincibilityUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsInvincibilityUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new InvincibilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsInvincibilityUCMutSet[setId] =
            new VersionAndIncarnation<InvincibilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectInvincibilityUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasInvincibilityUCMutSet(setId);

        CheckHasInvincibilityUC(elementId);


      var effect = new InvincibilityUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsInvincibilityUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new InvincibilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsInvincibilityUCMutSet[setId] =
            new VersionAndIncarnation<InvincibilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetDefyingUCMutSetHash(int id, int version, DefyingUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public DefyingUCMutSetIncarnation GetDefyingUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsDefyingUCMutSet[id].incarnation;
    }
    public DefyingUCMutSet GetDefyingUCMutSet(int id) {
      return new DefyingUCMutSet(this, id);
    }
    public List<DefyingUCMutSet> AllDefyingUCMutSet() {
      List<DefyingUCMutSet> result = new List<DefyingUCMutSet>(rootIncarnation.incarnationsDefyingUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsDefyingUCMutSet.Keys) {
        result.Add(new DefyingUCMutSet(this, id));
      }
      return result;
    }
    public bool DefyingUCMutSetExists(int id) {
      return rootIncarnation.incarnationsDefyingUCMutSet.ContainsKey(id);
    }
    public void CheckHasDefyingUCMutSet(DefyingUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasDefyingUCMutSet(thing.id);
    }
    public void CheckHasDefyingUCMutSet(int id) {
      if (!rootIncarnation.incarnationsDefyingUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid DefyingUCMutSet}: " + id);
      }
    }
    public DefyingUCMutSet EffectDefyingUCMutSetCreate() {
      return TrustedEffectDefyingUCMutSetCreateWithId(NewId());
    }
    public DefyingUCMutSet TrustedEffectDefyingUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new DefyingUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateDefyingUCMutSet(id, rootIncarnation.version, incarnation);
      return new DefyingUCMutSet(this, id);
    }
    public void EffectInternalCreateDefyingUCMutSet(int id, int incarnationVersion, DefyingUCMutSetIncarnation incarnation) {
      var effect = new DefyingUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsDefyingUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<DefyingUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectDefyingUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new DefyingUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsDefyingUCMutSet[id];
      rootIncarnation.incarnationsDefyingUCMutSet.Remove(id);
    }

       
    public void EffectDefyingUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasDefyingUCMutSet(setId);
      CheckHasDefyingUC(element);

      var effect = new DefyingUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsDefyingUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new DefyingUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDefyingUCMutSet[setId] =
            new VersionAndIncarnation<DefyingUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectDefyingUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasDefyingUCMutSet(setId);

        CheckHasDefyingUC(elementId);


      var effect = new DefyingUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsDefyingUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new DefyingUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDefyingUCMutSet[setId] =
            new VersionAndIncarnation<DefyingUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetBideAICapabilityUCMutSetHash(int id, int version, BideAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BideAICapabilityUCMutSetIncarnation GetBideAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBideAICapabilityUCMutSet[id].incarnation;
    }
    public BideAICapabilityUCMutSet GetBideAICapabilityUCMutSet(int id) {
      return new BideAICapabilityUCMutSet(this, id);
    }
    public List<BideAICapabilityUCMutSet> AllBideAICapabilityUCMutSet() {
      List<BideAICapabilityUCMutSet> result = new List<BideAICapabilityUCMutSet>(rootIncarnation.incarnationsBideAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBideAICapabilityUCMutSet.Keys) {
        result.Add(new BideAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool BideAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsBideAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasBideAICapabilityUCMutSet(BideAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBideAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasBideAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsBideAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BideAICapabilityUCMutSet}: " + id);
      }
    }
    public BideAICapabilityUCMutSet EffectBideAICapabilityUCMutSetCreate() {
      return TrustedEffectBideAICapabilityUCMutSetCreateWithId(NewId());
    }
    public BideAICapabilityUCMutSet TrustedEffectBideAICapabilityUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BideAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateBideAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      return new BideAICapabilityUCMutSet(this, id);
    }
    public void EffectInternalCreateBideAICapabilityUCMutSet(int id, int incarnationVersion, BideAICapabilityUCMutSetIncarnation incarnation) {
      var effect = new BideAICapabilityUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsBideAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<BideAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectBideAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new BideAICapabilityUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsBideAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsBideAICapabilityUCMutSet.Remove(id);
    }

       
    public void EffectBideAICapabilityUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasBideAICapabilityUCMutSet(setId);
      CheckHasBideAICapabilityUC(element);

      var effect = new BideAICapabilityUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBideAICapabilityUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BideAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBideAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<BideAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectBideAICapabilityUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasBideAICapabilityUCMutSet(setId);

        CheckHasBideAICapabilityUC(elementId);


      var effect = new BideAICapabilityUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBideAICapabilityUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BideAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBideAICapabilityUCMutSet[setId] =
            new VersionAndIncarnation<BideAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetBaseSightRangeUCMutSetHash(int id, int version, BaseSightRangeUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BaseSightRangeUCMutSetIncarnation GetBaseSightRangeUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBaseSightRangeUCMutSet[id].incarnation;
    }
    public BaseSightRangeUCMutSet GetBaseSightRangeUCMutSet(int id) {
      return new BaseSightRangeUCMutSet(this, id);
    }
    public List<BaseSightRangeUCMutSet> AllBaseSightRangeUCMutSet() {
      List<BaseSightRangeUCMutSet> result = new List<BaseSightRangeUCMutSet>(rootIncarnation.incarnationsBaseSightRangeUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBaseSightRangeUCMutSet.Keys) {
        result.Add(new BaseSightRangeUCMutSet(this, id));
      }
      return result;
    }
    public bool BaseSightRangeUCMutSetExists(int id) {
      return rootIncarnation.incarnationsBaseSightRangeUCMutSet.ContainsKey(id);
    }
    public void CheckHasBaseSightRangeUCMutSet(BaseSightRangeUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBaseSightRangeUCMutSet(thing.id);
    }
    public void CheckHasBaseSightRangeUCMutSet(int id) {
      if (!rootIncarnation.incarnationsBaseSightRangeUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BaseSightRangeUCMutSet}: " + id);
      }
    }
    public BaseSightRangeUCMutSet EffectBaseSightRangeUCMutSetCreate() {
      return TrustedEffectBaseSightRangeUCMutSetCreateWithId(NewId());
    }
    public BaseSightRangeUCMutSet TrustedEffectBaseSightRangeUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BaseSightRangeUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateBaseSightRangeUCMutSet(id, rootIncarnation.version, incarnation);
      return new BaseSightRangeUCMutSet(this, id);
    }
    public void EffectInternalCreateBaseSightRangeUCMutSet(int id, int incarnationVersion, BaseSightRangeUCMutSetIncarnation incarnation) {
      var effect = new BaseSightRangeUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsBaseSightRangeUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<BaseSightRangeUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectBaseSightRangeUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new BaseSightRangeUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsBaseSightRangeUCMutSet[id];
      rootIncarnation.incarnationsBaseSightRangeUCMutSet.Remove(id);
    }

       
    public void EffectBaseSightRangeUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasBaseSightRangeUCMutSet(setId);
      CheckHasBaseSightRangeUC(element);

      var effect = new BaseSightRangeUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBaseSightRangeUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BaseSightRangeUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBaseSightRangeUCMutSet[setId] =
            new VersionAndIncarnation<BaseSightRangeUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectBaseSightRangeUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasBaseSightRangeUCMutSet(setId);

        CheckHasBaseSightRangeUC(elementId);


      var effect = new BaseSightRangeUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBaseSightRangeUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BaseSightRangeUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBaseSightRangeUCMutSet[setId] =
            new VersionAndIncarnation<BaseSightRangeUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetBaseMovementTimeUCMutSetHash(int id, int version, BaseMovementTimeUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BaseMovementTimeUCMutSetIncarnation GetBaseMovementTimeUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBaseMovementTimeUCMutSet[id].incarnation;
    }
    public BaseMovementTimeUCMutSet GetBaseMovementTimeUCMutSet(int id) {
      return new BaseMovementTimeUCMutSet(this, id);
    }
    public List<BaseMovementTimeUCMutSet> AllBaseMovementTimeUCMutSet() {
      List<BaseMovementTimeUCMutSet> result = new List<BaseMovementTimeUCMutSet>(rootIncarnation.incarnationsBaseMovementTimeUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBaseMovementTimeUCMutSet.Keys) {
        result.Add(new BaseMovementTimeUCMutSet(this, id));
      }
      return result;
    }
    public bool BaseMovementTimeUCMutSetExists(int id) {
      return rootIncarnation.incarnationsBaseMovementTimeUCMutSet.ContainsKey(id);
    }
    public void CheckHasBaseMovementTimeUCMutSet(BaseMovementTimeUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBaseMovementTimeUCMutSet(thing.id);
    }
    public void CheckHasBaseMovementTimeUCMutSet(int id) {
      if (!rootIncarnation.incarnationsBaseMovementTimeUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BaseMovementTimeUCMutSet}: " + id);
      }
    }
    public BaseMovementTimeUCMutSet EffectBaseMovementTimeUCMutSetCreate() {
      return TrustedEffectBaseMovementTimeUCMutSetCreateWithId(NewId());
    }
    public BaseMovementTimeUCMutSet TrustedEffectBaseMovementTimeUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BaseMovementTimeUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateBaseMovementTimeUCMutSet(id, rootIncarnation.version, incarnation);
      return new BaseMovementTimeUCMutSet(this, id);
    }
    public void EffectInternalCreateBaseMovementTimeUCMutSet(int id, int incarnationVersion, BaseMovementTimeUCMutSetIncarnation incarnation) {
      var effect = new BaseMovementTimeUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsBaseMovementTimeUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<BaseMovementTimeUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectBaseMovementTimeUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new BaseMovementTimeUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsBaseMovementTimeUCMutSet[id];
      rootIncarnation.incarnationsBaseMovementTimeUCMutSet.Remove(id);
    }

       
    public void EffectBaseMovementTimeUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasBaseMovementTimeUCMutSet(setId);
      CheckHasBaseMovementTimeUC(element);

      var effect = new BaseMovementTimeUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBaseMovementTimeUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BaseMovementTimeUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBaseMovementTimeUCMutSet[setId] =
            new VersionAndIncarnation<BaseMovementTimeUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectBaseMovementTimeUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasBaseMovementTimeUCMutSet(setId);

        CheckHasBaseMovementTimeUC(elementId);


      var effect = new BaseMovementTimeUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBaseMovementTimeUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BaseMovementTimeUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBaseMovementTimeUCMutSet[setId] =
            new VersionAndIncarnation<BaseMovementTimeUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetBaseCombatTimeUCMutSetHash(int id, int version, BaseCombatTimeUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BaseCombatTimeUCMutSetIncarnation GetBaseCombatTimeUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBaseCombatTimeUCMutSet[id].incarnation;
    }
    public BaseCombatTimeUCMutSet GetBaseCombatTimeUCMutSet(int id) {
      return new BaseCombatTimeUCMutSet(this, id);
    }
    public List<BaseCombatTimeUCMutSet> AllBaseCombatTimeUCMutSet() {
      List<BaseCombatTimeUCMutSet> result = new List<BaseCombatTimeUCMutSet>(rootIncarnation.incarnationsBaseCombatTimeUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBaseCombatTimeUCMutSet.Keys) {
        result.Add(new BaseCombatTimeUCMutSet(this, id));
      }
      return result;
    }
    public bool BaseCombatTimeUCMutSetExists(int id) {
      return rootIncarnation.incarnationsBaseCombatTimeUCMutSet.ContainsKey(id);
    }
    public void CheckHasBaseCombatTimeUCMutSet(BaseCombatTimeUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBaseCombatTimeUCMutSet(thing.id);
    }
    public void CheckHasBaseCombatTimeUCMutSet(int id) {
      if (!rootIncarnation.incarnationsBaseCombatTimeUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BaseCombatTimeUCMutSet}: " + id);
      }
    }
    public BaseCombatTimeUCMutSet EffectBaseCombatTimeUCMutSetCreate() {
      return TrustedEffectBaseCombatTimeUCMutSetCreateWithId(NewId());
    }
    public BaseCombatTimeUCMutSet TrustedEffectBaseCombatTimeUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BaseCombatTimeUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateBaseCombatTimeUCMutSet(id, rootIncarnation.version, incarnation);
      return new BaseCombatTimeUCMutSet(this, id);
    }
    public void EffectInternalCreateBaseCombatTimeUCMutSet(int id, int incarnationVersion, BaseCombatTimeUCMutSetIncarnation incarnation) {
      var effect = new BaseCombatTimeUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsBaseCombatTimeUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<BaseCombatTimeUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectBaseCombatTimeUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new BaseCombatTimeUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsBaseCombatTimeUCMutSet[id];
      rootIncarnation.incarnationsBaseCombatTimeUCMutSet.Remove(id);
    }

       
    public void EffectBaseCombatTimeUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasBaseCombatTimeUCMutSet(setId);
      CheckHasBaseCombatTimeUC(element);

      var effect = new BaseCombatTimeUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBaseCombatTimeUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BaseCombatTimeUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBaseCombatTimeUCMutSet[setId] =
            new VersionAndIncarnation<BaseCombatTimeUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectBaseCombatTimeUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasBaseCombatTimeUCMutSet(setId);

        CheckHasBaseCombatTimeUC(elementId);


      var effect = new BaseCombatTimeUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBaseCombatTimeUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BaseCombatTimeUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBaseCombatTimeUCMutSet[setId] =
            new VersionAndIncarnation<BaseCombatTimeUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetManaPotionMutSetHash(int id, int version, ManaPotionMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ManaPotionMutSetIncarnation GetManaPotionMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsManaPotionMutSet[id].incarnation;
    }
    public ManaPotionMutSet GetManaPotionMutSet(int id) {
      return new ManaPotionMutSet(this, id);
    }
    public List<ManaPotionMutSet> AllManaPotionMutSet() {
      List<ManaPotionMutSet> result = new List<ManaPotionMutSet>(rootIncarnation.incarnationsManaPotionMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsManaPotionMutSet.Keys) {
        result.Add(new ManaPotionMutSet(this, id));
      }
      return result;
    }
    public bool ManaPotionMutSetExists(int id) {
      return rootIncarnation.incarnationsManaPotionMutSet.ContainsKey(id);
    }
    public void CheckHasManaPotionMutSet(ManaPotionMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasManaPotionMutSet(thing.id);
    }
    public void CheckHasManaPotionMutSet(int id) {
      if (!rootIncarnation.incarnationsManaPotionMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ManaPotionMutSet}: " + id);
      }
    }
    public ManaPotionMutSet EffectManaPotionMutSetCreate() {
      return TrustedEffectManaPotionMutSetCreateWithId(NewId());
    }
    public ManaPotionMutSet TrustedEffectManaPotionMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new ManaPotionMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateManaPotionMutSet(id, rootIncarnation.version, incarnation);
      return new ManaPotionMutSet(this, id);
    }
    public void EffectInternalCreateManaPotionMutSet(int id, int incarnationVersion, ManaPotionMutSetIncarnation incarnation) {
      var effect = new ManaPotionMutSetCreateEffect(id);
      rootIncarnation.incarnationsManaPotionMutSet
          .Add(
              id,
              new VersionAndIncarnation<ManaPotionMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectManaPotionMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new ManaPotionMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsManaPotionMutSet[id];
      rootIncarnation.incarnationsManaPotionMutSet.Remove(id);
    }

       
    public void EffectManaPotionMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasManaPotionMutSet(setId);
      CheckHasManaPotion(element);

      var effect = new ManaPotionMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsManaPotionMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new ManaPotionMutSetIncarnation(newMap);
        rootIncarnation.incarnationsManaPotionMutSet[setId] =
            new VersionAndIncarnation<ManaPotionMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectManaPotionMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasManaPotionMutSet(setId);

        CheckHasManaPotion(elementId);


      var effect = new ManaPotionMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsManaPotionMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ManaPotionMutSetIncarnation(newMap);
        rootIncarnation.incarnationsManaPotionMutSet[setId] =
            new VersionAndIncarnation<ManaPotionMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetHealthPotionMutSetHash(int id, int version, HealthPotionMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public HealthPotionMutSetIncarnation GetHealthPotionMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsHealthPotionMutSet[id].incarnation;
    }
    public HealthPotionMutSet GetHealthPotionMutSet(int id) {
      return new HealthPotionMutSet(this, id);
    }
    public List<HealthPotionMutSet> AllHealthPotionMutSet() {
      List<HealthPotionMutSet> result = new List<HealthPotionMutSet>(rootIncarnation.incarnationsHealthPotionMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsHealthPotionMutSet.Keys) {
        result.Add(new HealthPotionMutSet(this, id));
      }
      return result;
    }
    public bool HealthPotionMutSetExists(int id) {
      return rootIncarnation.incarnationsHealthPotionMutSet.ContainsKey(id);
    }
    public void CheckHasHealthPotionMutSet(HealthPotionMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasHealthPotionMutSet(thing.id);
    }
    public void CheckHasHealthPotionMutSet(int id) {
      if (!rootIncarnation.incarnationsHealthPotionMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid HealthPotionMutSet}: " + id);
      }
    }
    public HealthPotionMutSet EffectHealthPotionMutSetCreate() {
      return TrustedEffectHealthPotionMutSetCreateWithId(NewId());
    }
    public HealthPotionMutSet TrustedEffectHealthPotionMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new HealthPotionMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateHealthPotionMutSet(id, rootIncarnation.version, incarnation);
      return new HealthPotionMutSet(this, id);
    }
    public void EffectInternalCreateHealthPotionMutSet(int id, int incarnationVersion, HealthPotionMutSetIncarnation incarnation) {
      var effect = new HealthPotionMutSetCreateEffect(id);
      rootIncarnation.incarnationsHealthPotionMutSet
          .Add(
              id,
              new VersionAndIncarnation<HealthPotionMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectHealthPotionMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new HealthPotionMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsHealthPotionMutSet[id];
      rootIncarnation.incarnationsHealthPotionMutSet.Remove(id);
    }

       
    public void EffectHealthPotionMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasHealthPotionMutSet(setId);
      CheckHasHealthPotion(element);

      var effect = new HealthPotionMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsHealthPotionMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new HealthPotionMutSetIncarnation(newMap);
        rootIncarnation.incarnationsHealthPotionMutSet[setId] =
            new VersionAndIncarnation<HealthPotionMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectHealthPotionMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasHealthPotionMutSet(setId);

        CheckHasHealthPotion(elementId);


      var effect = new HealthPotionMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsHealthPotionMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new HealthPotionMutSetIncarnation(newMap);
        rootIncarnation.incarnationsHealthPotionMutSet[setId] =
            new VersionAndIncarnation<HealthPotionMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetSpeedRingMutSetHash(int id, int version, SpeedRingMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public SpeedRingMutSetIncarnation GetSpeedRingMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsSpeedRingMutSet[id].incarnation;
    }
    public SpeedRingMutSet GetSpeedRingMutSet(int id) {
      return new SpeedRingMutSet(this, id);
    }
    public List<SpeedRingMutSet> AllSpeedRingMutSet() {
      List<SpeedRingMutSet> result = new List<SpeedRingMutSet>(rootIncarnation.incarnationsSpeedRingMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsSpeedRingMutSet.Keys) {
        result.Add(new SpeedRingMutSet(this, id));
      }
      return result;
    }
    public bool SpeedRingMutSetExists(int id) {
      return rootIncarnation.incarnationsSpeedRingMutSet.ContainsKey(id);
    }
    public void CheckHasSpeedRingMutSet(SpeedRingMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasSpeedRingMutSet(thing.id);
    }
    public void CheckHasSpeedRingMutSet(int id) {
      if (!rootIncarnation.incarnationsSpeedRingMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid SpeedRingMutSet}: " + id);
      }
    }
    public SpeedRingMutSet EffectSpeedRingMutSetCreate() {
      return TrustedEffectSpeedRingMutSetCreateWithId(NewId());
    }
    public SpeedRingMutSet TrustedEffectSpeedRingMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new SpeedRingMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateSpeedRingMutSet(id, rootIncarnation.version, incarnation);
      return new SpeedRingMutSet(this, id);
    }
    public void EffectInternalCreateSpeedRingMutSet(int id, int incarnationVersion, SpeedRingMutSetIncarnation incarnation) {
      var effect = new SpeedRingMutSetCreateEffect(id);
      rootIncarnation.incarnationsSpeedRingMutSet
          .Add(
              id,
              new VersionAndIncarnation<SpeedRingMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectSpeedRingMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new SpeedRingMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsSpeedRingMutSet[id];
      rootIncarnation.incarnationsSpeedRingMutSet.Remove(id);
    }

       
    public void EffectSpeedRingMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasSpeedRingMutSet(setId);
      CheckHasSpeedRing(element);

      var effect = new SpeedRingMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsSpeedRingMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new SpeedRingMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSpeedRingMutSet[setId] =
            new VersionAndIncarnation<SpeedRingMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectSpeedRingMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasSpeedRingMutSet(setId);

        CheckHasSpeedRing(elementId);


      var effect = new SpeedRingMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsSpeedRingMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new SpeedRingMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSpeedRingMutSet[setId] =
            new VersionAndIncarnation<SpeedRingMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetGlaiveMutSetHash(int id, int version, GlaiveMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public GlaiveMutSetIncarnation GetGlaiveMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsGlaiveMutSet[id].incarnation;
    }
    public GlaiveMutSet GetGlaiveMutSet(int id) {
      return new GlaiveMutSet(this, id);
    }
    public List<GlaiveMutSet> AllGlaiveMutSet() {
      List<GlaiveMutSet> result = new List<GlaiveMutSet>(rootIncarnation.incarnationsGlaiveMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsGlaiveMutSet.Keys) {
        result.Add(new GlaiveMutSet(this, id));
      }
      return result;
    }
    public bool GlaiveMutSetExists(int id) {
      return rootIncarnation.incarnationsGlaiveMutSet.ContainsKey(id);
    }
    public void CheckHasGlaiveMutSet(GlaiveMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasGlaiveMutSet(thing.id);
    }
    public void CheckHasGlaiveMutSet(int id) {
      if (!rootIncarnation.incarnationsGlaiveMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid GlaiveMutSet}: " + id);
      }
    }
    public GlaiveMutSet EffectGlaiveMutSetCreate() {
      return TrustedEffectGlaiveMutSetCreateWithId(NewId());
    }
    public GlaiveMutSet TrustedEffectGlaiveMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new GlaiveMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateGlaiveMutSet(id, rootIncarnation.version, incarnation);
      return new GlaiveMutSet(this, id);
    }
    public void EffectInternalCreateGlaiveMutSet(int id, int incarnationVersion, GlaiveMutSetIncarnation incarnation) {
      var effect = new GlaiveMutSetCreateEffect(id);
      rootIncarnation.incarnationsGlaiveMutSet
          .Add(
              id,
              new VersionAndIncarnation<GlaiveMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectGlaiveMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new GlaiveMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsGlaiveMutSet[id];
      rootIncarnation.incarnationsGlaiveMutSet.Remove(id);
    }

       
    public void EffectGlaiveMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasGlaiveMutSet(setId);
      CheckHasGlaive(element);

      var effect = new GlaiveMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsGlaiveMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new GlaiveMutSetIncarnation(newMap);
        rootIncarnation.incarnationsGlaiveMutSet[setId] =
            new VersionAndIncarnation<GlaiveMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectGlaiveMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasGlaiveMutSet(setId);

        CheckHasGlaive(elementId);


      var effect = new GlaiveMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsGlaiveMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new GlaiveMutSetIncarnation(newMap);
        rootIncarnation.incarnationsGlaiveMutSet[setId] =
            new VersionAndIncarnation<GlaiveMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetSlowRodMutSetHash(int id, int version, SlowRodMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public SlowRodMutSetIncarnation GetSlowRodMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsSlowRodMutSet[id].incarnation;
    }
    public SlowRodMutSet GetSlowRodMutSet(int id) {
      return new SlowRodMutSet(this, id);
    }
    public List<SlowRodMutSet> AllSlowRodMutSet() {
      List<SlowRodMutSet> result = new List<SlowRodMutSet>(rootIncarnation.incarnationsSlowRodMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsSlowRodMutSet.Keys) {
        result.Add(new SlowRodMutSet(this, id));
      }
      return result;
    }
    public bool SlowRodMutSetExists(int id) {
      return rootIncarnation.incarnationsSlowRodMutSet.ContainsKey(id);
    }
    public void CheckHasSlowRodMutSet(SlowRodMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasSlowRodMutSet(thing.id);
    }
    public void CheckHasSlowRodMutSet(int id) {
      if (!rootIncarnation.incarnationsSlowRodMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid SlowRodMutSet}: " + id);
      }
    }
    public SlowRodMutSet EffectSlowRodMutSetCreate() {
      return TrustedEffectSlowRodMutSetCreateWithId(NewId());
    }
    public SlowRodMutSet TrustedEffectSlowRodMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new SlowRodMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateSlowRodMutSet(id, rootIncarnation.version, incarnation);
      return new SlowRodMutSet(this, id);
    }
    public void EffectInternalCreateSlowRodMutSet(int id, int incarnationVersion, SlowRodMutSetIncarnation incarnation) {
      var effect = new SlowRodMutSetCreateEffect(id);
      rootIncarnation.incarnationsSlowRodMutSet
          .Add(
              id,
              new VersionAndIncarnation<SlowRodMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectSlowRodMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new SlowRodMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsSlowRodMutSet[id];
      rootIncarnation.incarnationsSlowRodMutSet.Remove(id);
    }

       
    public void EffectSlowRodMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasSlowRodMutSet(setId);
      CheckHasSlowRod(element);

      var effect = new SlowRodMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsSlowRodMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new SlowRodMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSlowRodMutSet[setId] =
            new VersionAndIncarnation<SlowRodMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectSlowRodMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasSlowRodMutSet(setId);

        CheckHasSlowRod(elementId);


      var effect = new SlowRodMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsSlowRodMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new SlowRodMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSlowRodMutSet[setId] =
            new VersionAndIncarnation<SlowRodMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetBlastRodMutSetHash(int id, int version, BlastRodMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BlastRodMutSetIncarnation GetBlastRodMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBlastRodMutSet[id].incarnation;
    }
    public BlastRodMutSet GetBlastRodMutSet(int id) {
      return new BlastRodMutSet(this, id);
    }
    public List<BlastRodMutSet> AllBlastRodMutSet() {
      List<BlastRodMutSet> result = new List<BlastRodMutSet>(rootIncarnation.incarnationsBlastRodMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBlastRodMutSet.Keys) {
        result.Add(new BlastRodMutSet(this, id));
      }
      return result;
    }
    public bool BlastRodMutSetExists(int id) {
      return rootIncarnation.incarnationsBlastRodMutSet.ContainsKey(id);
    }
    public void CheckHasBlastRodMutSet(BlastRodMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBlastRodMutSet(thing.id);
    }
    public void CheckHasBlastRodMutSet(int id) {
      if (!rootIncarnation.incarnationsBlastRodMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BlastRodMutSet}: " + id);
      }
    }
    public BlastRodMutSet EffectBlastRodMutSetCreate() {
      return TrustedEffectBlastRodMutSetCreateWithId(NewId());
    }
    public BlastRodMutSet TrustedEffectBlastRodMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BlastRodMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateBlastRodMutSet(id, rootIncarnation.version, incarnation);
      return new BlastRodMutSet(this, id);
    }
    public void EffectInternalCreateBlastRodMutSet(int id, int incarnationVersion, BlastRodMutSetIncarnation incarnation) {
      var effect = new BlastRodMutSetCreateEffect(id);
      rootIncarnation.incarnationsBlastRodMutSet
          .Add(
              id,
              new VersionAndIncarnation<BlastRodMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectBlastRodMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new BlastRodMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsBlastRodMutSet[id];
      rootIncarnation.incarnationsBlastRodMutSet.Remove(id);
    }

       
    public void EffectBlastRodMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasBlastRodMutSet(setId);
      CheckHasBlastRod(element);

      var effect = new BlastRodMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBlastRodMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BlastRodMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBlastRodMutSet[setId] =
            new VersionAndIncarnation<BlastRodMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectBlastRodMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasBlastRodMutSet(setId);

        CheckHasBlastRod(elementId);


      var effect = new BlastRodMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBlastRodMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BlastRodMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBlastRodMutSet[setId] =
            new VersionAndIncarnation<BlastRodMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetArmorMutSetHash(int id, int version, ArmorMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ArmorMutSetIncarnation GetArmorMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsArmorMutSet[id].incarnation;
    }
    public ArmorMutSet GetArmorMutSet(int id) {
      return new ArmorMutSet(this, id);
    }
    public List<ArmorMutSet> AllArmorMutSet() {
      List<ArmorMutSet> result = new List<ArmorMutSet>(rootIncarnation.incarnationsArmorMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsArmorMutSet.Keys) {
        result.Add(new ArmorMutSet(this, id));
      }
      return result;
    }
    public bool ArmorMutSetExists(int id) {
      return rootIncarnation.incarnationsArmorMutSet.ContainsKey(id);
    }
    public void CheckHasArmorMutSet(ArmorMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasArmorMutSet(thing.id);
    }
    public void CheckHasArmorMutSet(int id) {
      if (!rootIncarnation.incarnationsArmorMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ArmorMutSet}: " + id);
      }
    }
    public ArmorMutSet EffectArmorMutSetCreate() {
      return TrustedEffectArmorMutSetCreateWithId(NewId());
    }
    public ArmorMutSet TrustedEffectArmorMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new ArmorMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateArmorMutSet(id, rootIncarnation.version, incarnation);
      return new ArmorMutSet(this, id);
    }
    public void EffectInternalCreateArmorMutSet(int id, int incarnationVersion, ArmorMutSetIncarnation incarnation) {
      var effect = new ArmorMutSetCreateEffect(id);
      rootIncarnation.incarnationsArmorMutSet
          .Add(
              id,
              new VersionAndIncarnation<ArmorMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectArmorMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new ArmorMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsArmorMutSet[id];
      rootIncarnation.incarnationsArmorMutSet.Remove(id);
    }

       
    public void EffectArmorMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasArmorMutSet(setId);
      CheckHasArmor(element);

      var effect = new ArmorMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsArmorMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new ArmorMutSetIncarnation(newMap);
        rootIncarnation.incarnationsArmorMutSet[setId] =
            new VersionAndIncarnation<ArmorMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectArmorMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasArmorMutSet(setId);

        CheckHasArmor(elementId);


      var effect = new ArmorMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsArmorMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ArmorMutSetIncarnation(newMap);
        rootIncarnation.incarnationsArmorMutSet[setId] =
            new VersionAndIncarnation<ArmorMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetSorcerousUCMutSetHash(int id, int version, SorcerousUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public SorcerousUCMutSetIncarnation GetSorcerousUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsSorcerousUCMutSet[id].incarnation;
    }
    public SorcerousUCMutSet GetSorcerousUCMutSet(int id) {
      return new SorcerousUCMutSet(this, id);
    }
    public List<SorcerousUCMutSet> AllSorcerousUCMutSet() {
      List<SorcerousUCMutSet> result = new List<SorcerousUCMutSet>(rootIncarnation.incarnationsSorcerousUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsSorcerousUCMutSet.Keys) {
        result.Add(new SorcerousUCMutSet(this, id));
      }
      return result;
    }
    public bool SorcerousUCMutSetExists(int id) {
      return rootIncarnation.incarnationsSorcerousUCMutSet.ContainsKey(id);
    }
    public void CheckHasSorcerousUCMutSet(SorcerousUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasSorcerousUCMutSet(thing.id);
    }
    public void CheckHasSorcerousUCMutSet(int id) {
      if (!rootIncarnation.incarnationsSorcerousUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid SorcerousUCMutSet}: " + id);
      }
    }
    public SorcerousUCMutSet EffectSorcerousUCMutSetCreate() {
      return TrustedEffectSorcerousUCMutSetCreateWithId(NewId());
    }
    public SorcerousUCMutSet TrustedEffectSorcerousUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new SorcerousUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateSorcerousUCMutSet(id, rootIncarnation.version, incarnation);
      return new SorcerousUCMutSet(this, id);
    }
    public void EffectInternalCreateSorcerousUCMutSet(int id, int incarnationVersion, SorcerousUCMutSetIncarnation incarnation) {
      var effect = new SorcerousUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsSorcerousUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<SorcerousUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectSorcerousUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new SorcerousUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsSorcerousUCMutSet[id];
      rootIncarnation.incarnationsSorcerousUCMutSet.Remove(id);
    }

       
    public void EffectSorcerousUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasSorcerousUCMutSet(setId);
      CheckHasSorcerousUC(element);

      var effect = new SorcerousUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsSorcerousUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new SorcerousUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSorcerousUCMutSet[setId] =
            new VersionAndIncarnation<SorcerousUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectSorcerousUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasSorcerousUCMutSet(setId);

        CheckHasSorcerousUC(elementId);


      var effect = new SorcerousUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsSorcerousUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new SorcerousUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSorcerousUCMutSet[setId] =
            new VersionAndIncarnation<SorcerousUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetBaseOffenseUCMutSetHash(int id, int version, BaseOffenseUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BaseOffenseUCMutSetIncarnation GetBaseOffenseUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBaseOffenseUCMutSet[id].incarnation;
    }
    public BaseOffenseUCMutSet GetBaseOffenseUCMutSet(int id) {
      return new BaseOffenseUCMutSet(this, id);
    }
    public List<BaseOffenseUCMutSet> AllBaseOffenseUCMutSet() {
      List<BaseOffenseUCMutSet> result = new List<BaseOffenseUCMutSet>(rootIncarnation.incarnationsBaseOffenseUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBaseOffenseUCMutSet.Keys) {
        result.Add(new BaseOffenseUCMutSet(this, id));
      }
      return result;
    }
    public bool BaseOffenseUCMutSetExists(int id) {
      return rootIncarnation.incarnationsBaseOffenseUCMutSet.ContainsKey(id);
    }
    public void CheckHasBaseOffenseUCMutSet(BaseOffenseUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBaseOffenseUCMutSet(thing.id);
    }
    public void CheckHasBaseOffenseUCMutSet(int id) {
      if (!rootIncarnation.incarnationsBaseOffenseUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BaseOffenseUCMutSet}: " + id);
      }
    }
    public BaseOffenseUCMutSet EffectBaseOffenseUCMutSetCreate() {
      return TrustedEffectBaseOffenseUCMutSetCreateWithId(NewId());
    }
    public BaseOffenseUCMutSet TrustedEffectBaseOffenseUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BaseOffenseUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateBaseOffenseUCMutSet(id, rootIncarnation.version, incarnation);
      return new BaseOffenseUCMutSet(this, id);
    }
    public void EffectInternalCreateBaseOffenseUCMutSet(int id, int incarnationVersion, BaseOffenseUCMutSetIncarnation incarnation) {
      var effect = new BaseOffenseUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsBaseOffenseUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<BaseOffenseUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectBaseOffenseUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new BaseOffenseUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsBaseOffenseUCMutSet[id];
      rootIncarnation.incarnationsBaseOffenseUCMutSet.Remove(id);
    }

       
    public void EffectBaseOffenseUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasBaseOffenseUCMutSet(setId);
      CheckHasBaseOffenseUC(element);

      var effect = new BaseOffenseUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBaseOffenseUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BaseOffenseUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBaseOffenseUCMutSet[setId] =
            new VersionAndIncarnation<BaseOffenseUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectBaseOffenseUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasBaseOffenseUCMutSet(setId);

        CheckHasBaseOffenseUC(elementId);


      var effect = new BaseOffenseUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBaseOffenseUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BaseOffenseUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBaseOffenseUCMutSet[setId] =
            new VersionAndIncarnation<BaseOffenseUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetBaseDefenseUCMutSetHash(int id, int version, BaseDefenseUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.set) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BaseDefenseUCMutSetIncarnation GetBaseDefenseUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBaseDefenseUCMutSet[id].incarnation;
    }
    public BaseDefenseUCMutSet GetBaseDefenseUCMutSet(int id) {
      return new BaseDefenseUCMutSet(this, id);
    }
    public List<BaseDefenseUCMutSet> AllBaseDefenseUCMutSet() {
      List<BaseDefenseUCMutSet> result = new List<BaseDefenseUCMutSet>(rootIncarnation.incarnationsBaseDefenseUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBaseDefenseUCMutSet.Keys) {
        result.Add(new BaseDefenseUCMutSet(this, id));
      }
      return result;
    }
    public bool BaseDefenseUCMutSetExists(int id) {
      return rootIncarnation.incarnationsBaseDefenseUCMutSet.ContainsKey(id);
    }
    public void CheckHasBaseDefenseUCMutSet(BaseDefenseUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBaseDefenseUCMutSet(thing.id);
    }
    public void CheckHasBaseDefenseUCMutSet(int id) {
      if (!rootIncarnation.incarnationsBaseDefenseUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BaseDefenseUCMutSet}: " + id);
      }
    }
    public BaseDefenseUCMutSet EffectBaseDefenseUCMutSetCreate() {
      return TrustedEffectBaseDefenseUCMutSetCreateWithId(NewId());
    }
    public BaseDefenseUCMutSet TrustedEffectBaseDefenseUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BaseDefenseUCMutSetIncarnation(new SortedSet<int>());
      EffectInternalCreateBaseDefenseUCMutSet(id, rootIncarnation.version, incarnation);
      return new BaseDefenseUCMutSet(this, id);
    }
    public void EffectInternalCreateBaseDefenseUCMutSet(int id, int incarnationVersion, BaseDefenseUCMutSetIncarnation incarnation) {
      var effect = new BaseDefenseUCMutSetCreateEffect(id);
      rootIncarnation.incarnationsBaseDefenseUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<BaseDefenseUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectBaseDefenseUCMutSetDelete(int id) {
      CheckUnlocked();
      var effect = new BaseDefenseUCMutSetDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsBaseDefenseUCMutSet[id];
      rootIncarnation.incarnationsBaseDefenseUCMutSet.Remove(id);
    }

       
    public void EffectBaseDefenseUCMutSetAdd(int setId, int element) {
      CheckUnlocked();
      CheckHasBaseDefenseUCMutSet(setId);
      CheckHasBaseDefenseUC(element);

      var effect = new BaseDefenseUCMutSetAddEffect(setId, element);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBaseDefenseUCMutSet[setId];
      if (oldIncarnationAndVersion.incarnation.set.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BaseDefenseUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBaseDefenseUCMutSet[setId] =
            new VersionAndIncarnation<BaseDefenseUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
    public void EffectBaseDefenseUCMutSetRemove(int setId, int elementId) {
      CheckUnlocked();
      CheckHasBaseDefenseUCMutSet(setId);

        CheckHasBaseDefenseUC(elementId);


      var effect = new BaseDefenseUCMutSetRemoveEffect(setId, elementId);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsBaseDefenseUCMutSet[setId];
      if (!oldIncarnationAndVersion.incarnation.set.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.set.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.set;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BaseDefenseUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBaseDefenseUCMutSet[setId] =
            new VersionAndIncarnation<BaseDefenseUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

       
    public int GetTerrainTileByLocationMutMapHash(int id, int version, TerrainTileByLocationMutMapIncarnation incarnation) {
      int result = id * version;
      foreach (var entry in incarnation.map) {
        result += id * version * entry.Key.GetDeterministicHashCode() * entry.Value.GetDeterministicHashCode();
      }
      return result;
    }
    public TerrainTileByLocationMutMapIncarnation GetTerrainTileByLocationMutMapIncarnation(int id) {
      return rootIncarnation.incarnationsTerrainTileByLocationMutMap[id].incarnation;
    }
    public TerrainTileByLocationMutMap GetTerrainTileByLocationMutMap(int id) {
      return new TerrainTileByLocationMutMap(this, id);
    }
    public List<TerrainTileByLocationMutMap> AllTerrainTileByLocationMutMap() {
      List<TerrainTileByLocationMutMap> result = new List<TerrainTileByLocationMutMap>(rootIncarnation.incarnationsTerrainTileByLocationMutMap.Count);
      foreach (var id in rootIncarnation.incarnationsTerrainTileByLocationMutMap.Keys) {
        result.Add(new TerrainTileByLocationMutMap(this, id));
      }
      return result;
    }
    public bool TerrainTileByLocationMutMapExists(int id) {
      return rootIncarnation.incarnationsTerrainTileByLocationMutMap.ContainsKey(id);
    }
    public void CheckHasTerrainTileByLocationMutMap(TerrainTileByLocationMutMap thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasTerrainTileByLocationMutMap(thing.id);
    }
    public void CheckHasTerrainTileByLocationMutMap(int id) {
      if (!rootIncarnation.incarnationsTerrainTileByLocationMutMap.ContainsKey(id)) {
        throw new System.Exception("Invalid TerrainTileByLocationMutMap}: " + id);
      }
    }
    public TerrainTileByLocationMutMap EffectTerrainTileByLocationMutMapCreate() {
      return TrustedEffectTerrainTileByLocationMutMapCreateWithId(NewId());
    }
    public TerrainTileByLocationMutMap TrustedEffectTerrainTileByLocationMutMapCreateWithId(int id) {
      CheckUnlocked();
      Asserts.Assert(!rootIncarnation.incarnationsTerrainTileByLocationMutMap.ContainsKey(id));
      EffectInternalCreateTerrainTileByLocationMutMap(
          id,
          rootIncarnation.version,
          new TerrainTileByLocationMutMapIncarnation(
              new SortedDictionary<Location, int>()));
      return new TerrainTileByLocationMutMap(this, id);
    }
       
    public void EffectInternalCreateTerrainTileByLocationMutMap(int id, int incarnationVersion, TerrainTileByLocationMutMapIncarnation incarnation) {
      var effect = new TerrainTileByLocationMutMapCreateEffect(id);
      rootIncarnation.incarnationsTerrainTileByLocationMutMap
          .Add(
              id,
              new VersionAndIncarnation<TerrainTileByLocationMutMapIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectTerrainTileByLocationMutMapDelete(int id) {
      CheckUnlocked();
      var effect = new TerrainTileByLocationMutMapDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsTerrainTileByLocationMutMap[id];
      rootIncarnation.incarnationsTerrainTileByLocationMutMap.Remove(id);
    }
    public void EffectTerrainTileByLocationMutMapAdd(int mapId, Location key, int value) {
      CheckUnlocked();
      CheckHasTerrainTileByLocationMutMap(mapId);
      CheckHasTerrainTile(value);

      var effect = new TerrainTileByLocationMutMapAddEffect(mapId, key, value);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTerrainTileByLocationMutMap[mapId];
      if (oldIncarnationAndVersion.incarnation.map.ContainsKey(key)) {
        throw new Exception("Key exists! " + key);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.map.Add(key, value);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.map;
        var newMap = new SortedDictionary<Location, int>(oldMap);
        newMap.Add(key, value);
        var newIncarnation = new TerrainTileByLocationMutMapIncarnation(newMap);
        rootIncarnation.incarnationsTerrainTileByLocationMutMap[mapId] =
            new VersionAndIncarnation<TerrainTileByLocationMutMapIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
       
    public void EffectTerrainTileByLocationMutMapRemove(int mapId, Location key) {
      CheckUnlocked();
      CheckHasTerrainTileByLocationMutMap(mapId);

      var effect = new TerrainTileByLocationMutMapRemoveEffect(mapId, key);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsTerrainTileByLocationMutMap[mapId];
      if (!oldIncarnationAndVersion.incarnation.map.ContainsKey(key)) {
        throw new Exception("Key doesnt exist! " + key);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        var oldValue = oldIncarnationAndVersion.incarnation.map[key];
        oldIncarnationAndVersion.incarnation.map.Remove(key);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.map;
        var newMap = new SortedDictionary<Location, int>(oldMap);
        newMap.Remove(key);
        var newIncarnation = new TerrainTileByLocationMutMapIncarnation(newMap);
        rootIncarnation.incarnationsTerrainTileByLocationMutMap[mapId] =
            new VersionAndIncarnation<TerrainTileByLocationMutMapIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }

    public int GetKamikazeTargetTTCStrongByLocationMutMapHash(int id, int version, KamikazeTargetTTCStrongByLocationMutMapIncarnation incarnation) {
      int result = id * version;
      foreach (var entry in incarnation.map) {
        result += id * version * entry.Key.GetDeterministicHashCode() * entry.Value.GetDeterministicHashCode();
      }
      return result;
    }
    public KamikazeTargetTTCStrongByLocationMutMapIncarnation GetKamikazeTargetTTCStrongByLocationMutMapIncarnation(int id) {
      return rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap[id].incarnation;
    }
    public KamikazeTargetTTCStrongByLocationMutMap GetKamikazeTargetTTCStrongByLocationMutMap(int id) {
      return new KamikazeTargetTTCStrongByLocationMutMap(this, id);
    }
    public List<KamikazeTargetTTCStrongByLocationMutMap> AllKamikazeTargetTTCStrongByLocationMutMap() {
      List<KamikazeTargetTTCStrongByLocationMutMap> result = new List<KamikazeTargetTTCStrongByLocationMutMap>(rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap.Count);
      foreach (var id in rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap.Keys) {
        result.Add(new KamikazeTargetTTCStrongByLocationMutMap(this, id));
      }
      return result;
    }
    public bool KamikazeTargetTTCStrongByLocationMutMapExists(int id) {
      return rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap.ContainsKey(id);
    }
    public void CheckHasKamikazeTargetTTCStrongByLocationMutMap(KamikazeTargetTTCStrongByLocationMutMap thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasKamikazeTargetTTCStrongByLocationMutMap(thing.id);
    }
    public void CheckHasKamikazeTargetTTCStrongByLocationMutMap(int id) {
      if (!rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap.ContainsKey(id)) {
        throw new System.Exception("Invalid KamikazeTargetTTCStrongByLocationMutMap}: " + id);
      }
    }
    public KamikazeTargetTTCStrongByLocationMutMap EffectKamikazeTargetTTCStrongByLocationMutMapCreate() {
      return TrustedEffectKamikazeTargetTTCStrongByLocationMutMapCreateWithId(NewId());
    }
    public KamikazeTargetTTCStrongByLocationMutMap TrustedEffectKamikazeTargetTTCStrongByLocationMutMapCreateWithId(int id) {
      CheckUnlocked();
      Asserts.Assert(!rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap.ContainsKey(id));
      EffectInternalCreateKamikazeTargetTTCStrongByLocationMutMap(
          id,
          rootIncarnation.version,
          new KamikazeTargetTTCStrongByLocationMutMapIncarnation(
              new SortedDictionary<Location, int>()));
      return new KamikazeTargetTTCStrongByLocationMutMap(this, id);
    }
       
    public void EffectInternalCreateKamikazeTargetTTCStrongByLocationMutMap(int id, int incarnationVersion, KamikazeTargetTTCStrongByLocationMutMapIncarnation incarnation) {
      var effect = new KamikazeTargetTTCStrongByLocationMutMapCreateEffect(id);
      rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap
          .Add(
              id,
              new VersionAndIncarnation<KamikazeTargetTTCStrongByLocationMutMapIncarnation>(
                  incarnationVersion,
                  incarnation));
      NotifyEffect(effect);
    }
    public void EffectKamikazeTargetTTCStrongByLocationMutMapDelete(int id) {
      CheckUnlocked();
      var effect = new KamikazeTargetTTCStrongByLocationMutMapDeleteEffect(id);
      NotifyEffect(effect);
      var versionAndIncarnation = rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap[id];
      rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap.Remove(id);
    }
    public void EffectKamikazeTargetTTCStrongByLocationMutMapAdd(int mapId, Location key, int value) {
      CheckUnlocked();
      CheckHasKamikazeTargetTTCStrongByLocationMutMap(mapId);
      CheckHasKamikazeTargetTTC(value);

      var effect = new KamikazeTargetTTCStrongByLocationMutMapAddEffect(mapId, key, value);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap[mapId];
      if (oldIncarnationAndVersion.incarnation.map.ContainsKey(key)) {
        throw new Exception("Key exists! " + key);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.map.Add(key, value);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.map;
        var newMap = new SortedDictionary<Location, int>(oldMap);
        newMap.Add(key, value);
        var newIncarnation = new KamikazeTargetTTCStrongByLocationMutMapIncarnation(newMap);
        rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap[mapId] =
            new VersionAndIncarnation<KamikazeTargetTTCStrongByLocationMutMapIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      NotifyEffect(effect);
    }
       
    public void EffectKamikazeTargetTTCStrongByLocationMutMapRemove(int mapId, Location key) {
      CheckUnlocked();
      CheckHasKamikazeTargetTTCStrongByLocationMutMap(mapId);

      var effect = new KamikazeTargetTTCStrongByLocationMutMapRemoveEffect(mapId, key);

      var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap[mapId];
      if (!oldIncarnationAndVersion.incarnation.map.ContainsKey(key)) {
        throw new Exception("Key doesnt exist! " + key);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        var oldValue = oldIncarnationAndVersion.incarnation.map[key];
        oldIncarnationAndVersion.incarnation.map.Remove(key);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.map;
        var newMap = new SortedDictionary<Location, int>(oldMap);
        newMap.Remove(key);
        var newIncarnation = new KamikazeTargetTTCStrongByLocationMutMapIncarnation(newMap);
        rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap[mapId] =
            new VersionAndIncarnation<KamikazeTargetTTCStrongByLocationMutMapIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      NotifyEffect(effect);
    }
}

}
