using System;
using System.Collections;

using System.Collections.Generic;

namespace Atharia.Model {

public interface ILogger {
  void Info(string str);
  void Warning(string str);
  void Error(string str);
}

public struct VersionAndIncarnation<T> {
  public int version;
  public T incarnation;
  public VersionAndIncarnation(int version, T incarnation) {
    this.version = version;
    this.incarnation = incarnation;
  }
}

public delegate void IEffectObserver(IEffect effect);

public interface IEffect {
  // True for deletes/removes, false for creates/adds/sets.
  bool isSubtractive();
  void visitIEffect(IEffectVisitor visitor);
}

public interface IEffectVisitor {
void visitRandEffect(IRandEffect effect);
void visitHoldPositionImpulseEffect(IHoldPositionImpulseEffect effect);
void visitWanderAICapabilityUCEffect(IWanderAICapabilityUCEffect effect);
void visitTutorialDefyCounterUCEffect(ITutorialDefyCounterUCEffect effect);
void visitUnitEffect(IUnitEffect effect);
void visitIUnitComponentMutBunchEffect(IIUnitComponentMutBunchEffect effect);
void visitLightningChargedUCEffect(ILightningChargedUCEffect effect);
void visitLightningChargingUCEffect(ILightningChargingUCEffect effect);
void visitDoomedUCEffect(IDoomedUCEffect effect);
void visitTemporaryCloneImpulseEffect(ITemporaryCloneImpulseEffect effect);
void visitTemporaryCloneAICapabilityUCEffect(ITemporaryCloneAICapabilityUCEffect effect);
void visitDeathTriggerUCEffect(IDeathTriggerUCEffect effect);
void visitBequeathUCEffect(IBequeathUCEffect effect);
void visitSummonImpulseEffect(ISummonImpulseEffect effect);
void visitSummonAICapabilityUCEffect(ISummonAICapabilityUCEffect effect);
void visitSorcerousUCEffect(ISorcerousUCEffect effect);
void visitBaseOffenseUCEffect(IBaseOffenseUCEffect effect);
void visitBaseSightRangeUCEffect(IBaseSightRangeUCEffect effect);
void visitBaseMovementTimeUCEffect(IBaseMovementTimeUCEffect effect);
void visitBaseDefenseUCEffect(IBaseDefenseUCEffect effect);
void visitBaseCombatTimeUCEffect(IBaseCombatTimeUCEffect effect);
void visitMiredUCEffect(IMiredUCEffect effect);
void visitMireImpulseEffect(IMireImpulseEffect effect);
void visitEvaporateImpulseEffect(IEvaporateImpulseEffect effect);
void visitTimeCloneAICapabilityUCEffect(ITimeCloneAICapabilityUCEffect effect);
void visitMoveImpulseEffect(IMoveImpulseEffect effect);
void visitKamikazeTargetTTCEffect(IKamikazeTargetTTCEffect effect);
void visitKamikazeJumpImpulseEffect(IKamikazeJumpImpulseEffect effect);
void visitKamikazeTargetImpulseEffect(IKamikazeTargetImpulseEffect effect);
void visitKamikazeAICapabilityUCEffect(IKamikazeAICapabilityUCEffect effect);
void visitInvincibilityUCEffect(IInvincibilityUCEffect effect);
void visitGuardAICapabilityUCEffect(IGuardAICapabilityUCEffect effect);
void visitNoImpulseEffect(INoImpulseEffect effect);
void visitEvolvifyImpulseEffect(IEvolvifyImpulseEffect effect);
void visitEvolvifyAICapabilityUCEffect(IEvolvifyAICapabilityUCEffect effect);
void visitFireImpulseEffect(IFireImpulseEffect effect);
void visitOnFireUCEffect(IOnFireUCEffect effect);
void visitDefyingUCEffect(IDefyingUCEffect effect);
void visitDefyImpulseEffect(IDefyImpulseEffect effect);
void visitCounteringUCEffect(ICounteringUCEffect effect);
void visitCounterImpulseEffect(ICounterImpulseEffect effect);
void visitUnleashBideImpulseEffect(IUnleashBideImpulseEffect effect);
void visitContinueBidingImpulseEffect(IContinueBidingImpulseEffect effect);
void visitStartBidingImpulseEffect(IStartBidingImpulseEffect effect);
void visitBideAICapabilityUCEffect(IBideAICapabilityUCEffect effect);
void visitAttackImpulseEffect(IAttackImpulseEffect effect);
void visitPursueImpulseEffect(IPursueImpulseEffect effect);
void visitKillDirectiveEffect(IKillDirectiveEffect effect);
void visitAttackAICapabilityUCEffect(IAttackAICapabilityUCEffect effect);
void visitWarperTTCEffect(IWarperTTCEffect effect);
void visitTimeAnchorTTCEffect(ITimeAnchorTTCEffect effect);
void visitTerrainTileEffect(ITerrainTileEffect effect);
void visitITerrainTileComponentMutBunchEffect(IITerrainTileComponentMutBunchEffect effect);
void visitTerrainEffect(ITerrainEffect effect);
void visitSimplePresenceTriggerTTCEffect(ISimplePresenceTriggerTTCEffect effect);
void visitFireBombImpulseEffect(IFireBombImpulseEffect effect);
void visitFireBombTTCEffect(IFireBombTTCEffect effect);
void visitFlowerTTCEffect(IFlowerTTCEffect effect);
void visitLotusTTCEffect(ILotusTTCEffect effect);
void visitRoseTTCEffect(IRoseTTCEffect effect);
void visitLeafTTCEffect(ILeafTTCEffect effect);
void visitOnFireTTCEffect(IOnFireTTCEffect effect);
void visitMarkerTTCEffect(IMarkerTTCEffect effect);
void visitLevelLinkTTCEffect(ILevelLinkTTCEffect effect);
void visitMudTTCEffect(IMudTTCEffect effect);
void visitDirtTTCEffect(IDirtTTCEffect effect);
void visitObsidianTTCEffect(IObsidianTTCEffect effect);
void visitDownStairsTTCEffect(IDownStairsTTCEffect effect);
void visitUpStairsTTCEffect(IUpStairsTTCEffect effect);
void visitWallTTCEffect(IWallTTCEffect effect);
void visitBloodTTCEffect(IBloodTTCEffect effect);
void visitRocksTTCEffect(IRocksTTCEffect effect);
void visitTreeTTCEffect(ITreeTTCEffect effect);
void visitWaterTTCEffect(IWaterTTCEffect effect);
void visitFloorTTCEffect(IFloorTTCEffect effect);
void visitCaveWallTTCEffect(ICaveWallTTCEffect effect);
void visitCaveTTCEffect(ICaveTTCEffect effect);
void visitFallsTTCEffect(IFallsTTCEffect effect);
void visitObsidianFloorTTCEffect(IObsidianFloorTTCEffect effect);
void visitMagmaTTCEffect(IMagmaTTCEffect effect);
void visitCliffTTCEffect(ICliffTTCEffect effect);
void visitRavaNestTTCEffect(IRavaNestTTCEffect effect);
void visitCliffLandingTTCEffect(ICliffLandingTTCEffect effect);
void visitStoneTTCEffect(IStoneTTCEffect effect);
void visitGrassTTCEffect(IGrassTTCEffect effect);
void visitLevelEffect(ILevelEffect effect);
void visitSpeedRingEffect(ISpeedRingEffect effect);
void visitManaPotionEffect(IManaPotionEffect effect);
void visitWatEffect(IWatEffect effect);
void visitIPreActingUCWeakMutBunchEffect(IIPreActingUCWeakMutBunchEffect effect);
void visitIPostActingUCWeakMutBunchEffect(IIPostActingUCWeakMutBunchEffect effect);
void visitIImpulseStrongMutBunchEffect(IIImpulseStrongMutBunchEffect effect);
void visitIItemStrongMutBunchEffect(IIItemStrongMutBunchEffect effect);
void visitItemTTCEffect(IItemTTCEffect effect);
void visitHealthPotionEffect(IHealthPotionEffect effect);
void visitGlaiveEffect(IGlaiveEffect effect);
void visitSlowRodEffect(ISlowRodEffect effect);
void visitExplosionRodEffect(IExplosionRodEffect effect);
void visitBlazeRodEffect(IBlazeRodEffect effect);
void visitBlastRodEffect(IBlastRodEffect effect);
void visitArmorEffect(IArmorEffect effect);
void visitVolcaetusLevelControllerEffect(IVolcaetusLevelControllerEffect effect);
void visitTutorial2LevelControllerEffect(ITutorial2LevelControllerEffect effect);
void visitTutorial1LevelControllerEffect(ITutorial1LevelControllerEffect effect);
void visitRetreatLevelControllerEffect(IRetreatLevelControllerEffect effect);
void visitSotaventoLevelControllerEffect(ISotaventoLevelControllerEffect effect);
void visitNestLevelControllerEffect(INestLevelControllerEffect effect);
void visitLakeLevelControllerEffect(ILakeLevelControllerEffect effect);
void visitEmberDeepLevelLinkerTTCEffect(IEmberDeepLevelLinkerTTCEffect effect);
void visitDirtRoadLevelControllerEffect(IDirtRoadLevelControllerEffect effect);
void visitCaveLevelControllerEffect(ICaveLevelControllerEffect effect);
void visitBridgesLevelControllerEffect(IBridgesLevelControllerEffect effect);
void visitAncientTownLevelControllerEffect(IAncientTownLevelControllerEffect effect);
void visitSquareCaveLevelControllerEffect(ISquareCaveLevelControllerEffect effect);
void visitRavashrikeLevelControllerEffect(IRavashrikeLevelControllerEffect effect);
void visitPentagonalCaveLevelControllerEffect(IPentagonalCaveLevelControllerEffect effect);
void visitIncendianFallsLevelLinkerTTCEffect(IIncendianFallsLevelLinkerTTCEffect effect);
void visitCliffLevelControllerEffect(ICliffLevelControllerEffect effect);
void visitPreGauntletLevelControllerEffect(IPreGauntletLevelControllerEffect effect);
void visitGauntletLevelControllerEffect(IGauntletLevelControllerEffect effect);
void visitRavaArcanaLevelLinkerTTCEffect(IRavaArcanaLevelLinkerTTCEffect effect);
void visitJumpingCaveLevelControllerEffect(IJumpingCaveLevelControllerEffect effect);
void visitCommEffect(ICommEffect effect);
void visitGameEffect(IGameEffect effect);
void visitCommMutListEffect(ICommMutListEffect effect);
void visitLocationMutListEffect(ILocationMutListEffect effect);
void visitIRequestMutListEffect(IIRequestMutListEffect effect);
void visitLevelMutSetEffect(ILevelMutSetEffect effect);
void visitManaPotionStrongMutSetEffect(IManaPotionStrongMutSetEffect effect);
void visitHealthPotionStrongMutSetEffect(IHealthPotionStrongMutSetEffect effect);
void visitSpeedRingStrongMutSetEffect(ISpeedRingStrongMutSetEffect effect);
void visitGlaiveStrongMutSetEffect(IGlaiveStrongMutSetEffect effect);
void visitSlowRodStrongMutSetEffect(ISlowRodStrongMutSetEffect effect);
void visitExplosionRodStrongMutSetEffect(IExplosionRodStrongMutSetEffect effect);
void visitBlazeRodStrongMutSetEffect(IBlazeRodStrongMutSetEffect effect);
void visitBlastRodStrongMutSetEffect(IBlastRodStrongMutSetEffect effect);
void visitArmorStrongMutSetEffect(IArmorStrongMutSetEffect effect);
void visitHoldPositionImpulseStrongMutSetEffect(IHoldPositionImpulseStrongMutSetEffect effect);
void visitTemporaryCloneImpulseStrongMutSetEffect(ITemporaryCloneImpulseStrongMutSetEffect effect);
void visitSummonImpulseStrongMutSetEffect(ISummonImpulseStrongMutSetEffect effect);
void visitMireImpulseStrongMutSetEffect(IMireImpulseStrongMutSetEffect effect);
void visitEvaporateImpulseStrongMutSetEffect(IEvaporateImpulseStrongMutSetEffect effect);
void visitMoveImpulseStrongMutSetEffect(IMoveImpulseStrongMutSetEffect effect);
void visitKamikazeJumpImpulseStrongMutSetEffect(IKamikazeJumpImpulseStrongMutSetEffect effect);
void visitKamikazeTargetImpulseStrongMutSetEffect(IKamikazeTargetImpulseStrongMutSetEffect effect);
void visitNoImpulseStrongMutSetEffect(INoImpulseStrongMutSetEffect effect);
void visitEvolvifyImpulseStrongMutSetEffect(IEvolvifyImpulseStrongMutSetEffect effect);
void visitFireImpulseStrongMutSetEffect(IFireImpulseStrongMutSetEffect effect);
void visitDefyImpulseStrongMutSetEffect(IDefyImpulseStrongMutSetEffect effect);
void visitCounterImpulseStrongMutSetEffect(ICounterImpulseStrongMutSetEffect effect);
void visitUnleashBideImpulseStrongMutSetEffect(IUnleashBideImpulseStrongMutSetEffect effect);
void visitContinueBidingImpulseStrongMutSetEffect(IContinueBidingImpulseStrongMutSetEffect effect);
void visitStartBidingImpulseStrongMutSetEffect(IStartBidingImpulseStrongMutSetEffect effect);
void visitAttackImpulseStrongMutSetEffect(IAttackImpulseStrongMutSetEffect effect);
void visitPursueImpulseStrongMutSetEffect(IPursueImpulseStrongMutSetEffect effect);
void visitFireBombImpulseStrongMutSetEffect(IFireBombImpulseStrongMutSetEffect effect);
void visitLightningChargedUCWeakMutSetEffect(ILightningChargedUCWeakMutSetEffect effect);
void visitTimeCloneAICapabilityUCWeakMutSetEffect(ITimeCloneAICapabilityUCWeakMutSetEffect effect);
void visitDoomedUCWeakMutSetEffect(IDoomedUCWeakMutSetEffect effect);
void visitMiredUCWeakMutSetEffect(IMiredUCWeakMutSetEffect effect);
void visitInvincibilityUCWeakMutSetEffect(IInvincibilityUCWeakMutSetEffect effect);
void visitOnFireUCWeakMutSetEffect(IOnFireUCWeakMutSetEffect effect);
void visitDefyingUCWeakMutSetEffect(IDefyingUCWeakMutSetEffect effect);
void visitCounteringUCWeakMutSetEffect(ICounteringUCWeakMutSetEffect effect);
void visitAttackAICapabilityUCWeakMutSetEffect(IAttackAICapabilityUCWeakMutSetEffect effect);
void visitUnitMutSetEffect(IUnitMutSetEffect effect);
void visitSimplePresenceTriggerTTCMutSetEffect(ISimplePresenceTriggerTTCMutSetEffect effect);
void visitItemTTCMutSetEffect(IItemTTCMutSetEffect effect);
void visitFlowerTTCMutSetEffect(IFlowerTTCMutSetEffect effect);
void visitLotusTTCMutSetEffect(ILotusTTCMutSetEffect effect);
void visitRoseTTCMutSetEffect(IRoseTTCMutSetEffect effect);
void visitLeafTTCMutSetEffect(ILeafTTCMutSetEffect effect);
void visitKamikazeTargetTTCMutSetEffect(IKamikazeTargetTTCMutSetEffect effect);
void visitWarperTTCMutSetEffect(IWarperTTCMutSetEffect effect);
void visitTimeAnchorTTCMutSetEffect(ITimeAnchorTTCMutSetEffect effect);
void visitFireBombTTCMutSetEffect(IFireBombTTCMutSetEffect effect);
void visitOnFireTTCMutSetEffect(IOnFireTTCMutSetEffect effect);
void visitMarkerTTCMutSetEffect(IMarkerTTCMutSetEffect effect);
void visitLevelLinkTTCMutSetEffect(ILevelLinkTTCMutSetEffect effect);
void visitMudTTCMutSetEffect(IMudTTCMutSetEffect effect);
void visitDirtTTCMutSetEffect(IDirtTTCMutSetEffect effect);
void visitObsidianTTCMutSetEffect(IObsidianTTCMutSetEffect effect);
void visitDownStairsTTCMutSetEffect(IDownStairsTTCMutSetEffect effect);
void visitUpStairsTTCMutSetEffect(IUpStairsTTCMutSetEffect effect);
void visitWallTTCMutSetEffect(IWallTTCMutSetEffect effect);
void visitBloodTTCMutSetEffect(IBloodTTCMutSetEffect effect);
void visitRocksTTCMutSetEffect(IRocksTTCMutSetEffect effect);
void visitTreeTTCMutSetEffect(ITreeTTCMutSetEffect effect);
void visitWaterTTCMutSetEffect(IWaterTTCMutSetEffect effect);
void visitFloorTTCMutSetEffect(IFloorTTCMutSetEffect effect);
void visitCaveWallTTCMutSetEffect(ICaveWallTTCMutSetEffect effect);
void visitCaveTTCMutSetEffect(ICaveTTCMutSetEffect effect);
void visitFallsTTCMutSetEffect(IFallsTTCMutSetEffect effect);
void visitObsidianFloorTTCMutSetEffect(IObsidianFloorTTCMutSetEffect effect);
void visitMagmaTTCMutSetEffect(IMagmaTTCMutSetEffect effect);
void visitCliffTTCMutSetEffect(ICliffTTCMutSetEffect effect);
void visitRavaNestTTCMutSetEffect(IRavaNestTTCMutSetEffect effect);
void visitCliffLandingTTCMutSetEffect(ICliffLandingTTCMutSetEffect effect);
void visitStoneTTCMutSetEffect(IStoneTTCMutSetEffect effect);
void visitGrassTTCMutSetEffect(IGrassTTCMutSetEffect effect);
void visitEmberDeepLevelLinkerTTCMutSetEffect(IEmberDeepLevelLinkerTTCMutSetEffect effect);
void visitIncendianFallsLevelLinkerTTCMutSetEffect(IIncendianFallsLevelLinkerTTCMutSetEffect effect);
void visitRavaArcanaLevelLinkerTTCMutSetEffect(IRavaArcanaLevelLinkerTTCMutSetEffect effect);
void visitDeathTriggerUCMutSetEffect(IDeathTriggerUCMutSetEffect effect);
void visitBequeathUCMutSetEffect(IBequeathUCMutSetEffect effect);
void visitTutorialDefyCounterUCMutSetEffect(ITutorialDefyCounterUCMutSetEffect effect);
void visitLightningChargingUCMutSetEffect(ILightningChargingUCMutSetEffect effect);
void visitWanderAICapabilityUCMutSetEffect(IWanderAICapabilityUCMutSetEffect effect);
void visitTemporaryCloneAICapabilityUCMutSetEffect(ITemporaryCloneAICapabilityUCMutSetEffect effect);
void visitSummonAICapabilityUCMutSetEffect(ISummonAICapabilityUCMutSetEffect effect);
void visitKamikazeAICapabilityUCMutSetEffect(IKamikazeAICapabilityUCMutSetEffect effect);
void visitGuardAICapabilityUCMutSetEffect(IGuardAICapabilityUCMutSetEffect effect);
void visitEvolvifyAICapabilityUCMutSetEffect(IEvolvifyAICapabilityUCMutSetEffect effect);
void visitTimeCloneAICapabilityUCMutSetEffect(ITimeCloneAICapabilityUCMutSetEffect effect);
void visitDoomedUCMutSetEffect(IDoomedUCMutSetEffect effect);
void visitMiredUCMutSetEffect(IMiredUCMutSetEffect effect);
void visitOnFireUCMutSetEffect(IOnFireUCMutSetEffect effect);
void visitAttackAICapabilityUCMutSetEffect(IAttackAICapabilityUCMutSetEffect effect);
void visitCounteringUCMutSetEffect(ICounteringUCMutSetEffect effect);
void visitLightningChargedUCMutSetEffect(ILightningChargedUCMutSetEffect effect);
void visitInvincibilityUCMutSetEffect(IInvincibilityUCMutSetEffect effect);
void visitDefyingUCMutSetEffect(IDefyingUCMutSetEffect effect);
void visitBideAICapabilityUCMutSetEffect(IBideAICapabilityUCMutSetEffect effect);
void visitBaseSightRangeUCMutSetEffect(IBaseSightRangeUCMutSetEffect effect);
void visitBaseMovementTimeUCMutSetEffect(IBaseMovementTimeUCMutSetEffect effect);
void visitBaseCombatTimeUCMutSetEffect(IBaseCombatTimeUCMutSetEffect effect);
void visitManaPotionMutSetEffect(IManaPotionMutSetEffect effect);
void visitHealthPotionMutSetEffect(IHealthPotionMutSetEffect effect);
void visitSpeedRingMutSetEffect(ISpeedRingMutSetEffect effect);
void visitGlaiveMutSetEffect(IGlaiveMutSetEffect effect);
void visitSlowRodMutSetEffect(ISlowRodMutSetEffect effect);
void visitExplosionRodMutSetEffect(IExplosionRodMutSetEffect effect);
void visitBlazeRodMutSetEffect(IBlazeRodMutSetEffect effect);
void visitBlastRodMutSetEffect(IBlastRodMutSetEffect effect);
void visitArmorMutSetEffect(IArmorMutSetEffect effect);
void visitSorcerousUCMutSetEffect(ISorcerousUCMutSetEffect effect);
void visitBaseOffenseUCMutSetEffect(IBaseOffenseUCMutSetEffect effect);
void visitBaseDefenseUCMutSetEffect(IBaseDefenseUCMutSetEffect effect);
void visitTerrainTileByLocationMutMapEffect(ITerrainTileByLocationMutMapEffect effect);
void visitKamikazeTargetTTCStrongByLocationMutMapEffect(IKamikazeTargetTTCStrongByLocationMutMapEffect effect);

}

public class Root {
  private static readonly int VERSION_HASH_MULTIPLIER = 179424673;
  private static readonly int NEXT_ID_HASH_MULTIPLIER = 373587883;

  private void CheckRootsEqual(Root a, Root b) {
    if (a != b) {
      throw new System.Exception("Given objects aren't from the same root!");
    }
  }

  public readonly ILogger logger;

  public List<IEffectObserver> effectObservers;

  // This *always* points to a live RootIncarnation. When we snapshot, we eagerly
  // make a new one of these.
  private RootIncarnation rootIncarnation;

  bool locked;

  // 0 means everything
  public Root(ILogger logger) {
    this.logger = logger;
    this.effectObservers = new List<IEffectObserver>();
    int initialVersion = 1;
    int initialNextId = 1;
    int initialHash = VERSION_HASH_MULTIPLIER * initialVersion + NEXT_ID_HASH_MULTIPLIER * initialNextId;
    rootIncarnation = new RootIncarnation(initialVersion, initialNextId, initialHash);
    this.locked = true;
  }

  public Root(ILogger logger, RootIncarnation rootIncarnation) {
    this.logger = logger;
    this.rootIncarnation = rootIncarnation;
    this.locked = false;
    this.Snapshot();
    this.locked = true;
  }

  public int nextId { get { return rootIncarnation.nextId; } }

  public int version { get { return rootIncarnation.version; } }

  public void AddObserver(IEffectObserver obs) {
    effectObservers.Add(obs);
  }

  public void RemoveObserver(IEffectObserver obs) {
    effectObservers.Remove(obs);
  }

  private void NotifyEffect(IEffect effect) {
    foreach (var obs in effectObservers) {
      obs(effect);
    }
  }

  public RootIncarnation Snapshot() {
    CheckUnlocked();
    RootIncarnation oldIncarnation = rootIncarnation;
    int newHash = oldIncarnation.hash;
    int newVersion = oldIncarnation.version + 1;
    rootIncarnation =
        new RootIncarnation(
            newVersion, oldIncarnation.nextId, newHash, oldIncarnation);
    return oldIncarnation;
  }

  public delegate T ITransaction<T>();

  public (List<IEffect>, T) Transact<T>(ITransaction<T> transaction) {
    var stopwatch = new System.Diagnostics.Stopwatch();
    stopwatch.Start();

    if (!locked) {
      throw new Exception("Can't unlock, not locked!");
    }
    locked = false;
    // var rollbackPoint = Snapshot();

    var effects = new List<IEffect>();
    IEffectObserver effectObserver = (effect) => effects.Add(effect);
    AddObserver(effectObserver);

    try {
      var result = transaction();
      return (effects, result);
    } catch (Exception e) {
      // logger.Error("Rolling back because of error: " + e.Message + "\n" + e.StackTrace);
      // Revert(rollbackPoint);
      logger.Error("Encountered error in transaction: " + e.Message + "\n" + e.StackTrace);
      throw;
    } finally {
      RemoveObserver(effectObserver);
      if (locked) {
        logger.Error("Can't lock, already locked!");
        Environment.Exit(1);
      }
      locked = true;
      // CheckForViolations();

      stopwatch.Stop();
      var calculationDuration = stopwatch.Elapsed.TotalMilliseconds;

      // logger.Info("Transaction run time " + calculationDuration + "ms");
    }
  }

  public void CheckUnlocked() {
    if (locked) {
      throw new Exception("Can't proceed, superstructure is locked!");
    }
  }

  private int NewId() {
    this.UpdateHashOnNextIdChange(rootIncarnation.nextId, rootIncarnation.nextId + 1);
    return rootIncarnation.nextId++;
  }

  private void UpdateHashOnNextIdChange(int oldNextId, int newNextId) {
    int oldIdAndVersionHashContribution =
        VERSION_HASH_MULTIPLIER * rootIncarnation.version +
        NEXT_ID_HASH_MULTIPLIER * oldNextId;
    int newIdAndVersionHashContribution =
        VERSION_HASH_MULTIPLIER * rootIncarnation.version +
        NEXT_ID_HASH_MULTIPLIER * newNextId;
    rootIncarnation.hash =
        rootIncarnation.hash -
        oldIdAndVersionHashContribution +
        newIdAndVersionHashContribution;
  }

  private int RecalculateEntireHash() {
    int result =
        VERSION_HASH_MULTIPLIER * rootIncarnation.version +
        NEXT_ID_HASH_MULTIPLIER * rootIncarnation.nextId;

    foreach (var entry in this.rootIncarnation.incarnationsRand) {
      result += GetRandHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsHoldPositionImpulse) {
      result += GetHoldPositionImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWanderAICapabilityUC) {
      result += GetWanderAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTutorialDefyCounterUC) {
      result += GetTutorialDefyCounterUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsUnit) {
      result += GetUnitHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIUnitComponentMutBunch) {
      result += GetIUnitComponentMutBunchHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLightningChargedUC) {
      result += GetLightningChargedUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLightningChargingUC) {
      result += GetLightningChargingUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDoomedUC) {
      result += GetDoomedUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTemporaryCloneImpulse) {
      result += GetTemporaryCloneImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTemporaryCloneAICapabilityUC) {
      result += GetTemporaryCloneAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDeathTriggerUC) {
      result += GetDeathTriggerUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBequeathUC) {
      result += GetBequeathUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSummonImpulse) {
      result += GetSummonImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSummonAICapabilityUC) {
      result += GetSummonAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSorcerousUC) {
      result += GetSorcerousUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBaseOffenseUC) {
      result += GetBaseOffenseUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBaseSightRangeUC) {
      result += GetBaseSightRangeUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBaseMovementTimeUC) {
      result += GetBaseMovementTimeUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBaseDefenseUC) {
      result += GetBaseDefenseUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBaseCombatTimeUC) {
      result += GetBaseCombatTimeUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMiredUC) {
      result += GetMiredUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMireImpulse) {
      result += GetMireImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsEvaporateImpulse) {
      result += GetEvaporateImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTimeCloneAICapabilityUC) {
      result += GetTimeCloneAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMoveImpulse) {
      result += GetMoveImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKamikazeTargetTTC) {
      result += GetKamikazeTargetTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKamikazeJumpImpulse) {
      result += GetKamikazeJumpImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKamikazeTargetImpulse) {
      result += GetKamikazeTargetImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKamikazeAICapabilityUC) {
      result += GetKamikazeAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsInvincibilityUC) {
      result += GetInvincibilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGuardAICapabilityUC) {
      result += GetGuardAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsNoImpulse) {
      result += GetNoImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsEvolvifyImpulse) {
      result += GetEvolvifyImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsEvolvifyAICapabilityUC) {
      result += GetEvolvifyAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFireImpulse) {
      result += GetFireImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsOnFireUC) {
      result += GetOnFireUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDefyingUC) {
      result += GetDefyingUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDefyImpulse) {
      result += GetDefyImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCounteringUC) {
      result += GetCounteringUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCounterImpulse) {
      result += GetCounterImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsUnleashBideImpulse) {
      result += GetUnleashBideImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsContinueBidingImpulse) {
      result += GetContinueBidingImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsStartBidingImpulse) {
      result += GetStartBidingImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBideAICapabilityUC) {
      result += GetBideAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsAttackImpulse) {
      result += GetAttackImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsPursueImpulse) {
      result += GetPursueImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKillDirective) {
      result += GetKillDirectiveHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsAttackAICapabilityUC) {
      result += GetAttackAICapabilityUCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWarperTTC) {
      result += GetWarperTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTimeAnchorTTC) {
      result += GetTimeAnchorTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTerrainTile) {
      result += GetTerrainTileHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsITerrainTileComponentMutBunch) {
      result += GetITerrainTileComponentMutBunchHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTerrain) {
      result += GetTerrainHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSimplePresenceTriggerTTC) {
      result += GetSimplePresenceTriggerTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFireBombImpulse) {
      result += GetFireBombImpulseHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFireBombTTC) {
      result += GetFireBombTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFlowerTTC) {
      result += GetFlowerTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLotusTTC) {
      result += GetLotusTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRoseTTC) {
      result += GetRoseTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLeafTTC) {
      result += GetLeafTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsOnFireTTC) {
      result += GetOnFireTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMarkerTTC) {
      result += GetMarkerTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLevelLinkTTC) {
      result += GetLevelLinkTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMudTTC) {
      result += GetMudTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDirtTTC) {
      result += GetDirtTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsObsidianTTC) {
      result += GetObsidianTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDownStairsTTC) {
      result += GetDownStairsTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsUpStairsTTC) {
      result += GetUpStairsTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWallTTC) {
      result += GetWallTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBloodTTC) {
      result += GetBloodTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRocksTTC) {
      result += GetRocksTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTreeTTC) {
      result += GetTreeTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWaterTTC) {
      result += GetWaterTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFloorTTC) {
      result += GetFloorTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCaveWallTTC) {
      result += GetCaveWallTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCaveTTC) {
      result += GetCaveTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFallsTTC) {
      result += GetFallsTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsObsidianFloorTTC) {
      result += GetObsidianFloorTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMagmaTTC) {
      result += GetMagmaTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCliffTTC) {
      result += GetCliffTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRavaNestTTC) {
      result += GetRavaNestTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCliffLandingTTC) {
      result += GetCliffLandingTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsStoneTTC) {
      result += GetStoneTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGrassTTC) {
      result += GetGrassTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLevel) {
      result += GetLevelHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSpeedRing) {
      result += GetSpeedRingHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsManaPotion) {
      result += GetManaPotionHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWat) {
      result += GetWatHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIPreActingUCWeakMutBunch) {
      result += GetIPreActingUCWeakMutBunchHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIPostActingUCWeakMutBunch) {
      result += GetIPostActingUCWeakMutBunchHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIImpulseStrongMutBunch) {
      result += GetIImpulseStrongMutBunchHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIItemStrongMutBunch) {
      result += GetIItemStrongMutBunchHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsItemTTC) {
      result += GetItemTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsHealthPotion) {
      result += GetHealthPotionHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGlaive) {
      result += GetGlaiveHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSlowRod) {
      result += GetSlowRodHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsExplosionRod) {
      result += GetExplosionRodHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBlazeRod) {
      result += GetBlazeRodHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBlastRod) {
      result += GetBlastRodHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsArmor) {
      result += GetArmorHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsVolcaetusLevelController) {
      result += GetVolcaetusLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTutorial2LevelController) {
      result += GetTutorial2LevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTutorial1LevelController) {
      result += GetTutorial1LevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRetreatLevelController) {
      result += GetRetreatLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSotaventoLevelController) {
      result += GetSotaventoLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsNestLevelController) {
      result += GetNestLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLakeLevelController) {
      result += GetLakeLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsEmberDeepLevelLinkerTTC) {
      result += GetEmberDeepLevelLinkerTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDirtRoadLevelController) {
      result += GetDirtRoadLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCaveLevelController) {
      result += GetCaveLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBridgesLevelController) {
      result += GetBridgesLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsAncientTownLevelController) {
      result += GetAncientTownLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSquareCaveLevelController) {
      result += GetSquareCaveLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRavashrikeLevelController) {
      result += GetRavashrikeLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsPentagonalCaveLevelController) {
      result += GetPentagonalCaveLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC) {
      result += GetIncendianFallsLevelLinkerTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCliffLevelController) {
      result += GetCliffLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsPreGauntletLevelController) {
      result += GetPreGauntletLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGauntletLevelController) {
      result += GetGauntletLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC) {
      result += GetRavaArcanaLevelLinkerTTCHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsJumpingCaveLevelController) {
      result += GetJumpingCaveLevelControllerHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsComm) {
      result += GetCommHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGame) {
      result += GetGameHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCommMutList) {
      result += GetCommMutListHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLocationMutList) {
      result += GetLocationMutListHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIRequestMutList) {
      result += GetIRequestMutListHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLevelMutSet) {
      result += GetLevelMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsManaPotionStrongMutSet) {
      result += GetManaPotionStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsHealthPotionStrongMutSet) {
      result += GetHealthPotionStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSpeedRingStrongMutSet) {
      result += GetSpeedRingStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGlaiveStrongMutSet) {
      result += GetGlaiveStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSlowRodStrongMutSet) {
      result += GetSlowRodStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsExplosionRodStrongMutSet) {
      result += GetExplosionRodStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBlazeRodStrongMutSet) {
      result += GetBlazeRodStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBlastRodStrongMutSet) {
      result += GetBlastRodStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsArmorStrongMutSet) {
      result += GetArmorStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet) {
      result += GetHoldPositionImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet) {
      result += GetTemporaryCloneImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSummonImpulseStrongMutSet) {
      result += GetSummonImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMireImpulseStrongMutSet) {
      result += GetMireImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsEvaporateImpulseStrongMutSet) {
      result += GetEvaporateImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMoveImpulseStrongMutSet) {
      result += GetMoveImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet) {
      result += GetKamikazeJumpImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet) {
      result += GetKamikazeTargetImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsNoImpulseStrongMutSet) {
      result += GetNoImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsEvolvifyImpulseStrongMutSet) {
      result += GetEvolvifyImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFireImpulseStrongMutSet) {
      result += GetFireImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDefyImpulseStrongMutSet) {
      result += GetDefyImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCounterImpulseStrongMutSet) {
      result += GetCounterImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet) {
      result += GetUnleashBideImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet) {
      result += GetContinueBidingImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsStartBidingImpulseStrongMutSet) {
      result += GetStartBidingImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsAttackImpulseStrongMutSet) {
      result += GetAttackImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsPursueImpulseStrongMutSet) {
      result += GetPursueImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFireBombImpulseStrongMutSet) {
      result += GetFireBombImpulseStrongMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLightningChargedUCWeakMutSet) {
      result += GetLightningChargedUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet) {
      result += GetTimeCloneAICapabilityUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDoomedUCWeakMutSet) {
      result += GetDoomedUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMiredUCWeakMutSet) {
      result += GetMiredUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsInvincibilityUCWeakMutSet) {
      result += GetInvincibilityUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsOnFireUCWeakMutSet) {
      result += GetOnFireUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDefyingUCWeakMutSet) {
      result += GetDefyingUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCounteringUCWeakMutSet) {
      result += GetCounteringUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet) {
      result += GetAttackAICapabilityUCWeakMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsUnitMutSet) {
      result += GetUnitMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet) {
      result += GetSimplePresenceTriggerTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsItemTTCMutSet) {
      result += GetItemTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFlowerTTCMutSet) {
      result += GetFlowerTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLotusTTCMutSet) {
      result += GetLotusTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRoseTTCMutSet) {
      result += GetRoseTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLeafTTCMutSet) {
      result += GetLeafTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKamikazeTargetTTCMutSet) {
      result += GetKamikazeTargetTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWarperTTCMutSet) {
      result += GetWarperTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTimeAnchorTTCMutSet) {
      result += GetTimeAnchorTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFireBombTTCMutSet) {
      result += GetFireBombTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsOnFireTTCMutSet) {
      result += GetOnFireTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMarkerTTCMutSet) {
      result += GetMarkerTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLevelLinkTTCMutSet) {
      result += GetLevelLinkTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMudTTCMutSet) {
      result += GetMudTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDirtTTCMutSet) {
      result += GetDirtTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsObsidianTTCMutSet) {
      result += GetObsidianTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDownStairsTTCMutSet) {
      result += GetDownStairsTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsUpStairsTTCMutSet) {
      result += GetUpStairsTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWallTTCMutSet) {
      result += GetWallTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBloodTTCMutSet) {
      result += GetBloodTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRocksTTCMutSet) {
      result += GetRocksTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTreeTTCMutSet) {
      result += GetTreeTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWaterTTCMutSet) {
      result += GetWaterTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFloorTTCMutSet) {
      result += GetFloorTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCaveWallTTCMutSet) {
      result += GetCaveWallTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCaveTTCMutSet) {
      result += GetCaveTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsFallsTTCMutSet) {
      result += GetFallsTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsObsidianFloorTTCMutSet) {
      result += GetObsidianFloorTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMagmaTTCMutSet) {
      result += GetMagmaTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCliffTTCMutSet) {
      result += GetCliffTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRavaNestTTCMutSet) {
      result += GetRavaNestTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCliffLandingTTCMutSet) {
      result += GetCliffLandingTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsStoneTTCMutSet) {
      result += GetStoneTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGrassTTCMutSet) {
      result += GetGrassTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet) {
      result += GetEmberDeepLevelLinkerTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet) {
      result += GetIncendianFallsLevelLinkerTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet) {
      result += GetRavaArcanaLevelLinkerTTCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDeathTriggerUCMutSet) {
      result += GetDeathTriggerUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBequeathUCMutSet) {
      result += GetBequeathUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTutorialDefyCounterUCMutSet) {
      result += GetTutorialDefyCounterUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLightningChargingUCMutSet) {
      result += GetLightningChargingUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsWanderAICapabilityUCMutSet) {
      result += GetWanderAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet) {
      result += GetTemporaryCloneAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSummonAICapabilityUCMutSet) {
      result += GetSummonAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet) {
      result += GetKamikazeAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGuardAICapabilityUCMutSet) {
      result += GetGuardAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsEvolvifyAICapabilityUCMutSet) {
      result += GetEvolvifyAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet) {
      result += GetTimeCloneAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDoomedUCMutSet) {
      result += GetDoomedUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsMiredUCMutSet) {
      result += GetMiredUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsOnFireUCMutSet) {
      result += GetOnFireUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsAttackAICapabilityUCMutSet) {
      result += GetAttackAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsCounteringUCMutSet) {
      result += GetCounteringUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsLightningChargedUCMutSet) {
      result += GetLightningChargedUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsInvincibilityUCMutSet) {
      result += GetInvincibilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsDefyingUCMutSet) {
      result += GetDefyingUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBideAICapabilityUCMutSet) {
      result += GetBideAICapabilityUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBaseSightRangeUCMutSet) {
      result += GetBaseSightRangeUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBaseMovementTimeUCMutSet) {
      result += GetBaseMovementTimeUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBaseCombatTimeUCMutSet) {
      result += GetBaseCombatTimeUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsManaPotionMutSet) {
      result += GetManaPotionMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsHealthPotionMutSet) {
      result += GetHealthPotionMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSpeedRingMutSet) {
      result += GetSpeedRingMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsGlaiveMutSet) {
      result += GetGlaiveMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSlowRodMutSet) {
      result += GetSlowRodMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsExplosionRodMutSet) {
      result += GetExplosionRodMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBlazeRodMutSet) {
      result += GetBlazeRodMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBlastRodMutSet) {
      result += GetBlastRodMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsArmorMutSet) {
      result += GetArmorMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsSorcerousUCMutSet) {
      result += GetSorcerousUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBaseOffenseUCMutSet) {
      result += GetBaseOffenseUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsBaseDefenseUCMutSet) {
      result += GetBaseDefenseUCMutSetHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsTerrainTileByLocationMutMap) {
      result += GetTerrainTileByLocationMutMapHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    foreach (var entry in this.rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap) {
      result += GetKamikazeTargetTTCStrongByLocationMutMapHash(entry.Key, entry.Value.version, entry.Value.incarnation);
    }
    return result;
  }

  public void CheckForViolations() {
    List<string> violations = new List<string>();

    foreach (var obj in this.AllRand()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllHoldPositionImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWanderAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTutorialDefyCounterUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllUnit()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIUnitComponentMutBunch()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLightningChargedUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLightningChargingUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDoomedUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTemporaryCloneImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTemporaryCloneAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDeathTriggerUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBequeathUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSummonImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSummonAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSorcerousUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBaseOffenseUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBaseSightRangeUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBaseMovementTimeUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBaseDefenseUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBaseCombatTimeUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMiredUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMireImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllEvaporateImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTimeCloneAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMoveImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKamikazeTargetTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKamikazeJumpImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKamikazeTargetImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKamikazeAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllInvincibilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGuardAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllNoImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllEvolvifyImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllEvolvifyAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFireImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllOnFireUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDefyingUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDefyImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCounteringUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCounterImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllUnleashBideImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllContinueBidingImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllStartBidingImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBideAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllAttackImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllPursueImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKillDirective()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllAttackAICapabilityUC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWarperTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTimeAnchorTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTerrainTile()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllITerrainTileComponentMutBunch()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTerrain()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSimplePresenceTriggerTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFireBombImpulse()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFireBombTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFlowerTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLotusTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRoseTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLeafTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllOnFireTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMarkerTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLevelLinkTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMudTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDirtTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllObsidianTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDownStairsTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllUpStairsTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWallTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBloodTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRocksTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTreeTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWaterTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFloorTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCaveWallTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCaveTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFallsTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllObsidianFloorTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMagmaTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCliffTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRavaNestTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCliffLandingTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllStoneTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGrassTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLevel()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSpeedRing()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllManaPotion()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWat()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIPreActingUCWeakMutBunch()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIPostActingUCWeakMutBunch()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIImpulseStrongMutBunch()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIItemStrongMutBunch()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllItemTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllHealthPotion()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGlaive()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSlowRod()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllExplosionRod()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBlazeRod()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBlastRod()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllArmor()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllVolcaetusLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTutorial2LevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTutorial1LevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRetreatLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSotaventoLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllNestLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLakeLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllEmberDeepLevelLinkerTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDirtRoadLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCaveLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBridgesLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllAncientTownLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSquareCaveLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRavashrikeLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllPentagonalCaveLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIncendianFallsLevelLinkerTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCliffLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllPreGauntletLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGauntletLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRavaArcanaLevelLinkerTTC()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllJumpingCaveLevelController()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllComm()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGame()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCommMutList()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLocationMutList()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIRequestMutList()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLevelMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllManaPotionStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllHealthPotionStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSpeedRingStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGlaiveStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSlowRodStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllExplosionRodStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBlazeRodStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBlastRodStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllArmorStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllHoldPositionImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTemporaryCloneImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSummonImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMireImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllEvaporateImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMoveImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKamikazeJumpImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKamikazeTargetImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllNoImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllEvolvifyImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFireImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDefyImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCounterImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllUnleashBideImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllContinueBidingImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllStartBidingImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllAttackImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllPursueImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFireBombImpulseStrongMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLightningChargedUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTimeCloneAICapabilityUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDoomedUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMiredUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllInvincibilityUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllOnFireUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDefyingUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCounteringUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllAttackAICapabilityUCWeakMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllUnitMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSimplePresenceTriggerTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllItemTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFlowerTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLotusTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRoseTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLeafTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKamikazeTargetTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWarperTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTimeAnchorTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFireBombTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllOnFireTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMarkerTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLevelLinkTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMudTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDirtTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllObsidianTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDownStairsTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllUpStairsTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWallTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBloodTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRocksTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTreeTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWaterTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFloorTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCaveWallTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCaveTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllFallsTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllObsidianFloorTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMagmaTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCliffTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRavaNestTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCliffLandingTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllStoneTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGrassTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllEmberDeepLevelLinkerTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllIncendianFallsLevelLinkerTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllRavaArcanaLevelLinkerTTCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDeathTriggerUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBequeathUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTutorialDefyCounterUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLightningChargingUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllWanderAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTemporaryCloneAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSummonAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKamikazeAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGuardAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllEvolvifyAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTimeCloneAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDoomedUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllMiredUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllOnFireUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllAttackAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllCounteringUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllLightningChargedUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllInvincibilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllDefyingUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBideAICapabilityUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBaseSightRangeUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBaseMovementTimeUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBaseCombatTimeUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllManaPotionMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllHealthPotionMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSpeedRingMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllGlaiveMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSlowRodMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllExplosionRodMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBlazeRodMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBlastRodMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllArmorMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllSorcerousUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBaseOffenseUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllBaseDefenseUCMutSet()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllTerrainTileByLocationMutMap()) {
      obj.CheckForNullViolations(violations);
    }
    foreach (var obj in this.AllKamikazeTargetTTCStrongByLocationMutMap()) {
      obj.CheckForNullViolations(violations);
    }

    SortedSet<int> reachableIds = new SortedSet<int>();
    foreach (var rootStruct in this.AllGame()) {
      rootStruct.FindReachableObjects(reachableIds);
    }
    foreach (var obj in this.AllRand()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllHoldPositionImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWanderAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTutorialDefyCounterUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllUnit()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIUnitComponentMutBunch()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLightningChargedUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLightningChargingUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDoomedUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTemporaryCloneImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTemporaryCloneAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDeathTriggerUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBequeathUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSummonImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSummonAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSorcerousUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBaseOffenseUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBaseSightRangeUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBaseMovementTimeUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBaseDefenseUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBaseCombatTimeUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMiredUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMireImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllEvaporateImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTimeCloneAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMoveImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKamikazeTargetTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKamikazeJumpImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKamikazeTargetImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKamikazeAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllInvincibilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGuardAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllNoImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllEvolvifyImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllEvolvifyAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFireImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllOnFireUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDefyingUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDefyImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCounteringUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCounterImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllUnleashBideImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllContinueBidingImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllStartBidingImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBideAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllAttackImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllPursueImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKillDirective()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllAttackAICapabilityUC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWarperTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTimeAnchorTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTerrainTile()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllITerrainTileComponentMutBunch()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTerrain()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSimplePresenceTriggerTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFireBombImpulse()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFireBombTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFlowerTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLotusTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRoseTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLeafTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllOnFireTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMarkerTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLevelLinkTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMudTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDirtTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllObsidianTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDownStairsTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllUpStairsTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWallTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBloodTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRocksTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTreeTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWaterTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFloorTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCaveWallTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCaveTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFallsTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllObsidianFloorTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMagmaTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCliffTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRavaNestTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCliffLandingTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllStoneTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGrassTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLevel()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSpeedRing()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllManaPotion()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWat()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIPreActingUCWeakMutBunch()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIPostActingUCWeakMutBunch()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIImpulseStrongMutBunch()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIItemStrongMutBunch()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllItemTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllHealthPotion()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGlaive()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSlowRod()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllExplosionRod()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBlazeRod()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBlastRod()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllArmor()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllVolcaetusLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTutorial2LevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTutorial1LevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRetreatLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSotaventoLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllNestLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLakeLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllEmberDeepLevelLinkerTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDirtRoadLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCaveLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBridgesLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllAncientTownLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSquareCaveLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRavashrikeLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllPentagonalCaveLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIncendianFallsLevelLinkerTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCliffLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllPreGauntletLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGauntletLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRavaArcanaLevelLinkerTTC()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllJumpingCaveLevelController()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllComm()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGame()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCommMutList()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLocationMutList()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIRequestMutList()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLevelMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllManaPotionStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllHealthPotionStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSpeedRingStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGlaiveStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSlowRodStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllExplosionRodStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBlazeRodStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBlastRodStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllArmorStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllHoldPositionImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTemporaryCloneImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSummonImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMireImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllEvaporateImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMoveImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKamikazeJumpImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKamikazeTargetImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllNoImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllEvolvifyImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFireImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDefyImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCounterImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllUnleashBideImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllContinueBidingImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllStartBidingImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllAttackImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllPursueImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFireBombImpulseStrongMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLightningChargedUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTimeCloneAICapabilityUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDoomedUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMiredUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllInvincibilityUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllOnFireUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDefyingUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCounteringUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllAttackAICapabilityUCWeakMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllUnitMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSimplePresenceTriggerTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllItemTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFlowerTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLotusTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRoseTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLeafTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKamikazeTargetTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWarperTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTimeAnchorTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFireBombTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllOnFireTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMarkerTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLevelLinkTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMudTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDirtTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllObsidianTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDownStairsTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllUpStairsTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWallTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBloodTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRocksTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTreeTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWaterTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFloorTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCaveWallTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCaveTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllFallsTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllObsidianFloorTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMagmaTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCliffTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRavaNestTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCliffLandingTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllStoneTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGrassTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllEmberDeepLevelLinkerTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllIncendianFallsLevelLinkerTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllRavaArcanaLevelLinkerTTCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDeathTriggerUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBequeathUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTutorialDefyCounterUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLightningChargingUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllWanderAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTemporaryCloneAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSummonAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKamikazeAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGuardAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllEvolvifyAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTimeCloneAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDoomedUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllMiredUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllOnFireUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllAttackAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllCounteringUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllLightningChargedUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllInvincibilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllDefyingUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBideAICapabilityUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBaseSightRangeUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBaseMovementTimeUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBaseCombatTimeUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllManaPotionMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllHealthPotionMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSpeedRingMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllGlaiveMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSlowRodMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllExplosionRodMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBlazeRodMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBlastRodMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllArmorMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllSorcerousUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBaseOffenseUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllBaseDefenseUCMutSet()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllTerrainTileByLocationMutMap()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }
    foreach (var obj in this.AllKamikazeTargetTTCStrongByLocationMutMap()) {
      if (!reachableIds.Contains(obj.id)) {
        violations.Add("Unreachable: " + obj + "#" + obj.id);
      }
    }

    if (violations.Count > 0) {
      string message = "Found violations!\n";
      foreach (var violation in violations) {
        message += violation + "\n";
      }
      throw new Exception(message);
    }
  }

  public int GetDeterministicHashCode() {
    // int doubleCheckHash = RecalculateEntireHash();
    // Asserts.Assert(doubleCheckHash == this.rootIncarnation.hash);
    return this.rootIncarnation.hash;
  }

  public void Revert(RootIncarnation sourceIncarnation) {
    CheckUnlocked();
    // We do all the adds first so that we don't violate any strong borrows.
    // Then we do all the changes, because those might be flipping things to point
    // at things that were just made.
    // Then we do all the removes.

    // We collect these and then flush them at the end, because there are some
    // cases where we want to fill different kinds of events at the same time.
    // For example, when creating a set that was in the sourceIncarnation but
    // not in the current one, we want to reuse the set's incarnation, which
    // is a create and a bunch of adds. We populate both those at the same time,
    // and then flush all the creates before all the adds.
    var createEffects = new List<IEffect>();
    var addEffects = new List<IEffect>();
    var setEffects = new List<IEffect>();
    var removeEffects = new List<IEffect>();
    var deleteEffects = new List<IEffect>();


    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRand) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsRand.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRand[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.rand != currentObjIncarnation.rand) {
            setEffects.Add(new RandSetRandEffect(objId, sourceObjIncarnation.rand));
          }

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsRand[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRand) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRand.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateRand(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RandIncarnation>>(rootIncarnation.incarnationsRand)) {
      if (!sourceIncarnation.incarnationsRand.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectRandDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHoldPositionImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsHoldPositionImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsHoldPositionImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsHoldPositionImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHoldPositionImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsHoldPositionImpulse.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateHoldPositionImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<HoldPositionImpulseIncarnation>>(rootIncarnation.incarnationsHoldPositionImpulse)) {
      if (!sourceIncarnation.incarnationsHoldPositionImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectHoldPositionImpulseDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWanderAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWanderAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsWanderAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWanderAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateWanderAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WanderAICapabilityUCIncarnation>>(rootIncarnation.incarnationsWanderAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectWanderAICapabilityUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTutorialDefyCounterUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTutorialDefyCounterUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.numDefiesRemaining != currentObjIncarnation.numDefiesRemaining) {
            setEffects.Add(new TutorialDefyCounterUCSetNumDefiesRemainingEffect(objId, sourceObjIncarnation.numDefiesRemaining));
          }

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsTutorialDefyCounterUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTutorialDefyCounterUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateTutorialDefyCounterUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TutorialDefyCounterUCIncarnation>>(rootIncarnation.incarnationsTutorialDefyCounterUC)) {
      if (!sourceIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectTutorialDefyCounterUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnit) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsUnit.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsUnit[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.evvent != currentObjIncarnation.evvent) {
            setEffects.Add(new UnitSetEvventEffect(objId, sourceObjIncarnation.evvent));
          }

          if (sourceObjIncarnation.lifeEndTime != currentObjIncarnation.lifeEndTime) {
            setEffects.Add(new UnitSetLifeEndTimeEffect(objId, sourceObjIncarnation.lifeEndTime));
          }

          if (sourceObjIncarnation.location != currentObjIncarnation.location) {
            setEffects.Add(new UnitSetLocationEffect(objId, sourceObjIncarnation.location));
          }

          if (sourceObjIncarnation.nextActionTime != currentObjIncarnation.nextActionTime) {
            setEffects.Add(new UnitSetNextActionTimeEffect(objId, sourceObjIncarnation.nextActionTime));
          }

          if (sourceObjIncarnation.hp != currentObjIncarnation.hp) {
            setEffects.Add(new UnitSetHpEffect(objId, sourceObjIncarnation.hp));
          }

          if (sourceObjIncarnation.maxHp != currentObjIncarnation.maxHp) {
            setEffects.Add(new UnitSetMaxHpEffect(objId, sourceObjIncarnation.maxHp));
          }

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsUnit[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnit) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsUnit.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateUnit(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<UnitIncarnation>>(rootIncarnation.incarnationsUnit)) {
      if (!sourceIncarnation.incarnationsUnit.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectUnitDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIUnitComponentMutBunch) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsIUnitComponentMutBunch.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIUnitComponentMutBunch[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsIUnitComponentMutBunch[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIUnitComponentMutBunch) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIUnitComponentMutBunch.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateIUnitComponentMutBunch(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IUnitComponentMutBunchIncarnation>>(rootIncarnation.incarnationsIUnitComponentMutBunch)) {
      if (!sourceIncarnation.incarnationsIUnitComponentMutBunch.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectIUnitComponentMutBunchDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLightningChargedUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsLightningChargedUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLightningChargedUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsLightningChargedUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLightningChargedUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLightningChargedUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateLightningChargedUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LightningChargedUCIncarnation>>(rootIncarnation.incarnationsLightningChargedUC)) {
      if (!sourceIncarnation.incarnationsLightningChargedUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectLightningChargedUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLightningChargingUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsLightningChargingUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLightningChargingUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsLightningChargingUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLightningChargingUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLightningChargingUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateLightningChargingUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LightningChargingUCIncarnation>>(rootIncarnation.incarnationsLightningChargingUC)) {
      if (!sourceIncarnation.incarnationsLightningChargingUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectLightningChargingUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDoomedUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsDoomedUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDoomedUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsDoomedUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDoomedUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDoomedUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateDoomedUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DoomedUCIncarnation>>(rootIncarnation.incarnationsDoomedUC)) {
      if (!sourceIncarnation.incarnationsDoomedUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectDoomedUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTemporaryCloneImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTemporaryCloneImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTemporaryCloneImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsTemporaryCloneImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTemporaryCloneImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTemporaryCloneImpulse.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateTemporaryCloneImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TemporaryCloneImpulseIncarnation>>(rootIncarnation.incarnationsTemporaryCloneImpulse)) {
      if (!sourceIncarnation.incarnationsTemporaryCloneImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectTemporaryCloneImpulseDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTemporaryCloneAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTemporaryCloneAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.charges != currentObjIncarnation.charges) {
            setEffects.Add(new TemporaryCloneAICapabilityUCSetChargesEffect(objId, sourceObjIncarnation.charges));
          }

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsTemporaryCloneAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTemporaryCloneAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateTemporaryCloneAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TemporaryCloneAICapabilityUCIncarnation>>(rootIncarnation.incarnationsTemporaryCloneAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectTemporaryCloneAICapabilityUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDeathTriggerUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsDeathTriggerUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDeathTriggerUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsDeathTriggerUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDeathTriggerUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDeathTriggerUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateDeathTriggerUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DeathTriggerUCIncarnation>>(rootIncarnation.incarnationsDeathTriggerUC)) {
      if (!sourceIncarnation.incarnationsDeathTriggerUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectDeathTriggerUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBequeathUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBequeathUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBequeathUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsBequeathUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBequeathUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBequeathUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateBequeathUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BequeathUCIncarnation>>(rootIncarnation.incarnationsBequeathUC)) {
      if (!sourceIncarnation.incarnationsBequeathUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectBequeathUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSummonImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsSummonImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSummonImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsSummonImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSummonImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSummonImpulse.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateSummonImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SummonImpulseIncarnation>>(rootIncarnation.incarnationsSummonImpulse)) {
      if (!sourceIncarnation.incarnationsSummonImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectSummonImpulseDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSummonAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSummonAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.charges != currentObjIncarnation.charges) {
            setEffects.Add(new SummonAICapabilityUCSetChargesEffect(objId, sourceObjIncarnation.charges));
          }

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsSummonAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSummonAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateSummonAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SummonAICapabilityUCIncarnation>>(rootIncarnation.incarnationsSummonAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectSummonAICapabilityUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSorcerousUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsSorcerousUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSorcerousUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.mp != currentObjIncarnation.mp) {
            setEffects.Add(new SorcerousUCSetMpEffect(objId, sourceObjIncarnation.mp));
          }

          if (sourceObjIncarnation.maxMp != currentObjIncarnation.maxMp) {
            setEffects.Add(new SorcerousUCSetMaxMpEffect(objId, sourceObjIncarnation.maxMp));
          }

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsSorcerousUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSorcerousUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSorcerousUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateSorcerousUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SorcerousUCIncarnation>>(rootIncarnation.incarnationsSorcerousUC)) {
      if (!sourceIncarnation.incarnationsSorcerousUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectSorcerousUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseOffenseUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBaseOffenseUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsBaseOffenseUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseOffenseUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateBaseOffenseUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BaseOffenseUCIncarnation>>(rootIncarnation.incarnationsBaseOffenseUC)) {
      if (!sourceIncarnation.incarnationsBaseOffenseUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectBaseOffenseUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseSightRangeUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBaseSightRangeUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsBaseSightRangeUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseSightRangeUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateBaseSightRangeUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BaseSightRangeUCIncarnation>>(rootIncarnation.incarnationsBaseSightRangeUC)) {
      if (!sourceIncarnation.incarnationsBaseSightRangeUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectBaseSightRangeUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseMovementTimeUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBaseMovementTimeUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsBaseMovementTimeUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseMovementTimeUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateBaseMovementTimeUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BaseMovementTimeUCIncarnation>>(rootIncarnation.incarnationsBaseMovementTimeUC)) {
      if (!sourceIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectBaseMovementTimeUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseDefenseUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBaseDefenseUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsBaseDefenseUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseDefenseUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateBaseDefenseUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BaseDefenseUCIncarnation>>(rootIncarnation.incarnationsBaseDefenseUC)) {
      if (!sourceIncarnation.incarnationsBaseDefenseUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectBaseDefenseUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseCombatTimeUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBaseCombatTimeUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsBaseCombatTimeUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseCombatTimeUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateBaseCombatTimeUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BaseCombatTimeUCIncarnation>>(rootIncarnation.incarnationsBaseCombatTimeUC)) {
      if (!sourceIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectBaseCombatTimeUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMiredUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsMiredUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMiredUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsMiredUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMiredUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMiredUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateMiredUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MiredUCIncarnation>>(rootIncarnation.incarnationsMiredUC)) {
      if (!sourceIncarnation.incarnationsMiredUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectMiredUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMireImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsMireImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMireImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsMireImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMireImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMireImpulse.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateMireImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MireImpulseIncarnation>>(rootIncarnation.incarnationsMireImpulse)) {
      if (!sourceIncarnation.incarnationsMireImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectMireImpulseDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEvaporateImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsEvaporateImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsEvaporateImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEvaporateImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateEvaporateImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<EvaporateImpulseIncarnation>>(rootIncarnation.incarnationsEvaporateImpulse)) {
      if (!sourceIncarnation.incarnationsEvaporateImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectEvaporateImpulseDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeCloneAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTimeCloneAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsTimeCloneAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeCloneAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateTimeCloneAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TimeCloneAICapabilityUCIncarnation>>(rootIncarnation.incarnationsTimeCloneAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectTimeCloneAICapabilityUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMoveImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsMoveImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMoveImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsMoveImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMoveImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMoveImpulse.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateMoveImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MoveImpulseIncarnation>>(rootIncarnation.incarnationsMoveImpulse)) {
      if (!sourceIncarnation.incarnationsMoveImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectMoveImpulseDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeTargetTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsKamikazeTargetTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKamikazeTargetTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsKamikazeTargetTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeTargetTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKamikazeTargetTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateKamikazeTargetTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KamikazeTargetTTCIncarnation>>(rootIncarnation.incarnationsKamikazeTargetTTC)) {
      if (!sourceIncarnation.incarnationsKamikazeTargetTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectKamikazeTargetTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeJumpImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsKamikazeJumpImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKamikazeJumpImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsKamikazeJumpImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeJumpImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKamikazeJumpImpulse.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateKamikazeJumpImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KamikazeJumpImpulseIncarnation>>(rootIncarnation.incarnationsKamikazeJumpImpulse)) {
      if (!sourceIncarnation.incarnationsKamikazeJumpImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectKamikazeJumpImpulseDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeTargetImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsKamikazeTargetImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKamikazeTargetImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsKamikazeTargetImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeTargetImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKamikazeTargetImpulse.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateKamikazeTargetImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KamikazeTargetImpulseIncarnation>>(rootIncarnation.incarnationsKamikazeTargetImpulse)) {
      if (!sourceIncarnation.incarnationsKamikazeTargetImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectKamikazeTargetImpulseDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKamikazeAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.targetByLocation != currentObjIncarnation.targetByLocation) {
            setEffects.Add(new KamikazeAICapabilityUCSetTargetByLocationEffect(objId, sourceObjIncarnation.targetByLocation));
          }

          if (sourceObjIncarnation.targetLocationCenter != currentObjIncarnation.targetLocationCenter) {
            setEffects.Add(new KamikazeAICapabilityUCSetTargetLocationCenterEffect(objId, sourceObjIncarnation.targetLocationCenter));
          }

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsKamikazeAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateKamikazeAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KamikazeAICapabilityUCIncarnation>>(rootIncarnation.incarnationsKamikazeAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectKamikazeAICapabilityUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsInvincibilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsInvincibilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsInvincibilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsInvincibilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsInvincibilityUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateInvincibilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<InvincibilityUCIncarnation>>(rootIncarnation.incarnationsInvincibilityUC)) {
      if (!sourceIncarnation.incarnationsInvincibilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectInvincibilityUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGuardAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGuardAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsGuardAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGuardAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateGuardAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GuardAICapabilityUCIncarnation>>(rootIncarnation.incarnationsGuardAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectGuardAICapabilityUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsNoImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsNoImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsNoImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsNoImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsNoImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsNoImpulse.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateNoImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<NoImpulseIncarnation>>(rootIncarnation.incarnationsNoImpulse)) {
      if (!sourceIncarnation.incarnationsNoImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectNoImpulseDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEvolvifyImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsEvolvifyImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsEvolvifyImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsEvolvifyImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEvolvifyImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsEvolvifyImpulse.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateEvolvifyImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<EvolvifyImpulseIncarnation>>(rootIncarnation.incarnationsEvolvifyImpulse)) {
      if (!sourceIncarnation.incarnationsEvolvifyImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectEvolvifyImpulseDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEvolvifyAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsEvolvifyAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsEvolvifyAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsEvolvifyAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEvolvifyAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsEvolvifyAICapabilityUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateEvolvifyAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<EvolvifyAICapabilityUCIncarnation>>(rootIncarnation.incarnationsEvolvifyAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsEvolvifyAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectEvolvifyAICapabilityUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsFireImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFireImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsFireImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFireImpulse.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateFireImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FireImpulseIncarnation>>(rootIncarnation.incarnationsFireImpulse)) {
      if (!sourceIncarnation.incarnationsFireImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectFireImpulseDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsOnFireUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsOnFireUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsOnFireUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.turnsRemaining != currentObjIncarnation.turnsRemaining) {
            setEffects.Add(new OnFireUCSetTurnsRemainingEffect(objId, sourceObjIncarnation.turnsRemaining));
          }

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsOnFireUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsOnFireUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsOnFireUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateOnFireUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<OnFireUCIncarnation>>(rootIncarnation.incarnationsOnFireUC)) {
      if (!sourceIncarnation.incarnationsOnFireUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectOnFireUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefyingUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsDefyingUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDefyingUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsDefyingUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefyingUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDefyingUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateDefyingUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DefyingUCIncarnation>>(rootIncarnation.incarnationsDefyingUC)) {
      if (!sourceIncarnation.incarnationsDefyingUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectDefyingUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefyImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsDefyImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDefyImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsDefyImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefyImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDefyImpulse.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateDefyImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DefyImpulseIncarnation>>(rootIncarnation.incarnationsDefyImpulse)) {
      if (!sourceIncarnation.incarnationsDefyImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectDefyImpulseDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounteringUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCounteringUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCounteringUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsCounteringUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounteringUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCounteringUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateCounteringUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CounteringUCIncarnation>>(rootIncarnation.incarnationsCounteringUC)) {
      if (!sourceIncarnation.incarnationsCounteringUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectCounteringUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounterImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCounterImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCounterImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsCounterImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounterImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCounterImpulse.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateCounterImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CounterImpulseIncarnation>>(rootIncarnation.incarnationsCounterImpulse)) {
      if (!sourceIncarnation.incarnationsCounterImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectCounterImpulseDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnleashBideImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsUnleashBideImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsUnleashBideImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnleashBideImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateUnleashBideImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<UnleashBideImpulseIncarnation>>(rootIncarnation.incarnationsUnleashBideImpulse)) {
      if (!sourceIncarnation.incarnationsUnleashBideImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectUnleashBideImpulseDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsContinueBidingImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsContinueBidingImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsContinueBidingImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsContinueBidingImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateContinueBidingImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ContinueBidingImpulseIncarnation>>(rootIncarnation.incarnationsContinueBidingImpulse)) {
      if (!sourceIncarnation.incarnationsContinueBidingImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectContinueBidingImpulseDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStartBidingImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsStartBidingImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsStartBidingImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStartBidingImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateStartBidingImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<StartBidingImpulseIncarnation>>(rootIncarnation.incarnationsStartBidingImpulse)) {
      if (!sourceIncarnation.incarnationsStartBidingImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectStartBidingImpulseDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBideAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBideAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.charge != currentObjIncarnation.charge) {
            setEffects.Add(new BideAICapabilityUCSetChargeEffect(objId, sourceObjIncarnation.charge));
          }

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsBideAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBideAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateBideAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BideAICapabilityUCIncarnation>>(rootIncarnation.incarnationsBideAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsBideAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectBideAICapabilityUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsAttackImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsAttackImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsAttackImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsAttackImpulse.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateAttackImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<AttackImpulseIncarnation>>(rootIncarnation.incarnationsAttackImpulse)) {
      if (!sourceIncarnation.incarnationsAttackImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectAttackImpulseDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPursueImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsPursueImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsPursueImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsPursueImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPursueImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsPursueImpulse.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreatePursueImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<PursueImpulseIncarnation>>(rootIncarnation.incarnationsPursueImpulse)) {
      if (!sourceIncarnation.incarnationsPursueImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectPursueImpulseDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKillDirective) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsKillDirective.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKillDirective[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsKillDirective[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKillDirective) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKillDirective.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateKillDirective(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KillDirectiveIncarnation>>(rootIncarnation.incarnationsKillDirective)) {
      if (!sourceIncarnation.incarnationsKillDirective.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectKillDirectiveDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackAICapabilityUC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsAttackAICapabilityUC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.killDirective != currentObjIncarnation.killDirective) {
            setEffects.Add(new AttackAICapabilityUCSetKillDirectiveEffect(objId, sourceObjIncarnation.killDirective));
          }

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsAttackAICapabilityUC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackAICapabilityUC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateAttackAICapabilityUC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<AttackAICapabilityUCIncarnation>>(rootIncarnation.incarnationsAttackAICapabilityUC)) {
      if (!sourceIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectAttackAICapabilityUCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWarperTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsWarperTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWarperTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsWarperTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWarperTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWarperTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateWarperTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WarperTTCIncarnation>>(rootIncarnation.incarnationsWarperTTC)) {
      if (!sourceIncarnation.incarnationsWarperTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectWarperTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeAnchorTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTimeAnchorTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsTimeAnchorTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeAnchorTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateTimeAnchorTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TimeAnchorTTCIncarnation>>(rootIncarnation.incarnationsTimeAnchorTTC)) {
      if (!sourceIncarnation.incarnationsTimeAnchorTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectTimeAnchorTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTerrainTile) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTerrainTile.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTerrainTile[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.evvent != currentObjIncarnation.evvent) {
            setEffects.Add(new TerrainTileSetEvventEffect(objId, sourceObjIncarnation.evvent));
          }

          if (sourceObjIncarnation.elevation != currentObjIncarnation.elevation) {
            setEffects.Add(new TerrainTileSetElevationEffect(objId, sourceObjIncarnation.elevation));
          }

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsTerrainTile[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTerrainTile) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTerrainTile.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateTerrainTile(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TerrainTileIncarnation>>(rootIncarnation.incarnationsTerrainTile)) {
      if (!sourceIncarnation.incarnationsTerrainTile.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectTerrainTileDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsITerrainTileComponentMutBunch) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsITerrainTileComponentMutBunch.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsITerrainTileComponentMutBunch[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsITerrainTileComponentMutBunch[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsITerrainTileComponentMutBunch) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsITerrainTileComponentMutBunch.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateITerrainTileComponentMutBunch(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ITerrainTileComponentMutBunchIncarnation>>(rootIncarnation.incarnationsITerrainTileComponentMutBunch)) {
      if (!sourceIncarnation.incarnationsITerrainTileComponentMutBunch.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectITerrainTileComponentMutBunchDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTerrain) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTerrain.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTerrain[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.pattern != currentObjIncarnation.pattern) {
            setEffects.Add(new TerrainSetPatternEffect(objId, sourceObjIncarnation.pattern));
          }

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsTerrain[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTerrain) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTerrain.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateTerrain(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TerrainIncarnation>>(rootIncarnation.incarnationsTerrain)) {
      if (!sourceIncarnation.incarnationsTerrain.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectTerrainDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSimplePresenceTriggerTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSimplePresenceTriggerTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsSimplePresenceTriggerTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSimplePresenceTriggerTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateSimplePresenceTriggerTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SimplePresenceTriggerTTCIncarnation>>(rootIncarnation.incarnationsSimplePresenceTriggerTTC)) {
      if (!sourceIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectSimplePresenceTriggerTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireBombImpulse) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsFireBombImpulse.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFireBombImpulse[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsFireBombImpulse[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireBombImpulse) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFireBombImpulse.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateFireBombImpulse(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FireBombImpulseIncarnation>>(rootIncarnation.incarnationsFireBombImpulse)) {
      if (!sourceIncarnation.incarnationsFireBombImpulse.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectFireBombImpulseDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireBombTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsFireBombTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFireBombTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.turnsUntilExplosion != currentObjIncarnation.turnsUntilExplosion) {
            setEffects.Add(new FireBombTTCSetTurnsUntilExplosionEffect(objId, sourceObjIncarnation.turnsUntilExplosion));
          }

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsFireBombTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireBombTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFireBombTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateFireBombTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FireBombTTCIncarnation>>(rootIncarnation.incarnationsFireBombTTC)) {
      if (!sourceIncarnation.incarnationsFireBombTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectFireBombTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFlowerTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsFlowerTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFlowerTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsFlowerTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFlowerTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFlowerTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateFlowerTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FlowerTTCIncarnation>>(rootIncarnation.incarnationsFlowerTTC)) {
      if (!sourceIncarnation.incarnationsFlowerTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectFlowerTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLotusTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsLotusTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLotusTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsLotusTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLotusTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLotusTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateLotusTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LotusTTCIncarnation>>(rootIncarnation.incarnationsLotusTTC)) {
      if (!sourceIncarnation.incarnationsLotusTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectLotusTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRoseTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsRoseTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRoseTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsRoseTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRoseTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRoseTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateRoseTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RoseTTCIncarnation>>(rootIncarnation.incarnationsRoseTTC)) {
      if (!sourceIncarnation.incarnationsRoseTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectRoseTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLeafTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsLeafTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLeafTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsLeafTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLeafTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLeafTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateLeafTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LeafTTCIncarnation>>(rootIncarnation.incarnationsLeafTTC)) {
      if (!sourceIncarnation.incarnationsLeafTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectLeafTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsOnFireTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsOnFireTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsOnFireTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.turnsRemaining != currentObjIncarnation.turnsRemaining) {
            setEffects.Add(new OnFireTTCSetTurnsRemainingEffect(objId, sourceObjIncarnation.turnsRemaining));
          }

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsOnFireTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsOnFireTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsOnFireTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateOnFireTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<OnFireTTCIncarnation>>(rootIncarnation.incarnationsOnFireTTC)) {
      if (!sourceIncarnation.incarnationsOnFireTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectOnFireTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMarkerTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsMarkerTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMarkerTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsMarkerTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMarkerTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMarkerTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateMarkerTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MarkerTTCIncarnation>>(rootIncarnation.incarnationsMarkerTTC)) {
      if (!sourceIncarnation.incarnationsMarkerTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectMarkerTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLevelLinkTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsLevelLinkTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLevelLinkTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsLevelLinkTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLevelLinkTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLevelLinkTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateLevelLinkTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LevelLinkTTCIncarnation>>(rootIncarnation.incarnationsLevelLinkTTC)) {
      if (!sourceIncarnation.incarnationsLevelLinkTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectLevelLinkTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMudTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsMudTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMudTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsMudTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMudTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMudTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateMudTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MudTTCIncarnation>>(rootIncarnation.incarnationsMudTTC)) {
      if (!sourceIncarnation.incarnationsMudTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectMudTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDirtTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsDirtTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDirtTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsDirtTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDirtTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDirtTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateDirtTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DirtTTCIncarnation>>(rootIncarnation.incarnationsDirtTTC)) {
      if (!sourceIncarnation.incarnationsDirtTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectDirtTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsObsidianTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsObsidianTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsObsidianTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsObsidianTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsObsidianTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsObsidianTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateObsidianTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ObsidianTTCIncarnation>>(rootIncarnation.incarnationsObsidianTTC)) {
      if (!sourceIncarnation.incarnationsObsidianTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectObsidianTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDownStairsTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsDownStairsTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDownStairsTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsDownStairsTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDownStairsTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDownStairsTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateDownStairsTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DownStairsTTCIncarnation>>(rootIncarnation.incarnationsDownStairsTTC)) {
      if (!sourceIncarnation.incarnationsDownStairsTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectDownStairsTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUpStairsTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsUpStairsTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsUpStairsTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsUpStairsTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUpStairsTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsUpStairsTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateUpStairsTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<UpStairsTTCIncarnation>>(rootIncarnation.incarnationsUpStairsTTC)) {
      if (!sourceIncarnation.incarnationsUpStairsTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectUpStairsTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWallTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsWallTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWallTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsWallTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWallTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWallTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateWallTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WallTTCIncarnation>>(rootIncarnation.incarnationsWallTTC)) {
      if (!sourceIncarnation.incarnationsWallTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectWallTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBloodTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBloodTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBloodTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsBloodTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBloodTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBloodTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateBloodTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BloodTTCIncarnation>>(rootIncarnation.incarnationsBloodTTC)) {
      if (!sourceIncarnation.incarnationsBloodTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectBloodTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRocksTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsRocksTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRocksTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsRocksTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRocksTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRocksTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateRocksTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RocksTTCIncarnation>>(rootIncarnation.incarnationsRocksTTC)) {
      if (!sourceIncarnation.incarnationsRocksTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectRocksTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTreeTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTreeTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTreeTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsTreeTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTreeTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTreeTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateTreeTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TreeTTCIncarnation>>(rootIncarnation.incarnationsTreeTTC)) {
      if (!sourceIncarnation.incarnationsTreeTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectTreeTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWaterTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsWaterTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWaterTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsWaterTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWaterTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWaterTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateWaterTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WaterTTCIncarnation>>(rootIncarnation.incarnationsWaterTTC)) {
      if (!sourceIncarnation.incarnationsWaterTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectWaterTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFloorTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsFloorTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFloorTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsFloorTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFloorTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFloorTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateFloorTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FloorTTCIncarnation>>(rootIncarnation.incarnationsFloorTTC)) {
      if (!sourceIncarnation.incarnationsFloorTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectFloorTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveWallTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCaveWallTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCaveWallTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsCaveWallTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveWallTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCaveWallTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateCaveWallTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CaveWallTTCIncarnation>>(rootIncarnation.incarnationsCaveWallTTC)) {
      if (!sourceIncarnation.incarnationsCaveWallTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectCaveWallTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCaveTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCaveTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsCaveTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCaveTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateCaveTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CaveTTCIncarnation>>(rootIncarnation.incarnationsCaveTTC)) {
      if (!sourceIncarnation.incarnationsCaveTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectCaveTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFallsTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsFallsTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFallsTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsFallsTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFallsTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFallsTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateFallsTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FallsTTCIncarnation>>(rootIncarnation.incarnationsFallsTTC)) {
      if (!sourceIncarnation.incarnationsFallsTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectFallsTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsObsidianFloorTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsObsidianFloorTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsObsidianFloorTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsObsidianFloorTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsObsidianFloorTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsObsidianFloorTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateObsidianFloorTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ObsidianFloorTTCIncarnation>>(rootIncarnation.incarnationsObsidianFloorTTC)) {
      if (!sourceIncarnation.incarnationsObsidianFloorTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectObsidianFloorTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMagmaTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMagmaTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsMagmaTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMagmaTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMagmaTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateMagmaTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MagmaTTCIncarnation>>(rootIncarnation.incarnationsMagmaTTC)) {
      if (!sourceIncarnation.incarnationsMagmaTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectMagmaTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCliffTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCliffTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsCliffTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCliffTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateCliffTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CliffTTCIncarnation>>(rootIncarnation.incarnationsCliffTTC)) {
      if (!sourceIncarnation.incarnationsCliffTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectCliffTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavaNestTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsRavaNestTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRavaNestTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsRavaNestTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavaNestTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRavaNestTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateRavaNestTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RavaNestTTCIncarnation>>(rootIncarnation.incarnationsRavaNestTTC)) {
      if (!sourceIncarnation.incarnationsRavaNestTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectRavaNestTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffLandingTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCliffLandingTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsCliffLandingTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffLandingTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateCliffLandingTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CliffLandingTTCIncarnation>>(rootIncarnation.incarnationsCliffLandingTTC)) {
      if (!sourceIncarnation.incarnationsCliffLandingTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectCliffLandingTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStoneTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsStoneTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsStoneTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsStoneTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStoneTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsStoneTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateStoneTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<StoneTTCIncarnation>>(rootIncarnation.incarnationsStoneTTC)) {
      if (!sourceIncarnation.incarnationsStoneTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectStoneTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGrassTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsGrassTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGrassTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsGrassTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGrassTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGrassTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateGrassTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GrassTTCIncarnation>>(rootIncarnation.incarnationsGrassTTC)) {
      if (!sourceIncarnation.incarnationsGrassTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectGrassTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLevel) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsLevel.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLevel[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.controller != currentObjIncarnation.controller) {
            setEffects.Add(new LevelSetControllerEffect(objId, sourceObjIncarnation.controller));
          }

          if (sourceObjIncarnation.time != currentObjIncarnation.time) {
            setEffects.Add(new LevelSetTimeEffect(objId, sourceObjIncarnation.time));
          }

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsLevel[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLevel) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLevel.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateLevel(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LevelIncarnation>>(rootIncarnation.incarnationsLevel)) {
      if (!sourceIncarnation.incarnationsLevel.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectLevelDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSpeedRing) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsSpeedRing.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSpeedRing[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsSpeedRing[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSpeedRing) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSpeedRing.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateSpeedRing(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SpeedRingIncarnation>>(rootIncarnation.incarnationsSpeedRing)) {
      if (!sourceIncarnation.incarnationsSpeedRing.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectSpeedRingDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsManaPotion) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsManaPotion.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsManaPotion[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsManaPotion[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsManaPotion) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsManaPotion.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateManaPotion(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ManaPotionIncarnation>>(rootIncarnation.incarnationsManaPotion)) {
      if (!sourceIncarnation.incarnationsManaPotion.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectManaPotionDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWat) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsWat.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWat[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsWat[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWat) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWat.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateWat(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WatIncarnation>>(rootIncarnation.incarnationsWat)) {
      if (!sourceIncarnation.incarnationsWat.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectWatDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIPreActingUCWeakMutBunch) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsIPreActingUCWeakMutBunch.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIPreActingUCWeakMutBunch[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsIPreActingUCWeakMutBunch[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIPreActingUCWeakMutBunch) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIPreActingUCWeakMutBunch.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateIPreActingUCWeakMutBunch(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IPreActingUCWeakMutBunchIncarnation>>(rootIncarnation.incarnationsIPreActingUCWeakMutBunch)) {
      if (!sourceIncarnation.incarnationsIPreActingUCWeakMutBunch.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectIPreActingUCWeakMutBunchDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIPostActingUCWeakMutBunch) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsIPostActingUCWeakMutBunch.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIPostActingUCWeakMutBunch[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsIPostActingUCWeakMutBunch[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIPostActingUCWeakMutBunch) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIPostActingUCWeakMutBunch.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateIPostActingUCWeakMutBunch(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IPostActingUCWeakMutBunchIncarnation>>(rootIncarnation.incarnationsIPostActingUCWeakMutBunch)) {
      if (!sourceIncarnation.incarnationsIPostActingUCWeakMutBunch.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectIPostActingUCWeakMutBunchDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIImpulseStrongMutBunch) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsIImpulseStrongMutBunch.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIImpulseStrongMutBunch[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsIImpulseStrongMutBunch[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIImpulseStrongMutBunch) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIImpulseStrongMutBunch.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateIImpulseStrongMutBunch(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IImpulseStrongMutBunchIncarnation>>(rootIncarnation.incarnationsIImpulseStrongMutBunch)) {
      if (!sourceIncarnation.incarnationsIImpulseStrongMutBunch.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectIImpulseStrongMutBunchDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIItemStrongMutBunch) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsIItemStrongMutBunch.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIItemStrongMutBunch[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsIItemStrongMutBunch[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIItemStrongMutBunch) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIItemStrongMutBunch.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateIItemStrongMutBunch(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IItemStrongMutBunchIncarnation>>(rootIncarnation.incarnationsIItemStrongMutBunch)) {
      if (!sourceIncarnation.incarnationsIItemStrongMutBunch.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectIItemStrongMutBunchDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsItemTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsItemTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsItemTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsItemTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsItemTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsItemTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateItemTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ItemTTCIncarnation>>(rootIncarnation.incarnationsItemTTC)) {
      if (!sourceIncarnation.incarnationsItemTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectItemTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHealthPotion) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsHealthPotion.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsHealthPotion[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsHealthPotion[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHealthPotion) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsHealthPotion.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateHealthPotion(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<HealthPotionIncarnation>>(rootIncarnation.incarnationsHealthPotion)) {
      if (!sourceIncarnation.incarnationsHealthPotion.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectHealthPotionDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGlaive) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsGlaive.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGlaive[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsGlaive[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGlaive) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGlaive.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateGlaive(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GlaiveIncarnation>>(rootIncarnation.incarnationsGlaive)) {
      if (!sourceIncarnation.incarnationsGlaive.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectGlaiveDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSlowRod) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsSlowRod.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSlowRod[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsSlowRod[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSlowRod) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSlowRod.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateSlowRod(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SlowRodIncarnation>>(rootIncarnation.incarnationsSlowRod)) {
      if (!sourceIncarnation.incarnationsSlowRod.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectSlowRodDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsExplosionRod) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsExplosionRod.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsExplosionRod[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsExplosionRod[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsExplosionRod) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsExplosionRod.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateExplosionRod(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ExplosionRodIncarnation>>(rootIncarnation.incarnationsExplosionRod)) {
      if (!sourceIncarnation.incarnationsExplosionRod.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectExplosionRodDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBlazeRod) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBlazeRod.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBlazeRod[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsBlazeRod[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBlazeRod) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBlazeRod.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateBlazeRod(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BlazeRodIncarnation>>(rootIncarnation.incarnationsBlazeRod)) {
      if (!sourceIncarnation.incarnationsBlazeRod.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectBlazeRodDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBlastRod) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBlastRod.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBlastRod[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsBlastRod[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBlastRod) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBlastRod.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateBlastRod(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BlastRodIncarnation>>(rootIncarnation.incarnationsBlastRod)) {
      if (!sourceIncarnation.incarnationsBlastRod.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectBlastRodDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsArmor) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsArmor.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsArmor[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsArmor[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsArmor) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsArmor.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateArmor(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ArmorIncarnation>>(rootIncarnation.incarnationsArmor)) {
      if (!sourceIncarnation.incarnationsArmor.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectArmorDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsVolcaetusLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsVolcaetusLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsVolcaetusLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsVolcaetusLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsVolcaetusLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsVolcaetusLevelController.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateVolcaetusLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<VolcaetusLevelControllerIncarnation>>(rootIncarnation.incarnationsVolcaetusLevelController)) {
      if (!sourceIncarnation.incarnationsVolcaetusLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectVolcaetusLevelControllerDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTutorial2LevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTutorial2LevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTutorial2LevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsTutorial2LevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTutorial2LevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTutorial2LevelController.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateTutorial2LevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<Tutorial2LevelControllerIncarnation>>(rootIncarnation.incarnationsTutorial2LevelController)) {
      if (!sourceIncarnation.incarnationsTutorial2LevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectTutorial2LevelControllerDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTutorial1LevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsTutorial1LevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTutorial1LevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsTutorial1LevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTutorial1LevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTutorial1LevelController.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateTutorial1LevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<Tutorial1LevelControllerIncarnation>>(rootIncarnation.incarnationsTutorial1LevelController)) {
      if (!sourceIncarnation.incarnationsTutorial1LevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectTutorial1LevelControllerDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRetreatLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsRetreatLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRetreatLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsRetreatLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRetreatLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRetreatLevelController.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateRetreatLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RetreatLevelControllerIncarnation>>(rootIncarnation.incarnationsRetreatLevelController)) {
      if (!sourceIncarnation.incarnationsRetreatLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectRetreatLevelControllerDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSotaventoLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsSotaventoLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSotaventoLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsSotaventoLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSotaventoLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSotaventoLevelController.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateSotaventoLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SotaventoLevelControllerIncarnation>>(rootIncarnation.incarnationsSotaventoLevelController)) {
      if (!sourceIncarnation.incarnationsSotaventoLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectSotaventoLevelControllerDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsNestLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsNestLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsNestLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsNestLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsNestLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsNestLevelController.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateNestLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<NestLevelControllerIncarnation>>(rootIncarnation.incarnationsNestLevelController)) {
      if (!sourceIncarnation.incarnationsNestLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectNestLevelControllerDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLakeLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsLakeLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLakeLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsLakeLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLakeLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLakeLevelController.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateLakeLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LakeLevelControllerIncarnation>>(rootIncarnation.incarnationsLakeLevelController)) {
      if (!sourceIncarnation.incarnationsLakeLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectLakeLevelControllerDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEmberDeepLevelLinkerTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsEmberDeepLevelLinkerTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsEmberDeepLevelLinkerTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEmberDeepLevelLinkerTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateEmberDeepLevelLinkerTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<EmberDeepLevelLinkerTTCIncarnation>>(rootIncarnation.incarnationsEmberDeepLevelLinkerTTC)) {
      if (!sourceIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectEmberDeepLevelLinkerTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDirtRoadLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsDirtRoadLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDirtRoadLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsDirtRoadLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDirtRoadLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDirtRoadLevelController.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateDirtRoadLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DirtRoadLevelControllerIncarnation>>(rootIncarnation.incarnationsDirtRoadLevelController)) {
      if (!sourceIncarnation.incarnationsDirtRoadLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectDirtRoadLevelControllerDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCaveLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCaveLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsCaveLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCaveLevelController.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateCaveLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CaveLevelControllerIncarnation>>(rootIncarnation.incarnationsCaveLevelController)) {
      if (!sourceIncarnation.incarnationsCaveLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectCaveLevelControllerDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBridgesLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsBridgesLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBridgesLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsBridgesLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBridgesLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBridgesLevelController.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateBridgesLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BridgesLevelControllerIncarnation>>(rootIncarnation.incarnationsBridgesLevelController)) {
      if (!sourceIncarnation.incarnationsBridgesLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectBridgesLevelControllerDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAncientTownLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsAncientTownLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsAncientTownLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsAncientTownLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAncientTownLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsAncientTownLevelController.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateAncientTownLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<AncientTownLevelControllerIncarnation>>(rootIncarnation.incarnationsAncientTownLevelController)) {
      if (!sourceIncarnation.incarnationsAncientTownLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectAncientTownLevelControllerDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSquareCaveLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSquareCaveLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsSquareCaveLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSquareCaveLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateSquareCaveLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SquareCaveLevelControllerIncarnation>>(rootIncarnation.incarnationsSquareCaveLevelController)) {
      if (!sourceIncarnation.incarnationsSquareCaveLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectSquareCaveLevelControllerDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavashrikeLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRavashrikeLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsRavashrikeLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavashrikeLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateRavashrikeLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RavashrikeLevelControllerIncarnation>>(rootIncarnation.incarnationsRavashrikeLevelController)) {
      if (!sourceIncarnation.incarnationsRavashrikeLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectRavashrikeLevelControllerDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPentagonalCaveLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsPentagonalCaveLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsPentagonalCaveLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPentagonalCaveLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreatePentagonalCaveLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<PentagonalCaveLevelControllerIncarnation>>(rootIncarnation.incarnationsPentagonalCaveLevelController)) {
      if (!sourceIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectPentagonalCaveLevelControllerDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIncendianFallsLevelLinkerTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIncendianFallsLevelLinkerTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateIncendianFallsLevelLinkerTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IncendianFallsLevelLinkerTTCIncarnation>>(rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC)) {
      if (!sourceIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectIncendianFallsLevelLinkerTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsCliffLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCliffLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsCliffLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCliffLevelController.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateCliffLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CliffLevelControllerIncarnation>>(rootIncarnation.incarnationsCliffLevelController)) {
      if (!sourceIncarnation.incarnationsCliffLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectCliffLevelControllerDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPreGauntletLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsPreGauntletLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsPreGauntletLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPreGauntletLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreatePreGauntletLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<PreGauntletLevelControllerIncarnation>>(rootIncarnation.incarnationsPreGauntletLevelController)) {
      if (!sourceIncarnation.incarnationsPreGauntletLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectPreGauntletLevelControllerDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGauntletLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsGauntletLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGauntletLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsGauntletLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGauntletLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGauntletLevelController.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateGauntletLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GauntletLevelControllerIncarnation>>(rootIncarnation.incarnationsGauntletLevelController)) {
      if (!sourceIncarnation.incarnationsGauntletLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectGauntletLevelControllerDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavaArcanaLevelLinkerTTC) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavaArcanaLevelLinkerTTC) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateRavaArcanaLevelLinkerTTC(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RavaArcanaLevelLinkerTTCIncarnation>>(rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC)) {
      if (!sourceIncarnation.incarnationsRavaArcanaLevelLinkerTTC.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectRavaArcanaLevelLinkerTTCDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsJumpingCaveLevelController) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsJumpingCaveLevelController.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsJumpingCaveLevelController[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsJumpingCaveLevelController[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsJumpingCaveLevelController) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsJumpingCaveLevelController.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateJumpingCaveLevelController(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<JumpingCaveLevelControllerIncarnation>>(rootIncarnation.incarnationsJumpingCaveLevelController)) {
      if (!sourceIncarnation.incarnationsJumpingCaveLevelController.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectJumpingCaveLevelControllerDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsComm) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsComm.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsComm[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsComm[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsComm) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsComm.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateComm(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CommIncarnation>>(rootIncarnation.incarnationsComm)) {
      if (!sourceIncarnation.incarnationsComm.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectCommDelete(id);
        deleteEffects.Add(effect);
      }
    }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGame) {
      var objId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (rootIncarnation.incarnationsGame.ContainsKey(objId)) {
        // Compare everything that could possibly have changed.
        var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGame[objId];
        var currentVersion = currentVersionAndObjIncarnation.version;
        var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
        if (currentVersion != sourceVersion) {

          if (sourceObjIncarnation.player != currentObjIncarnation.player) {
            setEffects.Add(new GameSetPlayerEffect(objId, sourceObjIncarnation.player));
          }

          if (sourceObjIncarnation.level != currentObjIncarnation.level) {
            setEffects.Add(new GameSetLevelEffect(objId, sourceObjIncarnation.level));
          }

          if (sourceObjIncarnation.time != currentObjIncarnation.time) {
            setEffects.Add(new GameSetTimeEffect(objId, sourceObjIncarnation.time));
          }

          if (sourceObjIncarnation.actingUnit != currentObjIncarnation.actingUnit) {
            setEffects.Add(new GameSetActingUnitEffect(objId, sourceObjIncarnation.actingUnit));
          }

          if (sourceObjIncarnation.pauseBeforeNextUnit != currentObjIncarnation.pauseBeforeNextUnit) {
            setEffects.Add(new GameSetPauseBeforeNextUnitEffect(objId, sourceObjIncarnation.pauseBeforeNextUnit));
          }

          if (sourceObjIncarnation.actionNum != currentObjIncarnation.actionNum) {
            setEffects.Add(new GameSetActionNumEffect(objId, sourceObjIncarnation.actionNum));
          }

          if (sourceObjIncarnation.instructions != currentObjIncarnation.instructions) {
            setEffects.Add(new GameSetInstructionsEffect(objId, sourceObjIncarnation.instructions));
          }

          if (sourceObjIncarnation.hideInput != currentObjIncarnation.hideInput) {
            setEffects.Add(new GameSetHideInputEffect(objId, sourceObjIncarnation.hideInput));
          }

          if (sourceObjIncarnation.evvent != currentObjIncarnation.evvent) {
            setEffects.Add(new GameSetEvventEffect(objId, sourceObjIncarnation.evvent));
          }

          // Swap out the underlying incarnation.
          
          rootIncarnation.incarnationsGame[objId] = sourceVersionAndObjIncarnation;
          
        }
      }
    }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGame) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGame.ContainsKey(sourceObjId)) {
        var effect = InternalEffectCreateGame(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation.Copy());
        createEffects.Add(effect);
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GameIncarnation>>(rootIncarnation.incarnationsGame)) {
      if (!sourceIncarnation.incarnationsGame.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var effect = InternalEffectGameDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCommMutList) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCommMutList.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCommMutList[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            for (int i = currentObjIncarnation.elements.Count - 1; i >= 0; i--) {
              removeEffects.Add(new CommMutListRemoveEffect(objId, i));
            }
            for (int i = 0; i < sourceObjIncarnation.elements.Count; i++) {
              addEffects.Add(new CommMutListAddEffect(objId, i, sourceObjIncarnation.elements[i]));
            }
            // Swap out the underlying incarnation.
                  rootIncarnation.incarnationsCommMutList[objId] = sourceVersionAndObjIncarnation;

          }
        }
      }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCommMutList) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCommMutList.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateCommMutList(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        for (int i = 0; i < sourceObjIncarnation.elements.Count; i++) {
          addEffects.Add(new CommMutListAddEffect(sourceObjId, i, sourceObjIncarnation.elements[i]));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CommMutListIncarnation>>(rootIncarnation.incarnationsCommMutList)) {
      if (!sourceIncarnation.incarnationsCommMutList.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        for (int i = currentObjIncarnation.elements.Count - 1; i >= 0; i--) {
          removeEffects.Add(new CommMutListRemoveEffect(id, i));
        }
        var effect = InternalEffectCommMutListDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLocationMutList) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsLocationMutList.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLocationMutList[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            for (int i = currentObjIncarnation.elements.Count - 1; i >= 0; i--) {
              removeEffects.Add(new LocationMutListRemoveEffect(objId, i));
            }
            for (int i = 0; i < sourceObjIncarnation.elements.Count; i++) {
              addEffects.Add(new LocationMutListAddEffect(objId, i, sourceObjIncarnation.elements[i]));
            }
            // Swap out the underlying incarnation.
                  rootIncarnation.incarnationsLocationMutList[objId] = sourceVersionAndObjIncarnation;

          }
        }
      }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLocationMutList) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLocationMutList.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateLocationMutList(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        for (int i = 0; i < sourceObjIncarnation.elements.Count; i++) {
          addEffects.Add(new LocationMutListAddEffect(sourceObjId, i, sourceObjIncarnation.elements[i]));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LocationMutListIncarnation>>(rootIncarnation.incarnationsLocationMutList)) {
      if (!sourceIncarnation.incarnationsLocationMutList.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        for (int i = currentObjIncarnation.elements.Count - 1; i >= 0; i--) {
          removeEffects.Add(new LocationMutListRemoveEffect(id, i));
        }
        var effect = InternalEffectLocationMutListDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIRequestMutList) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsIRequestMutList.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIRequestMutList[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            for (int i = currentObjIncarnation.elements.Count - 1; i >= 0; i--) {
              removeEffects.Add(new IRequestMutListRemoveEffect(objId, i));
            }
            for (int i = 0; i < sourceObjIncarnation.elements.Count; i++) {
              addEffects.Add(new IRequestMutListAddEffect(objId, i, sourceObjIncarnation.elements[i]));
            }
            // Swap out the underlying incarnation.
                  rootIncarnation.incarnationsIRequestMutList[objId] = sourceVersionAndObjIncarnation;

          }
        }
      }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIRequestMutList) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIRequestMutList.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateIRequestMutList(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        for (int i = 0; i < sourceObjIncarnation.elements.Count; i++) {
          addEffects.Add(new IRequestMutListAddEffect(sourceObjId, i, sourceObjIncarnation.elements[i]));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IRequestMutListIncarnation>>(rootIncarnation.incarnationsIRequestMutList)) {
      if (!sourceIncarnation.incarnationsIRequestMutList.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        for (int i = currentObjIncarnation.elements.Count - 1; i >= 0; i--) {
          removeEffects.Add(new IRequestMutListRemoveEffect(id, i));
        }
        var effect = InternalEffectIRequestMutListDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLevelMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsLevelMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLevelMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new LevelMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new LevelMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsLevelMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLevelMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLevelMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateLevelMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new LevelMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LevelMutSetIncarnation>>(rootIncarnation.incarnationsLevelMutSet)) {
      if (!sourceIncarnation.incarnationsLevelMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new LevelMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectLevelMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsManaPotionStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsManaPotionStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsManaPotionStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new ManaPotionStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new ManaPotionStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsManaPotionStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsManaPotionStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsManaPotionStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateManaPotionStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new ManaPotionStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ManaPotionStrongMutSetIncarnation>>(rootIncarnation.incarnationsManaPotionStrongMutSet)) {
      if (!sourceIncarnation.incarnationsManaPotionStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new ManaPotionStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectManaPotionStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHealthPotionStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsHealthPotionStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsHealthPotionStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new HealthPotionStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new HealthPotionStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsHealthPotionStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHealthPotionStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsHealthPotionStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateHealthPotionStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new HealthPotionStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<HealthPotionStrongMutSetIncarnation>>(rootIncarnation.incarnationsHealthPotionStrongMutSet)) {
      if (!sourceIncarnation.incarnationsHealthPotionStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new HealthPotionStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectHealthPotionStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSpeedRingStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsSpeedRingStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSpeedRingStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new SpeedRingStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new SpeedRingStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsSpeedRingStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSpeedRingStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSpeedRingStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateSpeedRingStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new SpeedRingStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SpeedRingStrongMutSetIncarnation>>(rootIncarnation.incarnationsSpeedRingStrongMutSet)) {
      if (!sourceIncarnation.incarnationsSpeedRingStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new SpeedRingStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectSpeedRingStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGlaiveStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsGlaiveStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGlaiveStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new GlaiveStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new GlaiveStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsGlaiveStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGlaiveStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGlaiveStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateGlaiveStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new GlaiveStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GlaiveStrongMutSetIncarnation>>(rootIncarnation.incarnationsGlaiveStrongMutSet)) {
      if (!sourceIncarnation.incarnationsGlaiveStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new GlaiveStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectGlaiveStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSlowRodStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsSlowRodStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSlowRodStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new SlowRodStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new SlowRodStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsSlowRodStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSlowRodStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSlowRodStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateSlowRodStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new SlowRodStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SlowRodStrongMutSetIncarnation>>(rootIncarnation.incarnationsSlowRodStrongMutSet)) {
      if (!sourceIncarnation.incarnationsSlowRodStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new SlowRodStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectSlowRodStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsExplosionRodStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsExplosionRodStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsExplosionRodStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new ExplosionRodStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new ExplosionRodStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsExplosionRodStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsExplosionRodStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsExplosionRodStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateExplosionRodStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new ExplosionRodStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ExplosionRodStrongMutSetIncarnation>>(rootIncarnation.incarnationsExplosionRodStrongMutSet)) {
      if (!sourceIncarnation.incarnationsExplosionRodStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new ExplosionRodStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectExplosionRodStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBlazeRodStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBlazeRodStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBlazeRodStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new BlazeRodStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new BlazeRodStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsBlazeRodStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBlazeRodStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBlazeRodStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateBlazeRodStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new BlazeRodStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BlazeRodStrongMutSetIncarnation>>(rootIncarnation.incarnationsBlazeRodStrongMutSet)) {
      if (!sourceIncarnation.incarnationsBlazeRodStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new BlazeRodStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectBlazeRodStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBlastRodStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBlastRodStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBlastRodStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new BlastRodStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new BlastRodStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsBlastRodStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBlastRodStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBlastRodStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateBlastRodStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new BlastRodStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BlastRodStrongMutSetIncarnation>>(rootIncarnation.incarnationsBlastRodStrongMutSet)) {
      if (!sourceIncarnation.incarnationsBlastRodStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new BlastRodStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectBlastRodStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsArmorStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsArmorStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsArmorStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new ArmorStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new ArmorStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsArmorStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsArmorStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsArmorStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateArmorStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new ArmorStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ArmorStrongMutSetIncarnation>>(rootIncarnation.incarnationsArmorStrongMutSet)) {
      if (!sourceIncarnation.incarnationsArmorStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new ArmorStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectArmorStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHoldPositionImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new HoldPositionImpulseStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new HoldPositionImpulseStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHoldPositionImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateHoldPositionImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new HoldPositionImpulseStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<HoldPositionImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsHoldPositionImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new HoldPositionImpulseStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectHoldPositionImpulseStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new TemporaryCloneImpulseStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new TemporaryCloneImpulseStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateTemporaryCloneImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new TemporaryCloneImpulseStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TemporaryCloneImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new TemporaryCloneImpulseStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectTemporaryCloneImpulseStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSummonImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsSummonImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSummonImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new SummonImpulseStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new SummonImpulseStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsSummonImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSummonImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSummonImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateSummonImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new SummonImpulseStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SummonImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsSummonImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsSummonImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new SummonImpulseStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectSummonImpulseStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMireImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsMireImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMireImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new MireImpulseStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new MireImpulseStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsMireImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMireImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMireImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateMireImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new MireImpulseStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MireImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsMireImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsMireImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new MireImpulseStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectMireImpulseStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEvaporateImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsEvaporateImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsEvaporateImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new EvaporateImpulseStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new EvaporateImpulseStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsEvaporateImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEvaporateImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsEvaporateImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateEvaporateImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new EvaporateImpulseStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<EvaporateImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsEvaporateImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsEvaporateImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new EvaporateImpulseStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectEvaporateImpulseStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMoveImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsMoveImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMoveImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new MoveImpulseStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new MoveImpulseStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsMoveImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMoveImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMoveImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateMoveImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new MoveImpulseStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MoveImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsMoveImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsMoveImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new MoveImpulseStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectMoveImpulseStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new KamikazeJumpImpulseStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new KamikazeJumpImpulseStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateKamikazeJumpImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new KamikazeJumpImpulseStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KamikazeJumpImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new KamikazeJumpImpulseStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectKamikazeJumpImpulseStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new KamikazeTargetImpulseStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new KamikazeTargetImpulseStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateKamikazeTargetImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new KamikazeTargetImpulseStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KamikazeTargetImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new KamikazeTargetImpulseStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectKamikazeTargetImpulseStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsNoImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsNoImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsNoImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new NoImpulseStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new NoImpulseStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsNoImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsNoImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsNoImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateNoImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new NoImpulseStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<NoImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsNoImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsNoImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new NoImpulseStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectNoImpulseStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEvolvifyImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsEvolvifyImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsEvolvifyImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new EvolvifyImpulseStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new EvolvifyImpulseStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsEvolvifyImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEvolvifyImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsEvolvifyImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateEvolvifyImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new EvolvifyImpulseStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<EvolvifyImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsEvolvifyImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsEvolvifyImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new EvolvifyImpulseStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectEvolvifyImpulseStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsFireImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFireImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new FireImpulseStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new FireImpulseStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsFireImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFireImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateFireImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new FireImpulseStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FireImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsFireImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsFireImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new FireImpulseStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectFireImpulseStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefyImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsDefyImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDefyImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new DefyImpulseStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new DefyImpulseStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsDefyImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefyImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDefyImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateDefyImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new DefyImpulseStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DefyImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsDefyImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsDefyImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new DefyImpulseStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectDefyImpulseStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounterImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCounterImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCounterImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new CounterImpulseStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new CounterImpulseStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsCounterImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounterImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCounterImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateCounterImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new CounterImpulseStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CounterImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsCounterImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsCounterImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new CounterImpulseStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectCounterImpulseStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnleashBideImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new UnleashBideImpulseStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new UnleashBideImpulseStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnleashBideImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateUnleashBideImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new UnleashBideImpulseStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<UnleashBideImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsUnleashBideImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new UnleashBideImpulseStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectUnleashBideImpulseStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsContinueBidingImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new ContinueBidingImpulseStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new ContinueBidingImpulseStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsContinueBidingImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateContinueBidingImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new ContinueBidingImpulseStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ContinueBidingImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsContinueBidingImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new ContinueBidingImpulseStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectContinueBidingImpulseStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStartBidingImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsStartBidingImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsStartBidingImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new StartBidingImpulseStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new StartBidingImpulseStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsStartBidingImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStartBidingImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsStartBidingImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateStartBidingImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new StartBidingImpulseStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<StartBidingImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsStartBidingImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsStartBidingImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new StartBidingImpulseStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectStartBidingImpulseStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsAttackImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsAttackImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new AttackImpulseStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new AttackImpulseStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsAttackImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsAttackImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateAttackImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new AttackImpulseStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<AttackImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsAttackImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsAttackImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new AttackImpulseStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectAttackImpulseStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPursueImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsPursueImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsPursueImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new PursueImpulseStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new PursueImpulseStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsPursueImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsPursueImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsPursueImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreatePursueImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new PursueImpulseStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<PursueImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsPursueImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsPursueImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new PursueImpulseStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectPursueImpulseStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireBombImpulseStrongMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsFireBombImpulseStrongMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFireBombImpulseStrongMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new FireBombImpulseStrongMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new FireBombImpulseStrongMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsFireBombImpulseStrongMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireBombImpulseStrongMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFireBombImpulseStrongMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateFireBombImpulseStrongMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new FireBombImpulseStrongMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FireBombImpulseStrongMutSetIncarnation>>(rootIncarnation.incarnationsFireBombImpulseStrongMutSet)) {
      if (!sourceIncarnation.incarnationsFireBombImpulseStrongMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new FireBombImpulseStrongMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectFireBombImpulseStrongMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLightningChargedUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsLightningChargedUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLightningChargedUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new LightningChargedUCWeakMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new LightningChargedUCWeakMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsLightningChargedUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLightningChargedUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLightningChargedUCWeakMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateLightningChargedUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new LightningChargedUCWeakMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LightningChargedUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsLightningChargedUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsLightningChargedUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new LightningChargedUCWeakMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectLightningChargedUCWeakMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new TimeCloneAICapabilityUCWeakMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new TimeCloneAICapabilityUCWeakMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateTimeCloneAICapabilityUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new TimeCloneAICapabilityUCWeakMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TimeCloneAICapabilityUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new TimeCloneAICapabilityUCWeakMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectTimeCloneAICapabilityUCWeakMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDoomedUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsDoomedUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDoomedUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new DoomedUCWeakMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new DoomedUCWeakMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsDoomedUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDoomedUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDoomedUCWeakMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateDoomedUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new DoomedUCWeakMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DoomedUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsDoomedUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsDoomedUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new DoomedUCWeakMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectDoomedUCWeakMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMiredUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsMiredUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMiredUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new MiredUCWeakMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new MiredUCWeakMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsMiredUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMiredUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMiredUCWeakMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateMiredUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new MiredUCWeakMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MiredUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsMiredUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsMiredUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new MiredUCWeakMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectMiredUCWeakMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsInvincibilityUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsInvincibilityUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsInvincibilityUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new InvincibilityUCWeakMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new InvincibilityUCWeakMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsInvincibilityUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsInvincibilityUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsInvincibilityUCWeakMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateInvincibilityUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new InvincibilityUCWeakMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<InvincibilityUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsInvincibilityUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsInvincibilityUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new InvincibilityUCWeakMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectInvincibilityUCWeakMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsOnFireUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsOnFireUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsOnFireUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new OnFireUCWeakMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new OnFireUCWeakMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsOnFireUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsOnFireUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsOnFireUCWeakMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateOnFireUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new OnFireUCWeakMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<OnFireUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsOnFireUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsOnFireUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new OnFireUCWeakMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectOnFireUCWeakMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefyingUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsDefyingUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDefyingUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new DefyingUCWeakMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new DefyingUCWeakMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsDefyingUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefyingUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDefyingUCWeakMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateDefyingUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new DefyingUCWeakMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DefyingUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsDefyingUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsDefyingUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new DefyingUCWeakMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectDefyingUCWeakMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounteringUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCounteringUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCounteringUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new CounteringUCWeakMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new CounteringUCWeakMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsCounteringUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounteringUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCounteringUCWeakMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateCounteringUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new CounteringUCWeakMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CounteringUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsCounteringUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsCounteringUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new CounteringUCWeakMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectCounteringUCWeakMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackAICapabilityUCWeakMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new AttackAICapabilityUCWeakMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new AttackAICapabilityUCWeakMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackAICapabilityUCWeakMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateAttackAICapabilityUCWeakMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new AttackAICapabilityUCWeakMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<AttackAICapabilityUCWeakMutSetIncarnation>>(rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet)) {
      if (!sourceIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new AttackAICapabilityUCWeakMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectAttackAICapabilityUCWeakMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnitMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsUnitMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsUnitMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new UnitMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new UnitMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsUnitMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUnitMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsUnitMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateUnitMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new UnitMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<UnitMutSetIncarnation>>(rootIncarnation.incarnationsUnitMutSet)) {
      if (!sourceIncarnation.incarnationsUnitMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new UnitMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectUnitMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSimplePresenceTriggerTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new SimplePresenceTriggerTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new SimplePresenceTriggerTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSimplePresenceTriggerTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateSimplePresenceTriggerTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new SimplePresenceTriggerTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SimplePresenceTriggerTTCMutSetIncarnation>>(rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet)) {
      if (!sourceIncarnation.incarnationsSimplePresenceTriggerTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new SimplePresenceTriggerTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectSimplePresenceTriggerTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsItemTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsItemTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsItemTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new ItemTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new ItemTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsItemTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsItemTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsItemTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateItemTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new ItemTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ItemTTCMutSetIncarnation>>(rootIncarnation.incarnationsItemTTCMutSet)) {
      if (!sourceIncarnation.incarnationsItemTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new ItemTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectItemTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFlowerTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsFlowerTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFlowerTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new FlowerTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new FlowerTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsFlowerTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFlowerTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFlowerTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateFlowerTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new FlowerTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FlowerTTCMutSetIncarnation>>(rootIncarnation.incarnationsFlowerTTCMutSet)) {
      if (!sourceIncarnation.incarnationsFlowerTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new FlowerTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectFlowerTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLotusTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsLotusTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLotusTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new LotusTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new LotusTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsLotusTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLotusTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLotusTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateLotusTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new LotusTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LotusTTCMutSetIncarnation>>(rootIncarnation.incarnationsLotusTTCMutSet)) {
      if (!sourceIncarnation.incarnationsLotusTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new LotusTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectLotusTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRoseTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsRoseTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRoseTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new RoseTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new RoseTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsRoseTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRoseTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRoseTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateRoseTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new RoseTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RoseTTCMutSetIncarnation>>(rootIncarnation.incarnationsRoseTTCMutSet)) {
      if (!sourceIncarnation.incarnationsRoseTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new RoseTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectRoseTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLeafTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsLeafTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLeafTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new LeafTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new LeafTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsLeafTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLeafTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLeafTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateLeafTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new LeafTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LeafTTCMutSetIncarnation>>(rootIncarnation.incarnationsLeafTTCMutSet)) {
      if (!sourceIncarnation.incarnationsLeafTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new LeafTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectLeafTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeTargetTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsKamikazeTargetTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKamikazeTargetTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new KamikazeTargetTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new KamikazeTargetTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsKamikazeTargetTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeTargetTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKamikazeTargetTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateKamikazeTargetTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new KamikazeTargetTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KamikazeTargetTTCMutSetIncarnation>>(rootIncarnation.incarnationsKamikazeTargetTTCMutSet)) {
      if (!sourceIncarnation.incarnationsKamikazeTargetTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new KamikazeTargetTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectKamikazeTargetTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWarperTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsWarperTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWarperTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new WarperTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new WarperTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsWarperTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWarperTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWarperTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateWarperTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new WarperTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WarperTTCMutSetIncarnation>>(rootIncarnation.incarnationsWarperTTCMutSet)) {
      if (!sourceIncarnation.incarnationsWarperTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new WarperTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectWarperTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeAnchorTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsTimeAnchorTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTimeAnchorTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new TimeAnchorTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new TimeAnchorTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsTimeAnchorTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeAnchorTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTimeAnchorTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateTimeAnchorTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new TimeAnchorTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TimeAnchorTTCMutSetIncarnation>>(rootIncarnation.incarnationsTimeAnchorTTCMutSet)) {
      if (!sourceIncarnation.incarnationsTimeAnchorTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new TimeAnchorTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectTimeAnchorTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireBombTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsFireBombTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFireBombTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new FireBombTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new FireBombTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsFireBombTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFireBombTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFireBombTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateFireBombTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new FireBombTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FireBombTTCMutSetIncarnation>>(rootIncarnation.incarnationsFireBombTTCMutSet)) {
      if (!sourceIncarnation.incarnationsFireBombTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new FireBombTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectFireBombTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsOnFireTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsOnFireTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsOnFireTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new OnFireTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new OnFireTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsOnFireTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsOnFireTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsOnFireTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateOnFireTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new OnFireTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<OnFireTTCMutSetIncarnation>>(rootIncarnation.incarnationsOnFireTTCMutSet)) {
      if (!sourceIncarnation.incarnationsOnFireTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new OnFireTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectOnFireTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMarkerTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsMarkerTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMarkerTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new MarkerTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new MarkerTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsMarkerTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMarkerTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMarkerTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateMarkerTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new MarkerTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MarkerTTCMutSetIncarnation>>(rootIncarnation.incarnationsMarkerTTCMutSet)) {
      if (!sourceIncarnation.incarnationsMarkerTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new MarkerTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectMarkerTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLevelLinkTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsLevelLinkTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLevelLinkTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new LevelLinkTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new LevelLinkTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsLevelLinkTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLevelLinkTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLevelLinkTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateLevelLinkTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new LevelLinkTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LevelLinkTTCMutSetIncarnation>>(rootIncarnation.incarnationsLevelLinkTTCMutSet)) {
      if (!sourceIncarnation.incarnationsLevelLinkTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new LevelLinkTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectLevelLinkTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMudTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsMudTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMudTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new MudTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new MudTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsMudTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMudTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMudTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateMudTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new MudTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MudTTCMutSetIncarnation>>(rootIncarnation.incarnationsMudTTCMutSet)) {
      if (!sourceIncarnation.incarnationsMudTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new MudTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectMudTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDirtTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsDirtTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDirtTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new DirtTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new DirtTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsDirtTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDirtTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDirtTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateDirtTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new DirtTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DirtTTCMutSetIncarnation>>(rootIncarnation.incarnationsDirtTTCMutSet)) {
      if (!sourceIncarnation.incarnationsDirtTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new DirtTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectDirtTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsObsidianTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsObsidianTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsObsidianTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new ObsidianTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new ObsidianTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsObsidianTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsObsidianTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsObsidianTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateObsidianTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new ObsidianTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ObsidianTTCMutSetIncarnation>>(rootIncarnation.incarnationsObsidianTTCMutSet)) {
      if (!sourceIncarnation.incarnationsObsidianTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new ObsidianTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectObsidianTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDownStairsTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsDownStairsTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDownStairsTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new DownStairsTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new DownStairsTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsDownStairsTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDownStairsTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDownStairsTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateDownStairsTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new DownStairsTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DownStairsTTCMutSetIncarnation>>(rootIncarnation.incarnationsDownStairsTTCMutSet)) {
      if (!sourceIncarnation.incarnationsDownStairsTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new DownStairsTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectDownStairsTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUpStairsTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsUpStairsTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsUpStairsTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new UpStairsTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new UpStairsTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsUpStairsTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsUpStairsTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsUpStairsTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateUpStairsTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new UpStairsTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<UpStairsTTCMutSetIncarnation>>(rootIncarnation.incarnationsUpStairsTTCMutSet)) {
      if (!sourceIncarnation.incarnationsUpStairsTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new UpStairsTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectUpStairsTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWallTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsWallTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWallTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new WallTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new WallTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsWallTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWallTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWallTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateWallTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new WallTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WallTTCMutSetIncarnation>>(rootIncarnation.incarnationsWallTTCMutSet)) {
      if (!sourceIncarnation.incarnationsWallTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new WallTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectWallTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBloodTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBloodTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBloodTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new BloodTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new BloodTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsBloodTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBloodTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBloodTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateBloodTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new BloodTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BloodTTCMutSetIncarnation>>(rootIncarnation.incarnationsBloodTTCMutSet)) {
      if (!sourceIncarnation.incarnationsBloodTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new BloodTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectBloodTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRocksTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsRocksTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRocksTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new RocksTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new RocksTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsRocksTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRocksTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRocksTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateRocksTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new RocksTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RocksTTCMutSetIncarnation>>(rootIncarnation.incarnationsRocksTTCMutSet)) {
      if (!sourceIncarnation.incarnationsRocksTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new RocksTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectRocksTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTreeTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsTreeTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTreeTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new TreeTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new TreeTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsTreeTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTreeTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTreeTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateTreeTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new TreeTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TreeTTCMutSetIncarnation>>(rootIncarnation.incarnationsTreeTTCMutSet)) {
      if (!sourceIncarnation.incarnationsTreeTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new TreeTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectTreeTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWaterTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsWaterTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWaterTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new WaterTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new WaterTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsWaterTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWaterTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWaterTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateWaterTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new WaterTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WaterTTCMutSetIncarnation>>(rootIncarnation.incarnationsWaterTTCMutSet)) {
      if (!sourceIncarnation.incarnationsWaterTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new WaterTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectWaterTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFloorTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsFloorTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFloorTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new FloorTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new FloorTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsFloorTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFloorTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFloorTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateFloorTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new FloorTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FloorTTCMutSetIncarnation>>(rootIncarnation.incarnationsFloorTTCMutSet)) {
      if (!sourceIncarnation.incarnationsFloorTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new FloorTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectFloorTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveWallTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCaveWallTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCaveWallTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new CaveWallTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new CaveWallTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsCaveWallTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveWallTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCaveWallTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateCaveWallTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new CaveWallTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CaveWallTTCMutSetIncarnation>>(rootIncarnation.incarnationsCaveWallTTCMutSet)) {
      if (!sourceIncarnation.incarnationsCaveWallTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new CaveWallTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectCaveWallTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCaveTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCaveTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new CaveTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new CaveTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsCaveTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCaveTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCaveTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateCaveTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new CaveTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CaveTTCMutSetIncarnation>>(rootIncarnation.incarnationsCaveTTCMutSet)) {
      if (!sourceIncarnation.incarnationsCaveTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new CaveTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectCaveTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFallsTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsFallsTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsFallsTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new FallsTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new FallsTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsFallsTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsFallsTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsFallsTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateFallsTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new FallsTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<FallsTTCMutSetIncarnation>>(rootIncarnation.incarnationsFallsTTCMutSet)) {
      if (!sourceIncarnation.incarnationsFallsTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new FallsTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectFallsTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsObsidianFloorTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsObsidianFloorTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsObsidianFloorTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new ObsidianFloorTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new ObsidianFloorTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsObsidianFloorTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsObsidianFloorTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsObsidianFloorTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateObsidianFloorTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new ObsidianFloorTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ObsidianFloorTTCMutSetIncarnation>>(rootIncarnation.incarnationsObsidianFloorTTCMutSet)) {
      if (!sourceIncarnation.incarnationsObsidianFloorTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new ObsidianFloorTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectObsidianFloorTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMagmaTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsMagmaTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMagmaTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new MagmaTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new MagmaTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsMagmaTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMagmaTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMagmaTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateMagmaTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new MagmaTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MagmaTTCMutSetIncarnation>>(rootIncarnation.incarnationsMagmaTTCMutSet)) {
      if (!sourceIncarnation.incarnationsMagmaTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new MagmaTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectMagmaTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCliffTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCliffTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new CliffTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new CliffTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsCliffTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCliffTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateCliffTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new CliffTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CliffTTCMutSetIncarnation>>(rootIncarnation.incarnationsCliffTTCMutSet)) {
      if (!sourceIncarnation.incarnationsCliffTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new CliffTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectCliffTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavaNestTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsRavaNestTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRavaNestTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new RavaNestTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new RavaNestTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsRavaNestTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavaNestTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRavaNestTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateRavaNestTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new RavaNestTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RavaNestTTCMutSetIncarnation>>(rootIncarnation.incarnationsRavaNestTTCMutSet)) {
      if (!sourceIncarnation.incarnationsRavaNestTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new RavaNestTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectRavaNestTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffLandingTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCliffLandingTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCliffLandingTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new CliffLandingTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new CliffLandingTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsCliffLandingTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCliffLandingTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCliffLandingTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateCliffLandingTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new CliffLandingTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CliffLandingTTCMutSetIncarnation>>(rootIncarnation.incarnationsCliffLandingTTCMutSet)) {
      if (!sourceIncarnation.incarnationsCliffLandingTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new CliffLandingTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectCliffLandingTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStoneTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsStoneTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsStoneTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new StoneTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new StoneTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsStoneTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsStoneTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsStoneTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateStoneTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new StoneTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<StoneTTCMutSetIncarnation>>(rootIncarnation.incarnationsStoneTTCMutSet)) {
      if (!sourceIncarnation.incarnationsStoneTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new StoneTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectStoneTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGrassTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsGrassTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGrassTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new GrassTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new GrassTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsGrassTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGrassTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGrassTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateGrassTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new GrassTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GrassTTCMutSetIncarnation>>(rootIncarnation.incarnationsGrassTTCMutSet)) {
      if (!sourceIncarnation.incarnationsGrassTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new GrassTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectGrassTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new EmberDeepLevelLinkerTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new EmberDeepLevelLinkerTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateEmberDeepLevelLinkerTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new EmberDeepLevelLinkerTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<EmberDeepLevelLinkerTTCMutSetIncarnation>>(rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet)) {
      if (!sourceIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new EmberDeepLevelLinkerTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectEmberDeepLevelLinkerTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new IncendianFallsLevelLinkerTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new IncendianFallsLevelLinkerTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateIncendianFallsLevelLinkerTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new IncendianFallsLevelLinkerTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<IncendianFallsLevelLinkerTTCMutSetIncarnation>>(rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet)) {
      if (!sourceIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new IncendianFallsLevelLinkerTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectIncendianFallsLevelLinkerTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new RavaArcanaLevelLinkerTTCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new RavaArcanaLevelLinkerTTCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateRavaArcanaLevelLinkerTTCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new RavaArcanaLevelLinkerTTCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<RavaArcanaLevelLinkerTTCMutSetIncarnation>>(rootIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet)) {
      if (!sourceIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new RavaArcanaLevelLinkerTTCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectRavaArcanaLevelLinkerTTCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDeathTriggerUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsDeathTriggerUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDeathTriggerUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new DeathTriggerUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new DeathTriggerUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsDeathTriggerUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDeathTriggerUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDeathTriggerUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateDeathTriggerUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new DeathTriggerUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DeathTriggerUCMutSetIncarnation>>(rootIncarnation.incarnationsDeathTriggerUCMutSet)) {
      if (!sourceIncarnation.incarnationsDeathTriggerUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new DeathTriggerUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectDeathTriggerUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBequeathUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBequeathUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBequeathUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new BequeathUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new BequeathUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsBequeathUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBequeathUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBequeathUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateBequeathUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new BequeathUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BequeathUCMutSetIncarnation>>(rootIncarnation.incarnationsBequeathUCMutSet)) {
      if (!sourceIncarnation.incarnationsBequeathUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new BequeathUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectBequeathUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTutorialDefyCounterUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsTutorialDefyCounterUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTutorialDefyCounterUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new TutorialDefyCounterUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new TutorialDefyCounterUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsTutorialDefyCounterUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTutorialDefyCounterUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTutorialDefyCounterUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateTutorialDefyCounterUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new TutorialDefyCounterUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TutorialDefyCounterUCMutSetIncarnation>>(rootIncarnation.incarnationsTutorialDefyCounterUCMutSet)) {
      if (!sourceIncarnation.incarnationsTutorialDefyCounterUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new TutorialDefyCounterUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectTutorialDefyCounterUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLightningChargingUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsLightningChargingUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLightningChargingUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new LightningChargingUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new LightningChargingUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsLightningChargingUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLightningChargingUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLightningChargingUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateLightningChargingUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new LightningChargingUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LightningChargingUCMutSetIncarnation>>(rootIncarnation.incarnationsLightningChargingUCMutSet)) {
      if (!sourceIncarnation.incarnationsLightningChargingUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new LightningChargingUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectLightningChargingUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWanderAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsWanderAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsWanderAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new WanderAICapabilityUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new WanderAICapabilityUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsWanderAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsWanderAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsWanderAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateWanderAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new WanderAICapabilityUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<WanderAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsWanderAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsWanderAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new WanderAICapabilityUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectWanderAICapabilityUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new TemporaryCloneAICapabilityUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new TemporaryCloneAICapabilityUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateTemporaryCloneAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new TemporaryCloneAICapabilityUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TemporaryCloneAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new TemporaryCloneAICapabilityUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectTemporaryCloneAICapabilityUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSummonAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsSummonAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSummonAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new SummonAICapabilityUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new SummonAICapabilityUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsSummonAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSummonAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSummonAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateSummonAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new SummonAICapabilityUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SummonAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsSummonAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsSummonAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new SummonAICapabilityUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectSummonAICapabilityUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new KamikazeAICapabilityUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new KamikazeAICapabilityUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateKamikazeAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new KamikazeAICapabilityUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KamikazeAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsKamikazeAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new KamikazeAICapabilityUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectKamikazeAICapabilityUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGuardAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsGuardAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGuardAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new GuardAICapabilityUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new GuardAICapabilityUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsGuardAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGuardAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGuardAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateGuardAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new GuardAICapabilityUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GuardAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsGuardAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsGuardAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new GuardAICapabilityUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectGuardAICapabilityUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEvolvifyAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsEvolvifyAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsEvolvifyAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new EvolvifyAICapabilityUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new EvolvifyAICapabilityUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsEvolvifyAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsEvolvifyAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsEvolvifyAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateEvolvifyAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new EvolvifyAICapabilityUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<EvolvifyAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsEvolvifyAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsEvolvifyAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new EvolvifyAICapabilityUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectEvolvifyAICapabilityUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeCloneAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new TimeCloneAICapabilityUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new TimeCloneAICapabilityUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTimeCloneAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateTimeCloneAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new TimeCloneAICapabilityUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TimeCloneAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new TimeCloneAICapabilityUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectTimeCloneAICapabilityUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDoomedUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsDoomedUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDoomedUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new DoomedUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new DoomedUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsDoomedUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDoomedUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDoomedUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateDoomedUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new DoomedUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DoomedUCMutSetIncarnation>>(rootIncarnation.incarnationsDoomedUCMutSet)) {
      if (!sourceIncarnation.incarnationsDoomedUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new DoomedUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectDoomedUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMiredUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsMiredUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsMiredUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new MiredUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new MiredUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsMiredUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsMiredUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsMiredUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateMiredUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new MiredUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<MiredUCMutSetIncarnation>>(rootIncarnation.incarnationsMiredUCMutSet)) {
      if (!sourceIncarnation.incarnationsMiredUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new MiredUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectMiredUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsOnFireUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsOnFireUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsOnFireUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new OnFireUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new OnFireUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsOnFireUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsOnFireUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsOnFireUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateOnFireUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new OnFireUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<OnFireUCMutSetIncarnation>>(rootIncarnation.incarnationsOnFireUCMutSet)) {
      if (!sourceIncarnation.incarnationsOnFireUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new OnFireUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectOnFireUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsAttackAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsAttackAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new AttackAICapabilityUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new AttackAICapabilityUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsAttackAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsAttackAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsAttackAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateAttackAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new AttackAICapabilityUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<AttackAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsAttackAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsAttackAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new AttackAICapabilityUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectAttackAICapabilityUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounteringUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsCounteringUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsCounteringUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new CounteringUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new CounteringUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsCounteringUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsCounteringUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsCounteringUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateCounteringUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new CounteringUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<CounteringUCMutSetIncarnation>>(rootIncarnation.incarnationsCounteringUCMutSet)) {
      if (!sourceIncarnation.incarnationsCounteringUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new CounteringUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectCounteringUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLightningChargedUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsLightningChargedUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsLightningChargedUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new LightningChargedUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new LightningChargedUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsLightningChargedUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsLightningChargedUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsLightningChargedUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateLightningChargedUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new LightningChargedUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<LightningChargedUCMutSetIncarnation>>(rootIncarnation.incarnationsLightningChargedUCMutSet)) {
      if (!sourceIncarnation.incarnationsLightningChargedUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new LightningChargedUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectLightningChargedUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsInvincibilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsInvincibilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsInvincibilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new InvincibilityUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new InvincibilityUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsInvincibilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsInvincibilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsInvincibilityUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateInvincibilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new InvincibilityUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<InvincibilityUCMutSetIncarnation>>(rootIncarnation.incarnationsInvincibilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsInvincibilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new InvincibilityUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectInvincibilityUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefyingUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsDefyingUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsDefyingUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new DefyingUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new DefyingUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsDefyingUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsDefyingUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsDefyingUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateDefyingUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new DefyingUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<DefyingUCMutSetIncarnation>>(rootIncarnation.incarnationsDefyingUCMutSet)) {
      if (!sourceIncarnation.incarnationsDefyingUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new DefyingUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectDefyingUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBideAICapabilityUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBideAICapabilityUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBideAICapabilityUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new BideAICapabilityUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new BideAICapabilityUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsBideAICapabilityUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBideAICapabilityUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBideAICapabilityUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateBideAICapabilityUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new BideAICapabilityUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BideAICapabilityUCMutSetIncarnation>>(rootIncarnation.incarnationsBideAICapabilityUCMutSet)) {
      if (!sourceIncarnation.incarnationsBideAICapabilityUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new BideAICapabilityUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectBideAICapabilityUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseSightRangeUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBaseSightRangeUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBaseSightRangeUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new BaseSightRangeUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new BaseSightRangeUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsBaseSightRangeUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseSightRangeUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBaseSightRangeUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateBaseSightRangeUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new BaseSightRangeUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BaseSightRangeUCMutSetIncarnation>>(rootIncarnation.incarnationsBaseSightRangeUCMutSet)) {
      if (!sourceIncarnation.incarnationsBaseSightRangeUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new BaseSightRangeUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectBaseSightRangeUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseMovementTimeUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBaseMovementTimeUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBaseMovementTimeUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new BaseMovementTimeUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new BaseMovementTimeUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsBaseMovementTimeUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseMovementTimeUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBaseMovementTimeUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateBaseMovementTimeUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new BaseMovementTimeUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BaseMovementTimeUCMutSetIncarnation>>(rootIncarnation.incarnationsBaseMovementTimeUCMutSet)) {
      if (!sourceIncarnation.incarnationsBaseMovementTimeUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new BaseMovementTimeUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectBaseMovementTimeUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseCombatTimeUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBaseCombatTimeUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBaseCombatTimeUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new BaseCombatTimeUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new BaseCombatTimeUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsBaseCombatTimeUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseCombatTimeUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBaseCombatTimeUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateBaseCombatTimeUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new BaseCombatTimeUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BaseCombatTimeUCMutSetIncarnation>>(rootIncarnation.incarnationsBaseCombatTimeUCMutSet)) {
      if (!sourceIncarnation.incarnationsBaseCombatTimeUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new BaseCombatTimeUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectBaseCombatTimeUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsManaPotionMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsManaPotionMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsManaPotionMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new ManaPotionMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new ManaPotionMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsManaPotionMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsManaPotionMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsManaPotionMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateManaPotionMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new ManaPotionMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ManaPotionMutSetIncarnation>>(rootIncarnation.incarnationsManaPotionMutSet)) {
      if (!sourceIncarnation.incarnationsManaPotionMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new ManaPotionMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectManaPotionMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHealthPotionMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsHealthPotionMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsHealthPotionMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new HealthPotionMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new HealthPotionMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsHealthPotionMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsHealthPotionMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsHealthPotionMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateHealthPotionMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new HealthPotionMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<HealthPotionMutSetIncarnation>>(rootIncarnation.incarnationsHealthPotionMutSet)) {
      if (!sourceIncarnation.incarnationsHealthPotionMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new HealthPotionMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectHealthPotionMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSpeedRingMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsSpeedRingMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSpeedRingMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new SpeedRingMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new SpeedRingMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsSpeedRingMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSpeedRingMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSpeedRingMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateSpeedRingMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new SpeedRingMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SpeedRingMutSetIncarnation>>(rootIncarnation.incarnationsSpeedRingMutSet)) {
      if (!sourceIncarnation.incarnationsSpeedRingMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new SpeedRingMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectSpeedRingMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGlaiveMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsGlaiveMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsGlaiveMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new GlaiveMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new GlaiveMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsGlaiveMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsGlaiveMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsGlaiveMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateGlaiveMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new GlaiveMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<GlaiveMutSetIncarnation>>(rootIncarnation.incarnationsGlaiveMutSet)) {
      if (!sourceIncarnation.incarnationsGlaiveMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new GlaiveMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectGlaiveMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSlowRodMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsSlowRodMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSlowRodMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new SlowRodMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new SlowRodMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsSlowRodMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSlowRodMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSlowRodMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateSlowRodMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new SlowRodMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SlowRodMutSetIncarnation>>(rootIncarnation.incarnationsSlowRodMutSet)) {
      if (!sourceIncarnation.incarnationsSlowRodMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new SlowRodMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectSlowRodMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsExplosionRodMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsExplosionRodMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsExplosionRodMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new ExplosionRodMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new ExplosionRodMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsExplosionRodMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsExplosionRodMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsExplosionRodMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateExplosionRodMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new ExplosionRodMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ExplosionRodMutSetIncarnation>>(rootIncarnation.incarnationsExplosionRodMutSet)) {
      if (!sourceIncarnation.incarnationsExplosionRodMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new ExplosionRodMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectExplosionRodMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBlazeRodMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBlazeRodMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBlazeRodMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new BlazeRodMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new BlazeRodMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsBlazeRodMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBlazeRodMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBlazeRodMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateBlazeRodMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new BlazeRodMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BlazeRodMutSetIncarnation>>(rootIncarnation.incarnationsBlazeRodMutSet)) {
      if (!sourceIncarnation.incarnationsBlazeRodMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new BlazeRodMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectBlazeRodMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBlastRodMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBlastRodMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBlastRodMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new BlastRodMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new BlastRodMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsBlastRodMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBlastRodMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBlastRodMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateBlastRodMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new BlastRodMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BlastRodMutSetIncarnation>>(rootIncarnation.incarnationsBlastRodMutSet)) {
      if (!sourceIncarnation.incarnationsBlastRodMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new BlastRodMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectBlastRodMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsArmorMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsArmorMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsArmorMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new ArmorMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new ArmorMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsArmorMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsArmorMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsArmorMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateArmorMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new ArmorMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<ArmorMutSetIncarnation>>(rootIncarnation.incarnationsArmorMutSet)) {
      if (!sourceIncarnation.incarnationsArmorMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new ArmorMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectArmorMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSorcerousUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsSorcerousUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsSorcerousUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new SorcerousUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new SorcerousUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsSorcerousUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsSorcerousUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsSorcerousUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateSorcerousUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new SorcerousUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<SorcerousUCMutSetIncarnation>>(rootIncarnation.incarnationsSorcerousUCMutSet)) {
      if (!sourceIncarnation.incarnationsSorcerousUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new SorcerousUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectSorcerousUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseOffenseUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBaseOffenseUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBaseOffenseUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new BaseOffenseUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new BaseOffenseUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsBaseOffenseUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseOffenseUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBaseOffenseUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateBaseOffenseUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new BaseOffenseUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BaseOffenseUCMutSetIncarnation>>(rootIncarnation.incarnationsBaseOffenseUCMutSet)) {
      if (!sourceIncarnation.incarnationsBaseOffenseUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new BaseOffenseUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectBaseOffenseUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseDefenseUCMutSet) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsBaseDefenseUCMutSet.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsBaseDefenseUCMutSet[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var objIdInCurrentObjIncarnation in new SortedSet<int>(currentObjIncarnation.elements)) {
              if (!sourceObjIncarnation.elements.Contains(objIdInCurrentObjIncarnation)) {
                removeEffects.Add(new BaseDefenseUCMutSetRemoveEffect(objId, objIdInCurrentObjIncarnation));
              }
            }
            foreach (var unitIdInSourceObjIncarnation in sourceObjIncarnation.elements) {
              if (!currentObjIncarnation.elements.Contains(unitIdInSourceObjIncarnation)) {
                addEffects.Add(new BaseDefenseUCMutSetAddEffect(objId, unitIdInSourceObjIncarnation));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsBaseDefenseUCMutSet[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }

    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsBaseDefenseUCMutSet) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsBaseDefenseUCMutSet.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateBaseDefenseUCMutSet(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var element in sourceObjIncarnation.elements) {
          addEffects.Add(new BaseDefenseUCMutSetAddEffect(sourceObjId, element));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<BaseDefenseUCMutSetIncarnation>>(rootIncarnation.incarnationsBaseDefenseUCMutSet)) {
      if (!sourceIncarnation.incarnationsBaseDefenseUCMutSet.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var element in currentObjIncarnation.elements) {
          removeEffects.Add(new BaseDefenseUCMutSetRemoveEffect(id, element));
        }
        var effect = InternalEffectBaseDefenseUCMutSetDelete(id);
        deleteEffects.Add(effect);
      }
    }

      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTerrainTileByLocationMutMap) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsTerrainTileByLocationMutMap.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsTerrainTileByLocationMutMap[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var entryInCurrentObjIncarnation in new SortedDictionary<Location, int>(currentObjIncarnation.elements)) {
              var key = entryInCurrentObjIncarnation.Key;
              if (!sourceObjIncarnation.elements.ContainsKey(key)) {
                removeEffects.Add(new TerrainTileByLocationMutMapRemoveEffect(objId, key));
              }
            }
            foreach (var entryInSourceObjIncarnation in sourceObjIncarnation.elements) {
              var key = entryInSourceObjIncarnation.Key;
              var element = entryInSourceObjIncarnation.Value;
              if (!currentObjIncarnation.elements.ContainsKey(key)) {
                addEffects.Add(new TerrainTileByLocationMutMapAddEffect(objId, key, element));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsTerrainTileByLocationMutMap[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsTerrainTileByLocationMutMap) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsTerrainTileByLocationMutMap.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateTerrainTileByLocationMutMap(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var keyAndElement in sourceObjIncarnation.elements) {
          addEffects.Add(new TerrainTileByLocationMutMapAddEffect(sourceObjId, keyAndElement.Key, keyAndElement.Value));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<TerrainTileByLocationMutMapIncarnation>>(rootIncarnation.incarnationsTerrainTileByLocationMutMap)) {
      if (!sourceIncarnation.incarnationsTerrainTileByLocationMutMap.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var keyAndElement in currentObjIncarnation.elements) {
          removeEffects.Add(new TerrainTileByLocationMutMapRemoveEffect(id, keyAndElement.Key));
        }
        var effect = InternalEffectTerrainTileByLocationMutMapDelete(id);
        deleteEffects.Add(effect);
      }
    }
             
      foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap) {
        var objId = sourceIdAndVersionAndObjIncarnation.Key;
        var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
        var sourceVersion = sourceVersionAndObjIncarnation.version;
        var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
        if (rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap.ContainsKey(objId)) {
          // Compare everything that could possibly have changed.
          var currentVersionAndObjIncarnation = rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap[objId];
          var currentVersion = currentVersionAndObjIncarnation.version;
          var currentObjIncarnation = currentVersionAndObjIncarnation.incarnation;
          if (currentVersion != sourceVersion) {
            foreach (var entryInCurrentObjIncarnation in new SortedDictionary<Location, int>(currentObjIncarnation.elements)) {
              var key = entryInCurrentObjIncarnation.Key;
              if (!sourceObjIncarnation.elements.ContainsKey(key)) {
                removeEffects.Add(new KamikazeTargetTTCStrongByLocationMutMapRemoveEffect(objId, key));
              }
            }
            foreach (var entryInSourceObjIncarnation in sourceObjIncarnation.elements) {
              var key = entryInSourceObjIncarnation.Key;
              var element = entryInSourceObjIncarnation.Value;
              if (!currentObjIncarnation.elements.ContainsKey(key)) {
                addEffects.Add(new KamikazeTargetTTCStrongByLocationMutMapAddEffect(objId, key, element));
              }
            }
            // Swap out the underlying incarnation.
            rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap[objId] = sourceVersionAndObjIncarnation;
          }
        }
      }
    foreach (var sourceIdAndVersionAndObjIncarnation in sourceIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap) {
      var sourceObjId = sourceIdAndVersionAndObjIncarnation.Key;
      var sourceVersionAndObjIncarnation = sourceIdAndVersionAndObjIncarnation.Value;
      var sourceVersion = sourceVersionAndObjIncarnation.version;
      var sourceObjIncarnation = sourceVersionAndObjIncarnation.incarnation;
      if (!rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap.ContainsKey(sourceObjId)) {
        var createEffect = InternalEffectCreateKamikazeTargetTTCStrongByLocationMutMap(sourceObjId, sourceVersionAndObjIncarnation.version, sourceObjIncarnation);
        createEffects.Add(createEffect);
        foreach (var keyAndElement in sourceObjIncarnation.elements) {
          addEffects.Add(new KamikazeTargetTTCStrongByLocationMutMapAddEffect(sourceObjId, keyAndElement.Key, keyAndElement.Value));
        }
      }
    }
    foreach (var currentIdAndVersionAndObjIncarnation in new SortedDictionary<int, VersionAndIncarnation<KamikazeTargetTTCStrongByLocationMutMapIncarnation>>(rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap)) {
      if (!sourceIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap.ContainsKey(currentIdAndVersionAndObjIncarnation.Key)) {
        var id = currentIdAndVersionAndObjIncarnation.Key;
        var currentObjIncarnation = currentIdAndVersionAndObjIncarnation.Value.incarnation;
        foreach (var keyAndElement in currentObjIncarnation.elements) {
          removeEffects.Add(new KamikazeTargetTTCStrongByLocationMutMapRemoveEffect(id, keyAndElement.Key));
        }
        var effect = InternalEffectKamikazeTargetTTCStrongByLocationMutMapDelete(id);
        deleteEffects.Add(effect);
      }
    }
             
    foreach (var effect in createEffects) {
      NotifyEffect(effect);
    }
    foreach (var effect in addEffects) {
      NotifyEffect(effect);
    }
    foreach (var effect in setEffects) {
      NotifyEffect(effect);
    }
    foreach (var effect in removeEffects) {
      NotifyEffect(effect);
    }
    foreach (var effect in deleteEffects) {
      NotifyEffect(effect);
    }
  }
       public RandIncarnation GetRandIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsRand[id].incarnation;
  }
  public bool RandExists(int id) {
    return rootIncarnation.incarnationsRand.ContainsKey(id);
  }
  public Rand GetRand(int id) {
    CheckHasRand(id);
    return new Rand(this, id);
  }
  public Rand GetRandOrNull(int id) {
    if (RandExists(id)) {
      return new Rand(this, id);
    } else {
      return new Rand(this, 0);
    }
  }
  public List<Rand> AllRand() {
    List<Rand> result = new List<Rand>(rootIncarnation.incarnationsRand.Count);
    foreach (var id in rootIncarnation.incarnationsRand.Keys) {
      result.Add(new Rand(this, id));
    }
    return result;
  }
  public IEnumerator<Rand> EnumAllRand() {
    foreach (var id in rootIncarnation.incarnationsRand.Keys) {
      yield return GetRand(id);
    }
  }
  public void CheckHasRand(Rand thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasRand(thing.id);
  }
  public void CheckHasRand(int id) {
    if (!rootIncarnation.incarnationsRand.ContainsKey(id)) {
      throw new System.Exception("Invalid Rand: " + id);
    }
  }
  public Rand EffectRandCreate(
      int rand) {
    return TrustedEffectRandCreateWithId(NewId()
            ,rand    );
  }
  public Rand TrustedEffectRandCreateWithId(int id
,      int rand) {
    CheckUnlocked();

    var incarnation =
        new RandIncarnation(
            rand
            );
    var effect = InternalEffectCreateRand(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new Rand(this, id);
  }
  public RandCreateEffect InternalEffectCreateRand(
      int id,
      int incarnationVersion,
      RandIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsRand.Add(
        id,
        new VersionAndIncarnation<RandIncarnation>(
            incarnationVersion,
            incarnation));
    return new RandCreateEffect(id, incarnation.Copy());
  }

  public void EffectRandDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectRandDelete(id);
    NotifyEffect(effect);
  }
  public RandDeleteEffect InternalEffectRandDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsRand[id];

    rootIncarnation.incarnationsRand.Remove(id);
    return new RandDeleteEffect(id);
  }

     
  public int GetRandHash(int id, int version, RandIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.rand.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectRandSetRand(
      int id, int newValue) {
    CheckUnlocked();
    CheckHasRand(id);
    var effect = InternalEffectRandSetRand(id, newValue);
    NotifyEffect(effect);
  }
  public RandSetRandEffect InternalEffectRandSetRand(int id, int newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsRand[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.rand;
      oldIncarnationAndVersion.incarnation.rand = newValue;

    } else {
      var newIncarnation =
          new RandIncarnation(
              newValue);
      rootIncarnation.incarnationsRand[id] =
          new VersionAndIncarnation<RandIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new RandSetRandEffect(id, newValue);
  }
  public HoldPositionImpulseIncarnation GetHoldPositionImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsHoldPositionImpulse[id].incarnation;
  }
  public bool HoldPositionImpulseExists(int id) {
    return rootIncarnation.incarnationsHoldPositionImpulse.ContainsKey(id);
  }
  public HoldPositionImpulse GetHoldPositionImpulse(int id) {
    CheckHasHoldPositionImpulse(id);
    return new HoldPositionImpulse(this, id);
  }
  public HoldPositionImpulse GetHoldPositionImpulseOrNull(int id) {
    if (HoldPositionImpulseExists(id)) {
      return new HoldPositionImpulse(this, id);
    } else {
      return new HoldPositionImpulse(this, 0);
    }
  }
  public List<HoldPositionImpulse> AllHoldPositionImpulse() {
    List<HoldPositionImpulse> result = new List<HoldPositionImpulse>(rootIncarnation.incarnationsHoldPositionImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsHoldPositionImpulse.Keys) {
      result.Add(new HoldPositionImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<HoldPositionImpulse> EnumAllHoldPositionImpulse() {
    foreach (var id in rootIncarnation.incarnationsHoldPositionImpulse.Keys) {
      yield return GetHoldPositionImpulse(id);
    }
  }
  public void CheckHasHoldPositionImpulse(HoldPositionImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasHoldPositionImpulse(thing.id);
  }
  public void CheckHasHoldPositionImpulse(int id) {
    if (!rootIncarnation.incarnationsHoldPositionImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid HoldPositionImpulse: " + id);
    }
  }
  public HoldPositionImpulse EffectHoldPositionImpulseCreate(
      int weight,
      int duration) {
    return TrustedEffectHoldPositionImpulseCreateWithId(NewId()
            ,weight
            ,duration    );
  }
  public HoldPositionImpulse TrustedEffectHoldPositionImpulseCreateWithId(int id
,      int weight
,      int duration) {
    CheckUnlocked();

    var incarnation =
        new HoldPositionImpulseIncarnation(
            weight,
            duration
            );
    var effect = InternalEffectCreateHoldPositionImpulse(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new HoldPositionImpulse(this, id);
  }
  public HoldPositionImpulseCreateEffect InternalEffectCreateHoldPositionImpulse(
      int id,
      int incarnationVersion,
      HoldPositionImpulseIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsHoldPositionImpulse.Add(
        id,
        new VersionAndIncarnation<HoldPositionImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    return new HoldPositionImpulseCreateEffect(id, incarnation.Copy());
  }

  public void EffectHoldPositionImpulseDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectHoldPositionImpulseDelete(id);
    NotifyEffect(effect);
  }
  public HoldPositionImpulseDeleteEffect InternalEffectHoldPositionImpulseDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsHoldPositionImpulse[id];

    rootIncarnation.incarnationsHoldPositionImpulse.Remove(id);
    return new HoldPositionImpulseDeleteEffect(id);
  }

     
  public int GetHoldPositionImpulseHash(int id, int version, HoldPositionImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.duration.GetDeterministicHashCode();
    return result;
  }
       public WanderAICapabilityUCIncarnation GetWanderAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsWanderAICapabilityUC[id].incarnation;
  }
  public bool WanderAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id);
  }
  public WanderAICapabilityUC GetWanderAICapabilityUC(int id) {
    CheckHasWanderAICapabilityUC(id);
    return new WanderAICapabilityUC(this, id);
  }
  public WanderAICapabilityUC GetWanderAICapabilityUCOrNull(int id) {
    if (WanderAICapabilityUCExists(id)) {
      return new WanderAICapabilityUC(this, id);
    } else {
      return new WanderAICapabilityUC(this, 0);
    }
  }
  public List<WanderAICapabilityUC> AllWanderAICapabilityUC() {
    List<WanderAICapabilityUC> result = new List<WanderAICapabilityUC>(rootIncarnation.incarnationsWanderAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsWanderAICapabilityUC.Keys) {
      result.Add(new WanderAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<WanderAICapabilityUC> EnumAllWanderAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsWanderAICapabilityUC.Keys) {
      yield return GetWanderAICapabilityUC(id);
    }
  }
  public void CheckHasWanderAICapabilityUC(WanderAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasWanderAICapabilityUC(thing.id);
  }
  public void CheckHasWanderAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid WanderAICapabilityUC: " + id);
    }
  }
  public WanderAICapabilityUC EffectWanderAICapabilityUCCreate(
) {
    return TrustedEffectWanderAICapabilityUCCreateWithId(NewId()
    );
  }
  public WanderAICapabilityUC TrustedEffectWanderAICapabilityUCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new WanderAICapabilityUCIncarnation(

            );
    var effect = InternalEffectCreateWanderAICapabilityUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new WanderAICapabilityUC(this, id);
  }
  public WanderAICapabilityUCCreateEffect InternalEffectCreateWanderAICapabilityUC(
      int id,
      int incarnationVersion,
      WanderAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsWanderAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<WanderAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new WanderAICapabilityUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectWanderAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectWanderAICapabilityUCDelete(id);
    NotifyEffect(effect);
  }
  public WanderAICapabilityUCDeleteEffect InternalEffectWanderAICapabilityUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsWanderAICapabilityUC[id];

    rootIncarnation.incarnationsWanderAICapabilityUC.Remove(id);
    return new WanderAICapabilityUCDeleteEffect(id);
  }

     
  public int GetWanderAICapabilityUCHash(int id, int version, WanderAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public TutorialDefyCounterUCIncarnation GetTutorialDefyCounterUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTutorialDefyCounterUC[id].incarnation;
  }
  public bool TutorialDefyCounterUCExists(int id) {
    return rootIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(id);
  }
  public TutorialDefyCounterUC GetTutorialDefyCounterUC(int id) {
    CheckHasTutorialDefyCounterUC(id);
    return new TutorialDefyCounterUC(this, id);
  }
  public TutorialDefyCounterUC GetTutorialDefyCounterUCOrNull(int id) {
    if (TutorialDefyCounterUCExists(id)) {
      return new TutorialDefyCounterUC(this, id);
    } else {
      return new TutorialDefyCounterUC(this, 0);
    }
  }
  public List<TutorialDefyCounterUC> AllTutorialDefyCounterUC() {
    List<TutorialDefyCounterUC> result = new List<TutorialDefyCounterUC>(rootIncarnation.incarnationsTutorialDefyCounterUC.Count);
    foreach (var id in rootIncarnation.incarnationsTutorialDefyCounterUC.Keys) {
      result.Add(new TutorialDefyCounterUC(this, id));
    }
    return result;
  }
  public IEnumerator<TutorialDefyCounterUC> EnumAllTutorialDefyCounterUC() {
    foreach (var id in rootIncarnation.incarnationsTutorialDefyCounterUC.Keys) {
      yield return GetTutorialDefyCounterUC(id);
    }
  }
  public void CheckHasTutorialDefyCounterUC(TutorialDefyCounterUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTutorialDefyCounterUC(thing.id);
  }
  public void CheckHasTutorialDefyCounterUC(int id) {
    if (!rootIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(id)) {
      throw new System.Exception("Invalid TutorialDefyCounterUC: " + id);
    }
  }
  public TutorialDefyCounterUC EffectTutorialDefyCounterUCCreate(
      int numDefiesRemaining,
      string onChangeTriggerName) {
    return TrustedEffectTutorialDefyCounterUCCreateWithId(NewId()
            ,numDefiesRemaining
            ,onChangeTriggerName    );
  }
  public TutorialDefyCounterUC TrustedEffectTutorialDefyCounterUCCreateWithId(int id
,      int numDefiesRemaining
,      string onChangeTriggerName) {
    CheckUnlocked();

    var incarnation =
        new TutorialDefyCounterUCIncarnation(
            numDefiesRemaining,
            onChangeTriggerName
            );
    var effect = InternalEffectCreateTutorialDefyCounterUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new TutorialDefyCounterUC(this, id);
  }
  public TutorialDefyCounterUCCreateEffect InternalEffectCreateTutorialDefyCounterUC(
      int id,
      int incarnationVersion,
      TutorialDefyCounterUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsTutorialDefyCounterUC.Add(
        id,
        new VersionAndIncarnation<TutorialDefyCounterUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new TutorialDefyCounterUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectTutorialDefyCounterUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectTutorialDefyCounterUCDelete(id);
    NotifyEffect(effect);
  }
  public TutorialDefyCounterUCDeleteEffect InternalEffectTutorialDefyCounterUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTutorialDefyCounterUC[id];

    rootIncarnation.incarnationsTutorialDefyCounterUC.Remove(id);
    return new TutorialDefyCounterUCDeleteEffect(id);
  }

     
  public int GetTutorialDefyCounterUCHash(int id, int version, TutorialDefyCounterUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.numDefiesRemaining.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.onChangeTriggerName.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectTutorialDefyCounterUCSetNumDefiesRemaining(
      int id, int newValue) {
    CheckUnlocked();
    CheckHasTutorialDefyCounterUC(id);
    var effect = InternalEffectTutorialDefyCounterUCSetNumDefiesRemaining(id, newValue);
    NotifyEffect(effect);
  }
  public TutorialDefyCounterUCSetNumDefiesRemainingEffect InternalEffectTutorialDefyCounterUCSetNumDefiesRemaining(int id, int newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsTutorialDefyCounterUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.numDefiesRemaining;
      oldIncarnationAndVersion.incarnation.numDefiesRemaining = newValue;

    } else {
      var newIncarnation =
          new TutorialDefyCounterUCIncarnation(
              newValue,
              oldIncarnationAndVersion.incarnation.onChangeTriggerName);
      rootIncarnation.incarnationsTutorialDefyCounterUC[id] =
          new VersionAndIncarnation<TutorialDefyCounterUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new TutorialDefyCounterUCSetNumDefiesRemainingEffect(id, newValue);
  }
  public UnitIncarnation GetUnitIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsUnit[id].incarnation;
  }
  public bool UnitExists(int id) {
    return rootIncarnation.incarnationsUnit.ContainsKey(id);
  }
  public Unit GetUnit(int id) {
    CheckHasUnit(id);
    return new Unit(this, id);
  }
  public Unit GetUnitOrNull(int id) {
    if (UnitExists(id)) {
      return new Unit(this, id);
    } else {
      return new Unit(this, 0);
    }
  }
  public List<Unit> AllUnit() {
    List<Unit> result = new List<Unit>(rootIncarnation.incarnationsUnit.Count);
    foreach (var id in rootIncarnation.incarnationsUnit.Keys) {
      result.Add(new Unit(this, id));
    }
    return result;
  }
  public IEnumerator<Unit> EnumAllUnit() {
    foreach (var id in rootIncarnation.incarnationsUnit.Keys) {
      yield return GetUnit(id);
    }
  }
  public void CheckHasUnit(Unit thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasUnit(thing.id);
  }
  public void CheckHasUnit(int id) {
    if (!rootIncarnation.incarnationsUnit.ContainsKey(id)) {
      throw new System.Exception("Invalid Unit: " + id);
    }
  }
  public Unit EffectUnitCreate(
      IUnitEvent evvent,
      int lifeEndTime,
      Location location,
      string classId,
      int nextActionTime,
      int hp,
      int maxHp,
      IUnitComponentMutBunch components,
      bool good) {
    CheckHasIUnitComponentMutBunch(components);
    return TrustedEffectUnitCreateWithId(NewId()
            ,evvent
            ,lifeEndTime
            ,location
            ,classId
            ,nextActionTime
            ,hp
            ,maxHp
            ,components.id
            ,good    );
  }
  public Unit TrustedEffectUnitCreateWithId(int id
,      IUnitEvent evvent
,      int lifeEndTime
,      Location location
,      string classId
,      int nextActionTime
,      int hp
,      int maxHp
,      int components
,      bool good) {
    CheckUnlocked();

    var incarnation =
        new UnitIncarnation(
            evvent,
            lifeEndTime,
            location,
            classId,
            nextActionTime,
            hp,
            maxHp,
            components,
            good
            );
    var effect = InternalEffectCreateUnit(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new Unit(this, id);
  }
  public UnitCreateEffect InternalEffectCreateUnit(
      int id,
      int incarnationVersion,
      UnitIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsUnit.Add(
        id,
        new VersionAndIncarnation<UnitIncarnation>(
            incarnationVersion,
            incarnation));
    return new UnitCreateEffect(id, incarnation.Copy());
  }

  public void EffectUnitDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectUnitDelete(id);
    NotifyEffect(effect);
  }
  public UnitDeleteEffect InternalEffectUnitDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsUnit[id];

    rootIncarnation.incarnationsUnit.Remove(id);
    return new UnitDeleteEffect(id);
  }

     
  public int GetUnitHash(int id, int version, UnitIncarnation incarnation) {
    int result = id * version;
    if (!object.ReferenceEquals(incarnation.evvent, null)) {
      result += id * version * 1 * incarnation.evvent.GetDeterministicHashCode();
    }
    result += id * version * 2 * incarnation.lifeEndTime.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.location.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.classId.GetDeterministicHashCode();
    result += id * version * 5 * incarnation.nextActionTime.GetDeterministicHashCode();
    result += id * version * 6 * incarnation.hp.GetDeterministicHashCode();
    result += id * version * 7 * incarnation.maxHp.GetDeterministicHashCode();
    result += id * version * 8 * incarnation.components.GetDeterministicHashCode();
    result += id * version * 9 * incarnation.good.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectUnitSetEvvent(
      int id, IUnitEvent newValue) {
    CheckUnlocked();
    CheckHasUnit(id);
    var effect = InternalEffectUnitSetEvvent(id, newValue);
    NotifyEffect(effect);
  }
  public UnitSetEvventEffect InternalEffectUnitSetEvvent(int id, IUnitEvent newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsUnit[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.evvent;
      oldIncarnationAndVersion.incarnation.evvent = newValue;

    } else {
      var newIncarnation =
          new UnitIncarnation(
              newValue,
              oldIncarnationAndVersion.incarnation.lifeEndTime,
              oldIncarnationAndVersion.incarnation.location,
              oldIncarnationAndVersion.incarnation.classId,
              oldIncarnationAndVersion.incarnation.nextActionTime,
              oldIncarnationAndVersion.incarnation.hp,
              oldIncarnationAndVersion.incarnation.maxHp,
              oldIncarnationAndVersion.incarnation.components,
              oldIncarnationAndVersion.incarnation.good);
      rootIncarnation.incarnationsUnit[id] =
          new VersionAndIncarnation<UnitIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new UnitSetEvventEffect(id, newValue);
  }

  public void EffectUnitSetLifeEndTime(
      int id, int newValue) {
    CheckUnlocked();
    CheckHasUnit(id);
    var effect = InternalEffectUnitSetLifeEndTime(id, newValue);
    NotifyEffect(effect);
  }
  public UnitSetLifeEndTimeEffect InternalEffectUnitSetLifeEndTime(int id, int newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsUnit[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.lifeEndTime;
      oldIncarnationAndVersion.incarnation.lifeEndTime = newValue;

    } else {
      var newIncarnation =
          new UnitIncarnation(
              oldIncarnationAndVersion.incarnation.evvent,
              newValue,
              oldIncarnationAndVersion.incarnation.location,
              oldIncarnationAndVersion.incarnation.classId,
              oldIncarnationAndVersion.incarnation.nextActionTime,
              oldIncarnationAndVersion.incarnation.hp,
              oldIncarnationAndVersion.incarnation.maxHp,
              oldIncarnationAndVersion.incarnation.components,
              oldIncarnationAndVersion.incarnation.good);
      rootIncarnation.incarnationsUnit[id] =
          new VersionAndIncarnation<UnitIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new UnitSetLifeEndTimeEffect(id, newValue);
  }

  public void EffectUnitSetLocation(
      int id, Location newValue) {
    CheckUnlocked();
    CheckHasUnit(id);
    var effect = InternalEffectUnitSetLocation(id, newValue);
    NotifyEffect(effect);
  }
  public UnitSetLocationEffect InternalEffectUnitSetLocation(int id, Location newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsUnit[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.location;
      oldIncarnationAndVersion.incarnation.location = newValue;

    } else {
      var newIncarnation =
          new UnitIncarnation(
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.lifeEndTime,
              newValue,
              oldIncarnationAndVersion.incarnation.classId,
              oldIncarnationAndVersion.incarnation.nextActionTime,
              oldIncarnationAndVersion.incarnation.hp,
              oldIncarnationAndVersion.incarnation.maxHp,
              oldIncarnationAndVersion.incarnation.components,
              oldIncarnationAndVersion.incarnation.good);
      rootIncarnation.incarnationsUnit[id] =
          new VersionAndIncarnation<UnitIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new UnitSetLocationEffect(id, newValue);
  }

  public void EffectUnitSetNextActionTime(
      int id, int newValue) {
    CheckUnlocked();
    CheckHasUnit(id);
    var effect = InternalEffectUnitSetNextActionTime(id, newValue);
    NotifyEffect(effect);
  }
  public UnitSetNextActionTimeEffect InternalEffectUnitSetNextActionTime(int id, int newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsUnit[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.nextActionTime;
      oldIncarnationAndVersion.incarnation.nextActionTime = newValue;

    } else {
      var newIncarnation =
          new UnitIncarnation(
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.lifeEndTime,
              oldIncarnationAndVersion.incarnation.location,
              oldIncarnationAndVersion.incarnation.classId,
              newValue,
              oldIncarnationAndVersion.incarnation.hp,
              oldIncarnationAndVersion.incarnation.maxHp,
              oldIncarnationAndVersion.incarnation.components,
              oldIncarnationAndVersion.incarnation.good);
      rootIncarnation.incarnationsUnit[id] =
          new VersionAndIncarnation<UnitIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new UnitSetNextActionTimeEffect(id, newValue);
  }

  public void EffectUnitSetHp(
      int id, int newValue) {
    CheckUnlocked();
    CheckHasUnit(id);
    var effect = InternalEffectUnitSetHp(id, newValue);
    NotifyEffect(effect);
  }
  public UnitSetHpEffect InternalEffectUnitSetHp(int id, int newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsUnit[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.hp;
      oldIncarnationAndVersion.incarnation.hp = newValue;

    } else {
      var newIncarnation =
          new UnitIncarnation(
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.lifeEndTime,
              oldIncarnationAndVersion.incarnation.location,
              oldIncarnationAndVersion.incarnation.classId,
              oldIncarnationAndVersion.incarnation.nextActionTime,
              newValue,
              oldIncarnationAndVersion.incarnation.maxHp,
              oldIncarnationAndVersion.incarnation.components,
              oldIncarnationAndVersion.incarnation.good);
      rootIncarnation.incarnationsUnit[id] =
          new VersionAndIncarnation<UnitIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new UnitSetHpEffect(id, newValue);
  }

  public void EffectUnitSetMaxHp(
      int id, int newValue) {
    CheckUnlocked();
    CheckHasUnit(id);
    var effect = InternalEffectUnitSetMaxHp(id, newValue);
    NotifyEffect(effect);
  }
  public UnitSetMaxHpEffect InternalEffectUnitSetMaxHp(int id, int newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsUnit[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.maxHp;
      oldIncarnationAndVersion.incarnation.maxHp = newValue;

    } else {
      var newIncarnation =
          new UnitIncarnation(
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.lifeEndTime,
              oldIncarnationAndVersion.incarnation.location,
              oldIncarnationAndVersion.incarnation.classId,
              oldIncarnationAndVersion.incarnation.nextActionTime,
              oldIncarnationAndVersion.incarnation.hp,
              newValue,
              oldIncarnationAndVersion.incarnation.components,
              oldIncarnationAndVersion.incarnation.good);
      rootIncarnation.incarnationsUnit[id] =
          new VersionAndIncarnation<UnitIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new UnitSetMaxHpEffect(id, newValue);
  }
  public IUnitComponentMutBunchIncarnation GetIUnitComponentMutBunchIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsIUnitComponentMutBunch[id].incarnation;
  }
  public bool IUnitComponentMutBunchExists(int id) {
    return rootIncarnation.incarnationsIUnitComponentMutBunch.ContainsKey(id);
  }
  public IUnitComponentMutBunch GetIUnitComponentMutBunch(int id) {
    CheckHasIUnitComponentMutBunch(id);
    return new IUnitComponentMutBunch(this, id);
  }
  public IUnitComponentMutBunch GetIUnitComponentMutBunchOrNull(int id) {
    if (IUnitComponentMutBunchExists(id)) {
      return new IUnitComponentMutBunch(this, id);
    } else {
      return new IUnitComponentMutBunch(this, 0);
    }
  }
  public List<IUnitComponentMutBunch> AllIUnitComponentMutBunch() {
    List<IUnitComponentMutBunch> result = new List<IUnitComponentMutBunch>(rootIncarnation.incarnationsIUnitComponentMutBunch.Count);
    foreach (var id in rootIncarnation.incarnationsIUnitComponentMutBunch.Keys) {
      result.Add(new IUnitComponentMutBunch(this, id));
    }
    return result;
  }
  public IEnumerator<IUnitComponentMutBunch> EnumAllIUnitComponentMutBunch() {
    foreach (var id in rootIncarnation.incarnationsIUnitComponentMutBunch.Keys) {
      yield return GetIUnitComponentMutBunch(id);
    }
  }
  public void CheckHasIUnitComponentMutBunch(IUnitComponentMutBunch thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasIUnitComponentMutBunch(thing.id);
  }
  public void CheckHasIUnitComponentMutBunch(int id) {
    if (!rootIncarnation.incarnationsIUnitComponentMutBunch.ContainsKey(id)) {
      throw new System.Exception("Invalid IUnitComponentMutBunch: " + id);
    }
  }
  public IUnitComponentMutBunch EffectIUnitComponentMutBunchCreate(
      DeathTriggerUCMutSet membersDeathTriggerUCMutSet,
      BequeathUCMutSet membersBequeathUCMutSet,
      TutorialDefyCounterUCMutSet membersTutorialDefyCounterUCMutSet,
      LightningChargingUCMutSet membersLightningChargingUCMutSet,
      WanderAICapabilityUCMutSet membersWanderAICapabilityUCMutSet,
      TemporaryCloneAICapabilityUCMutSet membersTemporaryCloneAICapabilityUCMutSet,
      SummonAICapabilityUCMutSet membersSummonAICapabilityUCMutSet,
      KamikazeAICapabilityUCMutSet membersKamikazeAICapabilityUCMutSet,
      GuardAICapabilityUCMutSet membersGuardAICapabilityUCMutSet,
      EvolvifyAICapabilityUCMutSet membersEvolvifyAICapabilityUCMutSet,
      TimeCloneAICapabilityUCMutSet membersTimeCloneAICapabilityUCMutSet,
      DoomedUCMutSet membersDoomedUCMutSet,
      MiredUCMutSet membersMiredUCMutSet,
      OnFireUCMutSet membersOnFireUCMutSet,
      AttackAICapabilityUCMutSet membersAttackAICapabilityUCMutSet,
      CounteringUCMutSet membersCounteringUCMutSet,
      LightningChargedUCMutSet membersLightningChargedUCMutSet,
      InvincibilityUCMutSet membersInvincibilityUCMutSet,
      DefyingUCMutSet membersDefyingUCMutSet,
      BideAICapabilityUCMutSet membersBideAICapabilityUCMutSet,
      BaseSightRangeUCMutSet membersBaseSightRangeUCMutSet,
      BaseMovementTimeUCMutSet membersBaseMovementTimeUCMutSet,
      BaseCombatTimeUCMutSet membersBaseCombatTimeUCMutSet,
      ManaPotionMutSet membersManaPotionMutSet,
      HealthPotionMutSet membersHealthPotionMutSet,
      SpeedRingMutSet membersSpeedRingMutSet,
      GlaiveMutSet membersGlaiveMutSet,
      SlowRodMutSet membersSlowRodMutSet,
      ExplosionRodMutSet membersExplosionRodMutSet,
      BlazeRodMutSet membersBlazeRodMutSet,
      BlastRodMutSet membersBlastRodMutSet,
      ArmorMutSet membersArmorMutSet,
      SorcerousUCMutSet membersSorcerousUCMutSet,
      BaseOffenseUCMutSet membersBaseOffenseUCMutSet,
      BaseDefenseUCMutSet membersBaseDefenseUCMutSet) {
    CheckHasDeathTriggerUCMutSet(membersDeathTriggerUCMutSet);
    CheckHasBequeathUCMutSet(membersBequeathUCMutSet);
    CheckHasTutorialDefyCounterUCMutSet(membersTutorialDefyCounterUCMutSet);
    CheckHasLightningChargingUCMutSet(membersLightningChargingUCMutSet);
    CheckHasWanderAICapabilityUCMutSet(membersWanderAICapabilityUCMutSet);
    CheckHasTemporaryCloneAICapabilityUCMutSet(membersTemporaryCloneAICapabilityUCMutSet);
    CheckHasSummonAICapabilityUCMutSet(membersSummonAICapabilityUCMutSet);
    CheckHasKamikazeAICapabilityUCMutSet(membersKamikazeAICapabilityUCMutSet);
    CheckHasGuardAICapabilityUCMutSet(membersGuardAICapabilityUCMutSet);
    CheckHasEvolvifyAICapabilityUCMutSet(membersEvolvifyAICapabilityUCMutSet);
    CheckHasTimeCloneAICapabilityUCMutSet(membersTimeCloneAICapabilityUCMutSet);
    CheckHasDoomedUCMutSet(membersDoomedUCMutSet);
    CheckHasMiredUCMutSet(membersMiredUCMutSet);
    CheckHasOnFireUCMutSet(membersOnFireUCMutSet);
    CheckHasAttackAICapabilityUCMutSet(membersAttackAICapabilityUCMutSet);
    CheckHasCounteringUCMutSet(membersCounteringUCMutSet);
    CheckHasLightningChargedUCMutSet(membersLightningChargedUCMutSet);
    CheckHasInvincibilityUCMutSet(membersInvincibilityUCMutSet);
    CheckHasDefyingUCMutSet(membersDefyingUCMutSet);
    CheckHasBideAICapabilityUCMutSet(membersBideAICapabilityUCMutSet);
    CheckHasBaseSightRangeUCMutSet(membersBaseSightRangeUCMutSet);
    CheckHasBaseMovementTimeUCMutSet(membersBaseMovementTimeUCMutSet);
    CheckHasBaseCombatTimeUCMutSet(membersBaseCombatTimeUCMutSet);
    CheckHasManaPotionMutSet(membersManaPotionMutSet);
    CheckHasHealthPotionMutSet(membersHealthPotionMutSet);
    CheckHasSpeedRingMutSet(membersSpeedRingMutSet);
    CheckHasGlaiveMutSet(membersGlaiveMutSet);
    CheckHasSlowRodMutSet(membersSlowRodMutSet);
    CheckHasExplosionRodMutSet(membersExplosionRodMutSet);
    CheckHasBlazeRodMutSet(membersBlazeRodMutSet);
    CheckHasBlastRodMutSet(membersBlastRodMutSet);
    CheckHasArmorMutSet(membersArmorMutSet);
    CheckHasSorcerousUCMutSet(membersSorcerousUCMutSet);
    CheckHasBaseOffenseUCMutSet(membersBaseOffenseUCMutSet);
    CheckHasBaseDefenseUCMutSet(membersBaseDefenseUCMutSet);
    return TrustedEffectIUnitComponentMutBunchCreateWithId(NewId()
            ,membersDeathTriggerUCMutSet.id
            ,membersBequeathUCMutSet.id
            ,membersTutorialDefyCounterUCMutSet.id
            ,membersLightningChargingUCMutSet.id
            ,membersWanderAICapabilityUCMutSet.id
            ,membersTemporaryCloneAICapabilityUCMutSet.id
            ,membersSummonAICapabilityUCMutSet.id
            ,membersKamikazeAICapabilityUCMutSet.id
            ,membersGuardAICapabilityUCMutSet.id
            ,membersEvolvifyAICapabilityUCMutSet.id
            ,membersTimeCloneAICapabilityUCMutSet.id
            ,membersDoomedUCMutSet.id
            ,membersMiredUCMutSet.id
            ,membersOnFireUCMutSet.id
            ,membersAttackAICapabilityUCMutSet.id
            ,membersCounteringUCMutSet.id
            ,membersLightningChargedUCMutSet.id
            ,membersInvincibilityUCMutSet.id
            ,membersDefyingUCMutSet.id
            ,membersBideAICapabilityUCMutSet.id
            ,membersBaseSightRangeUCMutSet.id
            ,membersBaseMovementTimeUCMutSet.id
            ,membersBaseCombatTimeUCMutSet.id
            ,membersManaPotionMutSet.id
            ,membersHealthPotionMutSet.id
            ,membersSpeedRingMutSet.id
            ,membersGlaiveMutSet.id
            ,membersSlowRodMutSet.id
            ,membersExplosionRodMutSet.id
            ,membersBlazeRodMutSet.id
            ,membersBlastRodMutSet.id
            ,membersArmorMutSet.id
            ,membersSorcerousUCMutSet.id
            ,membersBaseOffenseUCMutSet.id
            ,membersBaseDefenseUCMutSet.id    );
  }
  public IUnitComponentMutBunch TrustedEffectIUnitComponentMutBunchCreateWithId(int id
,      int membersDeathTriggerUCMutSet
,      int membersBequeathUCMutSet
,      int membersTutorialDefyCounterUCMutSet
,      int membersLightningChargingUCMutSet
,      int membersWanderAICapabilityUCMutSet
,      int membersTemporaryCloneAICapabilityUCMutSet
,      int membersSummonAICapabilityUCMutSet
,      int membersKamikazeAICapabilityUCMutSet
,      int membersGuardAICapabilityUCMutSet
,      int membersEvolvifyAICapabilityUCMutSet
,      int membersTimeCloneAICapabilityUCMutSet
,      int membersDoomedUCMutSet
,      int membersMiredUCMutSet
,      int membersOnFireUCMutSet
,      int membersAttackAICapabilityUCMutSet
,      int membersCounteringUCMutSet
,      int membersLightningChargedUCMutSet
,      int membersInvincibilityUCMutSet
,      int membersDefyingUCMutSet
,      int membersBideAICapabilityUCMutSet
,      int membersBaseSightRangeUCMutSet
,      int membersBaseMovementTimeUCMutSet
,      int membersBaseCombatTimeUCMutSet
,      int membersManaPotionMutSet
,      int membersHealthPotionMutSet
,      int membersSpeedRingMutSet
,      int membersGlaiveMutSet
,      int membersSlowRodMutSet
,      int membersExplosionRodMutSet
,      int membersBlazeRodMutSet
,      int membersBlastRodMutSet
,      int membersArmorMutSet
,      int membersSorcerousUCMutSet
,      int membersBaseOffenseUCMutSet
,      int membersBaseDefenseUCMutSet) {
    CheckUnlocked();

    var incarnation =
        new IUnitComponentMutBunchIncarnation(
            membersDeathTriggerUCMutSet,
            membersBequeathUCMutSet,
            membersTutorialDefyCounterUCMutSet,
            membersLightningChargingUCMutSet,
            membersWanderAICapabilityUCMutSet,
            membersTemporaryCloneAICapabilityUCMutSet,
            membersSummonAICapabilityUCMutSet,
            membersKamikazeAICapabilityUCMutSet,
            membersGuardAICapabilityUCMutSet,
            membersEvolvifyAICapabilityUCMutSet,
            membersTimeCloneAICapabilityUCMutSet,
            membersDoomedUCMutSet,
            membersMiredUCMutSet,
            membersOnFireUCMutSet,
            membersAttackAICapabilityUCMutSet,
            membersCounteringUCMutSet,
            membersLightningChargedUCMutSet,
            membersInvincibilityUCMutSet,
            membersDefyingUCMutSet,
            membersBideAICapabilityUCMutSet,
            membersBaseSightRangeUCMutSet,
            membersBaseMovementTimeUCMutSet,
            membersBaseCombatTimeUCMutSet,
            membersManaPotionMutSet,
            membersHealthPotionMutSet,
            membersSpeedRingMutSet,
            membersGlaiveMutSet,
            membersSlowRodMutSet,
            membersExplosionRodMutSet,
            membersBlazeRodMutSet,
            membersBlastRodMutSet,
            membersArmorMutSet,
            membersSorcerousUCMutSet,
            membersBaseOffenseUCMutSet,
            membersBaseDefenseUCMutSet
            );
    var effect = InternalEffectCreateIUnitComponentMutBunch(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new IUnitComponentMutBunch(this, id);
  }
  public IUnitComponentMutBunchCreateEffect InternalEffectCreateIUnitComponentMutBunch(
      int id,
      int incarnationVersion,
      IUnitComponentMutBunchIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsIUnitComponentMutBunch.Add(
        id,
        new VersionAndIncarnation<IUnitComponentMutBunchIncarnation>(
            incarnationVersion,
            incarnation));
    return new IUnitComponentMutBunchCreateEffect(id, incarnation.Copy());
  }

  public void EffectIUnitComponentMutBunchDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectIUnitComponentMutBunchDelete(id);
    NotifyEffect(effect);
  }
  public IUnitComponentMutBunchDeleteEffect InternalEffectIUnitComponentMutBunchDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsIUnitComponentMutBunch[id];

    rootIncarnation.incarnationsIUnitComponentMutBunch.Remove(id);
    return new IUnitComponentMutBunchDeleteEffect(id);
  }

     
  public int GetIUnitComponentMutBunchHash(int id, int version, IUnitComponentMutBunchIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.membersDeathTriggerUCMutSet.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.membersBequeathUCMutSet.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.membersTutorialDefyCounterUCMutSet.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.membersLightningChargingUCMutSet.GetDeterministicHashCode();
    result += id * version * 5 * incarnation.membersWanderAICapabilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 6 * incarnation.membersTemporaryCloneAICapabilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 7 * incarnation.membersSummonAICapabilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 8 * incarnation.membersKamikazeAICapabilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 9 * incarnation.membersGuardAICapabilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 10 * incarnation.membersEvolvifyAICapabilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 11 * incarnation.membersTimeCloneAICapabilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 12 * incarnation.membersDoomedUCMutSet.GetDeterministicHashCode();
    result += id * version * 13 * incarnation.membersMiredUCMutSet.GetDeterministicHashCode();
    result += id * version * 14 * incarnation.membersOnFireUCMutSet.GetDeterministicHashCode();
    result += id * version * 15 * incarnation.membersAttackAICapabilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 16 * incarnation.membersCounteringUCMutSet.GetDeterministicHashCode();
    result += id * version * 17 * incarnation.membersLightningChargedUCMutSet.GetDeterministicHashCode();
    result += id * version * 18 * incarnation.membersInvincibilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 19 * incarnation.membersDefyingUCMutSet.GetDeterministicHashCode();
    result += id * version * 20 * incarnation.membersBideAICapabilityUCMutSet.GetDeterministicHashCode();
    result += id * version * 21 * incarnation.membersBaseSightRangeUCMutSet.GetDeterministicHashCode();
    result += id * version * 22 * incarnation.membersBaseMovementTimeUCMutSet.GetDeterministicHashCode();
    result += id * version * 23 * incarnation.membersBaseCombatTimeUCMutSet.GetDeterministicHashCode();
    result += id * version * 24 * incarnation.membersManaPotionMutSet.GetDeterministicHashCode();
    result += id * version * 25 * incarnation.membersHealthPotionMutSet.GetDeterministicHashCode();
    result += id * version * 26 * incarnation.membersSpeedRingMutSet.GetDeterministicHashCode();
    result += id * version * 27 * incarnation.membersGlaiveMutSet.GetDeterministicHashCode();
    result += id * version * 28 * incarnation.membersSlowRodMutSet.GetDeterministicHashCode();
    result += id * version * 29 * incarnation.membersExplosionRodMutSet.GetDeterministicHashCode();
    result += id * version * 30 * incarnation.membersBlazeRodMutSet.GetDeterministicHashCode();
    result += id * version * 31 * incarnation.membersBlastRodMutSet.GetDeterministicHashCode();
    result += id * version * 32 * incarnation.membersArmorMutSet.GetDeterministicHashCode();
    result += id * version * 33 * incarnation.membersSorcerousUCMutSet.GetDeterministicHashCode();
    result += id * version * 34 * incarnation.membersBaseOffenseUCMutSet.GetDeterministicHashCode();
    result += id * version * 35 * incarnation.membersBaseDefenseUCMutSet.GetDeterministicHashCode();
    return result;
  }
       public LightningChargedUCIncarnation GetLightningChargedUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsLightningChargedUC[id].incarnation;
  }
  public bool LightningChargedUCExists(int id) {
    return rootIncarnation.incarnationsLightningChargedUC.ContainsKey(id);
  }
  public LightningChargedUC GetLightningChargedUC(int id) {
    CheckHasLightningChargedUC(id);
    return new LightningChargedUC(this, id);
  }
  public LightningChargedUC GetLightningChargedUCOrNull(int id) {
    if (LightningChargedUCExists(id)) {
      return new LightningChargedUC(this, id);
    } else {
      return new LightningChargedUC(this, 0);
    }
  }
  public List<LightningChargedUC> AllLightningChargedUC() {
    List<LightningChargedUC> result = new List<LightningChargedUC>(rootIncarnation.incarnationsLightningChargedUC.Count);
    foreach (var id in rootIncarnation.incarnationsLightningChargedUC.Keys) {
      result.Add(new LightningChargedUC(this, id));
    }
    return result;
  }
  public IEnumerator<LightningChargedUC> EnumAllLightningChargedUC() {
    foreach (var id in rootIncarnation.incarnationsLightningChargedUC.Keys) {
      yield return GetLightningChargedUC(id);
    }
  }
  public void CheckHasLightningChargedUC(LightningChargedUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasLightningChargedUC(thing.id);
  }
  public void CheckHasLightningChargedUC(int id) {
    if (!rootIncarnation.incarnationsLightningChargedUC.ContainsKey(id)) {
      throw new System.Exception("Invalid LightningChargedUC: " + id);
    }
  }
  public LightningChargedUC EffectLightningChargedUCCreate(
) {
    return TrustedEffectLightningChargedUCCreateWithId(NewId()
    );
  }
  public LightningChargedUC TrustedEffectLightningChargedUCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new LightningChargedUCIncarnation(

            );
    var effect = InternalEffectCreateLightningChargedUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new LightningChargedUC(this, id);
  }
  public LightningChargedUCCreateEffect InternalEffectCreateLightningChargedUC(
      int id,
      int incarnationVersion,
      LightningChargedUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsLightningChargedUC.Add(
        id,
        new VersionAndIncarnation<LightningChargedUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new LightningChargedUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectLightningChargedUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectLightningChargedUCDelete(id);
    NotifyEffect(effect);
  }
  public LightningChargedUCDeleteEffect InternalEffectLightningChargedUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsLightningChargedUC[id];

    rootIncarnation.incarnationsLightningChargedUC.Remove(id);
    return new LightningChargedUCDeleteEffect(id);
  }

     
  public int GetLightningChargedUCHash(int id, int version, LightningChargedUCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public LightningChargingUCIncarnation GetLightningChargingUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsLightningChargingUC[id].incarnation;
  }
  public bool LightningChargingUCExists(int id) {
    return rootIncarnation.incarnationsLightningChargingUC.ContainsKey(id);
  }
  public LightningChargingUC GetLightningChargingUC(int id) {
    CheckHasLightningChargingUC(id);
    return new LightningChargingUC(this, id);
  }
  public LightningChargingUC GetLightningChargingUCOrNull(int id) {
    if (LightningChargingUCExists(id)) {
      return new LightningChargingUC(this, id);
    } else {
      return new LightningChargingUC(this, 0);
    }
  }
  public List<LightningChargingUC> AllLightningChargingUC() {
    List<LightningChargingUC> result = new List<LightningChargingUC>(rootIncarnation.incarnationsLightningChargingUC.Count);
    foreach (var id in rootIncarnation.incarnationsLightningChargingUC.Keys) {
      result.Add(new LightningChargingUC(this, id));
    }
    return result;
  }
  public IEnumerator<LightningChargingUC> EnumAllLightningChargingUC() {
    foreach (var id in rootIncarnation.incarnationsLightningChargingUC.Keys) {
      yield return GetLightningChargingUC(id);
    }
  }
  public void CheckHasLightningChargingUC(LightningChargingUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasLightningChargingUC(thing.id);
  }
  public void CheckHasLightningChargingUC(int id) {
    if (!rootIncarnation.incarnationsLightningChargingUC.ContainsKey(id)) {
      throw new System.Exception("Invalid LightningChargingUC: " + id);
    }
  }
  public LightningChargingUC EffectLightningChargingUCCreate(
) {
    return TrustedEffectLightningChargingUCCreateWithId(NewId()
    );
  }
  public LightningChargingUC TrustedEffectLightningChargingUCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new LightningChargingUCIncarnation(

            );
    var effect = InternalEffectCreateLightningChargingUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new LightningChargingUC(this, id);
  }
  public LightningChargingUCCreateEffect InternalEffectCreateLightningChargingUC(
      int id,
      int incarnationVersion,
      LightningChargingUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsLightningChargingUC.Add(
        id,
        new VersionAndIncarnation<LightningChargingUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new LightningChargingUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectLightningChargingUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectLightningChargingUCDelete(id);
    NotifyEffect(effect);
  }
  public LightningChargingUCDeleteEffect InternalEffectLightningChargingUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsLightningChargingUC[id];

    rootIncarnation.incarnationsLightningChargingUC.Remove(id);
    return new LightningChargingUCDeleteEffect(id);
  }

     
  public int GetLightningChargingUCHash(int id, int version, LightningChargingUCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public DoomedUCIncarnation GetDoomedUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsDoomedUC[id].incarnation;
  }
  public bool DoomedUCExists(int id) {
    return rootIncarnation.incarnationsDoomedUC.ContainsKey(id);
  }
  public DoomedUC GetDoomedUC(int id) {
    CheckHasDoomedUC(id);
    return new DoomedUC(this, id);
  }
  public DoomedUC GetDoomedUCOrNull(int id) {
    if (DoomedUCExists(id)) {
      return new DoomedUC(this, id);
    } else {
      return new DoomedUC(this, 0);
    }
  }
  public List<DoomedUC> AllDoomedUC() {
    List<DoomedUC> result = new List<DoomedUC>(rootIncarnation.incarnationsDoomedUC.Count);
    foreach (var id in rootIncarnation.incarnationsDoomedUC.Keys) {
      result.Add(new DoomedUC(this, id));
    }
    return result;
  }
  public IEnumerator<DoomedUC> EnumAllDoomedUC() {
    foreach (var id in rootIncarnation.incarnationsDoomedUC.Keys) {
      yield return GetDoomedUC(id);
    }
  }
  public void CheckHasDoomedUC(DoomedUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasDoomedUC(thing.id);
  }
  public void CheckHasDoomedUC(int id) {
    if (!rootIncarnation.incarnationsDoomedUC.ContainsKey(id)) {
      throw new System.Exception("Invalid DoomedUC: " + id);
    }
  }
  public DoomedUC EffectDoomedUCCreate(
      int deathTime) {
    return TrustedEffectDoomedUCCreateWithId(NewId()
            ,deathTime    );
  }
  public DoomedUC TrustedEffectDoomedUCCreateWithId(int id
,      int deathTime) {
    CheckUnlocked();

    var incarnation =
        new DoomedUCIncarnation(
            deathTime
            );
    var effect = InternalEffectCreateDoomedUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new DoomedUC(this, id);
  }
  public DoomedUCCreateEffect InternalEffectCreateDoomedUC(
      int id,
      int incarnationVersion,
      DoomedUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsDoomedUC.Add(
        id,
        new VersionAndIncarnation<DoomedUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new DoomedUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectDoomedUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectDoomedUCDelete(id);
    NotifyEffect(effect);
  }
  public DoomedUCDeleteEffect InternalEffectDoomedUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsDoomedUC[id];

    rootIncarnation.incarnationsDoomedUC.Remove(id);
    return new DoomedUCDeleteEffect(id);
  }

     
  public int GetDoomedUCHash(int id, int version, DoomedUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.deathTime.GetDeterministicHashCode();
    return result;
  }
       public TemporaryCloneImpulseIncarnation GetTemporaryCloneImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTemporaryCloneImpulse[id].incarnation;
  }
  public bool TemporaryCloneImpulseExists(int id) {
    return rootIncarnation.incarnationsTemporaryCloneImpulse.ContainsKey(id);
  }
  public TemporaryCloneImpulse GetTemporaryCloneImpulse(int id) {
    CheckHasTemporaryCloneImpulse(id);
    return new TemporaryCloneImpulse(this, id);
  }
  public TemporaryCloneImpulse GetTemporaryCloneImpulseOrNull(int id) {
    if (TemporaryCloneImpulseExists(id)) {
      return new TemporaryCloneImpulse(this, id);
    } else {
      return new TemporaryCloneImpulse(this, 0);
    }
  }
  public List<TemporaryCloneImpulse> AllTemporaryCloneImpulse() {
    List<TemporaryCloneImpulse> result = new List<TemporaryCloneImpulse>(rootIncarnation.incarnationsTemporaryCloneImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsTemporaryCloneImpulse.Keys) {
      result.Add(new TemporaryCloneImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<TemporaryCloneImpulse> EnumAllTemporaryCloneImpulse() {
    foreach (var id in rootIncarnation.incarnationsTemporaryCloneImpulse.Keys) {
      yield return GetTemporaryCloneImpulse(id);
    }
  }
  public void CheckHasTemporaryCloneImpulse(TemporaryCloneImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTemporaryCloneImpulse(thing.id);
  }
  public void CheckHasTemporaryCloneImpulse(int id) {
    if (!rootIncarnation.incarnationsTemporaryCloneImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid TemporaryCloneImpulse: " + id);
    }
  }
  public TemporaryCloneImpulse EffectTemporaryCloneImpulseCreate(
      int weight,
      string blueprintName,
      Location location,
      int hp) {
    return TrustedEffectTemporaryCloneImpulseCreateWithId(NewId()
            ,weight
            ,blueprintName
            ,location
            ,hp    );
  }
  public TemporaryCloneImpulse TrustedEffectTemporaryCloneImpulseCreateWithId(int id
,      int weight
,      string blueprintName
,      Location location
,      int hp) {
    CheckUnlocked();

    var incarnation =
        new TemporaryCloneImpulseIncarnation(
            weight,
            blueprintName,
            location,
            hp
            );
    var effect = InternalEffectCreateTemporaryCloneImpulse(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new TemporaryCloneImpulse(this, id);
  }
  public TemporaryCloneImpulseCreateEffect InternalEffectCreateTemporaryCloneImpulse(
      int id,
      int incarnationVersion,
      TemporaryCloneImpulseIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsTemporaryCloneImpulse.Add(
        id,
        new VersionAndIncarnation<TemporaryCloneImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    return new TemporaryCloneImpulseCreateEffect(id, incarnation.Copy());
  }

  public void EffectTemporaryCloneImpulseDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectTemporaryCloneImpulseDelete(id);
    NotifyEffect(effect);
  }
  public TemporaryCloneImpulseDeleteEffect InternalEffectTemporaryCloneImpulseDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTemporaryCloneImpulse[id];

    rootIncarnation.incarnationsTemporaryCloneImpulse.Remove(id);
    return new TemporaryCloneImpulseDeleteEffect(id);
  }

     
  public int GetTemporaryCloneImpulseHash(int id, int version, TemporaryCloneImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.blueprintName.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.location.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.hp.GetDeterministicHashCode();
    return result;
  }
       public TemporaryCloneAICapabilityUCIncarnation GetTemporaryCloneAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTemporaryCloneAICapabilityUC[id].incarnation;
  }
  public bool TemporaryCloneAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(id);
  }
  public TemporaryCloneAICapabilityUC GetTemporaryCloneAICapabilityUC(int id) {
    CheckHasTemporaryCloneAICapabilityUC(id);
    return new TemporaryCloneAICapabilityUC(this, id);
  }
  public TemporaryCloneAICapabilityUC GetTemporaryCloneAICapabilityUCOrNull(int id) {
    if (TemporaryCloneAICapabilityUCExists(id)) {
      return new TemporaryCloneAICapabilityUC(this, id);
    } else {
      return new TemporaryCloneAICapabilityUC(this, 0);
    }
  }
  public List<TemporaryCloneAICapabilityUC> AllTemporaryCloneAICapabilityUC() {
    List<TemporaryCloneAICapabilityUC> result = new List<TemporaryCloneAICapabilityUC>(rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.Keys) {
      result.Add(new TemporaryCloneAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<TemporaryCloneAICapabilityUC> EnumAllTemporaryCloneAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.Keys) {
      yield return GetTemporaryCloneAICapabilityUC(id);
    }
  }
  public void CheckHasTemporaryCloneAICapabilityUC(TemporaryCloneAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTemporaryCloneAICapabilityUC(thing.id);
  }
  public void CheckHasTemporaryCloneAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid TemporaryCloneAICapabilityUC: " + id);
    }
  }
  public TemporaryCloneAICapabilityUC EffectTemporaryCloneAICapabilityUCCreate(
      string blueprintName,
      int charges) {
    return TrustedEffectTemporaryCloneAICapabilityUCCreateWithId(NewId()
            ,blueprintName
            ,charges    );
  }
  public TemporaryCloneAICapabilityUC TrustedEffectTemporaryCloneAICapabilityUCCreateWithId(int id
,      string blueprintName
,      int charges) {
    CheckUnlocked();

    var incarnation =
        new TemporaryCloneAICapabilityUCIncarnation(
            blueprintName,
            charges
            );
    var effect = InternalEffectCreateTemporaryCloneAICapabilityUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new TemporaryCloneAICapabilityUC(this, id);
  }
  public TemporaryCloneAICapabilityUCCreateEffect InternalEffectCreateTemporaryCloneAICapabilityUC(
      int id,
      int incarnationVersion,
      TemporaryCloneAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<TemporaryCloneAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new TemporaryCloneAICapabilityUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectTemporaryCloneAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectTemporaryCloneAICapabilityUCDelete(id);
    NotifyEffect(effect);
  }
  public TemporaryCloneAICapabilityUCDeleteEffect InternalEffectTemporaryCloneAICapabilityUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTemporaryCloneAICapabilityUC[id];

    rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.Remove(id);
    return new TemporaryCloneAICapabilityUCDeleteEffect(id);
  }

     
  public int GetTemporaryCloneAICapabilityUCHash(int id, int version, TemporaryCloneAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.blueprintName.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.charges.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectTemporaryCloneAICapabilityUCSetCharges(
      int id, int newValue) {
    CheckUnlocked();
    CheckHasTemporaryCloneAICapabilityUC(id);
    var effect = InternalEffectTemporaryCloneAICapabilityUCSetCharges(id, newValue);
    NotifyEffect(effect);
  }
  public TemporaryCloneAICapabilityUCSetChargesEffect InternalEffectTemporaryCloneAICapabilityUCSetCharges(int id, int newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsTemporaryCloneAICapabilityUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.charges;
      oldIncarnationAndVersion.incarnation.charges = newValue;

    } else {
      var newIncarnation =
          new TemporaryCloneAICapabilityUCIncarnation(
              oldIncarnationAndVersion.incarnation.blueprintName,
              newValue);
      rootIncarnation.incarnationsTemporaryCloneAICapabilityUC[id] =
          new VersionAndIncarnation<TemporaryCloneAICapabilityUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new TemporaryCloneAICapabilityUCSetChargesEffect(id, newValue);
  }
  public DeathTriggerUCIncarnation GetDeathTriggerUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsDeathTriggerUC[id].incarnation;
  }
  public bool DeathTriggerUCExists(int id) {
    return rootIncarnation.incarnationsDeathTriggerUC.ContainsKey(id);
  }
  public DeathTriggerUC GetDeathTriggerUC(int id) {
    CheckHasDeathTriggerUC(id);
    return new DeathTriggerUC(this, id);
  }
  public DeathTriggerUC GetDeathTriggerUCOrNull(int id) {
    if (DeathTriggerUCExists(id)) {
      return new DeathTriggerUC(this, id);
    } else {
      return new DeathTriggerUC(this, 0);
    }
  }
  public List<DeathTriggerUC> AllDeathTriggerUC() {
    List<DeathTriggerUC> result = new List<DeathTriggerUC>(rootIncarnation.incarnationsDeathTriggerUC.Count);
    foreach (var id in rootIncarnation.incarnationsDeathTriggerUC.Keys) {
      result.Add(new DeathTriggerUC(this, id));
    }
    return result;
  }
  public IEnumerator<DeathTriggerUC> EnumAllDeathTriggerUC() {
    foreach (var id in rootIncarnation.incarnationsDeathTriggerUC.Keys) {
      yield return GetDeathTriggerUC(id);
    }
  }
  public void CheckHasDeathTriggerUC(DeathTriggerUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasDeathTriggerUC(thing.id);
  }
  public void CheckHasDeathTriggerUC(int id) {
    if (!rootIncarnation.incarnationsDeathTriggerUC.ContainsKey(id)) {
      throw new System.Exception("Invalid DeathTriggerUC: " + id);
    }
  }
  public DeathTriggerUC EffectDeathTriggerUCCreate(
      string triggerName) {
    return TrustedEffectDeathTriggerUCCreateWithId(NewId()
            ,triggerName    );
  }
  public DeathTriggerUC TrustedEffectDeathTriggerUCCreateWithId(int id
,      string triggerName) {
    CheckUnlocked();

    var incarnation =
        new DeathTriggerUCIncarnation(
            triggerName
            );
    var effect = InternalEffectCreateDeathTriggerUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new DeathTriggerUC(this, id);
  }
  public DeathTriggerUCCreateEffect InternalEffectCreateDeathTriggerUC(
      int id,
      int incarnationVersion,
      DeathTriggerUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsDeathTriggerUC.Add(
        id,
        new VersionAndIncarnation<DeathTriggerUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new DeathTriggerUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectDeathTriggerUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectDeathTriggerUCDelete(id);
    NotifyEffect(effect);
  }
  public DeathTriggerUCDeleteEffect InternalEffectDeathTriggerUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsDeathTriggerUC[id];

    rootIncarnation.incarnationsDeathTriggerUC.Remove(id);
    return new DeathTriggerUCDeleteEffect(id);
  }

     
  public int GetDeathTriggerUCHash(int id, int version, DeathTriggerUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.triggerName.GetDeterministicHashCode();
    return result;
  }
       public BequeathUCIncarnation GetBequeathUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBequeathUC[id].incarnation;
  }
  public bool BequeathUCExists(int id) {
    return rootIncarnation.incarnationsBequeathUC.ContainsKey(id);
  }
  public BequeathUC GetBequeathUC(int id) {
    CheckHasBequeathUC(id);
    return new BequeathUC(this, id);
  }
  public BequeathUC GetBequeathUCOrNull(int id) {
    if (BequeathUCExists(id)) {
      return new BequeathUC(this, id);
    } else {
      return new BequeathUC(this, 0);
    }
  }
  public List<BequeathUC> AllBequeathUC() {
    List<BequeathUC> result = new List<BequeathUC>(rootIncarnation.incarnationsBequeathUC.Count);
    foreach (var id in rootIncarnation.incarnationsBequeathUC.Keys) {
      result.Add(new BequeathUC(this, id));
    }
    return result;
  }
  public IEnumerator<BequeathUC> EnumAllBequeathUC() {
    foreach (var id in rootIncarnation.incarnationsBequeathUC.Keys) {
      yield return GetBequeathUC(id);
    }
  }
  public void CheckHasBequeathUC(BequeathUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBequeathUC(thing.id);
  }
  public void CheckHasBequeathUC(int id) {
    if (!rootIncarnation.incarnationsBequeathUC.ContainsKey(id)) {
      throw new System.Exception("Invalid BequeathUC: " + id);
    }
  }
  public BequeathUC EffectBequeathUCCreate(
      string blueprintName) {
    return TrustedEffectBequeathUCCreateWithId(NewId()
            ,blueprintName    );
  }
  public BequeathUC TrustedEffectBequeathUCCreateWithId(int id
,      string blueprintName) {
    CheckUnlocked();

    var incarnation =
        new BequeathUCIncarnation(
            blueprintName
            );
    var effect = InternalEffectCreateBequeathUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new BequeathUC(this, id);
  }
  public BequeathUCCreateEffect InternalEffectCreateBequeathUC(
      int id,
      int incarnationVersion,
      BequeathUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsBequeathUC.Add(
        id,
        new VersionAndIncarnation<BequeathUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new BequeathUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectBequeathUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectBequeathUCDelete(id);
    NotifyEffect(effect);
  }
  public BequeathUCDeleteEffect InternalEffectBequeathUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBequeathUC[id];

    rootIncarnation.incarnationsBequeathUC.Remove(id);
    return new BequeathUCDeleteEffect(id);
  }

     
  public int GetBequeathUCHash(int id, int version, BequeathUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.blueprintName.GetDeterministicHashCode();
    return result;
  }
       public SummonImpulseIncarnation GetSummonImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsSummonImpulse[id].incarnation;
  }
  public bool SummonImpulseExists(int id) {
    return rootIncarnation.incarnationsSummonImpulse.ContainsKey(id);
  }
  public SummonImpulse GetSummonImpulse(int id) {
    CheckHasSummonImpulse(id);
    return new SummonImpulse(this, id);
  }
  public SummonImpulse GetSummonImpulseOrNull(int id) {
    if (SummonImpulseExists(id)) {
      return new SummonImpulse(this, id);
    } else {
      return new SummonImpulse(this, 0);
    }
  }
  public List<SummonImpulse> AllSummonImpulse() {
    List<SummonImpulse> result = new List<SummonImpulse>(rootIncarnation.incarnationsSummonImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsSummonImpulse.Keys) {
      result.Add(new SummonImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<SummonImpulse> EnumAllSummonImpulse() {
    foreach (var id in rootIncarnation.incarnationsSummonImpulse.Keys) {
      yield return GetSummonImpulse(id);
    }
  }
  public void CheckHasSummonImpulse(SummonImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasSummonImpulse(thing.id);
  }
  public void CheckHasSummonImpulse(int id) {
    if (!rootIncarnation.incarnationsSummonImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid SummonImpulse: " + id);
    }
  }
  public SummonImpulse EffectSummonImpulseCreate(
      int weight,
      string blueprintName,
      Location location) {
    return TrustedEffectSummonImpulseCreateWithId(NewId()
            ,weight
            ,blueprintName
            ,location    );
  }
  public SummonImpulse TrustedEffectSummonImpulseCreateWithId(int id
,      int weight
,      string blueprintName
,      Location location) {
    CheckUnlocked();

    var incarnation =
        new SummonImpulseIncarnation(
            weight,
            blueprintName,
            location
            );
    var effect = InternalEffectCreateSummonImpulse(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new SummonImpulse(this, id);
  }
  public SummonImpulseCreateEffect InternalEffectCreateSummonImpulse(
      int id,
      int incarnationVersion,
      SummonImpulseIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsSummonImpulse.Add(
        id,
        new VersionAndIncarnation<SummonImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    return new SummonImpulseCreateEffect(id, incarnation.Copy());
  }

  public void EffectSummonImpulseDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectSummonImpulseDelete(id);
    NotifyEffect(effect);
  }
  public SummonImpulseDeleteEffect InternalEffectSummonImpulseDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsSummonImpulse[id];

    rootIncarnation.incarnationsSummonImpulse.Remove(id);
    return new SummonImpulseDeleteEffect(id);
  }

     
  public int GetSummonImpulseHash(int id, int version, SummonImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.blueprintName.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.location.GetDeterministicHashCode();
    return result;
  }
       public SummonAICapabilityUCIncarnation GetSummonAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsSummonAICapabilityUC[id].incarnation;
  }
  public bool SummonAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(id);
  }
  public SummonAICapabilityUC GetSummonAICapabilityUC(int id) {
    CheckHasSummonAICapabilityUC(id);
    return new SummonAICapabilityUC(this, id);
  }
  public SummonAICapabilityUC GetSummonAICapabilityUCOrNull(int id) {
    if (SummonAICapabilityUCExists(id)) {
      return new SummonAICapabilityUC(this, id);
    } else {
      return new SummonAICapabilityUC(this, 0);
    }
  }
  public List<SummonAICapabilityUC> AllSummonAICapabilityUC() {
    List<SummonAICapabilityUC> result = new List<SummonAICapabilityUC>(rootIncarnation.incarnationsSummonAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsSummonAICapabilityUC.Keys) {
      result.Add(new SummonAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<SummonAICapabilityUC> EnumAllSummonAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsSummonAICapabilityUC.Keys) {
      yield return GetSummonAICapabilityUC(id);
    }
  }
  public void CheckHasSummonAICapabilityUC(SummonAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasSummonAICapabilityUC(thing.id);
  }
  public void CheckHasSummonAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid SummonAICapabilityUC: " + id);
    }
  }
  public SummonAICapabilityUC EffectSummonAICapabilityUCCreate(
      string blueprintName,
      int charges) {
    return TrustedEffectSummonAICapabilityUCCreateWithId(NewId()
            ,blueprintName
            ,charges    );
  }
  public SummonAICapabilityUC TrustedEffectSummonAICapabilityUCCreateWithId(int id
,      string blueprintName
,      int charges) {
    CheckUnlocked();

    var incarnation =
        new SummonAICapabilityUCIncarnation(
            blueprintName,
            charges
            );
    var effect = InternalEffectCreateSummonAICapabilityUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new SummonAICapabilityUC(this, id);
  }
  public SummonAICapabilityUCCreateEffect InternalEffectCreateSummonAICapabilityUC(
      int id,
      int incarnationVersion,
      SummonAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsSummonAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<SummonAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new SummonAICapabilityUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectSummonAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectSummonAICapabilityUCDelete(id);
    NotifyEffect(effect);
  }
  public SummonAICapabilityUCDeleteEffect InternalEffectSummonAICapabilityUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsSummonAICapabilityUC[id];

    rootIncarnation.incarnationsSummonAICapabilityUC.Remove(id);
    return new SummonAICapabilityUCDeleteEffect(id);
  }

     
  public int GetSummonAICapabilityUCHash(int id, int version, SummonAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.blueprintName.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.charges.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectSummonAICapabilityUCSetCharges(
      int id, int newValue) {
    CheckUnlocked();
    CheckHasSummonAICapabilityUC(id);
    var effect = InternalEffectSummonAICapabilityUCSetCharges(id, newValue);
    NotifyEffect(effect);
  }
  public SummonAICapabilityUCSetChargesEffect InternalEffectSummonAICapabilityUCSetCharges(int id, int newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsSummonAICapabilityUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.charges;
      oldIncarnationAndVersion.incarnation.charges = newValue;

    } else {
      var newIncarnation =
          new SummonAICapabilityUCIncarnation(
              oldIncarnationAndVersion.incarnation.blueprintName,
              newValue);
      rootIncarnation.incarnationsSummonAICapabilityUC[id] =
          new VersionAndIncarnation<SummonAICapabilityUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new SummonAICapabilityUCSetChargesEffect(id, newValue);
  }
  public SorcerousUCIncarnation GetSorcerousUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsSorcerousUC[id].incarnation;
  }
  public bool SorcerousUCExists(int id) {
    return rootIncarnation.incarnationsSorcerousUC.ContainsKey(id);
  }
  public SorcerousUC GetSorcerousUC(int id) {
    CheckHasSorcerousUC(id);
    return new SorcerousUC(this, id);
  }
  public SorcerousUC GetSorcerousUCOrNull(int id) {
    if (SorcerousUCExists(id)) {
      return new SorcerousUC(this, id);
    } else {
      return new SorcerousUC(this, 0);
    }
  }
  public List<SorcerousUC> AllSorcerousUC() {
    List<SorcerousUC> result = new List<SorcerousUC>(rootIncarnation.incarnationsSorcerousUC.Count);
    foreach (var id in rootIncarnation.incarnationsSorcerousUC.Keys) {
      result.Add(new SorcerousUC(this, id));
    }
    return result;
  }
  public IEnumerator<SorcerousUC> EnumAllSorcerousUC() {
    foreach (var id in rootIncarnation.incarnationsSorcerousUC.Keys) {
      yield return GetSorcerousUC(id);
    }
  }
  public void CheckHasSorcerousUC(SorcerousUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasSorcerousUC(thing.id);
  }
  public void CheckHasSorcerousUC(int id) {
    if (!rootIncarnation.incarnationsSorcerousUC.ContainsKey(id)) {
      throw new System.Exception("Invalid SorcerousUC: " + id);
    }
  }
  public SorcerousUC EffectSorcerousUCCreate(
      int mp,
      int maxMp) {
    return TrustedEffectSorcerousUCCreateWithId(NewId()
            ,mp
            ,maxMp    );
  }
  public SorcerousUC TrustedEffectSorcerousUCCreateWithId(int id
,      int mp
,      int maxMp) {
    CheckUnlocked();

    var incarnation =
        new SorcerousUCIncarnation(
            mp,
            maxMp
            );
    var effect = InternalEffectCreateSorcerousUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new SorcerousUC(this, id);
  }
  public SorcerousUCCreateEffect InternalEffectCreateSorcerousUC(
      int id,
      int incarnationVersion,
      SorcerousUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsSorcerousUC.Add(
        id,
        new VersionAndIncarnation<SorcerousUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new SorcerousUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectSorcerousUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectSorcerousUCDelete(id);
    NotifyEffect(effect);
  }
  public SorcerousUCDeleteEffect InternalEffectSorcerousUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsSorcerousUC[id];

    rootIncarnation.incarnationsSorcerousUC.Remove(id);
    return new SorcerousUCDeleteEffect(id);
  }

     
  public int GetSorcerousUCHash(int id, int version, SorcerousUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.mp.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.maxMp.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectSorcerousUCSetMp(
      int id, int newValue) {
    CheckUnlocked();
    CheckHasSorcerousUC(id);
    var effect = InternalEffectSorcerousUCSetMp(id, newValue);
    NotifyEffect(effect);
  }
  public SorcerousUCSetMpEffect InternalEffectSorcerousUCSetMp(int id, int newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsSorcerousUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.mp;
      oldIncarnationAndVersion.incarnation.mp = newValue;

    } else {
      var newIncarnation =
          new SorcerousUCIncarnation(
              newValue,
              oldIncarnationAndVersion.incarnation.maxMp);
      rootIncarnation.incarnationsSorcerousUC[id] =
          new VersionAndIncarnation<SorcerousUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new SorcerousUCSetMpEffect(id, newValue);
  }

  public void EffectSorcerousUCSetMaxMp(
      int id, int newValue) {
    CheckUnlocked();
    CheckHasSorcerousUC(id);
    var effect = InternalEffectSorcerousUCSetMaxMp(id, newValue);
    NotifyEffect(effect);
  }
  public SorcerousUCSetMaxMpEffect InternalEffectSorcerousUCSetMaxMp(int id, int newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsSorcerousUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.maxMp;
      oldIncarnationAndVersion.incarnation.maxMp = newValue;

    } else {
      var newIncarnation =
          new SorcerousUCIncarnation(
              oldIncarnationAndVersion.incarnation.mp,
              newValue);
      rootIncarnation.incarnationsSorcerousUC[id] =
          new VersionAndIncarnation<SorcerousUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new SorcerousUCSetMaxMpEffect(id, newValue);
  }
  public BaseOffenseUCIncarnation GetBaseOffenseUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBaseOffenseUC[id].incarnation;
  }
  public bool BaseOffenseUCExists(int id) {
    return rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(id);
  }
  public BaseOffenseUC GetBaseOffenseUC(int id) {
    CheckHasBaseOffenseUC(id);
    return new BaseOffenseUC(this, id);
  }
  public BaseOffenseUC GetBaseOffenseUCOrNull(int id) {
    if (BaseOffenseUCExists(id)) {
      return new BaseOffenseUC(this, id);
    } else {
      return new BaseOffenseUC(this, 0);
    }
  }
  public List<BaseOffenseUC> AllBaseOffenseUC() {
    List<BaseOffenseUC> result = new List<BaseOffenseUC>(rootIncarnation.incarnationsBaseOffenseUC.Count);
    foreach (var id in rootIncarnation.incarnationsBaseOffenseUC.Keys) {
      result.Add(new BaseOffenseUC(this, id));
    }
    return result;
  }
  public IEnumerator<BaseOffenseUC> EnumAllBaseOffenseUC() {
    foreach (var id in rootIncarnation.incarnationsBaseOffenseUC.Keys) {
      yield return GetBaseOffenseUC(id);
    }
  }
  public void CheckHasBaseOffenseUC(BaseOffenseUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBaseOffenseUC(thing.id);
  }
  public void CheckHasBaseOffenseUC(int id) {
    if (!rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(id)) {
      throw new System.Exception("Invalid BaseOffenseUC: " + id);
    }
  }
  public BaseOffenseUC EffectBaseOffenseUCCreate(
      int outgoingDamageAddConstant,
      int outgoingDamageMultiplierPercent) {
    return TrustedEffectBaseOffenseUCCreateWithId(NewId()
            ,outgoingDamageAddConstant
            ,outgoingDamageMultiplierPercent    );
  }
  public BaseOffenseUC TrustedEffectBaseOffenseUCCreateWithId(int id
,      int outgoingDamageAddConstant
,      int outgoingDamageMultiplierPercent) {
    CheckUnlocked();

    var incarnation =
        new BaseOffenseUCIncarnation(
            outgoingDamageAddConstant,
            outgoingDamageMultiplierPercent
            );
    var effect = InternalEffectCreateBaseOffenseUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new BaseOffenseUC(this, id);
  }
  public BaseOffenseUCCreateEffect InternalEffectCreateBaseOffenseUC(
      int id,
      int incarnationVersion,
      BaseOffenseUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsBaseOffenseUC.Add(
        id,
        new VersionAndIncarnation<BaseOffenseUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new BaseOffenseUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectBaseOffenseUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectBaseOffenseUCDelete(id);
    NotifyEffect(effect);
  }
  public BaseOffenseUCDeleteEffect InternalEffectBaseOffenseUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBaseOffenseUC[id];

    rootIncarnation.incarnationsBaseOffenseUC.Remove(id);
    return new BaseOffenseUCDeleteEffect(id);
  }

     
  public int GetBaseOffenseUCHash(int id, int version, BaseOffenseUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.outgoingDamageAddConstant.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.outgoingDamageMultiplierPercent.GetDeterministicHashCode();
    return result;
  }
       public BaseSightRangeUCIncarnation GetBaseSightRangeUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBaseSightRangeUC[id].incarnation;
  }
  public bool BaseSightRangeUCExists(int id) {
    return rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(id);
  }
  public BaseSightRangeUC GetBaseSightRangeUC(int id) {
    CheckHasBaseSightRangeUC(id);
    return new BaseSightRangeUC(this, id);
  }
  public BaseSightRangeUC GetBaseSightRangeUCOrNull(int id) {
    if (BaseSightRangeUCExists(id)) {
      return new BaseSightRangeUC(this, id);
    } else {
      return new BaseSightRangeUC(this, 0);
    }
  }
  public List<BaseSightRangeUC> AllBaseSightRangeUC() {
    List<BaseSightRangeUC> result = new List<BaseSightRangeUC>(rootIncarnation.incarnationsBaseSightRangeUC.Count);
    foreach (var id in rootIncarnation.incarnationsBaseSightRangeUC.Keys) {
      result.Add(new BaseSightRangeUC(this, id));
    }
    return result;
  }
  public IEnumerator<BaseSightRangeUC> EnumAllBaseSightRangeUC() {
    foreach (var id in rootIncarnation.incarnationsBaseSightRangeUC.Keys) {
      yield return GetBaseSightRangeUC(id);
    }
  }
  public void CheckHasBaseSightRangeUC(BaseSightRangeUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBaseSightRangeUC(thing.id);
  }
  public void CheckHasBaseSightRangeUC(int id) {
    if (!rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(id)) {
      throw new System.Exception("Invalid BaseSightRangeUC: " + id);
    }
  }
  public BaseSightRangeUC EffectBaseSightRangeUCCreate(
      int sightRangeAddConstant,
      int sightRangeMultiplierPercent) {
    return TrustedEffectBaseSightRangeUCCreateWithId(NewId()
            ,sightRangeAddConstant
            ,sightRangeMultiplierPercent    );
  }
  public BaseSightRangeUC TrustedEffectBaseSightRangeUCCreateWithId(int id
,      int sightRangeAddConstant
,      int sightRangeMultiplierPercent) {
    CheckUnlocked();

    var incarnation =
        new BaseSightRangeUCIncarnation(
            sightRangeAddConstant,
            sightRangeMultiplierPercent
            );
    var effect = InternalEffectCreateBaseSightRangeUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new BaseSightRangeUC(this, id);
  }
  public BaseSightRangeUCCreateEffect InternalEffectCreateBaseSightRangeUC(
      int id,
      int incarnationVersion,
      BaseSightRangeUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsBaseSightRangeUC.Add(
        id,
        new VersionAndIncarnation<BaseSightRangeUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new BaseSightRangeUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectBaseSightRangeUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectBaseSightRangeUCDelete(id);
    NotifyEffect(effect);
  }
  public BaseSightRangeUCDeleteEffect InternalEffectBaseSightRangeUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBaseSightRangeUC[id];

    rootIncarnation.incarnationsBaseSightRangeUC.Remove(id);
    return new BaseSightRangeUCDeleteEffect(id);
  }

     
  public int GetBaseSightRangeUCHash(int id, int version, BaseSightRangeUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.sightRangeAddConstant.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.sightRangeMultiplierPercent.GetDeterministicHashCode();
    return result;
  }
       public BaseMovementTimeUCIncarnation GetBaseMovementTimeUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBaseMovementTimeUC[id].incarnation;
  }
  public bool BaseMovementTimeUCExists(int id) {
    return rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(id);
  }
  public BaseMovementTimeUC GetBaseMovementTimeUC(int id) {
    CheckHasBaseMovementTimeUC(id);
    return new BaseMovementTimeUC(this, id);
  }
  public BaseMovementTimeUC GetBaseMovementTimeUCOrNull(int id) {
    if (BaseMovementTimeUCExists(id)) {
      return new BaseMovementTimeUC(this, id);
    } else {
      return new BaseMovementTimeUC(this, 0);
    }
  }
  public List<BaseMovementTimeUC> AllBaseMovementTimeUC() {
    List<BaseMovementTimeUC> result = new List<BaseMovementTimeUC>(rootIncarnation.incarnationsBaseMovementTimeUC.Count);
    foreach (var id in rootIncarnation.incarnationsBaseMovementTimeUC.Keys) {
      result.Add(new BaseMovementTimeUC(this, id));
    }
    return result;
  }
  public IEnumerator<BaseMovementTimeUC> EnumAllBaseMovementTimeUC() {
    foreach (var id in rootIncarnation.incarnationsBaseMovementTimeUC.Keys) {
      yield return GetBaseMovementTimeUC(id);
    }
  }
  public void CheckHasBaseMovementTimeUC(BaseMovementTimeUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBaseMovementTimeUC(thing.id);
  }
  public void CheckHasBaseMovementTimeUC(int id) {
    if (!rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(id)) {
      throw new System.Exception("Invalid BaseMovementTimeUC: " + id);
    }
  }
  public BaseMovementTimeUC EffectBaseMovementTimeUCCreate(
      int movementTimeAddConstant,
      int movementTimeMultiplierPercent) {
    return TrustedEffectBaseMovementTimeUCCreateWithId(NewId()
            ,movementTimeAddConstant
            ,movementTimeMultiplierPercent    );
  }
  public BaseMovementTimeUC TrustedEffectBaseMovementTimeUCCreateWithId(int id
,      int movementTimeAddConstant
,      int movementTimeMultiplierPercent) {
    CheckUnlocked();

    var incarnation =
        new BaseMovementTimeUCIncarnation(
            movementTimeAddConstant,
            movementTimeMultiplierPercent
            );
    var effect = InternalEffectCreateBaseMovementTimeUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new BaseMovementTimeUC(this, id);
  }
  public BaseMovementTimeUCCreateEffect InternalEffectCreateBaseMovementTimeUC(
      int id,
      int incarnationVersion,
      BaseMovementTimeUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsBaseMovementTimeUC.Add(
        id,
        new VersionAndIncarnation<BaseMovementTimeUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new BaseMovementTimeUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectBaseMovementTimeUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectBaseMovementTimeUCDelete(id);
    NotifyEffect(effect);
  }
  public BaseMovementTimeUCDeleteEffect InternalEffectBaseMovementTimeUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBaseMovementTimeUC[id];

    rootIncarnation.incarnationsBaseMovementTimeUC.Remove(id);
    return new BaseMovementTimeUCDeleteEffect(id);
  }

     
  public int GetBaseMovementTimeUCHash(int id, int version, BaseMovementTimeUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.movementTimeAddConstant.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.movementTimeMultiplierPercent.GetDeterministicHashCode();
    return result;
  }
       public BaseDefenseUCIncarnation GetBaseDefenseUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBaseDefenseUC[id].incarnation;
  }
  public bool BaseDefenseUCExists(int id) {
    return rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(id);
  }
  public BaseDefenseUC GetBaseDefenseUC(int id) {
    CheckHasBaseDefenseUC(id);
    return new BaseDefenseUC(this, id);
  }
  public BaseDefenseUC GetBaseDefenseUCOrNull(int id) {
    if (BaseDefenseUCExists(id)) {
      return new BaseDefenseUC(this, id);
    } else {
      return new BaseDefenseUC(this, 0);
    }
  }
  public List<BaseDefenseUC> AllBaseDefenseUC() {
    List<BaseDefenseUC> result = new List<BaseDefenseUC>(rootIncarnation.incarnationsBaseDefenseUC.Count);
    foreach (var id in rootIncarnation.incarnationsBaseDefenseUC.Keys) {
      result.Add(new BaseDefenseUC(this, id));
    }
    return result;
  }
  public IEnumerator<BaseDefenseUC> EnumAllBaseDefenseUC() {
    foreach (var id in rootIncarnation.incarnationsBaseDefenseUC.Keys) {
      yield return GetBaseDefenseUC(id);
    }
  }
  public void CheckHasBaseDefenseUC(BaseDefenseUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBaseDefenseUC(thing.id);
  }
  public void CheckHasBaseDefenseUC(int id) {
    if (!rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(id)) {
      throw new System.Exception("Invalid BaseDefenseUC: " + id);
    }
  }
  public BaseDefenseUC EffectBaseDefenseUCCreate(
      int incomingDamageAddConstant,
      int incomingDamageMultiplierPercent) {
    return TrustedEffectBaseDefenseUCCreateWithId(NewId()
            ,incomingDamageAddConstant
            ,incomingDamageMultiplierPercent    );
  }
  public BaseDefenseUC TrustedEffectBaseDefenseUCCreateWithId(int id
,      int incomingDamageAddConstant
,      int incomingDamageMultiplierPercent) {
    CheckUnlocked();

    var incarnation =
        new BaseDefenseUCIncarnation(
            incomingDamageAddConstant,
            incomingDamageMultiplierPercent
            );
    var effect = InternalEffectCreateBaseDefenseUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new BaseDefenseUC(this, id);
  }
  public BaseDefenseUCCreateEffect InternalEffectCreateBaseDefenseUC(
      int id,
      int incarnationVersion,
      BaseDefenseUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsBaseDefenseUC.Add(
        id,
        new VersionAndIncarnation<BaseDefenseUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new BaseDefenseUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectBaseDefenseUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectBaseDefenseUCDelete(id);
    NotifyEffect(effect);
  }
  public BaseDefenseUCDeleteEffect InternalEffectBaseDefenseUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBaseDefenseUC[id];

    rootIncarnation.incarnationsBaseDefenseUC.Remove(id);
    return new BaseDefenseUCDeleteEffect(id);
  }

     
  public int GetBaseDefenseUCHash(int id, int version, BaseDefenseUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.incomingDamageAddConstant.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.incomingDamageMultiplierPercent.GetDeterministicHashCode();
    return result;
  }
       public BaseCombatTimeUCIncarnation GetBaseCombatTimeUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBaseCombatTimeUC[id].incarnation;
  }
  public bool BaseCombatTimeUCExists(int id) {
    return rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(id);
  }
  public BaseCombatTimeUC GetBaseCombatTimeUC(int id) {
    CheckHasBaseCombatTimeUC(id);
    return new BaseCombatTimeUC(this, id);
  }
  public BaseCombatTimeUC GetBaseCombatTimeUCOrNull(int id) {
    if (BaseCombatTimeUCExists(id)) {
      return new BaseCombatTimeUC(this, id);
    } else {
      return new BaseCombatTimeUC(this, 0);
    }
  }
  public List<BaseCombatTimeUC> AllBaseCombatTimeUC() {
    List<BaseCombatTimeUC> result = new List<BaseCombatTimeUC>(rootIncarnation.incarnationsBaseCombatTimeUC.Count);
    foreach (var id in rootIncarnation.incarnationsBaseCombatTimeUC.Keys) {
      result.Add(new BaseCombatTimeUC(this, id));
    }
    return result;
  }
  public IEnumerator<BaseCombatTimeUC> EnumAllBaseCombatTimeUC() {
    foreach (var id in rootIncarnation.incarnationsBaseCombatTimeUC.Keys) {
      yield return GetBaseCombatTimeUC(id);
    }
  }
  public void CheckHasBaseCombatTimeUC(BaseCombatTimeUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBaseCombatTimeUC(thing.id);
  }
  public void CheckHasBaseCombatTimeUC(int id) {
    if (!rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(id)) {
      throw new System.Exception("Invalid BaseCombatTimeUC: " + id);
    }
  }
  public BaseCombatTimeUC EffectBaseCombatTimeUCCreate(
      int combatTimeAddConstant,
      int combatTimeMultiplierPercent) {
    return TrustedEffectBaseCombatTimeUCCreateWithId(NewId()
            ,combatTimeAddConstant
            ,combatTimeMultiplierPercent    );
  }
  public BaseCombatTimeUC TrustedEffectBaseCombatTimeUCCreateWithId(int id
,      int combatTimeAddConstant
,      int combatTimeMultiplierPercent) {
    CheckUnlocked();

    var incarnation =
        new BaseCombatTimeUCIncarnation(
            combatTimeAddConstant,
            combatTimeMultiplierPercent
            );
    var effect = InternalEffectCreateBaseCombatTimeUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new BaseCombatTimeUC(this, id);
  }
  public BaseCombatTimeUCCreateEffect InternalEffectCreateBaseCombatTimeUC(
      int id,
      int incarnationVersion,
      BaseCombatTimeUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsBaseCombatTimeUC.Add(
        id,
        new VersionAndIncarnation<BaseCombatTimeUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new BaseCombatTimeUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectBaseCombatTimeUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectBaseCombatTimeUCDelete(id);
    NotifyEffect(effect);
  }
  public BaseCombatTimeUCDeleteEffect InternalEffectBaseCombatTimeUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBaseCombatTimeUC[id];

    rootIncarnation.incarnationsBaseCombatTimeUC.Remove(id);
    return new BaseCombatTimeUCDeleteEffect(id);
  }

     
  public int GetBaseCombatTimeUCHash(int id, int version, BaseCombatTimeUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.combatTimeAddConstant.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.combatTimeMultiplierPercent.GetDeterministicHashCode();
    return result;
  }
       public MiredUCIncarnation GetMiredUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsMiredUC[id].incarnation;
  }
  public bool MiredUCExists(int id) {
    return rootIncarnation.incarnationsMiredUC.ContainsKey(id);
  }
  public MiredUC GetMiredUC(int id) {
    CheckHasMiredUC(id);
    return new MiredUC(this, id);
  }
  public MiredUC GetMiredUCOrNull(int id) {
    if (MiredUCExists(id)) {
      return new MiredUC(this, id);
    } else {
      return new MiredUC(this, 0);
    }
  }
  public List<MiredUC> AllMiredUC() {
    List<MiredUC> result = new List<MiredUC>(rootIncarnation.incarnationsMiredUC.Count);
    foreach (var id in rootIncarnation.incarnationsMiredUC.Keys) {
      result.Add(new MiredUC(this, id));
    }
    return result;
  }
  public IEnumerator<MiredUC> EnumAllMiredUC() {
    foreach (var id in rootIncarnation.incarnationsMiredUC.Keys) {
      yield return GetMiredUC(id);
    }
  }
  public void CheckHasMiredUC(MiredUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasMiredUC(thing.id);
  }
  public void CheckHasMiredUC(int id) {
    if (!rootIncarnation.incarnationsMiredUC.ContainsKey(id)) {
      throw new System.Exception("Invalid MiredUC: " + id);
    }
  }
  public MiredUC EffectMiredUCCreate(
) {
    return TrustedEffectMiredUCCreateWithId(NewId()
    );
  }
  public MiredUC TrustedEffectMiredUCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new MiredUCIncarnation(

            );
    var effect = InternalEffectCreateMiredUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new MiredUC(this, id);
  }
  public MiredUCCreateEffect InternalEffectCreateMiredUC(
      int id,
      int incarnationVersion,
      MiredUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsMiredUC.Add(
        id,
        new VersionAndIncarnation<MiredUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new MiredUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectMiredUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectMiredUCDelete(id);
    NotifyEffect(effect);
  }
  public MiredUCDeleteEffect InternalEffectMiredUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsMiredUC[id];

    rootIncarnation.incarnationsMiredUC.Remove(id);
    return new MiredUCDeleteEffect(id);
  }

     
  public int GetMiredUCHash(int id, int version, MiredUCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public MireImpulseIncarnation GetMireImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsMireImpulse[id].incarnation;
  }
  public bool MireImpulseExists(int id) {
    return rootIncarnation.incarnationsMireImpulse.ContainsKey(id);
  }
  public MireImpulse GetMireImpulse(int id) {
    CheckHasMireImpulse(id);
    return new MireImpulse(this, id);
  }
  public MireImpulse GetMireImpulseOrNull(int id) {
    if (MireImpulseExists(id)) {
      return new MireImpulse(this, id);
    } else {
      return new MireImpulse(this, 0);
    }
  }
  public List<MireImpulse> AllMireImpulse() {
    List<MireImpulse> result = new List<MireImpulse>(rootIncarnation.incarnationsMireImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsMireImpulse.Keys) {
      result.Add(new MireImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<MireImpulse> EnumAllMireImpulse() {
    foreach (var id in rootIncarnation.incarnationsMireImpulse.Keys) {
      yield return GetMireImpulse(id);
    }
  }
  public void CheckHasMireImpulse(MireImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasMireImpulse(thing.id);
  }
  public void CheckHasMireImpulse(int id) {
    if (!rootIncarnation.incarnationsMireImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid MireImpulse: " + id);
    }
  }
  public MireImpulse EffectMireImpulseCreate(
      int weight,
      Unit targetUnit) {
    CheckHasUnit(targetUnit);
    return TrustedEffectMireImpulseCreateWithId(NewId()
            ,weight
            ,targetUnit.id    );
  }
  public MireImpulse TrustedEffectMireImpulseCreateWithId(int id
,      int weight
,      int targetUnit) {
    CheckUnlocked();

    var incarnation =
        new MireImpulseIncarnation(
            weight,
            targetUnit
            );
    var effect = InternalEffectCreateMireImpulse(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new MireImpulse(this, id);
  }
  public MireImpulseCreateEffect InternalEffectCreateMireImpulse(
      int id,
      int incarnationVersion,
      MireImpulseIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsMireImpulse.Add(
        id,
        new VersionAndIncarnation<MireImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    return new MireImpulseCreateEffect(id, incarnation.Copy());
  }

  public void EffectMireImpulseDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectMireImpulseDelete(id);
    NotifyEffect(effect);
  }
  public MireImpulseDeleteEffect InternalEffectMireImpulseDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsMireImpulse[id];

    rootIncarnation.incarnationsMireImpulse.Remove(id);
    return new MireImpulseDeleteEffect(id);
  }

     
  public int GetMireImpulseHash(int id, int version, MireImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.targetUnit.GetDeterministicHashCode();
    return result;
  }
       public EvaporateImpulseIncarnation GetEvaporateImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsEvaporateImpulse[id].incarnation;
  }
  public bool EvaporateImpulseExists(int id) {
    return rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(id);
  }
  public EvaporateImpulse GetEvaporateImpulse(int id) {
    CheckHasEvaporateImpulse(id);
    return new EvaporateImpulse(this, id);
  }
  public EvaporateImpulse GetEvaporateImpulseOrNull(int id) {
    if (EvaporateImpulseExists(id)) {
      return new EvaporateImpulse(this, id);
    } else {
      return new EvaporateImpulse(this, 0);
    }
  }
  public List<EvaporateImpulse> AllEvaporateImpulse() {
    List<EvaporateImpulse> result = new List<EvaporateImpulse>(rootIncarnation.incarnationsEvaporateImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsEvaporateImpulse.Keys) {
      result.Add(new EvaporateImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<EvaporateImpulse> EnumAllEvaporateImpulse() {
    foreach (var id in rootIncarnation.incarnationsEvaporateImpulse.Keys) {
      yield return GetEvaporateImpulse(id);
    }
  }
  public void CheckHasEvaporateImpulse(EvaporateImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasEvaporateImpulse(thing.id);
  }
  public void CheckHasEvaporateImpulse(int id) {
    if (!rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid EvaporateImpulse: " + id);
    }
  }
  public EvaporateImpulse EffectEvaporateImpulseCreate(
) {
    return TrustedEffectEvaporateImpulseCreateWithId(NewId()
    );
  }
  public EvaporateImpulse TrustedEffectEvaporateImpulseCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new EvaporateImpulseIncarnation(

            );
    var effect = InternalEffectCreateEvaporateImpulse(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new EvaporateImpulse(this, id);
  }
  public EvaporateImpulseCreateEffect InternalEffectCreateEvaporateImpulse(
      int id,
      int incarnationVersion,
      EvaporateImpulseIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsEvaporateImpulse.Add(
        id,
        new VersionAndIncarnation<EvaporateImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    return new EvaporateImpulseCreateEffect(id, incarnation.Copy());
  }

  public void EffectEvaporateImpulseDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectEvaporateImpulseDelete(id);
    NotifyEffect(effect);
  }
  public EvaporateImpulseDeleteEffect InternalEffectEvaporateImpulseDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsEvaporateImpulse[id];

    rootIncarnation.incarnationsEvaporateImpulse.Remove(id);
    return new EvaporateImpulseDeleteEffect(id);
  }

     
  public int GetEvaporateImpulseHash(int id, int version, EvaporateImpulseIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public TimeCloneAICapabilityUCIncarnation GetTimeCloneAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTimeCloneAICapabilityUC[id].incarnation;
  }
  public bool TimeCloneAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id);
  }
  public TimeCloneAICapabilityUC GetTimeCloneAICapabilityUC(int id) {
    CheckHasTimeCloneAICapabilityUC(id);
    return new TimeCloneAICapabilityUC(this, id);
  }
  public TimeCloneAICapabilityUC GetTimeCloneAICapabilityUCOrNull(int id) {
    if (TimeCloneAICapabilityUCExists(id)) {
      return new TimeCloneAICapabilityUC(this, id);
    } else {
      return new TimeCloneAICapabilityUC(this, 0);
    }
  }
  public List<TimeCloneAICapabilityUC> AllTimeCloneAICapabilityUC() {
    List<TimeCloneAICapabilityUC> result = new List<TimeCloneAICapabilityUC>(rootIncarnation.incarnationsTimeCloneAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsTimeCloneAICapabilityUC.Keys) {
      result.Add(new TimeCloneAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<TimeCloneAICapabilityUC> EnumAllTimeCloneAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsTimeCloneAICapabilityUC.Keys) {
      yield return GetTimeCloneAICapabilityUC(id);
    }
  }
  public void CheckHasTimeCloneAICapabilityUC(TimeCloneAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTimeCloneAICapabilityUC(thing.id);
  }
  public void CheckHasTimeCloneAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid TimeCloneAICapabilityUC: " + id);
    }
  }
  public TimeCloneAICapabilityUC EffectTimeCloneAICapabilityUCCreate(
      IRequestMutList script) {
    return TrustedEffectTimeCloneAICapabilityUCCreateWithId(NewId()
            ,script.id    );
  }
  public TimeCloneAICapabilityUC TrustedEffectTimeCloneAICapabilityUCCreateWithId(int id
,      int script) {
    CheckUnlocked();

    var incarnation =
        new TimeCloneAICapabilityUCIncarnation(
            script
            );
    var effect = InternalEffectCreateTimeCloneAICapabilityUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new TimeCloneAICapabilityUC(this, id);
  }
  public TimeCloneAICapabilityUCCreateEffect InternalEffectCreateTimeCloneAICapabilityUC(
      int id,
      int incarnationVersion,
      TimeCloneAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsTimeCloneAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<TimeCloneAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new TimeCloneAICapabilityUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectTimeCloneAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectTimeCloneAICapabilityUCDelete(id);
    NotifyEffect(effect);
  }
  public TimeCloneAICapabilityUCDeleteEffect InternalEffectTimeCloneAICapabilityUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTimeCloneAICapabilityUC[id];

    rootIncarnation.incarnationsTimeCloneAICapabilityUC.Remove(id);
    return new TimeCloneAICapabilityUCDeleteEffect(id);
  }

     
  public int GetTimeCloneAICapabilityUCHash(int id, int version, TimeCloneAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    if (!object.ReferenceEquals(incarnation.script, null)) {
      result += id * version * 1 * incarnation.script.GetDeterministicHashCode();
    }
    return result;
  }
       public MoveImpulseIncarnation GetMoveImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsMoveImpulse[id].incarnation;
  }
  public bool MoveImpulseExists(int id) {
    return rootIncarnation.incarnationsMoveImpulse.ContainsKey(id);
  }
  public MoveImpulse GetMoveImpulse(int id) {
    CheckHasMoveImpulse(id);
    return new MoveImpulse(this, id);
  }
  public MoveImpulse GetMoveImpulseOrNull(int id) {
    if (MoveImpulseExists(id)) {
      return new MoveImpulse(this, id);
    } else {
      return new MoveImpulse(this, 0);
    }
  }
  public List<MoveImpulse> AllMoveImpulse() {
    List<MoveImpulse> result = new List<MoveImpulse>(rootIncarnation.incarnationsMoveImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsMoveImpulse.Keys) {
      result.Add(new MoveImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<MoveImpulse> EnumAllMoveImpulse() {
    foreach (var id in rootIncarnation.incarnationsMoveImpulse.Keys) {
      yield return GetMoveImpulse(id);
    }
  }
  public void CheckHasMoveImpulse(MoveImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasMoveImpulse(thing.id);
  }
  public void CheckHasMoveImpulse(int id) {
    if (!rootIncarnation.incarnationsMoveImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid MoveImpulse: " + id);
    }
  }
  public MoveImpulse EffectMoveImpulseCreate(
      int weight,
      Location stepLocation) {
    return TrustedEffectMoveImpulseCreateWithId(NewId()
            ,weight
            ,stepLocation    );
  }
  public MoveImpulse TrustedEffectMoveImpulseCreateWithId(int id
,      int weight
,      Location stepLocation) {
    CheckUnlocked();

    var incarnation =
        new MoveImpulseIncarnation(
            weight,
            stepLocation
            );
    var effect = InternalEffectCreateMoveImpulse(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new MoveImpulse(this, id);
  }
  public MoveImpulseCreateEffect InternalEffectCreateMoveImpulse(
      int id,
      int incarnationVersion,
      MoveImpulseIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsMoveImpulse.Add(
        id,
        new VersionAndIncarnation<MoveImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    return new MoveImpulseCreateEffect(id, incarnation.Copy());
  }

  public void EffectMoveImpulseDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectMoveImpulseDelete(id);
    NotifyEffect(effect);
  }
  public MoveImpulseDeleteEffect InternalEffectMoveImpulseDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsMoveImpulse[id];

    rootIncarnation.incarnationsMoveImpulse.Remove(id);
    return new MoveImpulseDeleteEffect(id);
  }

     
  public int GetMoveImpulseHash(int id, int version, MoveImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.stepLocation.GetDeterministicHashCode();
    return result;
  }
       public KamikazeTargetTTCIncarnation GetKamikazeTargetTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsKamikazeTargetTTC[id].incarnation;
  }
  public bool KamikazeTargetTTCExists(int id) {
    return rootIncarnation.incarnationsKamikazeTargetTTC.ContainsKey(id);
  }
  public KamikazeTargetTTC GetKamikazeTargetTTC(int id) {
    CheckHasKamikazeTargetTTC(id);
    return new KamikazeTargetTTC(this, id);
  }
  public KamikazeTargetTTC GetKamikazeTargetTTCOrNull(int id) {
    if (KamikazeTargetTTCExists(id)) {
      return new KamikazeTargetTTC(this, id);
    } else {
      return new KamikazeTargetTTC(this, 0);
    }
  }
  public List<KamikazeTargetTTC> AllKamikazeTargetTTC() {
    List<KamikazeTargetTTC> result = new List<KamikazeTargetTTC>(rootIncarnation.incarnationsKamikazeTargetTTC.Count);
    foreach (var id in rootIncarnation.incarnationsKamikazeTargetTTC.Keys) {
      result.Add(new KamikazeTargetTTC(this, id));
    }
    return result;
  }
  public IEnumerator<KamikazeTargetTTC> EnumAllKamikazeTargetTTC() {
    foreach (var id in rootIncarnation.incarnationsKamikazeTargetTTC.Keys) {
      yield return GetKamikazeTargetTTC(id);
    }
  }
  public void CheckHasKamikazeTargetTTC(KamikazeTargetTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasKamikazeTargetTTC(thing.id);
  }
  public void CheckHasKamikazeTargetTTC(int id) {
    if (!rootIncarnation.incarnationsKamikazeTargetTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid KamikazeTargetTTC: " + id);
    }
  }
  public KamikazeTargetTTC EffectKamikazeTargetTTCCreate(
      KamikazeAICapabilityUC capability) {
    CheckHasKamikazeAICapabilityUC(capability);
    return TrustedEffectKamikazeTargetTTCCreateWithId(NewId()
            ,capability.id    );
  }
  public KamikazeTargetTTC TrustedEffectKamikazeTargetTTCCreateWithId(int id
,      int capability) {
    CheckUnlocked();

    var incarnation =
        new KamikazeTargetTTCIncarnation(
            capability
            );
    var effect = InternalEffectCreateKamikazeTargetTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new KamikazeTargetTTC(this, id);
  }
  public KamikazeTargetTTCCreateEffect InternalEffectCreateKamikazeTargetTTC(
      int id,
      int incarnationVersion,
      KamikazeTargetTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsKamikazeTargetTTC.Add(
        id,
        new VersionAndIncarnation<KamikazeTargetTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new KamikazeTargetTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectKamikazeTargetTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectKamikazeTargetTTCDelete(id);
    NotifyEffect(effect);
  }
  public KamikazeTargetTTCDeleteEffect InternalEffectKamikazeTargetTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsKamikazeTargetTTC[id];

    rootIncarnation.incarnationsKamikazeTargetTTC.Remove(id);
    return new KamikazeTargetTTCDeleteEffect(id);
  }

     
  public int GetKamikazeTargetTTCHash(int id, int version, KamikazeTargetTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.capability.GetDeterministicHashCode();
    return result;
  }
       public KamikazeJumpImpulseIncarnation GetKamikazeJumpImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsKamikazeJumpImpulse[id].incarnation;
  }
  public bool KamikazeJumpImpulseExists(int id) {
    return rootIncarnation.incarnationsKamikazeJumpImpulse.ContainsKey(id);
  }
  public KamikazeJumpImpulse GetKamikazeJumpImpulse(int id) {
    CheckHasKamikazeJumpImpulse(id);
    return new KamikazeJumpImpulse(this, id);
  }
  public KamikazeJumpImpulse GetKamikazeJumpImpulseOrNull(int id) {
    if (KamikazeJumpImpulseExists(id)) {
      return new KamikazeJumpImpulse(this, id);
    } else {
      return new KamikazeJumpImpulse(this, 0);
    }
  }
  public List<KamikazeJumpImpulse> AllKamikazeJumpImpulse() {
    List<KamikazeJumpImpulse> result = new List<KamikazeJumpImpulse>(rootIncarnation.incarnationsKamikazeJumpImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsKamikazeJumpImpulse.Keys) {
      result.Add(new KamikazeJumpImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<KamikazeJumpImpulse> EnumAllKamikazeJumpImpulse() {
    foreach (var id in rootIncarnation.incarnationsKamikazeJumpImpulse.Keys) {
      yield return GetKamikazeJumpImpulse(id);
    }
  }
  public void CheckHasKamikazeJumpImpulse(KamikazeJumpImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasKamikazeJumpImpulse(thing.id);
  }
  public void CheckHasKamikazeJumpImpulse(int id) {
    if (!rootIncarnation.incarnationsKamikazeJumpImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid KamikazeJumpImpulse: " + id);
    }
  }
  public KamikazeJumpImpulse EffectKamikazeJumpImpulseCreate(
      int weight,
      KamikazeAICapabilityUC capability,
      Location jumpTarget) {
    CheckHasKamikazeAICapabilityUC(capability);
    return TrustedEffectKamikazeJumpImpulseCreateWithId(NewId()
            ,weight
            ,capability.id
            ,jumpTarget    );
  }
  public KamikazeJumpImpulse TrustedEffectKamikazeJumpImpulseCreateWithId(int id
,      int weight
,      int capability
,      Location jumpTarget) {
    CheckUnlocked();

    var incarnation =
        new KamikazeJumpImpulseIncarnation(
            weight,
            capability,
            jumpTarget
            );
    var effect = InternalEffectCreateKamikazeJumpImpulse(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new KamikazeJumpImpulse(this, id);
  }
  public KamikazeJumpImpulseCreateEffect InternalEffectCreateKamikazeJumpImpulse(
      int id,
      int incarnationVersion,
      KamikazeJumpImpulseIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsKamikazeJumpImpulse.Add(
        id,
        new VersionAndIncarnation<KamikazeJumpImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    return new KamikazeJumpImpulseCreateEffect(id, incarnation.Copy());
  }

  public void EffectKamikazeJumpImpulseDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectKamikazeJumpImpulseDelete(id);
    NotifyEffect(effect);
  }
  public KamikazeJumpImpulseDeleteEffect InternalEffectKamikazeJumpImpulseDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsKamikazeJumpImpulse[id];

    rootIncarnation.incarnationsKamikazeJumpImpulse.Remove(id);
    return new KamikazeJumpImpulseDeleteEffect(id);
  }

     
  public int GetKamikazeJumpImpulseHash(int id, int version, KamikazeJumpImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.capability.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.jumpTarget.GetDeterministicHashCode();
    return result;
  }
       public KamikazeTargetImpulseIncarnation GetKamikazeTargetImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsKamikazeTargetImpulse[id].incarnation;
  }
  public bool KamikazeTargetImpulseExists(int id) {
    return rootIncarnation.incarnationsKamikazeTargetImpulse.ContainsKey(id);
  }
  public KamikazeTargetImpulse GetKamikazeTargetImpulse(int id) {
    CheckHasKamikazeTargetImpulse(id);
    return new KamikazeTargetImpulse(this, id);
  }
  public KamikazeTargetImpulse GetKamikazeTargetImpulseOrNull(int id) {
    if (KamikazeTargetImpulseExists(id)) {
      return new KamikazeTargetImpulse(this, id);
    } else {
      return new KamikazeTargetImpulse(this, 0);
    }
  }
  public List<KamikazeTargetImpulse> AllKamikazeTargetImpulse() {
    List<KamikazeTargetImpulse> result = new List<KamikazeTargetImpulse>(rootIncarnation.incarnationsKamikazeTargetImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsKamikazeTargetImpulse.Keys) {
      result.Add(new KamikazeTargetImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<KamikazeTargetImpulse> EnumAllKamikazeTargetImpulse() {
    foreach (var id in rootIncarnation.incarnationsKamikazeTargetImpulse.Keys) {
      yield return GetKamikazeTargetImpulse(id);
    }
  }
  public void CheckHasKamikazeTargetImpulse(KamikazeTargetImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasKamikazeTargetImpulse(thing.id);
  }
  public void CheckHasKamikazeTargetImpulse(int id) {
    if (!rootIncarnation.incarnationsKamikazeTargetImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid KamikazeTargetImpulse: " + id);
    }
  }
  public KamikazeTargetImpulse EffectKamikazeTargetImpulseCreate(
      int weight,
      KamikazeAICapabilityUC capability,
      Location targetLocationCenter,
      LocationImmList targetLocations) {
    CheckHasKamikazeAICapabilityUC(capability);
    return TrustedEffectKamikazeTargetImpulseCreateWithId(NewId()
            ,weight
            ,capability.id
            ,targetLocationCenter
            ,targetLocations    );
  }
  public KamikazeTargetImpulse TrustedEffectKamikazeTargetImpulseCreateWithId(int id
,      int weight
,      int capability
,      Location targetLocationCenter
,      LocationImmList targetLocations) {
    CheckUnlocked();

    var incarnation =
        new KamikazeTargetImpulseIncarnation(
            weight,
            capability,
            targetLocationCenter,
            targetLocations
            );
    var effect = InternalEffectCreateKamikazeTargetImpulse(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new KamikazeTargetImpulse(this, id);
  }
  public KamikazeTargetImpulseCreateEffect InternalEffectCreateKamikazeTargetImpulse(
      int id,
      int incarnationVersion,
      KamikazeTargetImpulseIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsKamikazeTargetImpulse.Add(
        id,
        new VersionAndIncarnation<KamikazeTargetImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    return new KamikazeTargetImpulseCreateEffect(id, incarnation.Copy());
  }

  public void EffectKamikazeTargetImpulseDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectKamikazeTargetImpulseDelete(id);
    NotifyEffect(effect);
  }
  public KamikazeTargetImpulseDeleteEffect InternalEffectKamikazeTargetImpulseDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsKamikazeTargetImpulse[id];

    rootIncarnation.incarnationsKamikazeTargetImpulse.Remove(id);
    return new KamikazeTargetImpulseDeleteEffect(id);
  }

     
  public int GetKamikazeTargetImpulseHash(int id, int version, KamikazeTargetImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.capability.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.targetLocationCenter.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.targetLocations.GetDeterministicHashCode();
    return result;
  }
       public KamikazeAICapabilityUCIncarnation GetKamikazeAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsKamikazeAICapabilityUC[id].incarnation;
  }
  public bool KamikazeAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id);
  }
  public KamikazeAICapabilityUC GetKamikazeAICapabilityUC(int id) {
    CheckHasKamikazeAICapabilityUC(id);
    return new KamikazeAICapabilityUC(this, id);
  }
  public KamikazeAICapabilityUC GetKamikazeAICapabilityUCOrNull(int id) {
    if (KamikazeAICapabilityUCExists(id)) {
      return new KamikazeAICapabilityUC(this, id);
    } else {
      return new KamikazeAICapabilityUC(this, 0);
    }
  }
  public List<KamikazeAICapabilityUC> AllKamikazeAICapabilityUC() {
    List<KamikazeAICapabilityUC> result = new List<KamikazeAICapabilityUC>(rootIncarnation.incarnationsKamikazeAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsKamikazeAICapabilityUC.Keys) {
      result.Add(new KamikazeAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<KamikazeAICapabilityUC> EnumAllKamikazeAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsKamikazeAICapabilityUC.Keys) {
      yield return GetKamikazeAICapabilityUC(id);
    }
  }
  public void CheckHasKamikazeAICapabilityUC(KamikazeAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasKamikazeAICapabilityUC(thing.id);
  }
  public void CheckHasKamikazeAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid KamikazeAICapabilityUC: " + id);
    }
  }
  public KamikazeAICapabilityUC EffectKamikazeAICapabilityUCCreate(
      KamikazeTargetTTCStrongByLocationMutMap targetByLocation,
      Location targetLocationCenter) {
    CheckHasKamikazeTargetTTCStrongByLocationMutMap(targetByLocation);
    return TrustedEffectKamikazeAICapabilityUCCreateWithId(NewId()
            ,targetByLocation.id
            ,targetLocationCenter    );
  }
  public KamikazeAICapabilityUC TrustedEffectKamikazeAICapabilityUCCreateWithId(int id
,      int targetByLocation
,      Location targetLocationCenter) {
    CheckUnlocked();

    var incarnation =
        new KamikazeAICapabilityUCIncarnation(
            targetByLocation,
            targetLocationCenter
            );
    var effect = InternalEffectCreateKamikazeAICapabilityUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new KamikazeAICapabilityUC(this, id);
  }
  public KamikazeAICapabilityUCCreateEffect InternalEffectCreateKamikazeAICapabilityUC(
      int id,
      int incarnationVersion,
      KamikazeAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsKamikazeAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<KamikazeAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new KamikazeAICapabilityUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectKamikazeAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectKamikazeAICapabilityUCDelete(id);
    NotifyEffect(effect);
  }
  public KamikazeAICapabilityUCDeleteEffect InternalEffectKamikazeAICapabilityUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsKamikazeAICapabilityUC[id];

    rootIncarnation.incarnationsKamikazeAICapabilityUC.Remove(id);
    return new KamikazeAICapabilityUCDeleteEffect(id);
  }

     
  public int GetKamikazeAICapabilityUCHash(int id, int version, KamikazeAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.targetByLocation.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.targetLocationCenter.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectKamikazeAICapabilityUCSetTargetByLocation(
      int id, KamikazeTargetTTCStrongByLocationMutMap newValue) {
    CheckUnlocked();
    CheckHasKamikazeAICapabilityUC(id);
    var effect = InternalEffectKamikazeAICapabilityUCSetTargetByLocation(id, newValue);
    NotifyEffect(effect);
  }
  public KamikazeAICapabilityUCSetTargetByLocationEffect InternalEffectKamikazeAICapabilityUCSetTargetByLocation(int id, KamikazeTargetTTCStrongByLocationMutMap newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeAICapabilityUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldId = oldIncarnationAndVersion.incarnation.targetByLocation;
      oldIncarnationAndVersion.incarnation.targetByLocation = newValue.id;

    } else {
      var newIncarnation =
          new KamikazeAICapabilityUCIncarnation(
              newValue.id,
              oldIncarnationAndVersion.incarnation.targetLocationCenter);
      rootIncarnation.incarnationsKamikazeAICapabilityUC[id] =
          new VersionAndIncarnation<KamikazeAICapabilityUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new KamikazeAICapabilityUCSetTargetByLocationEffect(id, newValue.id);
  }

  public void EffectKamikazeAICapabilityUCSetTargetLocationCenter(
      int id, Location newValue) {
    CheckUnlocked();
    CheckHasKamikazeAICapabilityUC(id);
    var effect = InternalEffectKamikazeAICapabilityUCSetTargetLocationCenter(id, newValue);
    NotifyEffect(effect);
  }
  public KamikazeAICapabilityUCSetTargetLocationCenterEffect InternalEffectKamikazeAICapabilityUCSetTargetLocationCenter(int id, Location newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeAICapabilityUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.targetLocationCenter;
      oldIncarnationAndVersion.incarnation.targetLocationCenter = newValue;

    } else {
      var newIncarnation =
          new KamikazeAICapabilityUCIncarnation(
              oldIncarnationAndVersion.incarnation.targetByLocation,
              newValue);
      rootIncarnation.incarnationsKamikazeAICapabilityUC[id] =
          new VersionAndIncarnation<KamikazeAICapabilityUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new KamikazeAICapabilityUCSetTargetLocationCenterEffect(id, newValue);
  }
  public InvincibilityUCIncarnation GetInvincibilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsInvincibilityUC[id].incarnation;
  }
  public bool InvincibilityUCExists(int id) {
    return rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id);
  }
  public InvincibilityUC GetInvincibilityUC(int id) {
    CheckHasInvincibilityUC(id);
    return new InvincibilityUC(this, id);
  }
  public InvincibilityUC GetInvincibilityUCOrNull(int id) {
    if (InvincibilityUCExists(id)) {
      return new InvincibilityUC(this, id);
    } else {
      return new InvincibilityUC(this, 0);
    }
  }
  public List<InvincibilityUC> AllInvincibilityUC() {
    List<InvincibilityUC> result = new List<InvincibilityUC>(rootIncarnation.incarnationsInvincibilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsInvincibilityUC.Keys) {
      result.Add(new InvincibilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<InvincibilityUC> EnumAllInvincibilityUC() {
    foreach (var id in rootIncarnation.incarnationsInvincibilityUC.Keys) {
      yield return GetInvincibilityUC(id);
    }
  }
  public void CheckHasInvincibilityUC(InvincibilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasInvincibilityUC(thing.id);
  }
  public void CheckHasInvincibilityUC(int id) {
    if (!rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid InvincibilityUC: " + id);
    }
  }
  public InvincibilityUC EffectInvincibilityUCCreate(
) {
    return TrustedEffectInvincibilityUCCreateWithId(NewId()
    );
  }
  public InvincibilityUC TrustedEffectInvincibilityUCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new InvincibilityUCIncarnation(

            );
    var effect = InternalEffectCreateInvincibilityUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new InvincibilityUC(this, id);
  }
  public InvincibilityUCCreateEffect InternalEffectCreateInvincibilityUC(
      int id,
      int incarnationVersion,
      InvincibilityUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsInvincibilityUC.Add(
        id,
        new VersionAndIncarnation<InvincibilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new InvincibilityUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectInvincibilityUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectInvincibilityUCDelete(id);
    NotifyEffect(effect);
  }
  public InvincibilityUCDeleteEffect InternalEffectInvincibilityUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsInvincibilityUC[id];

    rootIncarnation.incarnationsInvincibilityUC.Remove(id);
    return new InvincibilityUCDeleteEffect(id);
  }

     
  public int GetInvincibilityUCHash(int id, int version, InvincibilityUCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public GuardAICapabilityUCIncarnation GetGuardAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsGuardAICapabilityUC[id].incarnation;
  }
  public bool GuardAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(id);
  }
  public GuardAICapabilityUC GetGuardAICapabilityUC(int id) {
    CheckHasGuardAICapabilityUC(id);
    return new GuardAICapabilityUC(this, id);
  }
  public GuardAICapabilityUC GetGuardAICapabilityUCOrNull(int id) {
    if (GuardAICapabilityUCExists(id)) {
      return new GuardAICapabilityUC(this, id);
    } else {
      return new GuardAICapabilityUC(this, 0);
    }
  }
  public List<GuardAICapabilityUC> AllGuardAICapabilityUC() {
    List<GuardAICapabilityUC> result = new List<GuardAICapabilityUC>(rootIncarnation.incarnationsGuardAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsGuardAICapabilityUC.Keys) {
      result.Add(new GuardAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<GuardAICapabilityUC> EnumAllGuardAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsGuardAICapabilityUC.Keys) {
      yield return GetGuardAICapabilityUC(id);
    }
  }
  public void CheckHasGuardAICapabilityUC(GuardAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasGuardAICapabilityUC(thing.id);
  }
  public void CheckHasGuardAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid GuardAICapabilityUC: " + id);
    }
  }
  public GuardAICapabilityUC EffectGuardAICapabilityUCCreate(
      Location guardCenterLocation,
      int guardRadius) {
    return TrustedEffectGuardAICapabilityUCCreateWithId(NewId()
            ,guardCenterLocation
            ,guardRadius    );
  }
  public GuardAICapabilityUC TrustedEffectGuardAICapabilityUCCreateWithId(int id
,      Location guardCenterLocation
,      int guardRadius) {
    CheckUnlocked();

    var incarnation =
        new GuardAICapabilityUCIncarnation(
            guardCenterLocation,
            guardRadius
            );
    var effect = InternalEffectCreateGuardAICapabilityUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new GuardAICapabilityUC(this, id);
  }
  public GuardAICapabilityUCCreateEffect InternalEffectCreateGuardAICapabilityUC(
      int id,
      int incarnationVersion,
      GuardAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsGuardAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<GuardAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new GuardAICapabilityUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectGuardAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectGuardAICapabilityUCDelete(id);
    NotifyEffect(effect);
  }
  public GuardAICapabilityUCDeleteEffect InternalEffectGuardAICapabilityUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsGuardAICapabilityUC[id];

    rootIncarnation.incarnationsGuardAICapabilityUC.Remove(id);
    return new GuardAICapabilityUCDeleteEffect(id);
  }

     
  public int GetGuardAICapabilityUCHash(int id, int version, GuardAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.guardCenterLocation.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.guardRadius.GetDeterministicHashCode();
    return result;
  }
       public NoImpulseIncarnation GetNoImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsNoImpulse[id].incarnation;
  }
  public bool NoImpulseExists(int id) {
    return rootIncarnation.incarnationsNoImpulse.ContainsKey(id);
  }
  public NoImpulse GetNoImpulse(int id) {
    CheckHasNoImpulse(id);
    return new NoImpulse(this, id);
  }
  public NoImpulse GetNoImpulseOrNull(int id) {
    if (NoImpulseExists(id)) {
      return new NoImpulse(this, id);
    } else {
      return new NoImpulse(this, 0);
    }
  }
  public List<NoImpulse> AllNoImpulse() {
    List<NoImpulse> result = new List<NoImpulse>(rootIncarnation.incarnationsNoImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsNoImpulse.Keys) {
      result.Add(new NoImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<NoImpulse> EnumAllNoImpulse() {
    foreach (var id in rootIncarnation.incarnationsNoImpulse.Keys) {
      yield return GetNoImpulse(id);
    }
  }
  public void CheckHasNoImpulse(NoImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasNoImpulse(thing.id);
  }
  public void CheckHasNoImpulse(int id) {
    if (!rootIncarnation.incarnationsNoImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid NoImpulse: " + id);
    }
  }
  public NoImpulse EffectNoImpulseCreate(
) {
    return TrustedEffectNoImpulseCreateWithId(NewId()
    );
  }
  public NoImpulse TrustedEffectNoImpulseCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new NoImpulseIncarnation(

            );
    var effect = InternalEffectCreateNoImpulse(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new NoImpulse(this, id);
  }
  public NoImpulseCreateEffect InternalEffectCreateNoImpulse(
      int id,
      int incarnationVersion,
      NoImpulseIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsNoImpulse.Add(
        id,
        new VersionAndIncarnation<NoImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    return new NoImpulseCreateEffect(id, incarnation.Copy());
  }

  public void EffectNoImpulseDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectNoImpulseDelete(id);
    NotifyEffect(effect);
  }
  public NoImpulseDeleteEffect InternalEffectNoImpulseDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsNoImpulse[id];

    rootIncarnation.incarnationsNoImpulse.Remove(id);
    return new NoImpulseDeleteEffect(id);
  }

     
  public int GetNoImpulseHash(int id, int version, NoImpulseIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public EvolvifyImpulseIncarnation GetEvolvifyImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsEvolvifyImpulse[id].incarnation;
  }
  public bool EvolvifyImpulseExists(int id) {
    return rootIncarnation.incarnationsEvolvifyImpulse.ContainsKey(id);
  }
  public EvolvifyImpulse GetEvolvifyImpulse(int id) {
    CheckHasEvolvifyImpulse(id);
    return new EvolvifyImpulse(this, id);
  }
  public EvolvifyImpulse GetEvolvifyImpulseOrNull(int id) {
    if (EvolvifyImpulseExists(id)) {
      return new EvolvifyImpulse(this, id);
    } else {
      return new EvolvifyImpulse(this, 0);
    }
  }
  public List<EvolvifyImpulse> AllEvolvifyImpulse() {
    List<EvolvifyImpulse> result = new List<EvolvifyImpulse>(rootIncarnation.incarnationsEvolvifyImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsEvolvifyImpulse.Keys) {
      result.Add(new EvolvifyImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<EvolvifyImpulse> EnumAllEvolvifyImpulse() {
    foreach (var id in rootIncarnation.incarnationsEvolvifyImpulse.Keys) {
      yield return GetEvolvifyImpulse(id);
    }
  }
  public void CheckHasEvolvifyImpulse(EvolvifyImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasEvolvifyImpulse(thing.id);
  }
  public void CheckHasEvolvifyImpulse(int id) {
    if (!rootIncarnation.incarnationsEvolvifyImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid EvolvifyImpulse: " + id);
    }
  }
  public EvolvifyImpulse EffectEvolvifyImpulseCreate(
      int weight,
      Location moveToLocation) {
    return TrustedEffectEvolvifyImpulseCreateWithId(NewId()
            ,weight
            ,moveToLocation    );
  }
  public EvolvifyImpulse TrustedEffectEvolvifyImpulseCreateWithId(int id
,      int weight
,      Location moveToLocation) {
    CheckUnlocked();

    var incarnation =
        new EvolvifyImpulseIncarnation(
            weight,
            moveToLocation
            );
    var effect = InternalEffectCreateEvolvifyImpulse(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new EvolvifyImpulse(this, id);
  }
  public EvolvifyImpulseCreateEffect InternalEffectCreateEvolvifyImpulse(
      int id,
      int incarnationVersion,
      EvolvifyImpulseIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsEvolvifyImpulse.Add(
        id,
        new VersionAndIncarnation<EvolvifyImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    return new EvolvifyImpulseCreateEffect(id, incarnation.Copy());
  }

  public void EffectEvolvifyImpulseDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectEvolvifyImpulseDelete(id);
    NotifyEffect(effect);
  }
  public EvolvifyImpulseDeleteEffect InternalEffectEvolvifyImpulseDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsEvolvifyImpulse[id];

    rootIncarnation.incarnationsEvolvifyImpulse.Remove(id);
    return new EvolvifyImpulseDeleteEffect(id);
  }

     
  public int GetEvolvifyImpulseHash(int id, int version, EvolvifyImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.moveToLocation.GetDeterministicHashCode();
    return result;
  }
       public EvolvifyAICapabilityUCIncarnation GetEvolvifyAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsEvolvifyAICapabilityUC[id].incarnation;
  }
  public bool EvolvifyAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsEvolvifyAICapabilityUC.ContainsKey(id);
  }
  public EvolvifyAICapabilityUC GetEvolvifyAICapabilityUC(int id) {
    CheckHasEvolvifyAICapabilityUC(id);
    return new EvolvifyAICapabilityUC(this, id);
  }
  public EvolvifyAICapabilityUC GetEvolvifyAICapabilityUCOrNull(int id) {
    if (EvolvifyAICapabilityUCExists(id)) {
      return new EvolvifyAICapabilityUC(this, id);
    } else {
      return new EvolvifyAICapabilityUC(this, 0);
    }
  }
  public List<EvolvifyAICapabilityUC> AllEvolvifyAICapabilityUC() {
    List<EvolvifyAICapabilityUC> result = new List<EvolvifyAICapabilityUC>(rootIncarnation.incarnationsEvolvifyAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsEvolvifyAICapabilityUC.Keys) {
      result.Add(new EvolvifyAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<EvolvifyAICapabilityUC> EnumAllEvolvifyAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsEvolvifyAICapabilityUC.Keys) {
      yield return GetEvolvifyAICapabilityUC(id);
    }
  }
  public void CheckHasEvolvifyAICapabilityUC(EvolvifyAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasEvolvifyAICapabilityUC(thing.id);
  }
  public void CheckHasEvolvifyAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsEvolvifyAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid EvolvifyAICapabilityUC: " + id);
    }
  }
  public EvolvifyAICapabilityUC EffectEvolvifyAICapabilityUCCreate(
) {
    return TrustedEffectEvolvifyAICapabilityUCCreateWithId(NewId()
    );
  }
  public EvolvifyAICapabilityUC TrustedEffectEvolvifyAICapabilityUCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new EvolvifyAICapabilityUCIncarnation(

            );
    var effect = InternalEffectCreateEvolvifyAICapabilityUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new EvolvifyAICapabilityUC(this, id);
  }
  public EvolvifyAICapabilityUCCreateEffect InternalEffectCreateEvolvifyAICapabilityUC(
      int id,
      int incarnationVersion,
      EvolvifyAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsEvolvifyAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<EvolvifyAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new EvolvifyAICapabilityUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectEvolvifyAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectEvolvifyAICapabilityUCDelete(id);
    NotifyEffect(effect);
  }
  public EvolvifyAICapabilityUCDeleteEffect InternalEffectEvolvifyAICapabilityUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsEvolvifyAICapabilityUC[id];

    rootIncarnation.incarnationsEvolvifyAICapabilityUC.Remove(id);
    return new EvolvifyAICapabilityUCDeleteEffect(id);
  }

     
  public int GetEvolvifyAICapabilityUCHash(int id, int version, EvolvifyAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public FireImpulseIncarnation GetFireImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsFireImpulse[id].incarnation;
  }
  public bool FireImpulseExists(int id) {
    return rootIncarnation.incarnationsFireImpulse.ContainsKey(id);
  }
  public FireImpulse GetFireImpulse(int id) {
    CheckHasFireImpulse(id);
    return new FireImpulse(this, id);
  }
  public FireImpulse GetFireImpulseOrNull(int id) {
    if (FireImpulseExists(id)) {
      return new FireImpulse(this, id);
    } else {
      return new FireImpulse(this, 0);
    }
  }
  public List<FireImpulse> AllFireImpulse() {
    List<FireImpulse> result = new List<FireImpulse>(rootIncarnation.incarnationsFireImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsFireImpulse.Keys) {
      result.Add(new FireImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<FireImpulse> EnumAllFireImpulse() {
    foreach (var id in rootIncarnation.incarnationsFireImpulse.Keys) {
      yield return GetFireImpulse(id);
    }
  }
  public void CheckHasFireImpulse(FireImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasFireImpulse(thing.id);
  }
  public void CheckHasFireImpulse(int id) {
    if (!rootIncarnation.incarnationsFireImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid FireImpulse: " + id);
    }
  }
  public FireImpulse EffectFireImpulseCreate(
      int weight,
      Unit targetUnit) {
    CheckHasUnit(targetUnit);
    return TrustedEffectFireImpulseCreateWithId(NewId()
            ,weight
            ,targetUnit.id    );
  }
  public FireImpulse TrustedEffectFireImpulseCreateWithId(int id
,      int weight
,      int targetUnit) {
    CheckUnlocked();

    var incarnation =
        new FireImpulseIncarnation(
            weight,
            targetUnit
            );
    var effect = InternalEffectCreateFireImpulse(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new FireImpulse(this, id);
  }
  public FireImpulseCreateEffect InternalEffectCreateFireImpulse(
      int id,
      int incarnationVersion,
      FireImpulseIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsFireImpulse.Add(
        id,
        new VersionAndIncarnation<FireImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    return new FireImpulseCreateEffect(id, incarnation.Copy());
  }

  public void EffectFireImpulseDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectFireImpulseDelete(id);
    NotifyEffect(effect);
  }
  public FireImpulseDeleteEffect InternalEffectFireImpulseDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsFireImpulse[id];

    rootIncarnation.incarnationsFireImpulse.Remove(id);
    return new FireImpulseDeleteEffect(id);
  }

     
  public int GetFireImpulseHash(int id, int version, FireImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.targetUnit.GetDeterministicHashCode();
    return result;
  }
       public OnFireUCIncarnation GetOnFireUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsOnFireUC[id].incarnation;
  }
  public bool OnFireUCExists(int id) {
    return rootIncarnation.incarnationsOnFireUC.ContainsKey(id);
  }
  public OnFireUC GetOnFireUC(int id) {
    CheckHasOnFireUC(id);
    return new OnFireUC(this, id);
  }
  public OnFireUC GetOnFireUCOrNull(int id) {
    if (OnFireUCExists(id)) {
      return new OnFireUC(this, id);
    } else {
      return new OnFireUC(this, 0);
    }
  }
  public List<OnFireUC> AllOnFireUC() {
    List<OnFireUC> result = new List<OnFireUC>(rootIncarnation.incarnationsOnFireUC.Count);
    foreach (var id in rootIncarnation.incarnationsOnFireUC.Keys) {
      result.Add(new OnFireUC(this, id));
    }
    return result;
  }
  public IEnumerator<OnFireUC> EnumAllOnFireUC() {
    foreach (var id in rootIncarnation.incarnationsOnFireUC.Keys) {
      yield return GetOnFireUC(id);
    }
  }
  public void CheckHasOnFireUC(OnFireUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasOnFireUC(thing.id);
  }
  public void CheckHasOnFireUC(int id) {
    if (!rootIncarnation.incarnationsOnFireUC.ContainsKey(id)) {
      throw new System.Exception("Invalid OnFireUC: " + id);
    }
  }
  public OnFireUC EffectOnFireUCCreate(
      int turnsRemaining) {
    return TrustedEffectOnFireUCCreateWithId(NewId()
            ,turnsRemaining    );
  }
  public OnFireUC TrustedEffectOnFireUCCreateWithId(int id
,      int turnsRemaining) {
    CheckUnlocked();

    var incarnation =
        new OnFireUCIncarnation(
            turnsRemaining
            );
    var effect = InternalEffectCreateOnFireUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new OnFireUC(this, id);
  }
  public OnFireUCCreateEffect InternalEffectCreateOnFireUC(
      int id,
      int incarnationVersion,
      OnFireUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsOnFireUC.Add(
        id,
        new VersionAndIncarnation<OnFireUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new OnFireUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectOnFireUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectOnFireUCDelete(id);
    NotifyEffect(effect);
  }
  public OnFireUCDeleteEffect InternalEffectOnFireUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsOnFireUC[id];

    rootIncarnation.incarnationsOnFireUC.Remove(id);
    return new OnFireUCDeleteEffect(id);
  }

     
  public int GetOnFireUCHash(int id, int version, OnFireUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.turnsRemaining.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectOnFireUCSetTurnsRemaining(
      int id, int newValue) {
    CheckUnlocked();
    CheckHasOnFireUC(id);
    var effect = InternalEffectOnFireUCSetTurnsRemaining(id, newValue);
    NotifyEffect(effect);
  }
  public OnFireUCSetTurnsRemainingEffect InternalEffectOnFireUCSetTurnsRemaining(int id, int newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsOnFireUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.turnsRemaining;
      oldIncarnationAndVersion.incarnation.turnsRemaining = newValue;

    } else {
      var newIncarnation =
          new OnFireUCIncarnation(
              newValue);
      rootIncarnation.incarnationsOnFireUC[id] =
          new VersionAndIncarnation<OnFireUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new OnFireUCSetTurnsRemainingEffect(id, newValue);
  }
  public DefyingUCIncarnation GetDefyingUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsDefyingUC[id].incarnation;
  }
  public bool DefyingUCExists(int id) {
    return rootIncarnation.incarnationsDefyingUC.ContainsKey(id);
  }
  public DefyingUC GetDefyingUC(int id) {
    CheckHasDefyingUC(id);
    return new DefyingUC(this, id);
  }
  public DefyingUC GetDefyingUCOrNull(int id) {
    if (DefyingUCExists(id)) {
      return new DefyingUC(this, id);
    } else {
      return new DefyingUC(this, 0);
    }
  }
  public List<DefyingUC> AllDefyingUC() {
    List<DefyingUC> result = new List<DefyingUC>(rootIncarnation.incarnationsDefyingUC.Count);
    foreach (var id in rootIncarnation.incarnationsDefyingUC.Keys) {
      result.Add(new DefyingUC(this, id));
    }
    return result;
  }
  public IEnumerator<DefyingUC> EnumAllDefyingUC() {
    foreach (var id in rootIncarnation.incarnationsDefyingUC.Keys) {
      yield return GetDefyingUC(id);
    }
  }
  public void CheckHasDefyingUC(DefyingUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasDefyingUC(thing.id);
  }
  public void CheckHasDefyingUC(int id) {
    if (!rootIncarnation.incarnationsDefyingUC.ContainsKey(id)) {
      throw new System.Exception("Invalid DefyingUC: " + id);
    }
  }
  public DefyingUC EffectDefyingUCCreate(
) {
    return TrustedEffectDefyingUCCreateWithId(NewId()
    );
  }
  public DefyingUC TrustedEffectDefyingUCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new DefyingUCIncarnation(

            );
    var effect = InternalEffectCreateDefyingUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new DefyingUC(this, id);
  }
  public DefyingUCCreateEffect InternalEffectCreateDefyingUC(
      int id,
      int incarnationVersion,
      DefyingUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsDefyingUC.Add(
        id,
        new VersionAndIncarnation<DefyingUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new DefyingUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectDefyingUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectDefyingUCDelete(id);
    NotifyEffect(effect);
  }
  public DefyingUCDeleteEffect InternalEffectDefyingUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsDefyingUC[id];

    rootIncarnation.incarnationsDefyingUC.Remove(id);
    return new DefyingUCDeleteEffect(id);
  }

     
  public int GetDefyingUCHash(int id, int version, DefyingUCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public DefyImpulseIncarnation GetDefyImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsDefyImpulse[id].incarnation;
  }
  public bool DefyImpulseExists(int id) {
    return rootIncarnation.incarnationsDefyImpulse.ContainsKey(id);
  }
  public DefyImpulse GetDefyImpulse(int id) {
    CheckHasDefyImpulse(id);
    return new DefyImpulse(this, id);
  }
  public DefyImpulse GetDefyImpulseOrNull(int id) {
    if (DefyImpulseExists(id)) {
      return new DefyImpulse(this, id);
    } else {
      return new DefyImpulse(this, 0);
    }
  }
  public List<DefyImpulse> AllDefyImpulse() {
    List<DefyImpulse> result = new List<DefyImpulse>(rootIncarnation.incarnationsDefyImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsDefyImpulse.Keys) {
      result.Add(new DefyImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<DefyImpulse> EnumAllDefyImpulse() {
    foreach (var id in rootIncarnation.incarnationsDefyImpulse.Keys) {
      yield return GetDefyImpulse(id);
    }
  }
  public void CheckHasDefyImpulse(DefyImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasDefyImpulse(thing.id);
  }
  public void CheckHasDefyImpulse(int id) {
    if (!rootIncarnation.incarnationsDefyImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid DefyImpulse: " + id);
    }
  }
  public DefyImpulse EffectDefyImpulseCreate(
      int weight) {
    return TrustedEffectDefyImpulseCreateWithId(NewId()
            ,weight    );
  }
  public DefyImpulse TrustedEffectDefyImpulseCreateWithId(int id
,      int weight) {
    CheckUnlocked();

    var incarnation =
        new DefyImpulseIncarnation(
            weight
            );
    var effect = InternalEffectCreateDefyImpulse(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new DefyImpulse(this, id);
  }
  public DefyImpulseCreateEffect InternalEffectCreateDefyImpulse(
      int id,
      int incarnationVersion,
      DefyImpulseIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsDefyImpulse.Add(
        id,
        new VersionAndIncarnation<DefyImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    return new DefyImpulseCreateEffect(id, incarnation.Copy());
  }

  public void EffectDefyImpulseDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectDefyImpulseDelete(id);
    NotifyEffect(effect);
  }
  public DefyImpulseDeleteEffect InternalEffectDefyImpulseDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsDefyImpulse[id];

    rootIncarnation.incarnationsDefyImpulse.Remove(id);
    return new DefyImpulseDeleteEffect(id);
  }

     
  public int GetDefyImpulseHash(int id, int version, DefyImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    return result;
  }
       public CounteringUCIncarnation GetCounteringUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCounteringUC[id].incarnation;
  }
  public bool CounteringUCExists(int id) {
    return rootIncarnation.incarnationsCounteringUC.ContainsKey(id);
  }
  public CounteringUC GetCounteringUC(int id) {
    CheckHasCounteringUC(id);
    return new CounteringUC(this, id);
  }
  public CounteringUC GetCounteringUCOrNull(int id) {
    if (CounteringUCExists(id)) {
      return new CounteringUC(this, id);
    } else {
      return new CounteringUC(this, 0);
    }
  }
  public List<CounteringUC> AllCounteringUC() {
    List<CounteringUC> result = new List<CounteringUC>(rootIncarnation.incarnationsCounteringUC.Count);
    foreach (var id in rootIncarnation.incarnationsCounteringUC.Keys) {
      result.Add(new CounteringUC(this, id));
    }
    return result;
  }
  public IEnumerator<CounteringUC> EnumAllCounteringUC() {
    foreach (var id in rootIncarnation.incarnationsCounteringUC.Keys) {
      yield return GetCounteringUC(id);
    }
  }
  public void CheckHasCounteringUC(CounteringUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCounteringUC(thing.id);
  }
  public void CheckHasCounteringUC(int id) {
    if (!rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      throw new System.Exception("Invalid CounteringUC: " + id);
    }
  }
  public CounteringUC EffectCounteringUCCreate(
) {
    return TrustedEffectCounteringUCCreateWithId(NewId()
    );
  }
  public CounteringUC TrustedEffectCounteringUCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new CounteringUCIncarnation(

            );
    var effect = InternalEffectCreateCounteringUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new CounteringUC(this, id);
  }
  public CounteringUCCreateEffect InternalEffectCreateCounteringUC(
      int id,
      int incarnationVersion,
      CounteringUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsCounteringUC.Add(
        id,
        new VersionAndIncarnation<CounteringUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new CounteringUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectCounteringUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectCounteringUCDelete(id);
    NotifyEffect(effect);
  }
  public CounteringUCDeleteEffect InternalEffectCounteringUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCounteringUC[id];

    rootIncarnation.incarnationsCounteringUC.Remove(id);
    return new CounteringUCDeleteEffect(id);
  }

     
  public int GetCounteringUCHash(int id, int version, CounteringUCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public CounterImpulseIncarnation GetCounterImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCounterImpulse[id].incarnation;
  }
  public bool CounterImpulseExists(int id) {
    return rootIncarnation.incarnationsCounterImpulse.ContainsKey(id);
  }
  public CounterImpulse GetCounterImpulse(int id) {
    CheckHasCounterImpulse(id);
    return new CounterImpulse(this, id);
  }
  public CounterImpulse GetCounterImpulseOrNull(int id) {
    if (CounterImpulseExists(id)) {
      return new CounterImpulse(this, id);
    } else {
      return new CounterImpulse(this, 0);
    }
  }
  public List<CounterImpulse> AllCounterImpulse() {
    List<CounterImpulse> result = new List<CounterImpulse>(rootIncarnation.incarnationsCounterImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsCounterImpulse.Keys) {
      result.Add(new CounterImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<CounterImpulse> EnumAllCounterImpulse() {
    foreach (var id in rootIncarnation.incarnationsCounterImpulse.Keys) {
      yield return GetCounterImpulse(id);
    }
  }
  public void CheckHasCounterImpulse(CounterImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCounterImpulse(thing.id);
  }
  public void CheckHasCounterImpulse(int id) {
    if (!rootIncarnation.incarnationsCounterImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid CounterImpulse: " + id);
    }
  }
  public CounterImpulse EffectCounterImpulseCreate(
      int weight) {
    return TrustedEffectCounterImpulseCreateWithId(NewId()
            ,weight    );
  }
  public CounterImpulse TrustedEffectCounterImpulseCreateWithId(int id
,      int weight) {
    CheckUnlocked();

    var incarnation =
        new CounterImpulseIncarnation(
            weight
            );
    var effect = InternalEffectCreateCounterImpulse(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new CounterImpulse(this, id);
  }
  public CounterImpulseCreateEffect InternalEffectCreateCounterImpulse(
      int id,
      int incarnationVersion,
      CounterImpulseIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsCounterImpulse.Add(
        id,
        new VersionAndIncarnation<CounterImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    return new CounterImpulseCreateEffect(id, incarnation.Copy());
  }

  public void EffectCounterImpulseDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectCounterImpulseDelete(id);
    NotifyEffect(effect);
  }
  public CounterImpulseDeleteEffect InternalEffectCounterImpulseDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCounterImpulse[id];

    rootIncarnation.incarnationsCounterImpulse.Remove(id);
    return new CounterImpulseDeleteEffect(id);
  }

     
  public int GetCounterImpulseHash(int id, int version, CounterImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    return result;
  }
       public UnleashBideImpulseIncarnation GetUnleashBideImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsUnleashBideImpulse[id].incarnation;
  }
  public bool UnleashBideImpulseExists(int id) {
    return rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(id);
  }
  public UnleashBideImpulse GetUnleashBideImpulse(int id) {
    CheckHasUnleashBideImpulse(id);
    return new UnleashBideImpulse(this, id);
  }
  public UnleashBideImpulse GetUnleashBideImpulseOrNull(int id) {
    if (UnleashBideImpulseExists(id)) {
      return new UnleashBideImpulse(this, id);
    } else {
      return new UnleashBideImpulse(this, 0);
    }
  }
  public List<UnleashBideImpulse> AllUnleashBideImpulse() {
    List<UnleashBideImpulse> result = new List<UnleashBideImpulse>(rootIncarnation.incarnationsUnleashBideImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsUnleashBideImpulse.Keys) {
      result.Add(new UnleashBideImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<UnleashBideImpulse> EnumAllUnleashBideImpulse() {
    foreach (var id in rootIncarnation.incarnationsUnleashBideImpulse.Keys) {
      yield return GetUnleashBideImpulse(id);
    }
  }
  public void CheckHasUnleashBideImpulse(UnleashBideImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasUnleashBideImpulse(thing.id);
  }
  public void CheckHasUnleashBideImpulse(int id) {
    if (!rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid UnleashBideImpulse: " + id);
    }
  }
  public UnleashBideImpulse EffectUnleashBideImpulseCreate(
      int weight) {
    return TrustedEffectUnleashBideImpulseCreateWithId(NewId()
            ,weight    );
  }
  public UnleashBideImpulse TrustedEffectUnleashBideImpulseCreateWithId(int id
,      int weight) {
    CheckUnlocked();

    var incarnation =
        new UnleashBideImpulseIncarnation(
            weight
            );
    var effect = InternalEffectCreateUnleashBideImpulse(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new UnleashBideImpulse(this, id);
  }
  public UnleashBideImpulseCreateEffect InternalEffectCreateUnleashBideImpulse(
      int id,
      int incarnationVersion,
      UnleashBideImpulseIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsUnleashBideImpulse.Add(
        id,
        new VersionAndIncarnation<UnleashBideImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    return new UnleashBideImpulseCreateEffect(id, incarnation.Copy());
  }

  public void EffectUnleashBideImpulseDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectUnleashBideImpulseDelete(id);
    NotifyEffect(effect);
  }
  public UnleashBideImpulseDeleteEffect InternalEffectUnleashBideImpulseDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsUnleashBideImpulse[id];

    rootIncarnation.incarnationsUnleashBideImpulse.Remove(id);
    return new UnleashBideImpulseDeleteEffect(id);
  }

     
  public int GetUnleashBideImpulseHash(int id, int version, UnleashBideImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    return result;
  }
       public ContinueBidingImpulseIncarnation GetContinueBidingImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsContinueBidingImpulse[id].incarnation;
  }
  public bool ContinueBidingImpulseExists(int id) {
    return rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(id);
  }
  public ContinueBidingImpulse GetContinueBidingImpulse(int id) {
    CheckHasContinueBidingImpulse(id);
    return new ContinueBidingImpulse(this, id);
  }
  public ContinueBidingImpulse GetContinueBidingImpulseOrNull(int id) {
    if (ContinueBidingImpulseExists(id)) {
      return new ContinueBidingImpulse(this, id);
    } else {
      return new ContinueBidingImpulse(this, 0);
    }
  }
  public List<ContinueBidingImpulse> AllContinueBidingImpulse() {
    List<ContinueBidingImpulse> result = new List<ContinueBidingImpulse>(rootIncarnation.incarnationsContinueBidingImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsContinueBidingImpulse.Keys) {
      result.Add(new ContinueBidingImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<ContinueBidingImpulse> EnumAllContinueBidingImpulse() {
    foreach (var id in rootIncarnation.incarnationsContinueBidingImpulse.Keys) {
      yield return GetContinueBidingImpulse(id);
    }
  }
  public void CheckHasContinueBidingImpulse(ContinueBidingImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasContinueBidingImpulse(thing.id);
  }
  public void CheckHasContinueBidingImpulse(int id) {
    if (!rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid ContinueBidingImpulse: " + id);
    }
  }
  public ContinueBidingImpulse EffectContinueBidingImpulseCreate(
      int weight) {
    return TrustedEffectContinueBidingImpulseCreateWithId(NewId()
            ,weight    );
  }
  public ContinueBidingImpulse TrustedEffectContinueBidingImpulseCreateWithId(int id
,      int weight) {
    CheckUnlocked();

    var incarnation =
        new ContinueBidingImpulseIncarnation(
            weight
            );
    var effect = InternalEffectCreateContinueBidingImpulse(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new ContinueBidingImpulse(this, id);
  }
  public ContinueBidingImpulseCreateEffect InternalEffectCreateContinueBidingImpulse(
      int id,
      int incarnationVersion,
      ContinueBidingImpulseIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsContinueBidingImpulse.Add(
        id,
        new VersionAndIncarnation<ContinueBidingImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    return new ContinueBidingImpulseCreateEffect(id, incarnation.Copy());
  }

  public void EffectContinueBidingImpulseDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectContinueBidingImpulseDelete(id);
    NotifyEffect(effect);
  }
  public ContinueBidingImpulseDeleteEffect InternalEffectContinueBidingImpulseDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsContinueBidingImpulse[id];

    rootIncarnation.incarnationsContinueBidingImpulse.Remove(id);
    return new ContinueBidingImpulseDeleteEffect(id);
  }

     
  public int GetContinueBidingImpulseHash(int id, int version, ContinueBidingImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    return result;
  }
       public StartBidingImpulseIncarnation GetStartBidingImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsStartBidingImpulse[id].incarnation;
  }
  public bool StartBidingImpulseExists(int id) {
    return rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(id);
  }
  public StartBidingImpulse GetStartBidingImpulse(int id) {
    CheckHasStartBidingImpulse(id);
    return new StartBidingImpulse(this, id);
  }
  public StartBidingImpulse GetStartBidingImpulseOrNull(int id) {
    if (StartBidingImpulseExists(id)) {
      return new StartBidingImpulse(this, id);
    } else {
      return new StartBidingImpulse(this, 0);
    }
  }
  public List<StartBidingImpulse> AllStartBidingImpulse() {
    List<StartBidingImpulse> result = new List<StartBidingImpulse>(rootIncarnation.incarnationsStartBidingImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsStartBidingImpulse.Keys) {
      result.Add(new StartBidingImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<StartBidingImpulse> EnumAllStartBidingImpulse() {
    foreach (var id in rootIncarnation.incarnationsStartBidingImpulse.Keys) {
      yield return GetStartBidingImpulse(id);
    }
  }
  public void CheckHasStartBidingImpulse(StartBidingImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasStartBidingImpulse(thing.id);
  }
  public void CheckHasStartBidingImpulse(int id) {
    if (!rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid StartBidingImpulse: " + id);
    }
  }
  public StartBidingImpulse EffectStartBidingImpulseCreate(
      int weight) {
    return TrustedEffectStartBidingImpulseCreateWithId(NewId()
            ,weight    );
  }
  public StartBidingImpulse TrustedEffectStartBidingImpulseCreateWithId(int id
,      int weight) {
    CheckUnlocked();

    var incarnation =
        new StartBidingImpulseIncarnation(
            weight
            );
    var effect = InternalEffectCreateStartBidingImpulse(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new StartBidingImpulse(this, id);
  }
  public StartBidingImpulseCreateEffect InternalEffectCreateStartBidingImpulse(
      int id,
      int incarnationVersion,
      StartBidingImpulseIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsStartBidingImpulse.Add(
        id,
        new VersionAndIncarnation<StartBidingImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    return new StartBidingImpulseCreateEffect(id, incarnation.Copy());
  }

  public void EffectStartBidingImpulseDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectStartBidingImpulseDelete(id);
    NotifyEffect(effect);
  }
  public StartBidingImpulseDeleteEffect InternalEffectStartBidingImpulseDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsStartBidingImpulse[id];

    rootIncarnation.incarnationsStartBidingImpulse.Remove(id);
    return new StartBidingImpulseDeleteEffect(id);
  }

     
  public int GetStartBidingImpulseHash(int id, int version, StartBidingImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    return result;
  }
       public BideAICapabilityUCIncarnation GetBideAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBideAICapabilityUC[id].incarnation;
  }
  public bool BideAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id);
  }
  public BideAICapabilityUC GetBideAICapabilityUC(int id) {
    CheckHasBideAICapabilityUC(id);
    return new BideAICapabilityUC(this, id);
  }
  public BideAICapabilityUC GetBideAICapabilityUCOrNull(int id) {
    if (BideAICapabilityUCExists(id)) {
      return new BideAICapabilityUC(this, id);
    } else {
      return new BideAICapabilityUC(this, 0);
    }
  }
  public List<BideAICapabilityUC> AllBideAICapabilityUC() {
    List<BideAICapabilityUC> result = new List<BideAICapabilityUC>(rootIncarnation.incarnationsBideAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsBideAICapabilityUC.Keys) {
      result.Add(new BideAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<BideAICapabilityUC> EnumAllBideAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsBideAICapabilityUC.Keys) {
      yield return GetBideAICapabilityUC(id);
    }
  }
  public void CheckHasBideAICapabilityUC(BideAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBideAICapabilityUC(thing.id);
  }
  public void CheckHasBideAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid BideAICapabilityUC: " + id);
    }
  }
  public BideAICapabilityUC EffectBideAICapabilityUCCreate(
      int charge) {
    return TrustedEffectBideAICapabilityUCCreateWithId(NewId()
            ,charge    );
  }
  public BideAICapabilityUC TrustedEffectBideAICapabilityUCCreateWithId(int id
,      int charge) {
    CheckUnlocked();

    var incarnation =
        new BideAICapabilityUCIncarnation(
            charge
            );
    var effect = InternalEffectCreateBideAICapabilityUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new BideAICapabilityUC(this, id);
  }
  public BideAICapabilityUCCreateEffect InternalEffectCreateBideAICapabilityUC(
      int id,
      int incarnationVersion,
      BideAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsBideAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<BideAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new BideAICapabilityUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectBideAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectBideAICapabilityUCDelete(id);
    NotifyEffect(effect);
  }
  public BideAICapabilityUCDeleteEffect InternalEffectBideAICapabilityUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBideAICapabilityUC[id];

    rootIncarnation.incarnationsBideAICapabilityUC.Remove(id);
    return new BideAICapabilityUCDeleteEffect(id);
  }

     
  public int GetBideAICapabilityUCHash(int id, int version, BideAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.charge.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectBideAICapabilityUCSetCharge(
      int id, int newValue) {
    CheckUnlocked();
    CheckHasBideAICapabilityUC(id);
    var effect = InternalEffectBideAICapabilityUCSetCharge(id, newValue);
    NotifyEffect(effect);
  }
  public BideAICapabilityUCSetChargeEffect InternalEffectBideAICapabilityUCSetCharge(int id, int newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsBideAICapabilityUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.charge;
      oldIncarnationAndVersion.incarnation.charge = newValue;

    } else {
      var newIncarnation =
          new BideAICapabilityUCIncarnation(
              newValue);
      rootIncarnation.incarnationsBideAICapabilityUC[id] =
          new VersionAndIncarnation<BideAICapabilityUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new BideAICapabilityUCSetChargeEffect(id, newValue);
  }
  public AttackImpulseIncarnation GetAttackImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsAttackImpulse[id].incarnation;
  }
  public bool AttackImpulseExists(int id) {
    return rootIncarnation.incarnationsAttackImpulse.ContainsKey(id);
  }
  public AttackImpulse GetAttackImpulse(int id) {
    CheckHasAttackImpulse(id);
    return new AttackImpulse(this, id);
  }
  public AttackImpulse GetAttackImpulseOrNull(int id) {
    if (AttackImpulseExists(id)) {
      return new AttackImpulse(this, id);
    } else {
      return new AttackImpulse(this, 0);
    }
  }
  public List<AttackImpulse> AllAttackImpulse() {
    List<AttackImpulse> result = new List<AttackImpulse>(rootIncarnation.incarnationsAttackImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsAttackImpulse.Keys) {
      result.Add(new AttackImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<AttackImpulse> EnumAllAttackImpulse() {
    foreach (var id in rootIncarnation.incarnationsAttackImpulse.Keys) {
      yield return GetAttackImpulse(id);
    }
  }
  public void CheckHasAttackImpulse(AttackImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasAttackImpulse(thing.id);
  }
  public void CheckHasAttackImpulse(int id) {
    if (!rootIncarnation.incarnationsAttackImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid AttackImpulse: " + id);
    }
  }
  public AttackImpulse EffectAttackImpulseCreate(
      int weight,
      Unit targetUnit) {
    CheckHasUnit(targetUnit);
    return TrustedEffectAttackImpulseCreateWithId(NewId()
            ,weight
            ,targetUnit.id    );
  }
  public AttackImpulse TrustedEffectAttackImpulseCreateWithId(int id
,      int weight
,      int targetUnit) {
    CheckUnlocked();

    var incarnation =
        new AttackImpulseIncarnation(
            weight,
            targetUnit
            );
    var effect = InternalEffectCreateAttackImpulse(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new AttackImpulse(this, id);
  }
  public AttackImpulseCreateEffect InternalEffectCreateAttackImpulse(
      int id,
      int incarnationVersion,
      AttackImpulseIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsAttackImpulse.Add(
        id,
        new VersionAndIncarnation<AttackImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    return new AttackImpulseCreateEffect(id, incarnation.Copy());
  }

  public void EffectAttackImpulseDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectAttackImpulseDelete(id);
    NotifyEffect(effect);
  }
  public AttackImpulseDeleteEffect InternalEffectAttackImpulseDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsAttackImpulse[id];

    rootIncarnation.incarnationsAttackImpulse.Remove(id);
    return new AttackImpulseDeleteEffect(id);
  }

     
  public int GetAttackImpulseHash(int id, int version, AttackImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.targetUnit.GetDeterministicHashCode();
    return result;
  }
       public PursueImpulseIncarnation GetPursueImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsPursueImpulse[id].incarnation;
  }
  public bool PursueImpulseExists(int id) {
    return rootIncarnation.incarnationsPursueImpulse.ContainsKey(id);
  }
  public PursueImpulse GetPursueImpulse(int id) {
    CheckHasPursueImpulse(id);
    return new PursueImpulse(this, id);
  }
  public PursueImpulse GetPursueImpulseOrNull(int id) {
    if (PursueImpulseExists(id)) {
      return new PursueImpulse(this, id);
    } else {
      return new PursueImpulse(this, 0);
    }
  }
  public List<PursueImpulse> AllPursueImpulse() {
    List<PursueImpulse> result = new List<PursueImpulse>(rootIncarnation.incarnationsPursueImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsPursueImpulse.Keys) {
      result.Add(new PursueImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<PursueImpulse> EnumAllPursueImpulse() {
    foreach (var id in rootIncarnation.incarnationsPursueImpulse.Keys) {
      yield return GetPursueImpulse(id);
    }
  }
  public void CheckHasPursueImpulse(PursueImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasPursueImpulse(thing.id);
  }
  public void CheckHasPursueImpulse(int id) {
    if (!rootIncarnation.incarnationsPursueImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid PursueImpulse: " + id);
    }
  }
  public PursueImpulse EffectPursueImpulseCreate(
      int weight,
      bool isClearPath) {
    return TrustedEffectPursueImpulseCreateWithId(NewId()
            ,weight
            ,isClearPath    );
  }
  public PursueImpulse TrustedEffectPursueImpulseCreateWithId(int id
,      int weight
,      bool isClearPath) {
    CheckUnlocked();

    var incarnation =
        new PursueImpulseIncarnation(
            weight,
            isClearPath
            );
    var effect = InternalEffectCreatePursueImpulse(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new PursueImpulse(this, id);
  }
  public PursueImpulseCreateEffect InternalEffectCreatePursueImpulse(
      int id,
      int incarnationVersion,
      PursueImpulseIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsPursueImpulse.Add(
        id,
        new VersionAndIncarnation<PursueImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    return new PursueImpulseCreateEffect(id, incarnation.Copy());
  }

  public void EffectPursueImpulseDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectPursueImpulseDelete(id);
    NotifyEffect(effect);
  }
  public PursueImpulseDeleteEffect InternalEffectPursueImpulseDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsPursueImpulse[id];

    rootIncarnation.incarnationsPursueImpulse.Remove(id);
    return new PursueImpulseDeleteEffect(id);
  }

     
  public int GetPursueImpulseHash(int id, int version, PursueImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.isClearPath.GetDeterministicHashCode();
    return result;
  }
       public KillDirectiveIncarnation GetKillDirectiveIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsKillDirective[id].incarnation;
  }
  public bool KillDirectiveExists(int id) {
    return rootIncarnation.incarnationsKillDirective.ContainsKey(id);
  }
  public KillDirective GetKillDirective(int id) {
    CheckHasKillDirective(id);
    return new KillDirective(this, id);
  }
  public KillDirective GetKillDirectiveOrNull(int id) {
    if (KillDirectiveExists(id)) {
      return new KillDirective(this, id);
    } else {
      return new KillDirective(this, 0);
    }
  }
  public List<KillDirective> AllKillDirective() {
    List<KillDirective> result = new List<KillDirective>(rootIncarnation.incarnationsKillDirective.Count);
    foreach (var id in rootIncarnation.incarnationsKillDirective.Keys) {
      result.Add(new KillDirective(this, id));
    }
    return result;
  }
  public IEnumerator<KillDirective> EnumAllKillDirective() {
    foreach (var id in rootIncarnation.incarnationsKillDirective.Keys) {
      yield return GetKillDirective(id);
    }
  }
  public void CheckHasKillDirective(KillDirective thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasKillDirective(thing.id);
  }
  public void CheckHasKillDirective(int id) {
    if (!rootIncarnation.incarnationsKillDirective.ContainsKey(id)) {
      throw new System.Exception("Invalid KillDirective: " + id);
    }
  }
  public KillDirective EffectKillDirectiveCreate(
      Unit targetUnit,
      LocationMutList pathToLastSeenLocation) {
    CheckHasUnit(targetUnit);
    CheckHasLocationMutList(pathToLastSeenLocation);
    return TrustedEffectKillDirectiveCreateWithId(NewId()
            ,targetUnit.id
            ,pathToLastSeenLocation.id    );
  }
  public KillDirective TrustedEffectKillDirectiveCreateWithId(int id
,      int targetUnit
,      int pathToLastSeenLocation) {
    CheckUnlocked();

    var incarnation =
        new KillDirectiveIncarnation(
            targetUnit,
            pathToLastSeenLocation
            );
    var effect = InternalEffectCreateKillDirective(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new KillDirective(this, id);
  }
  public KillDirectiveCreateEffect InternalEffectCreateKillDirective(
      int id,
      int incarnationVersion,
      KillDirectiveIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsKillDirective.Add(
        id,
        new VersionAndIncarnation<KillDirectiveIncarnation>(
            incarnationVersion,
            incarnation));
    return new KillDirectiveCreateEffect(id, incarnation.Copy());
  }

  public void EffectKillDirectiveDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectKillDirectiveDelete(id);
    NotifyEffect(effect);
  }
  public KillDirectiveDeleteEffect InternalEffectKillDirectiveDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsKillDirective[id];

    rootIncarnation.incarnationsKillDirective.Remove(id);
    return new KillDirectiveDeleteEffect(id);
  }

     
  public int GetKillDirectiveHash(int id, int version, KillDirectiveIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.targetUnit.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.pathToLastSeenLocation.GetDeterministicHashCode();
    return result;
  }
       public AttackAICapabilityUCIncarnation GetAttackAICapabilityUCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsAttackAICapabilityUC[id].incarnation;
  }
  public bool AttackAICapabilityUCExists(int id) {
    return rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id);
  }
  public AttackAICapabilityUC GetAttackAICapabilityUC(int id) {
    CheckHasAttackAICapabilityUC(id);
    return new AttackAICapabilityUC(this, id);
  }
  public AttackAICapabilityUC GetAttackAICapabilityUCOrNull(int id) {
    if (AttackAICapabilityUCExists(id)) {
      return new AttackAICapabilityUC(this, id);
    } else {
      return new AttackAICapabilityUC(this, 0);
    }
  }
  public List<AttackAICapabilityUC> AllAttackAICapabilityUC() {
    List<AttackAICapabilityUC> result = new List<AttackAICapabilityUC>(rootIncarnation.incarnationsAttackAICapabilityUC.Count);
    foreach (var id in rootIncarnation.incarnationsAttackAICapabilityUC.Keys) {
      result.Add(new AttackAICapabilityUC(this, id));
    }
    return result;
  }
  public IEnumerator<AttackAICapabilityUC> EnumAllAttackAICapabilityUC() {
    foreach (var id in rootIncarnation.incarnationsAttackAICapabilityUC.Keys) {
      yield return GetAttackAICapabilityUC(id);
    }
  }
  public void CheckHasAttackAICapabilityUC(AttackAICapabilityUC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasAttackAICapabilityUC(thing.id);
  }
  public void CheckHasAttackAICapabilityUC(int id) {
    if (!rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      throw new System.Exception("Invalid AttackAICapabilityUC: " + id);
    }
  }
  public AttackAICapabilityUC EffectAttackAICapabilityUCCreate(
      KillDirective killDirective) {
    return TrustedEffectAttackAICapabilityUCCreateWithId(NewId()
            ,killDirective.id    );
  }
  public AttackAICapabilityUC TrustedEffectAttackAICapabilityUCCreateWithId(int id
,      int killDirective) {
    CheckUnlocked();

    var incarnation =
        new AttackAICapabilityUCIncarnation(
            killDirective
            );
    var effect = InternalEffectCreateAttackAICapabilityUC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new AttackAICapabilityUC(this, id);
  }
  public AttackAICapabilityUCCreateEffect InternalEffectCreateAttackAICapabilityUC(
      int id,
      int incarnationVersion,
      AttackAICapabilityUCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsAttackAICapabilityUC.Add(
        id,
        new VersionAndIncarnation<AttackAICapabilityUCIncarnation>(
            incarnationVersion,
            incarnation));
    return new AttackAICapabilityUCCreateEffect(id, incarnation.Copy());
  }

  public void EffectAttackAICapabilityUCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectAttackAICapabilityUCDelete(id);
    NotifyEffect(effect);
  }
  public AttackAICapabilityUCDeleteEffect InternalEffectAttackAICapabilityUCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsAttackAICapabilityUC[id];

    rootIncarnation.incarnationsAttackAICapabilityUC.Remove(id);
    return new AttackAICapabilityUCDeleteEffect(id);
  }

     
  public int GetAttackAICapabilityUCHash(int id, int version, AttackAICapabilityUCIncarnation incarnation) {
    int result = id * version;
    if (!object.ReferenceEquals(incarnation.killDirective, null)) {
      result += id * version * 1 * incarnation.killDirective.GetDeterministicHashCode();
    }
    return result;
  }
     
  public void EffectAttackAICapabilityUCSetKillDirective(
      int id, KillDirective newValue) {
    CheckUnlocked();
    CheckHasAttackAICapabilityUC(id);
    var effect = InternalEffectAttackAICapabilityUCSetKillDirective(id, newValue);
    NotifyEffect(effect);
  }
  public AttackAICapabilityUCSetKillDirectiveEffect InternalEffectAttackAICapabilityUCSetKillDirective(int id, KillDirective newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsAttackAICapabilityUC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldId = oldIncarnationAndVersion.incarnation.killDirective;
      oldIncarnationAndVersion.incarnation.killDirective = newValue.id;

    } else {
      var newIncarnation =
          new AttackAICapabilityUCIncarnation(
              newValue.id);
      rootIncarnation.incarnationsAttackAICapabilityUC[id] =
          new VersionAndIncarnation<AttackAICapabilityUCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new AttackAICapabilityUCSetKillDirectiveEffect(id, newValue.id);
  }
  public WarperTTCIncarnation GetWarperTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsWarperTTC[id].incarnation;
  }
  public bool WarperTTCExists(int id) {
    return rootIncarnation.incarnationsWarperTTC.ContainsKey(id);
  }
  public WarperTTC GetWarperTTC(int id) {
    CheckHasWarperTTC(id);
    return new WarperTTC(this, id);
  }
  public WarperTTC GetWarperTTCOrNull(int id) {
    if (WarperTTCExists(id)) {
      return new WarperTTC(this, id);
    } else {
      return new WarperTTC(this, 0);
    }
  }
  public List<WarperTTC> AllWarperTTC() {
    List<WarperTTC> result = new List<WarperTTC>(rootIncarnation.incarnationsWarperTTC.Count);
    foreach (var id in rootIncarnation.incarnationsWarperTTC.Keys) {
      result.Add(new WarperTTC(this, id));
    }
    return result;
  }
  public IEnumerator<WarperTTC> EnumAllWarperTTC() {
    foreach (var id in rootIncarnation.incarnationsWarperTTC.Keys) {
      yield return GetWarperTTC(id);
    }
  }
  public void CheckHasWarperTTC(WarperTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasWarperTTC(thing.id);
  }
  public void CheckHasWarperTTC(int id) {
    if (!rootIncarnation.incarnationsWarperTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid WarperTTC: " + id);
    }
  }
  public WarperTTC EffectWarperTTCCreate(
      Location destinationLocation) {
    return TrustedEffectWarperTTCCreateWithId(NewId()
            ,destinationLocation    );
  }
  public WarperTTC TrustedEffectWarperTTCCreateWithId(int id
,      Location destinationLocation) {
    CheckUnlocked();

    var incarnation =
        new WarperTTCIncarnation(
            destinationLocation
            );
    var effect = InternalEffectCreateWarperTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new WarperTTC(this, id);
  }
  public WarperTTCCreateEffect InternalEffectCreateWarperTTC(
      int id,
      int incarnationVersion,
      WarperTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsWarperTTC.Add(
        id,
        new VersionAndIncarnation<WarperTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new WarperTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectWarperTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectWarperTTCDelete(id);
    NotifyEffect(effect);
  }
  public WarperTTCDeleteEffect InternalEffectWarperTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsWarperTTC[id];

    rootIncarnation.incarnationsWarperTTC.Remove(id);
    return new WarperTTCDeleteEffect(id);
  }

     
  public int GetWarperTTCHash(int id, int version, WarperTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.destinationLocation.GetDeterministicHashCode();
    return result;
  }
       public TimeAnchorTTCIncarnation GetTimeAnchorTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTimeAnchorTTC[id].incarnation;
  }
  public bool TimeAnchorTTCExists(int id) {
    return rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(id);
  }
  public TimeAnchorTTC GetTimeAnchorTTC(int id) {
    CheckHasTimeAnchorTTC(id);
    return new TimeAnchorTTC(this, id);
  }
  public TimeAnchorTTC GetTimeAnchorTTCOrNull(int id) {
    if (TimeAnchorTTCExists(id)) {
      return new TimeAnchorTTC(this, id);
    } else {
      return new TimeAnchorTTC(this, 0);
    }
  }
  public List<TimeAnchorTTC> AllTimeAnchorTTC() {
    List<TimeAnchorTTC> result = new List<TimeAnchorTTC>(rootIncarnation.incarnationsTimeAnchorTTC.Count);
    foreach (var id in rootIncarnation.incarnationsTimeAnchorTTC.Keys) {
      result.Add(new TimeAnchorTTC(this, id));
    }
    return result;
  }
  public IEnumerator<TimeAnchorTTC> EnumAllTimeAnchorTTC() {
    foreach (var id in rootIncarnation.incarnationsTimeAnchorTTC.Keys) {
      yield return GetTimeAnchorTTC(id);
    }
  }
  public void CheckHasTimeAnchorTTC(TimeAnchorTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTimeAnchorTTC(thing.id);
  }
  public void CheckHasTimeAnchorTTC(int id) {
    if (!rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid TimeAnchorTTC: " + id);
    }
  }
  public TimeAnchorTTC EffectTimeAnchorTTCCreate(
      int pastVersion) {
    return TrustedEffectTimeAnchorTTCCreateWithId(NewId()
            ,pastVersion    );
  }
  public TimeAnchorTTC TrustedEffectTimeAnchorTTCCreateWithId(int id
,      int pastVersion) {
    CheckUnlocked();

    var incarnation =
        new TimeAnchorTTCIncarnation(
            pastVersion
            );
    var effect = InternalEffectCreateTimeAnchorTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new TimeAnchorTTC(this, id);
  }
  public TimeAnchorTTCCreateEffect InternalEffectCreateTimeAnchorTTC(
      int id,
      int incarnationVersion,
      TimeAnchorTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsTimeAnchorTTC.Add(
        id,
        new VersionAndIncarnation<TimeAnchorTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new TimeAnchorTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectTimeAnchorTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectTimeAnchorTTCDelete(id);
    NotifyEffect(effect);
  }
  public TimeAnchorTTCDeleteEffect InternalEffectTimeAnchorTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTimeAnchorTTC[id];

    rootIncarnation.incarnationsTimeAnchorTTC.Remove(id);
    return new TimeAnchorTTCDeleteEffect(id);
  }

     
  public int GetTimeAnchorTTCHash(int id, int version, TimeAnchorTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.pastVersion.GetDeterministicHashCode();
    return result;
  }
       public TerrainTileIncarnation GetTerrainTileIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTerrainTile[id].incarnation;
  }
  public bool TerrainTileExists(int id) {
    return rootIncarnation.incarnationsTerrainTile.ContainsKey(id);
  }
  public TerrainTile GetTerrainTile(int id) {
    CheckHasTerrainTile(id);
    return new TerrainTile(this, id);
  }
  public TerrainTile GetTerrainTileOrNull(int id) {
    if (TerrainTileExists(id)) {
      return new TerrainTile(this, id);
    } else {
      return new TerrainTile(this, 0);
    }
  }
  public List<TerrainTile> AllTerrainTile() {
    List<TerrainTile> result = new List<TerrainTile>(rootIncarnation.incarnationsTerrainTile.Count);
    foreach (var id in rootIncarnation.incarnationsTerrainTile.Keys) {
      result.Add(new TerrainTile(this, id));
    }
    return result;
  }
  public IEnumerator<TerrainTile> EnumAllTerrainTile() {
    foreach (var id in rootIncarnation.incarnationsTerrainTile.Keys) {
      yield return GetTerrainTile(id);
    }
  }
  public void CheckHasTerrainTile(TerrainTile thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTerrainTile(thing.id);
  }
  public void CheckHasTerrainTile(int id) {
    if (!rootIncarnation.incarnationsTerrainTile.ContainsKey(id)) {
      throw new System.Exception("Invalid TerrainTile: " + id);
    }
  }
  public TerrainTile EffectTerrainTileCreate(
      ITerrainTileEvent evvent,
      int elevation,
      ITerrainTileComponentMutBunch components) {
    CheckHasITerrainTileComponentMutBunch(components);
    return TrustedEffectTerrainTileCreateWithId(NewId()
            ,evvent
            ,elevation
            ,components.id    );
  }
  public TerrainTile TrustedEffectTerrainTileCreateWithId(int id
,      ITerrainTileEvent evvent
,      int elevation
,      int components) {
    CheckUnlocked();

    var incarnation =
        new TerrainTileIncarnation(
            evvent,
            elevation,
            components
            );
    var effect = InternalEffectCreateTerrainTile(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new TerrainTile(this, id);
  }
  public TerrainTileCreateEffect InternalEffectCreateTerrainTile(
      int id,
      int incarnationVersion,
      TerrainTileIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsTerrainTile.Add(
        id,
        new VersionAndIncarnation<TerrainTileIncarnation>(
            incarnationVersion,
            incarnation));
    return new TerrainTileCreateEffect(id, incarnation.Copy());
  }

  public void EffectTerrainTileDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectTerrainTileDelete(id);
    NotifyEffect(effect);
  }
  public TerrainTileDeleteEffect InternalEffectTerrainTileDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTerrainTile[id];

    rootIncarnation.incarnationsTerrainTile.Remove(id);
    return new TerrainTileDeleteEffect(id);
  }

     
  public int GetTerrainTileHash(int id, int version, TerrainTileIncarnation incarnation) {
    int result = id * version;
    if (!object.ReferenceEquals(incarnation.evvent, null)) {
      result += id * version * 1 * incarnation.evvent.GetDeterministicHashCode();
    }
    result += id * version * 2 * incarnation.elevation.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.components.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectTerrainTileSetEvvent(
      int id, ITerrainTileEvent newValue) {
    CheckUnlocked();
    CheckHasTerrainTile(id);
    var effect = InternalEffectTerrainTileSetEvvent(id, newValue);
    NotifyEffect(effect);
  }
  public TerrainTileSetEvventEffect InternalEffectTerrainTileSetEvvent(int id, ITerrainTileEvent newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsTerrainTile[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.evvent;
      oldIncarnationAndVersion.incarnation.evvent = newValue;

    } else {
      var newIncarnation =
          new TerrainTileIncarnation(
              newValue,
              oldIncarnationAndVersion.incarnation.elevation,
              oldIncarnationAndVersion.incarnation.components);
      rootIncarnation.incarnationsTerrainTile[id] =
          new VersionAndIncarnation<TerrainTileIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new TerrainTileSetEvventEffect(id, newValue);
  }

  public void EffectTerrainTileSetElevation(
      int id, int newValue) {
    CheckUnlocked();
    CheckHasTerrainTile(id);
    var effect = InternalEffectTerrainTileSetElevation(id, newValue);
    NotifyEffect(effect);
  }
  public TerrainTileSetElevationEffect InternalEffectTerrainTileSetElevation(int id, int newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsTerrainTile[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.elevation;
      oldIncarnationAndVersion.incarnation.elevation = newValue;

    } else {
      var newIncarnation =
          new TerrainTileIncarnation(
              oldIncarnationAndVersion.incarnation.evvent,
              newValue,
              oldIncarnationAndVersion.incarnation.components);
      rootIncarnation.incarnationsTerrainTile[id] =
          new VersionAndIncarnation<TerrainTileIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new TerrainTileSetElevationEffect(id, newValue);
  }
  public ITerrainTileComponentMutBunchIncarnation GetITerrainTileComponentMutBunchIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsITerrainTileComponentMutBunch[id].incarnation;
  }
  public bool ITerrainTileComponentMutBunchExists(int id) {
    return rootIncarnation.incarnationsITerrainTileComponentMutBunch.ContainsKey(id);
  }
  public ITerrainTileComponentMutBunch GetITerrainTileComponentMutBunch(int id) {
    CheckHasITerrainTileComponentMutBunch(id);
    return new ITerrainTileComponentMutBunch(this, id);
  }
  public ITerrainTileComponentMutBunch GetITerrainTileComponentMutBunchOrNull(int id) {
    if (ITerrainTileComponentMutBunchExists(id)) {
      return new ITerrainTileComponentMutBunch(this, id);
    } else {
      return new ITerrainTileComponentMutBunch(this, 0);
    }
  }
  public List<ITerrainTileComponentMutBunch> AllITerrainTileComponentMutBunch() {
    List<ITerrainTileComponentMutBunch> result = new List<ITerrainTileComponentMutBunch>(rootIncarnation.incarnationsITerrainTileComponentMutBunch.Count);
    foreach (var id in rootIncarnation.incarnationsITerrainTileComponentMutBunch.Keys) {
      result.Add(new ITerrainTileComponentMutBunch(this, id));
    }
    return result;
  }
  public IEnumerator<ITerrainTileComponentMutBunch> EnumAllITerrainTileComponentMutBunch() {
    foreach (var id in rootIncarnation.incarnationsITerrainTileComponentMutBunch.Keys) {
      yield return GetITerrainTileComponentMutBunch(id);
    }
  }
  public void CheckHasITerrainTileComponentMutBunch(ITerrainTileComponentMutBunch thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasITerrainTileComponentMutBunch(thing.id);
  }
  public void CheckHasITerrainTileComponentMutBunch(int id) {
    if (!rootIncarnation.incarnationsITerrainTileComponentMutBunch.ContainsKey(id)) {
      throw new System.Exception("Invalid ITerrainTileComponentMutBunch: " + id);
    }
  }
  public ITerrainTileComponentMutBunch EffectITerrainTileComponentMutBunchCreate(
      SimplePresenceTriggerTTCMutSet membersSimplePresenceTriggerTTCMutSet,
      ItemTTCMutSet membersItemTTCMutSet,
      FlowerTTCMutSet membersFlowerTTCMutSet,
      LotusTTCMutSet membersLotusTTCMutSet,
      RoseTTCMutSet membersRoseTTCMutSet,
      LeafTTCMutSet membersLeafTTCMutSet,
      KamikazeTargetTTCMutSet membersKamikazeTargetTTCMutSet,
      WarperTTCMutSet membersWarperTTCMutSet,
      TimeAnchorTTCMutSet membersTimeAnchorTTCMutSet,
      FireBombTTCMutSet membersFireBombTTCMutSet,
      OnFireTTCMutSet membersOnFireTTCMutSet,
      MarkerTTCMutSet membersMarkerTTCMutSet,
      LevelLinkTTCMutSet membersLevelLinkTTCMutSet,
      MudTTCMutSet membersMudTTCMutSet,
      DirtTTCMutSet membersDirtTTCMutSet,
      ObsidianTTCMutSet membersObsidianTTCMutSet,
      DownStairsTTCMutSet membersDownStairsTTCMutSet,
      UpStairsTTCMutSet membersUpStairsTTCMutSet,
      WallTTCMutSet membersWallTTCMutSet,
      BloodTTCMutSet membersBloodTTCMutSet,
      RocksTTCMutSet membersRocksTTCMutSet,
      TreeTTCMutSet membersTreeTTCMutSet,
      WaterTTCMutSet membersWaterTTCMutSet,
      FloorTTCMutSet membersFloorTTCMutSet,
      CaveWallTTCMutSet membersCaveWallTTCMutSet,
      CaveTTCMutSet membersCaveTTCMutSet,
      FallsTTCMutSet membersFallsTTCMutSet,
      ObsidianFloorTTCMutSet membersObsidianFloorTTCMutSet,
      MagmaTTCMutSet membersMagmaTTCMutSet,
      CliffTTCMutSet membersCliffTTCMutSet,
      RavaNestTTCMutSet membersRavaNestTTCMutSet,
      CliffLandingTTCMutSet membersCliffLandingTTCMutSet,
      StoneTTCMutSet membersStoneTTCMutSet,
      GrassTTCMutSet membersGrassTTCMutSet,
      EmberDeepLevelLinkerTTCMutSet membersEmberDeepLevelLinkerTTCMutSet,
      IncendianFallsLevelLinkerTTCMutSet membersIncendianFallsLevelLinkerTTCMutSet,
      RavaArcanaLevelLinkerTTCMutSet membersRavaArcanaLevelLinkerTTCMutSet) {
    CheckHasSimplePresenceTriggerTTCMutSet(membersSimplePresenceTriggerTTCMutSet);
    CheckHasItemTTCMutSet(membersItemTTCMutSet);
    CheckHasFlowerTTCMutSet(membersFlowerTTCMutSet);
    CheckHasLotusTTCMutSet(membersLotusTTCMutSet);
    CheckHasRoseTTCMutSet(membersRoseTTCMutSet);
    CheckHasLeafTTCMutSet(membersLeafTTCMutSet);
    CheckHasKamikazeTargetTTCMutSet(membersKamikazeTargetTTCMutSet);
    CheckHasWarperTTCMutSet(membersWarperTTCMutSet);
    CheckHasTimeAnchorTTCMutSet(membersTimeAnchorTTCMutSet);
    CheckHasFireBombTTCMutSet(membersFireBombTTCMutSet);
    CheckHasOnFireTTCMutSet(membersOnFireTTCMutSet);
    CheckHasMarkerTTCMutSet(membersMarkerTTCMutSet);
    CheckHasLevelLinkTTCMutSet(membersLevelLinkTTCMutSet);
    CheckHasMudTTCMutSet(membersMudTTCMutSet);
    CheckHasDirtTTCMutSet(membersDirtTTCMutSet);
    CheckHasObsidianTTCMutSet(membersObsidianTTCMutSet);
    CheckHasDownStairsTTCMutSet(membersDownStairsTTCMutSet);
    CheckHasUpStairsTTCMutSet(membersUpStairsTTCMutSet);
    CheckHasWallTTCMutSet(membersWallTTCMutSet);
    CheckHasBloodTTCMutSet(membersBloodTTCMutSet);
    CheckHasRocksTTCMutSet(membersRocksTTCMutSet);
    CheckHasTreeTTCMutSet(membersTreeTTCMutSet);
    CheckHasWaterTTCMutSet(membersWaterTTCMutSet);
    CheckHasFloorTTCMutSet(membersFloorTTCMutSet);
    CheckHasCaveWallTTCMutSet(membersCaveWallTTCMutSet);
    CheckHasCaveTTCMutSet(membersCaveTTCMutSet);
    CheckHasFallsTTCMutSet(membersFallsTTCMutSet);
    CheckHasObsidianFloorTTCMutSet(membersObsidianFloorTTCMutSet);
    CheckHasMagmaTTCMutSet(membersMagmaTTCMutSet);
    CheckHasCliffTTCMutSet(membersCliffTTCMutSet);
    CheckHasRavaNestTTCMutSet(membersRavaNestTTCMutSet);
    CheckHasCliffLandingTTCMutSet(membersCliffLandingTTCMutSet);
    CheckHasStoneTTCMutSet(membersStoneTTCMutSet);
    CheckHasGrassTTCMutSet(membersGrassTTCMutSet);
    CheckHasEmberDeepLevelLinkerTTCMutSet(membersEmberDeepLevelLinkerTTCMutSet);
    CheckHasIncendianFallsLevelLinkerTTCMutSet(membersIncendianFallsLevelLinkerTTCMutSet);
    CheckHasRavaArcanaLevelLinkerTTCMutSet(membersRavaArcanaLevelLinkerTTCMutSet);
    return TrustedEffectITerrainTileComponentMutBunchCreateWithId(NewId()
            ,membersSimplePresenceTriggerTTCMutSet.id
            ,membersItemTTCMutSet.id
            ,membersFlowerTTCMutSet.id
            ,membersLotusTTCMutSet.id
            ,membersRoseTTCMutSet.id
            ,membersLeafTTCMutSet.id
            ,membersKamikazeTargetTTCMutSet.id
            ,membersWarperTTCMutSet.id
            ,membersTimeAnchorTTCMutSet.id
            ,membersFireBombTTCMutSet.id
            ,membersOnFireTTCMutSet.id
            ,membersMarkerTTCMutSet.id
            ,membersLevelLinkTTCMutSet.id
            ,membersMudTTCMutSet.id
            ,membersDirtTTCMutSet.id
            ,membersObsidianTTCMutSet.id
            ,membersDownStairsTTCMutSet.id
            ,membersUpStairsTTCMutSet.id
            ,membersWallTTCMutSet.id
            ,membersBloodTTCMutSet.id
            ,membersRocksTTCMutSet.id
            ,membersTreeTTCMutSet.id
            ,membersWaterTTCMutSet.id
            ,membersFloorTTCMutSet.id
            ,membersCaveWallTTCMutSet.id
            ,membersCaveTTCMutSet.id
            ,membersFallsTTCMutSet.id
            ,membersObsidianFloorTTCMutSet.id
            ,membersMagmaTTCMutSet.id
            ,membersCliffTTCMutSet.id
            ,membersRavaNestTTCMutSet.id
            ,membersCliffLandingTTCMutSet.id
            ,membersStoneTTCMutSet.id
            ,membersGrassTTCMutSet.id
            ,membersEmberDeepLevelLinkerTTCMutSet.id
            ,membersIncendianFallsLevelLinkerTTCMutSet.id
            ,membersRavaArcanaLevelLinkerTTCMutSet.id    );
  }
  public ITerrainTileComponentMutBunch TrustedEffectITerrainTileComponentMutBunchCreateWithId(int id
,      int membersSimplePresenceTriggerTTCMutSet
,      int membersItemTTCMutSet
,      int membersFlowerTTCMutSet
,      int membersLotusTTCMutSet
,      int membersRoseTTCMutSet
,      int membersLeafTTCMutSet
,      int membersKamikazeTargetTTCMutSet
,      int membersWarperTTCMutSet
,      int membersTimeAnchorTTCMutSet
,      int membersFireBombTTCMutSet
,      int membersOnFireTTCMutSet
,      int membersMarkerTTCMutSet
,      int membersLevelLinkTTCMutSet
,      int membersMudTTCMutSet
,      int membersDirtTTCMutSet
,      int membersObsidianTTCMutSet
,      int membersDownStairsTTCMutSet
,      int membersUpStairsTTCMutSet
,      int membersWallTTCMutSet
,      int membersBloodTTCMutSet
,      int membersRocksTTCMutSet
,      int membersTreeTTCMutSet
,      int membersWaterTTCMutSet
,      int membersFloorTTCMutSet
,      int membersCaveWallTTCMutSet
,      int membersCaveTTCMutSet
,      int membersFallsTTCMutSet
,      int membersObsidianFloorTTCMutSet
,      int membersMagmaTTCMutSet
,      int membersCliffTTCMutSet
,      int membersRavaNestTTCMutSet
,      int membersCliffLandingTTCMutSet
,      int membersStoneTTCMutSet
,      int membersGrassTTCMutSet
,      int membersEmberDeepLevelLinkerTTCMutSet
,      int membersIncendianFallsLevelLinkerTTCMutSet
,      int membersRavaArcanaLevelLinkerTTCMutSet) {
    CheckUnlocked();

    var incarnation =
        new ITerrainTileComponentMutBunchIncarnation(
            membersSimplePresenceTriggerTTCMutSet,
            membersItemTTCMutSet,
            membersFlowerTTCMutSet,
            membersLotusTTCMutSet,
            membersRoseTTCMutSet,
            membersLeafTTCMutSet,
            membersKamikazeTargetTTCMutSet,
            membersWarperTTCMutSet,
            membersTimeAnchorTTCMutSet,
            membersFireBombTTCMutSet,
            membersOnFireTTCMutSet,
            membersMarkerTTCMutSet,
            membersLevelLinkTTCMutSet,
            membersMudTTCMutSet,
            membersDirtTTCMutSet,
            membersObsidianTTCMutSet,
            membersDownStairsTTCMutSet,
            membersUpStairsTTCMutSet,
            membersWallTTCMutSet,
            membersBloodTTCMutSet,
            membersRocksTTCMutSet,
            membersTreeTTCMutSet,
            membersWaterTTCMutSet,
            membersFloorTTCMutSet,
            membersCaveWallTTCMutSet,
            membersCaveTTCMutSet,
            membersFallsTTCMutSet,
            membersObsidianFloorTTCMutSet,
            membersMagmaTTCMutSet,
            membersCliffTTCMutSet,
            membersRavaNestTTCMutSet,
            membersCliffLandingTTCMutSet,
            membersStoneTTCMutSet,
            membersGrassTTCMutSet,
            membersEmberDeepLevelLinkerTTCMutSet,
            membersIncendianFallsLevelLinkerTTCMutSet,
            membersRavaArcanaLevelLinkerTTCMutSet
            );
    var effect = InternalEffectCreateITerrainTileComponentMutBunch(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new ITerrainTileComponentMutBunch(this, id);
  }
  public ITerrainTileComponentMutBunchCreateEffect InternalEffectCreateITerrainTileComponentMutBunch(
      int id,
      int incarnationVersion,
      ITerrainTileComponentMutBunchIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsITerrainTileComponentMutBunch.Add(
        id,
        new VersionAndIncarnation<ITerrainTileComponentMutBunchIncarnation>(
            incarnationVersion,
            incarnation));
    return new ITerrainTileComponentMutBunchCreateEffect(id, incarnation.Copy());
  }

  public void EffectITerrainTileComponentMutBunchDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectITerrainTileComponentMutBunchDelete(id);
    NotifyEffect(effect);
  }
  public ITerrainTileComponentMutBunchDeleteEffect InternalEffectITerrainTileComponentMutBunchDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsITerrainTileComponentMutBunch[id];

    rootIncarnation.incarnationsITerrainTileComponentMutBunch.Remove(id);
    return new ITerrainTileComponentMutBunchDeleteEffect(id);
  }

     
  public int GetITerrainTileComponentMutBunchHash(int id, int version, ITerrainTileComponentMutBunchIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.membersSimplePresenceTriggerTTCMutSet.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.membersItemTTCMutSet.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.membersFlowerTTCMutSet.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.membersLotusTTCMutSet.GetDeterministicHashCode();
    result += id * version * 5 * incarnation.membersRoseTTCMutSet.GetDeterministicHashCode();
    result += id * version * 6 * incarnation.membersLeafTTCMutSet.GetDeterministicHashCode();
    result += id * version * 7 * incarnation.membersKamikazeTargetTTCMutSet.GetDeterministicHashCode();
    result += id * version * 8 * incarnation.membersWarperTTCMutSet.GetDeterministicHashCode();
    result += id * version * 9 * incarnation.membersTimeAnchorTTCMutSet.GetDeterministicHashCode();
    result += id * version * 10 * incarnation.membersFireBombTTCMutSet.GetDeterministicHashCode();
    result += id * version * 11 * incarnation.membersOnFireTTCMutSet.GetDeterministicHashCode();
    result += id * version * 12 * incarnation.membersMarkerTTCMutSet.GetDeterministicHashCode();
    result += id * version * 13 * incarnation.membersLevelLinkTTCMutSet.GetDeterministicHashCode();
    result += id * version * 14 * incarnation.membersMudTTCMutSet.GetDeterministicHashCode();
    result += id * version * 15 * incarnation.membersDirtTTCMutSet.GetDeterministicHashCode();
    result += id * version * 16 * incarnation.membersObsidianTTCMutSet.GetDeterministicHashCode();
    result += id * version * 17 * incarnation.membersDownStairsTTCMutSet.GetDeterministicHashCode();
    result += id * version * 18 * incarnation.membersUpStairsTTCMutSet.GetDeterministicHashCode();
    result += id * version * 19 * incarnation.membersWallTTCMutSet.GetDeterministicHashCode();
    result += id * version * 20 * incarnation.membersBloodTTCMutSet.GetDeterministicHashCode();
    result += id * version * 21 * incarnation.membersRocksTTCMutSet.GetDeterministicHashCode();
    result += id * version * 22 * incarnation.membersTreeTTCMutSet.GetDeterministicHashCode();
    result += id * version * 23 * incarnation.membersWaterTTCMutSet.GetDeterministicHashCode();
    result += id * version * 24 * incarnation.membersFloorTTCMutSet.GetDeterministicHashCode();
    result += id * version * 25 * incarnation.membersCaveWallTTCMutSet.GetDeterministicHashCode();
    result += id * version * 26 * incarnation.membersCaveTTCMutSet.GetDeterministicHashCode();
    result += id * version * 27 * incarnation.membersFallsTTCMutSet.GetDeterministicHashCode();
    result += id * version * 28 * incarnation.membersObsidianFloorTTCMutSet.GetDeterministicHashCode();
    result += id * version * 29 * incarnation.membersMagmaTTCMutSet.GetDeterministicHashCode();
    result += id * version * 30 * incarnation.membersCliffTTCMutSet.GetDeterministicHashCode();
    result += id * version * 31 * incarnation.membersRavaNestTTCMutSet.GetDeterministicHashCode();
    result += id * version * 32 * incarnation.membersCliffLandingTTCMutSet.GetDeterministicHashCode();
    result += id * version * 33 * incarnation.membersStoneTTCMutSet.GetDeterministicHashCode();
    result += id * version * 34 * incarnation.membersGrassTTCMutSet.GetDeterministicHashCode();
    result += id * version * 35 * incarnation.membersEmberDeepLevelLinkerTTCMutSet.GetDeterministicHashCode();
    result += id * version * 36 * incarnation.membersIncendianFallsLevelLinkerTTCMutSet.GetDeterministicHashCode();
    result += id * version * 37 * incarnation.membersRavaArcanaLevelLinkerTTCMutSet.GetDeterministicHashCode();
    return result;
  }
       public TerrainIncarnation GetTerrainIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTerrain[id].incarnation;
  }
  public bool TerrainExists(int id) {
    return rootIncarnation.incarnationsTerrain.ContainsKey(id);
  }
  public Terrain GetTerrain(int id) {
    CheckHasTerrain(id);
    return new Terrain(this, id);
  }
  public Terrain GetTerrainOrNull(int id) {
    if (TerrainExists(id)) {
      return new Terrain(this, id);
    } else {
      return new Terrain(this, 0);
    }
  }
  public List<Terrain> AllTerrain() {
    List<Terrain> result = new List<Terrain>(rootIncarnation.incarnationsTerrain.Count);
    foreach (var id in rootIncarnation.incarnationsTerrain.Keys) {
      result.Add(new Terrain(this, id));
    }
    return result;
  }
  public IEnumerator<Terrain> EnumAllTerrain() {
    foreach (var id in rootIncarnation.incarnationsTerrain.Keys) {
      yield return GetTerrain(id);
    }
  }
  public void CheckHasTerrain(Terrain thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTerrain(thing.id);
  }
  public void CheckHasTerrain(int id) {
    if (!rootIncarnation.incarnationsTerrain.ContainsKey(id)) {
      throw new System.Exception("Invalid Terrain: " + id);
    }
  }
  public Terrain EffectTerrainCreate(
      Pattern pattern,
      bool considerCornersAdjacent,
      float elevationStepHeight,
      TerrainTileByLocationMutMap tiles) {
    CheckHasTerrainTileByLocationMutMap(tiles);
    return TrustedEffectTerrainCreateWithId(NewId()
            ,pattern
            ,considerCornersAdjacent
            ,elevationStepHeight
            ,tiles.id    );
  }
  public Terrain TrustedEffectTerrainCreateWithId(int id
,      Pattern pattern
,      bool considerCornersAdjacent
,      float elevationStepHeight
,      int tiles) {
    CheckUnlocked();

    var incarnation =
        new TerrainIncarnation(
            pattern,
            considerCornersAdjacent,
            elevationStepHeight,
            tiles
            );
    var effect = InternalEffectCreateTerrain(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new Terrain(this, id);
  }
  public TerrainCreateEffect InternalEffectCreateTerrain(
      int id,
      int incarnationVersion,
      TerrainIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsTerrain.Add(
        id,
        new VersionAndIncarnation<TerrainIncarnation>(
            incarnationVersion,
            incarnation));
    return new TerrainCreateEffect(id, incarnation.Copy());
  }

  public void EffectTerrainDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectTerrainDelete(id);
    NotifyEffect(effect);
  }
  public TerrainDeleteEffect InternalEffectTerrainDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTerrain[id];

    rootIncarnation.incarnationsTerrain.Remove(id);
    return new TerrainDeleteEffect(id);
  }

     
  public int GetTerrainHash(int id, int version, TerrainIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.pattern.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.considerCornersAdjacent.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.elevationStepHeight.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.tiles.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectTerrainSetPattern(
      int id, Pattern newValue) {
    CheckUnlocked();
    CheckHasTerrain(id);
    var effect = InternalEffectTerrainSetPattern(id, newValue);
    NotifyEffect(effect);
  }
  public TerrainSetPatternEffect InternalEffectTerrainSetPattern(int id, Pattern newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsTerrain[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.pattern;
      oldIncarnationAndVersion.incarnation.pattern = newValue;

    } else {
      var newIncarnation =
          new TerrainIncarnation(
              newValue,
              oldIncarnationAndVersion.incarnation.considerCornersAdjacent,
              oldIncarnationAndVersion.incarnation.elevationStepHeight,
              oldIncarnationAndVersion.incarnation.tiles);
      rootIncarnation.incarnationsTerrain[id] =
          new VersionAndIncarnation<TerrainIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new TerrainSetPatternEffect(id, newValue);
  }
  public SimplePresenceTriggerTTCIncarnation GetSimplePresenceTriggerTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsSimplePresenceTriggerTTC[id].incarnation;
  }
  public bool SimplePresenceTriggerTTCExists(int id) {
    return rootIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(id);
  }
  public SimplePresenceTriggerTTC GetSimplePresenceTriggerTTC(int id) {
    CheckHasSimplePresenceTriggerTTC(id);
    return new SimplePresenceTriggerTTC(this, id);
  }
  public SimplePresenceTriggerTTC GetSimplePresenceTriggerTTCOrNull(int id) {
    if (SimplePresenceTriggerTTCExists(id)) {
      return new SimplePresenceTriggerTTC(this, id);
    } else {
      return new SimplePresenceTriggerTTC(this, 0);
    }
  }
  public List<SimplePresenceTriggerTTC> AllSimplePresenceTriggerTTC() {
    List<SimplePresenceTriggerTTC> result = new List<SimplePresenceTriggerTTC>(rootIncarnation.incarnationsSimplePresenceTriggerTTC.Count);
    foreach (var id in rootIncarnation.incarnationsSimplePresenceTriggerTTC.Keys) {
      result.Add(new SimplePresenceTriggerTTC(this, id));
    }
    return result;
  }
  public IEnumerator<SimplePresenceTriggerTTC> EnumAllSimplePresenceTriggerTTC() {
    foreach (var id in rootIncarnation.incarnationsSimplePresenceTriggerTTC.Keys) {
      yield return GetSimplePresenceTriggerTTC(id);
    }
  }
  public void CheckHasSimplePresenceTriggerTTC(SimplePresenceTriggerTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasSimplePresenceTriggerTTC(thing.id);
  }
  public void CheckHasSimplePresenceTriggerTTC(int id) {
    if (!rootIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid SimplePresenceTriggerTTC: " + id);
    }
  }
  public SimplePresenceTriggerTTC EffectSimplePresenceTriggerTTCCreate(
      string name) {
    return TrustedEffectSimplePresenceTriggerTTCCreateWithId(NewId()
            ,name    );
  }
  public SimplePresenceTriggerTTC TrustedEffectSimplePresenceTriggerTTCCreateWithId(int id
,      string name) {
    CheckUnlocked();

    var incarnation =
        new SimplePresenceTriggerTTCIncarnation(
            name
            );
    var effect = InternalEffectCreateSimplePresenceTriggerTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new SimplePresenceTriggerTTC(this, id);
  }
  public SimplePresenceTriggerTTCCreateEffect InternalEffectCreateSimplePresenceTriggerTTC(
      int id,
      int incarnationVersion,
      SimplePresenceTriggerTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsSimplePresenceTriggerTTC.Add(
        id,
        new VersionAndIncarnation<SimplePresenceTriggerTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new SimplePresenceTriggerTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectSimplePresenceTriggerTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectSimplePresenceTriggerTTCDelete(id);
    NotifyEffect(effect);
  }
  public SimplePresenceTriggerTTCDeleteEffect InternalEffectSimplePresenceTriggerTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsSimplePresenceTriggerTTC[id];

    rootIncarnation.incarnationsSimplePresenceTriggerTTC.Remove(id);
    return new SimplePresenceTriggerTTCDeleteEffect(id);
  }

     
  public int GetSimplePresenceTriggerTTCHash(int id, int version, SimplePresenceTriggerTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.name.GetDeterministicHashCode();
    return result;
  }
       public FireBombImpulseIncarnation GetFireBombImpulseIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsFireBombImpulse[id].incarnation;
  }
  public bool FireBombImpulseExists(int id) {
    return rootIncarnation.incarnationsFireBombImpulse.ContainsKey(id);
  }
  public FireBombImpulse GetFireBombImpulse(int id) {
    CheckHasFireBombImpulse(id);
    return new FireBombImpulse(this, id);
  }
  public FireBombImpulse GetFireBombImpulseOrNull(int id) {
    if (FireBombImpulseExists(id)) {
      return new FireBombImpulse(this, id);
    } else {
      return new FireBombImpulse(this, 0);
    }
  }
  public List<FireBombImpulse> AllFireBombImpulse() {
    List<FireBombImpulse> result = new List<FireBombImpulse>(rootIncarnation.incarnationsFireBombImpulse.Count);
    foreach (var id in rootIncarnation.incarnationsFireBombImpulse.Keys) {
      result.Add(new FireBombImpulse(this, id));
    }
    return result;
  }
  public IEnumerator<FireBombImpulse> EnumAllFireBombImpulse() {
    foreach (var id in rootIncarnation.incarnationsFireBombImpulse.Keys) {
      yield return GetFireBombImpulse(id);
    }
  }
  public void CheckHasFireBombImpulse(FireBombImpulse thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasFireBombImpulse(thing.id);
  }
  public void CheckHasFireBombImpulse(int id) {
    if (!rootIncarnation.incarnationsFireBombImpulse.ContainsKey(id)) {
      throw new System.Exception("Invalid FireBombImpulse: " + id);
    }
  }
  public FireBombImpulse EffectFireBombImpulseCreate(
      int weight,
      Location location) {
    return TrustedEffectFireBombImpulseCreateWithId(NewId()
            ,weight
            ,location    );
  }
  public FireBombImpulse TrustedEffectFireBombImpulseCreateWithId(int id
,      int weight
,      Location location) {
    CheckUnlocked();

    var incarnation =
        new FireBombImpulseIncarnation(
            weight,
            location
            );
    var effect = InternalEffectCreateFireBombImpulse(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new FireBombImpulse(this, id);
  }
  public FireBombImpulseCreateEffect InternalEffectCreateFireBombImpulse(
      int id,
      int incarnationVersion,
      FireBombImpulseIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsFireBombImpulse.Add(
        id,
        new VersionAndIncarnation<FireBombImpulseIncarnation>(
            incarnationVersion,
            incarnation));
    return new FireBombImpulseCreateEffect(id, incarnation.Copy());
  }

  public void EffectFireBombImpulseDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectFireBombImpulseDelete(id);
    NotifyEffect(effect);
  }
  public FireBombImpulseDeleteEffect InternalEffectFireBombImpulseDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsFireBombImpulse[id];

    rootIncarnation.incarnationsFireBombImpulse.Remove(id);
    return new FireBombImpulseDeleteEffect(id);
  }

     
  public int GetFireBombImpulseHash(int id, int version, FireBombImpulseIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.weight.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.location.GetDeterministicHashCode();
    return result;
  }
       public FireBombTTCIncarnation GetFireBombTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsFireBombTTC[id].incarnation;
  }
  public bool FireBombTTCExists(int id) {
    return rootIncarnation.incarnationsFireBombTTC.ContainsKey(id);
  }
  public FireBombTTC GetFireBombTTC(int id) {
    CheckHasFireBombTTC(id);
    return new FireBombTTC(this, id);
  }
  public FireBombTTC GetFireBombTTCOrNull(int id) {
    if (FireBombTTCExists(id)) {
      return new FireBombTTC(this, id);
    } else {
      return new FireBombTTC(this, 0);
    }
  }
  public List<FireBombTTC> AllFireBombTTC() {
    List<FireBombTTC> result = new List<FireBombTTC>(rootIncarnation.incarnationsFireBombTTC.Count);
    foreach (var id in rootIncarnation.incarnationsFireBombTTC.Keys) {
      result.Add(new FireBombTTC(this, id));
    }
    return result;
  }
  public IEnumerator<FireBombTTC> EnumAllFireBombTTC() {
    foreach (var id in rootIncarnation.incarnationsFireBombTTC.Keys) {
      yield return GetFireBombTTC(id);
    }
  }
  public void CheckHasFireBombTTC(FireBombTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasFireBombTTC(thing.id);
  }
  public void CheckHasFireBombTTC(int id) {
    if (!rootIncarnation.incarnationsFireBombTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid FireBombTTC: " + id);
    }
  }
  public FireBombTTC EffectFireBombTTCCreate(
      int turnsUntilExplosion) {
    return TrustedEffectFireBombTTCCreateWithId(NewId()
            ,turnsUntilExplosion    );
  }
  public FireBombTTC TrustedEffectFireBombTTCCreateWithId(int id
,      int turnsUntilExplosion) {
    CheckUnlocked();

    var incarnation =
        new FireBombTTCIncarnation(
            turnsUntilExplosion
            );
    var effect = InternalEffectCreateFireBombTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new FireBombTTC(this, id);
  }
  public FireBombTTCCreateEffect InternalEffectCreateFireBombTTC(
      int id,
      int incarnationVersion,
      FireBombTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsFireBombTTC.Add(
        id,
        new VersionAndIncarnation<FireBombTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new FireBombTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectFireBombTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectFireBombTTCDelete(id);
    NotifyEffect(effect);
  }
  public FireBombTTCDeleteEffect InternalEffectFireBombTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsFireBombTTC[id];

    rootIncarnation.incarnationsFireBombTTC.Remove(id);
    return new FireBombTTCDeleteEffect(id);
  }

     
  public int GetFireBombTTCHash(int id, int version, FireBombTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.turnsUntilExplosion.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectFireBombTTCSetTurnsUntilExplosion(
      int id, int newValue) {
    CheckUnlocked();
    CheckHasFireBombTTC(id);
    var effect = InternalEffectFireBombTTCSetTurnsUntilExplosion(id, newValue);
    NotifyEffect(effect);
  }
  public FireBombTTCSetTurnsUntilExplosionEffect InternalEffectFireBombTTCSetTurnsUntilExplosion(int id, int newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsFireBombTTC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.turnsUntilExplosion;
      oldIncarnationAndVersion.incarnation.turnsUntilExplosion = newValue;

    } else {
      var newIncarnation =
          new FireBombTTCIncarnation(
              newValue);
      rootIncarnation.incarnationsFireBombTTC[id] =
          new VersionAndIncarnation<FireBombTTCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new FireBombTTCSetTurnsUntilExplosionEffect(id, newValue);
  }
  public FlowerTTCIncarnation GetFlowerTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsFlowerTTC[id].incarnation;
  }
  public bool FlowerTTCExists(int id) {
    return rootIncarnation.incarnationsFlowerTTC.ContainsKey(id);
  }
  public FlowerTTC GetFlowerTTC(int id) {
    CheckHasFlowerTTC(id);
    return new FlowerTTC(this, id);
  }
  public FlowerTTC GetFlowerTTCOrNull(int id) {
    if (FlowerTTCExists(id)) {
      return new FlowerTTC(this, id);
    } else {
      return new FlowerTTC(this, 0);
    }
  }
  public List<FlowerTTC> AllFlowerTTC() {
    List<FlowerTTC> result = new List<FlowerTTC>(rootIncarnation.incarnationsFlowerTTC.Count);
    foreach (var id in rootIncarnation.incarnationsFlowerTTC.Keys) {
      result.Add(new FlowerTTC(this, id));
    }
    return result;
  }
  public IEnumerator<FlowerTTC> EnumAllFlowerTTC() {
    foreach (var id in rootIncarnation.incarnationsFlowerTTC.Keys) {
      yield return GetFlowerTTC(id);
    }
  }
  public void CheckHasFlowerTTC(FlowerTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasFlowerTTC(thing.id);
  }
  public void CheckHasFlowerTTC(int id) {
    if (!rootIncarnation.incarnationsFlowerTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid FlowerTTC: " + id);
    }
  }
  public FlowerTTC EffectFlowerTTCCreate(
) {
    return TrustedEffectFlowerTTCCreateWithId(NewId()
    );
  }
  public FlowerTTC TrustedEffectFlowerTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new FlowerTTCIncarnation(

            );
    var effect = InternalEffectCreateFlowerTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new FlowerTTC(this, id);
  }
  public FlowerTTCCreateEffect InternalEffectCreateFlowerTTC(
      int id,
      int incarnationVersion,
      FlowerTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsFlowerTTC.Add(
        id,
        new VersionAndIncarnation<FlowerTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new FlowerTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectFlowerTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectFlowerTTCDelete(id);
    NotifyEffect(effect);
  }
  public FlowerTTCDeleteEffect InternalEffectFlowerTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsFlowerTTC[id];

    rootIncarnation.incarnationsFlowerTTC.Remove(id);
    return new FlowerTTCDeleteEffect(id);
  }

     
  public int GetFlowerTTCHash(int id, int version, FlowerTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public LotusTTCIncarnation GetLotusTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsLotusTTC[id].incarnation;
  }
  public bool LotusTTCExists(int id) {
    return rootIncarnation.incarnationsLotusTTC.ContainsKey(id);
  }
  public LotusTTC GetLotusTTC(int id) {
    CheckHasLotusTTC(id);
    return new LotusTTC(this, id);
  }
  public LotusTTC GetLotusTTCOrNull(int id) {
    if (LotusTTCExists(id)) {
      return new LotusTTC(this, id);
    } else {
      return new LotusTTC(this, 0);
    }
  }
  public List<LotusTTC> AllLotusTTC() {
    List<LotusTTC> result = new List<LotusTTC>(rootIncarnation.incarnationsLotusTTC.Count);
    foreach (var id in rootIncarnation.incarnationsLotusTTC.Keys) {
      result.Add(new LotusTTC(this, id));
    }
    return result;
  }
  public IEnumerator<LotusTTC> EnumAllLotusTTC() {
    foreach (var id in rootIncarnation.incarnationsLotusTTC.Keys) {
      yield return GetLotusTTC(id);
    }
  }
  public void CheckHasLotusTTC(LotusTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasLotusTTC(thing.id);
  }
  public void CheckHasLotusTTC(int id) {
    if (!rootIncarnation.incarnationsLotusTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid LotusTTC: " + id);
    }
  }
  public LotusTTC EffectLotusTTCCreate(
) {
    return TrustedEffectLotusTTCCreateWithId(NewId()
    );
  }
  public LotusTTC TrustedEffectLotusTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new LotusTTCIncarnation(

            );
    var effect = InternalEffectCreateLotusTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new LotusTTC(this, id);
  }
  public LotusTTCCreateEffect InternalEffectCreateLotusTTC(
      int id,
      int incarnationVersion,
      LotusTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsLotusTTC.Add(
        id,
        new VersionAndIncarnation<LotusTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new LotusTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectLotusTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectLotusTTCDelete(id);
    NotifyEffect(effect);
  }
  public LotusTTCDeleteEffect InternalEffectLotusTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsLotusTTC[id];

    rootIncarnation.incarnationsLotusTTC.Remove(id);
    return new LotusTTCDeleteEffect(id);
  }

     
  public int GetLotusTTCHash(int id, int version, LotusTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public RoseTTCIncarnation GetRoseTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsRoseTTC[id].incarnation;
  }
  public bool RoseTTCExists(int id) {
    return rootIncarnation.incarnationsRoseTTC.ContainsKey(id);
  }
  public RoseTTC GetRoseTTC(int id) {
    CheckHasRoseTTC(id);
    return new RoseTTC(this, id);
  }
  public RoseTTC GetRoseTTCOrNull(int id) {
    if (RoseTTCExists(id)) {
      return new RoseTTC(this, id);
    } else {
      return new RoseTTC(this, 0);
    }
  }
  public List<RoseTTC> AllRoseTTC() {
    List<RoseTTC> result = new List<RoseTTC>(rootIncarnation.incarnationsRoseTTC.Count);
    foreach (var id in rootIncarnation.incarnationsRoseTTC.Keys) {
      result.Add(new RoseTTC(this, id));
    }
    return result;
  }
  public IEnumerator<RoseTTC> EnumAllRoseTTC() {
    foreach (var id in rootIncarnation.incarnationsRoseTTC.Keys) {
      yield return GetRoseTTC(id);
    }
  }
  public void CheckHasRoseTTC(RoseTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasRoseTTC(thing.id);
  }
  public void CheckHasRoseTTC(int id) {
    if (!rootIncarnation.incarnationsRoseTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid RoseTTC: " + id);
    }
  }
  public RoseTTC EffectRoseTTCCreate(
) {
    return TrustedEffectRoseTTCCreateWithId(NewId()
    );
  }
  public RoseTTC TrustedEffectRoseTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new RoseTTCIncarnation(

            );
    var effect = InternalEffectCreateRoseTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new RoseTTC(this, id);
  }
  public RoseTTCCreateEffect InternalEffectCreateRoseTTC(
      int id,
      int incarnationVersion,
      RoseTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsRoseTTC.Add(
        id,
        new VersionAndIncarnation<RoseTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new RoseTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectRoseTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectRoseTTCDelete(id);
    NotifyEffect(effect);
  }
  public RoseTTCDeleteEffect InternalEffectRoseTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsRoseTTC[id];

    rootIncarnation.incarnationsRoseTTC.Remove(id);
    return new RoseTTCDeleteEffect(id);
  }

     
  public int GetRoseTTCHash(int id, int version, RoseTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public LeafTTCIncarnation GetLeafTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsLeafTTC[id].incarnation;
  }
  public bool LeafTTCExists(int id) {
    return rootIncarnation.incarnationsLeafTTC.ContainsKey(id);
  }
  public LeafTTC GetLeafTTC(int id) {
    CheckHasLeafTTC(id);
    return new LeafTTC(this, id);
  }
  public LeafTTC GetLeafTTCOrNull(int id) {
    if (LeafTTCExists(id)) {
      return new LeafTTC(this, id);
    } else {
      return new LeafTTC(this, 0);
    }
  }
  public List<LeafTTC> AllLeafTTC() {
    List<LeafTTC> result = new List<LeafTTC>(rootIncarnation.incarnationsLeafTTC.Count);
    foreach (var id in rootIncarnation.incarnationsLeafTTC.Keys) {
      result.Add(new LeafTTC(this, id));
    }
    return result;
  }
  public IEnumerator<LeafTTC> EnumAllLeafTTC() {
    foreach (var id in rootIncarnation.incarnationsLeafTTC.Keys) {
      yield return GetLeafTTC(id);
    }
  }
  public void CheckHasLeafTTC(LeafTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasLeafTTC(thing.id);
  }
  public void CheckHasLeafTTC(int id) {
    if (!rootIncarnation.incarnationsLeafTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid LeafTTC: " + id);
    }
  }
  public LeafTTC EffectLeafTTCCreate(
) {
    return TrustedEffectLeafTTCCreateWithId(NewId()
    );
  }
  public LeafTTC TrustedEffectLeafTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new LeafTTCIncarnation(

            );
    var effect = InternalEffectCreateLeafTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new LeafTTC(this, id);
  }
  public LeafTTCCreateEffect InternalEffectCreateLeafTTC(
      int id,
      int incarnationVersion,
      LeafTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsLeafTTC.Add(
        id,
        new VersionAndIncarnation<LeafTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new LeafTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectLeafTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectLeafTTCDelete(id);
    NotifyEffect(effect);
  }
  public LeafTTCDeleteEffect InternalEffectLeafTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsLeafTTC[id];

    rootIncarnation.incarnationsLeafTTC.Remove(id);
    return new LeafTTCDeleteEffect(id);
  }

     
  public int GetLeafTTCHash(int id, int version, LeafTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public OnFireTTCIncarnation GetOnFireTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsOnFireTTC[id].incarnation;
  }
  public bool OnFireTTCExists(int id) {
    return rootIncarnation.incarnationsOnFireTTC.ContainsKey(id);
  }
  public OnFireTTC GetOnFireTTC(int id) {
    CheckHasOnFireTTC(id);
    return new OnFireTTC(this, id);
  }
  public OnFireTTC GetOnFireTTCOrNull(int id) {
    if (OnFireTTCExists(id)) {
      return new OnFireTTC(this, id);
    } else {
      return new OnFireTTC(this, 0);
    }
  }
  public List<OnFireTTC> AllOnFireTTC() {
    List<OnFireTTC> result = new List<OnFireTTC>(rootIncarnation.incarnationsOnFireTTC.Count);
    foreach (var id in rootIncarnation.incarnationsOnFireTTC.Keys) {
      result.Add(new OnFireTTC(this, id));
    }
    return result;
  }
  public IEnumerator<OnFireTTC> EnumAllOnFireTTC() {
    foreach (var id in rootIncarnation.incarnationsOnFireTTC.Keys) {
      yield return GetOnFireTTC(id);
    }
  }
  public void CheckHasOnFireTTC(OnFireTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasOnFireTTC(thing.id);
  }
  public void CheckHasOnFireTTC(int id) {
    if (!rootIncarnation.incarnationsOnFireTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid OnFireTTC: " + id);
    }
  }
  public OnFireTTC EffectOnFireTTCCreate(
      int turnsRemaining) {
    return TrustedEffectOnFireTTCCreateWithId(NewId()
            ,turnsRemaining    );
  }
  public OnFireTTC TrustedEffectOnFireTTCCreateWithId(int id
,      int turnsRemaining) {
    CheckUnlocked();

    var incarnation =
        new OnFireTTCIncarnation(
            turnsRemaining
            );
    var effect = InternalEffectCreateOnFireTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new OnFireTTC(this, id);
  }
  public OnFireTTCCreateEffect InternalEffectCreateOnFireTTC(
      int id,
      int incarnationVersion,
      OnFireTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsOnFireTTC.Add(
        id,
        new VersionAndIncarnation<OnFireTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new OnFireTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectOnFireTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectOnFireTTCDelete(id);
    NotifyEffect(effect);
  }
  public OnFireTTCDeleteEffect InternalEffectOnFireTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsOnFireTTC[id];

    rootIncarnation.incarnationsOnFireTTC.Remove(id);
    return new OnFireTTCDeleteEffect(id);
  }

     
  public int GetOnFireTTCHash(int id, int version, OnFireTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.turnsRemaining.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectOnFireTTCSetTurnsRemaining(
      int id, int newValue) {
    CheckUnlocked();
    CheckHasOnFireTTC(id);
    var effect = InternalEffectOnFireTTCSetTurnsRemaining(id, newValue);
    NotifyEffect(effect);
  }
  public OnFireTTCSetTurnsRemainingEffect InternalEffectOnFireTTCSetTurnsRemaining(int id, int newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsOnFireTTC[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.turnsRemaining;
      oldIncarnationAndVersion.incarnation.turnsRemaining = newValue;

    } else {
      var newIncarnation =
          new OnFireTTCIncarnation(
              newValue);
      rootIncarnation.incarnationsOnFireTTC[id] =
          new VersionAndIncarnation<OnFireTTCIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new OnFireTTCSetTurnsRemainingEffect(id, newValue);
  }
  public MarkerTTCIncarnation GetMarkerTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsMarkerTTC[id].incarnation;
  }
  public bool MarkerTTCExists(int id) {
    return rootIncarnation.incarnationsMarkerTTC.ContainsKey(id);
  }
  public MarkerTTC GetMarkerTTC(int id) {
    CheckHasMarkerTTC(id);
    return new MarkerTTC(this, id);
  }
  public MarkerTTC GetMarkerTTCOrNull(int id) {
    if (MarkerTTCExists(id)) {
      return new MarkerTTC(this, id);
    } else {
      return new MarkerTTC(this, 0);
    }
  }
  public List<MarkerTTC> AllMarkerTTC() {
    List<MarkerTTC> result = new List<MarkerTTC>(rootIncarnation.incarnationsMarkerTTC.Count);
    foreach (var id in rootIncarnation.incarnationsMarkerTTC.Keys) {
      result.Add(new MarkerTTC(this, id));
    }
    return result;
  }
  public IEnumerator<MarkerTTC> EnumAllMarkerTTC() {
    foreach (var id in rootIncarnation.incarnationsMarkerTTC.Keys) {
      yield return GetMarkerTTC(id);
    }
  }
  public void CheckHasMarkerTTC(MarkerTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasMarkerTTC(thing.id);
  }
  public void CheckHasMarkerTTC(int id) {
    if (!rootIncarnation.incarnationsMarkerTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid MarkerTTC: " + id);
    }
  }
  public MarkerTTC EffectMarkerTTCCreate(
      string name) {
    return TrustedEffectMarkerTTCCreateWithId(NewId()
            ,name    );
  }
  public MarkerTTC TrustedEffectMarkerTTCCreateWithId(int id
,      string name) {
    CheckUnlocked();

    var incarnation =
        new MarkerTTCIncarnation(
            name
            );
    var effect = InternalEffectCreateMarkerTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new MarkerTTC(this, id);
  }
  public MarkerTTCCreateEffect InternalEffectCreateMarkerTTC(
      int id,
      int incarnationVersion,
      MarkerTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsMarkerTTC.Add(
        id,
        new VersionAndIncarnation<MarkerTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new MarkerTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectMarkerTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectMarkerTTCDelete(id);
    NotifyEffect(effect);
  }
  public MarkerTTCDeleteEffect InternalEffectMarkerTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsMarkerTTC[id];

    rootIncarnation.incarnationsMarkerTTC.Remove(id);
    return new MarkerTTCDeleteEffect(id);
  }

     
  public int GetMarkerTTCHash(int id, int version, MarkerTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.name.GetDeterministicHashCode();
    return result;
  }
       public LevelLinkTTCIncarnation GetLevelLinkTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsLevelLinkTTC[id].incarnation;
  }
  public bool LevelLinkTTCExists(int id) {
    return rootIncarnation.incarnationsLevelLinkTTC.ContainsKey(id);
  }
  public LevelLinkTTC GetLevelLinkTTC(int id) {
    CheckHasLevelLinkTTC(id);
    return new LevelLinkTTC(this, id);
  }
  public LevelLinkTTC GetLevelLinkTTCOrNull(int id) {
    if (LevelLinkTTCExists(id)) {
      return new LevelLinkTTC(this, id);
    } else {
      return new LevelLinkTTC(this, 0);
    }
  }
  public List<LevelLinkTTC> AllLevelLinkTTC() {
    List<LevelLinkTTC> result = new List<LevelLinkTTC>(rootIncarnation.incarnationsLevelLinkTTC.Count);
    foreach (var id in rootIncarnation.incarnationsLevelLinkTTC.Keys) {
      result.Add(new LevelLinkTTC(this, id));
    }
    return result;
  }
  public IEnumerator<LevelLinkTTC> EnumAllLevelLinkTTC() {
    foreach (var id in rootIncarnation.incarnationsLevelLinkTTC.Keys) {
      yield return GetLevelLinkTTC(id);
    }
  }
  public void CheckHasLevelLinkTTC(LevelLinkTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasLevelLinkTTC(thing.id);
  }
  public void CheckHasLevelLinkTTC(int id) {
    if (!rootIncarnation.incarnationsLevelLinkTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid LevelLinkTTC: " + id);
    }
  }
  public LevelLinkTTC EffectLevelLinkTTCCreate(
      bool destroyThisLevel,
      Level destinationLevel,
      Location destinationLevelLocation) {
    CheckHasLevel(destinationLevel);
    return TrustedEffectLevelLinkTTCCreateWithId(NewId()
            ,destroyThisLevel
            ,destinationLevel.id
            ,destinationLevelLocation    );
  }
  public LevelLinkTTC TrustedEffectLevelLinkTTCCreateWithId(int id
,      bool destroyThisLevel
,      int destinationLevel
,      Location destinationLevelLocation) {
    CheckUnlocked();

    var incarnation =
        new LevelLinkTTCIncarnation(
            destroyThisLevel,
            destinationLevel,
            destinationLevelLocation
            );
    var effect = InternalEffectCreateLevelLinkTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new LevelLinkTTC(this, id);
  }
  public LevelLinkTTCCreateEffect InternalEffectCreateLevelLinkTTC(
      int id,
      int incarnationVersion,
      LevelLinkTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsLevelLinkTTC.Add(
        id,
        new VersionAndIncarnation<LevelLinkTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new LevelLinkTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectLevelLinkTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectLevelLinkTTCDelete(id);
    NotifyEffect(effect);
  }
  public LevelLinkTTCDeleteEffect InternalEffectLevelLinkTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsLevelLinkTTC[id];

    rootIncarnation.incarnationsLevelLinkTTC.Remove(id);
    return new LevelLinkTTCDeleteEffect(id);
  }

     
  public int GetLevelLinkTTCHash(int id, int version, LevelLinkTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.destroyThisLevel.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.destinationLevel.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.destinationLevelLocation.GetDeterministicHashCode();
    return result;
  }
       public MudTTCIncarnation GetMudTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsMudTTC[id].incarnation;
  }
  public bool MudTTCExists(int id) {
    return rootIncarnation.incarnationsMudTTC.ContainsKey(id);
  }
  public MudTTC GetMudTTC(int id) {
    CheckHasMudTTC(id);
    return new MudTTC(this, id);
  }
  public MudTTC GetMudTTCOrNull(int id) {
    if (MudTTCExists(id)) {
      return new MudTTC(this, id);
    } else {
      return new MudTTC(this, 0);
    }
  }
  public List<MudTTC> AllMudTTC() {
    List<MudTTC> result = new List<MudTTC>(rootIncarnation.incarnationsMudTTC.Count);
    foreach (var id in rootIncarnation.incarnationsMudTTC.Keys) {
      result.Add(new MudTTC(this, id));
    }
    return result;
  }
  public IEnumerator<MudTTC> EnumAllMudTTC() {
    foreach (var id in rootIncarnation.incarnationsMudTTC.Keys) {
      yield return GetMudTTC(id);
    }
  }
  public void CheckHasMudTTC(MudTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasMudTTC(thing.id);
  }
  public void CheckHasMudTTC(int id) {
    if (!rootIncarnation.incarnationsMudTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid MudTTC: " + id);
    }
  }
  public MudTTC EffectMudTTCCreate(
) {
    return TrustedEffectMudTTCCreateWithId(NewId()
    );
  }
  public MudTTC TrustedEffectMudTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new MudTTCIncarnation(

            );
    var effect = InternalEffectCreateMudTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new MudTTC(this, id);
  }
  public MudTTCCreateEffect InternalEffectCreateMudTTC(
      int id,
      int incarnationVersion,
      MudTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsMudTTC.Add(
        id,
        new VersionAndIncarnation<MudTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new MudTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectMudTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectMudTTCDelete(id);
    NotifyEffect(effect);
  }
  public MudTTCDeleteEffect InternalEffectMudTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsMudTTC[id];

    rootIncarnation.incarnationsMudTTC.Remove(id);
    return new MudTTCDeleteEffect(id);
  }

     
  public int GetMudTTCHash(int id, int version, MudTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public DirtTTCIncarnation GetDirtTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsDirtTTC[id].incarnation;
  }
  public bool DirtTTCExists(int id) {
    return rootIncarnation.incarnationsDirtTTC.ContainsKey(id);
  }
  public DirtTTC GetDirtTTC(int id) {
    CheckHasDirtTTC(id);
    return new DirtTTC(this, id);
  }
  public DirtTTC GetDirtTTCOrNull(int id) {
    if (DirtTTCExists(id)) {
      return new DirtTTC(this, id);
    } else {
      return new DirtTTC(this, 0);
    }
  }
  public List<DirtTTC> AllDirtTTC() {
    List<DirtTTC> result = new List<DirtTTC>(rootIncarnation.incarnationsDirtTTC.Count);
    foreach (var id in rootIncarnation.incarnationsDirtTTC.Keys) {
      result.Add(new DirtTTC(this, id));
    }
    return result;
  }
  public IEnumerator<DirtTTC> EnumAllDirtTTC() {
    foreach (var id in rootIncarnation.incarnationsDirtTTC.Keys) {
      yield return GetDirtTTC(id);
    }
  }
  public void CheckHasDirtTTC(DirtTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasDirtTTC(thing.id);
  }
  public void CheckHasDirtTTC(int id) {
    if (!rootIncarnation.incarnationsDirtTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid DirtTTC: " + id);
    }
  }
  public DirtTTC EffectDirtTTCCreate(
) {
    return TrustedEffectDirtTTCCreateWithId(NewId()
    );
  }
  public DirtTTC TrustedEffectDirtTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new DirtTTCIncarnation(

            );
    var effect = InternalEffectCreateDirtTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new DirtTTC(this, id);
  }
  public DirtTTCCreateEffect InternalEffectCreateDirtTTC(
      int id,
      int incarnationVersion,
      DirtTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsDirtTTC.Add(
        id,
        new VersionAndIncarnation<DirtTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new DirtTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectDirtTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectDirtTTCDelete(id);
    NotifyEffect(effect);
  }
  public DirtTTCDeleteEffect InternalEffectDirtTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsDirtTTC[id];

    rootIncarnation.incarnationsDirtTTC.Remove(id);
    return new DirtTTCDeleteEffect(id);
  }

     
  public int GetDirtTTCHash(int id, int version, DirtTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public ObsidianTTCIncarnation GetObsidianTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsObsidianTTC[id].incarnation;
  }
  public bool ObsidianTTCExists(int id) {
    return rootIncarnation.incarnationsObsidianTTC.ContainsKey(id);
  }
  public ObsidianTTC GetObsidianTTC(int id) {
    CheckHasObsidianTTC(id);
    return new ObsidianTTC(this, id);
  }
  public ObsidianTTC GetObsidianTTCOrNull(int id) {
    if (ObsidianTTCExists(id)) {
      return new ObsidianTTC(this, id);
    } else {
      return new ObsidianTTC(this, 0);
    }
  }
  public List<ObsidianTTC> AllObsidianTTC() {
    List<ObsidianTTC> result = new List<ObsidianTTC>(rootIncarnation.incarnationsObsidianTTC.Count);
    foreach (var id in rootIncarnation.incarnationsObsidianTTC.Keys) {
      result.Add(new ObsidianTTC(this, id));
    }
    return result;
  }
  public IEnumerator<ObsidianTTC> EnumAllObsidianTTC() {
    foreach (var id in rootIncarnation.incarnationsObsidianTTC.Keys) {
      yield return GetObsidianTTC(id);
    }
  }
  public void CheckHasObsidianTTC(ObsidianTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasObsidianTTC(thing.id);
  }
  public void CheckHasObsidianTTC(int id) {
    if (!rootIncarnation.incarnationsObsidianTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid ObsidianTTC: " + id);
    }
  }
  public ObsidianTTC EffectObsidianTTCCreate(
) {
    return TrustedEffectObsidianTTCCreateWithId(NewId()
    );
  }
  public ObsidianTTC TrustedEffectObsidianTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new ObsidianTTCIncarnation(

            );
    var effect = InternalEffectCreateObsidianTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new ObsidianTTC(this, id);
  }
  public ObsidianTTCCreateEffect InternalEffectCreateObsidianTTC(
      int id,
      int incarnationVersion,
      ObsidianTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsObsidianTTC.Add(
        id,
        new VersionAndIncarnation<ObsidianTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new ObsidianTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectObsidianTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectObsidianTTCDelete(id);
    NotifyEffect(effect);
  }
  public ObsidianTTCDeleteEffect InternalEffectObsidianTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsObsidianTTC[id];

    rootIncarnation.incarnationsObsidianTTC.Remove(id);
    return new ObsidianTTCDeleteEffect(id);
  }

     
  public int GetObsidianTTCHash(int id, int version, ObsidianTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public DownStairsTTCIncarnation GetDownStairsTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsDownStairsTTC[id].incarnation;
  }
  public bool DownStairsTTCExists(int id) {
    return rootIncarnation.incarnationsDownStairsTTC.ContainsKey(id);
  }
  public DownStairsTTC GetDownStairsTTC(int id) {
    CheckHasDownStairsTTC(id);
    return new DownStairsTTC(this, id);
  }
  public DownStairsTTC GetDownStairsTTCOrNull(int id) {
    if (DownStairsTTCExists(id)) {
      return new DownStairsTTC(this, id);
    } else {
      return new DownStairsTTC(this, 0);
    }
  }
  public List<DownStairsTTC> AllDownStairsTTC() {
    List<DownStairsTTC> result = new List<DownStairsTTC>(rootIncarnation.incarnationsDownStairsTTC.Count);
    foreach (var id in rootIncarnation.incarnationsDownStairsTTC.Keys) {
      result.Add(new DownStairsTTC(this, id));
    }
    return result;
  }
  public IEnumerator<DownStairsTTC> EnumAllDownStairsTTC() {
    foreach (var id in rootIncarnation.incarnationsDownStairsTTC.Keys) {
      yield return GetDownStairsTTC(id);
    }
  }
  public void CheckHasDownStairsTTC(DownStairsTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasDownStairsTTC(thing.id);
  }
  public void CheckHasDownStairsTTC(int id) {
    if (!rootIncarnation.incarnationsDownStairsTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid DownStairsTTC: " + id);
    }
  }
  public DownStairsTTC EffectDownStairsTTCCreate(
) {
    return TrustedEffectDownStairsTTCCreateWithId(NewId()
    );
  }
  public DownStairsTTC TrustedEffectDownStairsTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new DownStairsTTCIncarnation(

            );
    var effect = InternalEffectCreateDownStairsTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new DownStairsTTC(this, id);
  }
  public DownStairsTTCCreateEffect InternalEffectCreateDownStairsTTC(
      int id,
      int incarnationVersion,
      DownStairsTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsDownStairsTTC.Add(
        id,
        new VersionAndIncarnation<DownStairsTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new DownStairsTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectDownStairsTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectDownStairsTTCDelete(id);
    NotifyEffect(effect);
  }
  public DownStairsTTCDeleteEffect InternalEffectDownStairsTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsDownStairsTTC[id];

    rootIncarnation.incarnationsDownStairsTTC.Remove(id);
    return new DownStairsTTCDeleteEffect(id);
  }

     
  public int GetDownStairsTTCHash(int id, int version, DownStairsTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public UpStairsTTCIncarnation GetUpStairsTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsUpStairsTTC[id].incarnation;
  }
  public bool UpStairsTTCExists(int id) {
    return rootIncarnation.incarnationsUpStairsTTC.ContainsKey(id);
  }
  public UpStairsTTC GetUpStairsTTC(int id) {
    CheckHasUpStairsTTC(id);
    return new UpStairsTTC(this, id);
  }
  public UpStairsTTC GetUpStairsTTCOrNull(int id) {
    if (UpStairsTTCExists(id)) {
      return new UpStairsTTC(this, id);
    } else {
      return new UpStairsTTC(this, 0);
    }
  }
  public List<UpStairsTTC> AllUpStairsTTC() {
    List<UpStairsTTC> result = new List<UpStairsTTC>(rootIncarnation.incarnationsUpStairsTTC.Count);
    foreach (var id in rootIncarnation.incarnationsUpStairsTTC.Keys) {
      result.Add(new UpStairsTTC(this, id));
    }
    return result;
  }
  public IEnumerator<UpStairsTTC> EnumAllUpStairsTTC() {
    foreach (var id in rootIncarnation.incarnationsUpStairsTTC.Keys) {
      yield return GetUpStairsTTC(id);
    }
  }
  public void CheckHasUpStairsTTC(UpStairsTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasUpStairsTTC(thing.id);
  }
  public void CheckHasUpStairsTTC(int id) {
    if (!rootIncarnation.incarnationsUpStairsTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid UpStairsTTC: " + id);
    }
  }
  public UpStairsTTC EffectUpStairsTTCCreate(
) {
    return TrustedEffectUpStairsTTCCreateWithId(NewId()
    );
  }
  public UpStairsTTC TrustedEffectUpStairsTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new UpStairsTTCIncarnation(

            );
    var effect = InternalEffectCreateUpStairsTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new UpStairsTTC(this, id);
  }
  public UpStairsTTCCreateEffect InternalEffectCreateUpStairsTTC(
      int id,
      int incarnationVersion,
      UpStairsTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsUpStairsTTC.Add(
        id,
        new VersionAndIncarnation<UpStairsTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new UpStairsTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectUpStairsTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectUpStairsTTCDelete(id);
    NotifyEffect(effect);
  }
  public UpStairsTTCDeleteEffect InternalEffectUpStairsTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsUpStairsTTC[id];

    rootIncarnation.incarnationsUpStairsTTC.Remove(id);
    return new UpStairsTTCDeleteEffect(id);
  }

     
  public int GetUpStairsTTCHash(int id, int version, UpStairsTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public WallTTCIncarnation GetWallTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsWallTTC[id].incarnation;
  }
  public bool WallTTCExists(int id) {
    return rootIncarnation.incarnationsWallTTC.ContainsKey(id);
  }
  public WallTTC GetWallTTC(int id) {
    CheckHasWallTTC(id);
    return new WallTTC(this, id);
  }
  public WallTTC GetWallTTCOrNull(int id) {
    if (WallTTCExists(id)) {
      return new WallTTC(this, id);
    } else {
      return new WallTTC(this, 0);
    }
  }
  public List<WallTTC> AllWallTTC() {
    List<WallTTC> result = new List<WallTTC>(rootIncarnation.incarnationsWallTTC.Count);
    foreach (var id in rootIncarnation.incarnationsWallTTC.Keys) {
      result.Add(new WallTTC(this, id));
    }
    return result;
  }
  public IEnumerator<WallTTC> EnumAllWallTTC() {
    foreach (var id in rootIncarnation.incarnationsWallTTC.Keys) {
      yield return GetWallTTC(id);
    }
  }
  public void CheckHasWallTTC(WallTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasWallTTC(thing.id);
  }
  public void CheckHasWallTTC(int id) {
    if (!rootIncarnation.incarnationsWallTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid WallTTC: " + id);
    }
  }
  public WallTTC EffectWallTTCCreate(
) {
    return TrustedEffectWallTTCCreateWithId(NewId()
    );
  }
  public WallTTC TrustedEffectWallTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new WallTTCIncarnation(

            );
    var effect = InternalEffectCreateWallTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new WallTTC(this, id);
  }
  public WallTTCCreateEffect InternalEffectCreateWallTTC(
      int id,
      int incarnationVersion,
      WallTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsWallTTC.Add(
        id,
        new VersionAndIncarnation<WallTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new WallTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectWallTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectWallTTCDelete(id);
    NotifyEffect(effect);
  }
  public WallTTCDeleteEffect InternalEffectWallTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsWallTTC[id];

    rootIncarnation.incarnationsWallTTC.Remove(id);
    return new WallTTCDeleteEffect(id);
  }

     
  public int GetWallTTCHash(int id, int version, WallTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public BloodTTCIncarnation GetBloodTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBloodTTC[id].incarnation;
  }
  public bool BloodTTCExists(int id) {
    return rootIncarnation.incarnationsBloodTTC.ContainsKey(id);
  }
  public BloodTTC GetBloodTTC(int id) {
    CheckHasBloodTTC(id);
    return new BloodTTC(this, id);
  }
  public BloodTTC GetBloodTTCOrNull(int id) {
    if (BloodTTCExists(id)) {
      return new BloodTTC(this, id);
    } else {
      return new BloodTTC(this, 0);
    }
  }
  public List<BloodTTC> AllBloodTTC() {
    List<BloodTTC> result = new List<BloodTTC>(rootIncarnation.incarnationsBloodTTC.Count);
    foreach (var id in rootIncarnation.incarnationsBloodTTC.Keys) {
      result.Add(new BloodTTC(this, id));
    }
    return result;
  }
  public IEnumerator<BloodTTC> EnumAllBloodTTC() {
    foreach (var id in rootIncarnation.incarnationsBloodTTC.Keys) {
      yield return GetBloodTTC(id);
    }
  }
  public void CheckHasBloodTTC(BloodTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBloodTTC(thing.id);
  }
  public void CheckHasBloodTTC(int id) {
    if (!rootIncarnation.incarnationsBloodTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid BloodTTC: " + id);
    }
  }
  public BloodTTC EffectBloodTTCCreate(
) {
    return TrustedEffectBloodTTCCreateWithId(NewId()
    );
  }
  public BloodTTC TrustedEffectBloodTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new BloodTTCIncarnation(

            );
    var effect = InternalEffectCreateBloodTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new BloodTTC(this, id);
  }
  public BloodTTCCreateEffect InternalEffectCreateBloodTTC(
      int id,
      int incarnationVersion,
      BloodTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsBloodTTC.Add(
        id,
        new VersionAndIncarnation<BloodTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new BloodTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectBloodTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectBloodTTCDelete(id);
    NotifyEffect(effect);
  }
  public BloodTTCDeleteEffect InternalEffectBloodTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBloodTTC[id];

    rootIncarnation.incarnationsBloodTTC.Remove(id);
    return new BloodTTCDeleteEffect(id);
  }

     
  public int GetBloodTTCHash(int id, int version, BloodTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public RocksTTCIncarnation GetRocksTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsRocksTTC[id].incarnation;
  }
  public bool RocksTTCExists(int id) {
    return rootIncarnation.incarnationsRocksTTC.ContainsKey(id);
  }
  public RocksTTC GetRocksTTC(int id) {
    CheckHasRocksTTC(id);
    return new RocksTTC(this, id);
  }
  public RocksTTC GetRocksTTCOrNull(int id) {
    if (RocksTTCExists(id)) {
      return new RocksTTC(this, id);
    } else {
      return new RocksTTC(this, 0);
    }
  }
  public List<RocksTTC> AllRocksTTC() {
    List<RocksTTC> result = new List<RocksTTC>(rootIncarnation.incarnationsRocksTTC.Count);
    foreach (var id in rootIncarnation.incarnationsRocksTTC.Keys) {
      result.Add(new RocksTTC(this, id));
    }
    return result;
  }
  public IEnumerator<RocksTTC> EnumAllRocksTTC() {
    foreach (var id in rootIncarnation.incarnationsRocksTTC.Keys) {
      yield return GetRocksTTC(id);
    }
  }
  public void CheckHasRocksTTC(RocksTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasRocksTTC(thing.id);
  }
  public void CheckHasRocksTTC(int id) {
    if (!rootIncarnation.incarnationsRocksTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid RocksTTC: " + id);
    }
  }
  public RocksTTC EffectRocksTTCCreate(
) {
    return TrustedEffectRocksTTCCreateWithId(NewId()
    );
  }
  public RocksTTC TrustedEffectRocksTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new RocksTTCIncarnation(

            );
    var effect = InternalEffectCreateRocksTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new RocksTTC(this, id);
  }
  public RocksTTCCreateEffect InternalEffectCreateRocksTTC(
      int id,
      int incarnationVersion,
      RocksTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsRocksTTC.Add(
        id,
        new VersionAndIncarnation<RocksTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new RocksTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectRocksTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectRocksTTCDelete(id);
    NotifyEffect(effect);
  }
  public RocksTTCDeleteEffect InternalEffectRocksTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsRocksTTC[id];

    rootIncarnation.incarnationsRocksTTC.Remove(id);
    return new RocksTTCDeleteEffect(id);
  }

     
  public int GetRocksTTCHash(int id, int version, RocksTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public TreeTTCIncarnation GetTreeTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTreeTTC[id].incarnation;
  }
  public bool TreeTTCExists(int id) {
    return rootIncarnation.incarnationsTreeTTC.ContainsKey(id);
  }
  public TreeTTC GetTreeTTC(int id) {
    CheckHasTreeTTC(id);
    return new TreeTTC(this, id);
  }
  public TreeTTC GetTreeTTCOrNull(int id) {
    if (TreeTTCExists(id)) {
      return new TreeTTC(this, id);
    } else {
      return new TreeTTC(this, 0);
    }
  }
  public List<TreeTTC> AllTreeTTC() {
    List<TreeTTC> result = new List<TreeTTC>(rootIncarnation.incarnationsTreeTTC.Count);
    foreach (var id in rootIncarnation.incarnationsTreeTTC.Keys) {
      result.Add(new TreeTTC(this, id));
    }
    return result;
  }
  public IEnumerator<TreeTTC> EnumAllTreeTTC() {
    foreach (var id in rootIncarnation.incarnationsTreeTTC.Keys) {
      yield return GetTreeTTC(id);
    }
  }
  public void CheckHasTreeTTC(TreeTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTreeTTC(thing.id);
  }
  public void CheckHasTreeTTC(int id) {
    if (!rootIncarnation.incarnationsTreeTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid TreeTTC: " + id);
    }
  }
  public TreeTTC EffectTreeTTCCreate(
) {
    return TrustedEffectTreeTTCCreateWithId(NewId()
    );
  }
  public TreeTTC TrustedEffectTreeTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new TreeTTCIncarnation(

            );
    var effect = InternalEffectCreateTreeTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new TreeTTC(this, id);
  }
  public TreeTTCCreateEffect InternalEffectCreateTreeTTC(
      int id,
      int incarnationVersion,
      TreeTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsTreeTTC.Add(
        id,
        new VersionAndIncarnation<TreeTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new TreeTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectTreeTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectTreeTTCDelete(id);
    NotifyEffect(effect);
  }
  public TreeTTCDeleteEffect InternalEffectTreeTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTreeTTC[id];

    rootIncarnation.incarnationsTreeTTC.Remove(id);
    return new TreeTTCDeleteEffect(id);
  }

     
  public int GetTreeTTCHash(int id, int version, TreeTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public WaterTTCIncarnation GetWaterTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsWaterTTC[id].incarnation;
  }
  public bool WaterTTCExists(int id) {
    return rootIncarnation.incarnationsWaterTTC.ContainsKey(id);
  }
  public WaterTTC GetWaterTTC(int id) {
    CheckHasWaterTTC(id);
    return new WaterTTC(this, id);
  }
  public WaterTTC GetWaterTTCOrNull(int id) {
    if (WaterTTCExists(id)) {
      return new WaterTTC(this, id);
    } else {
      return new WaterTTC(this, 0);
    }
  }
  public List<WaterTTC> AllWaterTTC() {
    List<WaterTTC> result = new List<WaterTTC>(rootIncarnation.incarnationsWaterTTC.Count);
    foreach (var id in rootIncarnation.incarnationsWaterTTC.Keys) {
      result.Add(new WaterTTC(this, id));
    }
    return result;
  }
  public IEnumerator<WaterTTC> EnumAllWaterTTC() {
    foreach (var id in rootIncarnation.incarnationsWaterTTC.Keys) {
      yield return GetWaterTTC(id);
    }
  }
  public void CheckHasWaterTTC(WaterTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasWaterTTC(thing.id);
  }
  public void CheckHasWaterTTC(int id) {
    if (!rootIncarnation.incarnationsWaterTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid WaterTTC: " + id);
    }
  }
  public WaterTTC EffectWaterTTCCreate(
) {
    return TrustedEffectWaterTTCCreateWithId(NewId()
    );
  }
  public WaterTTC TrustedEffectWaterTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new WaterTTCIncarnation(

            );
    var effect = InternalEffectCreateWaterTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new WaterTTC(this, id);
  }
  public WaterTTCCreateEffect InternalEffectCreateWaterTTC(
      int id,
      int incarnationVersion,
      WaterTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsWaterTTC.Add(
        id,
        new VersionAndIncarnation<WaterTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new WaterTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectWaterTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectWaterTTCDelete(id);
    NotifyEffect(effect);
  }
  public WaterTTCDeleteEffect InternalEffectWaterTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsWaterTTC[id];

    rootIncarnation.incarnationsWaterTTC.Remove(id);
    return new WaterTTCDeleteEffect(id);
  }

     
  public int GetWaterTTCHash(int id, int version, WaterTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public FloorTTCIncarnation GetFloorTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsFloorTTC[id].incarnation;
  }
  public bool FloorTTCExists(int id) {
    return rootIncarnation.incarnationsFloorTTC.ContainsKey(id);
  }
  public FloorTTC GetFloorTTC(int id) {
    CheckHasFloorTTC(id);
    return new FloorTTC(this, id);
  }
  public FloorTTC GetFloorTTCOrNull(int id) {
    if (FloorTTCExists(id)) {
      return new FloorTTC(this, id);
    } else {
      return new FloorTTC(this, 0);
    }
  }
  public List<FloorTTC> AllFloorTTC() {
    List<FloorTTC> result = new List<FloorTTC>(rootIncarnation.incarnationsFloorTTC.Count);
    foreach (var id in rootIncarnation.incarnationsFloorTTC.Keys) {
      result.Add(new FloorTTC(this, id));
    }
    return result;
  }
  public IEnumerator<FloorTTC> EnumAllFloorTTC() {
    foreach (var id in rootIncarnation.incarnationsFloorTTC.Keys) {
      yield return GetFloorTTC(id);
    }
  }
  public void CheckHasFloorTTC(FloorTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasFloorTTC(thing.id);
  }
  public void CheckHasFloorTTC(int id) {
    if (!rootIncarnation.incarnationsFloorTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid FloorTTC: " + id);
    }
  }
  public FloorTTC EffectFloorTTCCreate(
) {
    return TrustedEffectFloorTTCCreateWithId(NewId()
    );
  }
  public FloorTTC TrustedEffectFloorTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new FloorTTCIncarnation(

            );
    var effect = InternalEffectCreateFloorTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new FloorTTC(this, id);
  }
  public FloorTTCCreateEffect InternalEffectCreateFloorTTC(
      int id,
      int incarnationVersion,
      FloorTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsFloorTTC.Add(
        id,
        new VersionAndIncarnation<FloorTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new FloorTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectFloorTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectFloorTTCDelete(id);
    NotifyEffect(effect);
  }
  public FloorTTCDeleteEffect InternalEffectFloorTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsFloorTTC[id];

    rootIncarnation.incarnationsFloorTTC.Remove(id);
    return new FloorTTCDeleteEffect(id);
  }

     
  public int GetFloorTTCHash(int id, int version, FloorTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public CaveWallTTCIncarnation GetCaveWallTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCaveWallTTC[id].incarnation;
  }
  public bool CaveWallTTCExists(int id) {
    return rootIncarnation.incarnationsCaveWallTTC.ContainsKey(id);
  }
  public CaveWallTTC GetCaveWallTTC(int id) {
    CheckHasCaveWallTTC(id);
    return new CaveWallTTC(this, id);
  }
  public CaveWallTTC GetCaveWallTTCOrNull(int id) {
    if (CaveWallTTCExists(id)) {
      return new CaveWallTTC(this, id);
    } else {
      return new CaveWallTTC(this, 0);
    }
  }
  public List<CaveWallTTC> AllCaveWallTTC() {
    List<CaveWallTTC> result = new List<CaveWallTTC>(rootIncarnation.incarnationsCaveWallTTC.Count);
    foreach (var id in rootIncarnation.incarnationsCaveWallTTC.Keys) {
      result.Add(new CaveWallTTC(this, id));
    }
    return result;
  }
  public IEnumerator<CaveWallTTC> EnumAllCaveWallTTC() {
    foreach (var id in rootIncarnation.incarnationsCaveWallTTC.Keys) {
      yield return GetCaveWallTTC(id);
    }
  }
  public void CheckHasCaveWallTTC(CaveWallTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCaveWallTTC(thing.id);
  }
  public void CheckHasCaveWallTTC(int id) {
    if (!rootIncarnation.incarnationsCaveWallTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid CaveWallTTC: " + id);
    }
  }
  public CaveWallTTC EffectCaveWallTTCCreate(
) {
    return TrustedEffectCaveWallTTCCreateWithId(NewId()
    );
  }
  public CaveWallTTC TrustedEffectCaveWallTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new CaveWallTTCIncarnation(

            );
    var effect = InternalEffectCreateCaveWallTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new CaveWallTTC(this, id);
  }
  public CaveWallTTCCreateEffect InternalEffectCreateCaveWallTTC(
      int id,
      int incarnationVersion,
      CaveWallTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsCaveWallTTC.Add(
        id,
        new VersionAndIncarnation<CaveWallTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new CaveWallTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectCaveWallTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectCaveWallTTCDelete(id);
    NotifyEffect(effect);
  }
  public CaveWallTTCDeleteEffect InternalEffectCaveWallTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCaveWallTTC[id];

    rootIncarnation.incarnationsCaveWallTTC.Remove(id);
    return new CaveWallTTCDeleteEffect(id);
  }

     
  public int GetCaveWallTTCHash(int id, int version, CaveWallTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public CaveTTCIncarnation GetCaveTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCaveTTC[id].incarnation;
  }
  public bool CaveTTCExists(int id) {
    return rootIncarnation.incarnationsCaveTTC.ContainsKey(id);
  }
  public CaveTTC GetCaveTTC(int id) {
    CheckHasCaveTTC(id);
    return new CaveTTC(this, id);
  }
  public CaveTTC GetCaveTTCOrNull(int id) {
    if (CaveTTCExists(id)) {
      return new CaveTTC(this, id);
    } else {
      return new CaveTTC(this, 0);
    }
  }
  public List<CaveTTC> AllCaveTTC() {
    List<CaveTTC> result = new List<CaveTTC>(rootIncarnation.incarnationsCaveTTC.Count);
    foreach (var id in rootIncarnation.incarnationsCaveTTC.Keys) {
      result.Add(new CaveTTC(this, id));
    }
    return result;
  }
  public IEnumerator<CaveTTC> EnumAllCaveTTC() {
    foreach (var id in rootIncarnation.incarnationsCaveTTC.Keys) {
      yield return GetCaveTTC(id);
    }
  }
  public void CheckHasCaveTTC(CaveTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCaveTTC(thing.id);
  }
  public void CheckHasCaveTTC(int id) {
    if (!rootIncarnation.incarnationsCaveTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid CaveTTC: " + id);
    }
  }
  public CaveTTC EffectCaveTTCCreate(
) {
    return TrustedEffectCaveTTCCreateWithId(NewId()
    );
  }
  public CaveTTC TrustedEffectCaveTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new CaveTTCIncarnation(

            );
    var effect = InternalEffectCreateCaveTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new CaveTTC(this, id);
  }
  public CaveTTCCreateEffect InternalEffectCreateCaveTTC(
      int id,
      int incarnationVersion,
      CaveTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsCaveTTC.Add(
        id,
        new VersionAndIncarnation<CaveTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new CaveTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectCaveTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectCaveTTCDelete(id);
    NotifyEffect(effect);
  }
  public CaveTTCDeleteEffect InternalEffectCaveTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCaveTTC[id];

    rootIncarnation.incarnationsCaveTTC.Remove(id);
    return new CaveTTCDeleteEffect(id);
  }

     
  public int GetCaveTTCHash(int id, int version, CaveTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public FallsTTCIncarnation GetFallsTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsFallsTTC[id].incarnation;
  }
  public bool FallsTTCExists(int id) {
    return rootIncarnation.incarnationsFallsTTC.ContainsKey(id);
  }
  public FallsTTC GetFallsTTC(int id) {
    CheckHasFallsTTC(id);
    return new FallsTTC(this, id);
  }
  public FallsTTC GetFallsTTCOrNull(int id) {
    if (FallsTTCExists(id)) {
      return new FallsTTC(this, id);
    } else {
      return new FallsTTC(this, 0);
    }
  }
  public List<FallsTTC> AllFallsTTC() {
    List<FallsTTC> result = new List<FallsTTC>(rootIncarnation.incarnationsFallsTTC.Count);
    foreach (var id in rootIncarnation.incarnationsFallsTTC.Keys) {
      result.Add(new FallsTTC(this, id));
    }
    return result;
  }
  public IEnumerator<FallsTTC> EnumAllFallsTTC() {
    foreach (var id in rootIncarnation.incarnationsFallsTTC.Keys) {
      yield return GetFallsTTC(id);
    }
  }
  public void CheckHasFallsTTC(FallsTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasFallsTTC(thing.id);
  }
  public void CheckHasFallsTTC(int id) {
    if (!rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid FallsTTC: " + id);
    }
  }
  public FallsTTC EffectFallsTTCCreate(
) {
    return TrustedEffectFallsTTCCreateWithId(NewId()
    );
  }
  public FallsTTC TrustedEffectFallsTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new FallsTTCIncarnation(

            );
    var effect = InternalEffectCreateFallsTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new FallsTTC(this, id);
  }
  public FallsTTCCreateEffect InternalEffectCreateFallsTTC(
      int id,
      int incarnationVersion,
      FallsTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsFallsTTC.Add(
        id,
        new VersionAndIncarnation<FallsTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new FallsTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectFallsTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectFallsTTCDelete(id);
    NotifyEffect(effect);
  }
  public FallsTTCDeleteEffect InternalEffectFallsTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsFallsTTC[id];

    rootIncarnation.incarnationsFallsTTC.Remove(id);
    return new FallsTTCDeleteEffect(id);
  }

     
  public int GetFallsTTCHash(int id, int version, FallsTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public ObsidianFloorTTCIncarnation GetObsidianFloorTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsObsidianFloorTTC[id].incarnation;
  }
  public bool ObsidianFloorTTCExists(int id) {
    return rootIncarnation.incarnationsObsidianFloorTTC.ContainsKey(id);
  }
  public ObsidianFloorTTC GetObsidianFloorTTC(int id) {
    CheckHasObsidianFloorTTC(id);
    return new ObsidianFloorTTC(this, id);
  }
  public ObsidianFloorTTC GetObsidianFloorTTCOrNull(int id) {
    if (ObsidianFloorTTCExists(id)) {
      return new ObsidianFloorTTC(this, id);
    } else {
      return new ObsidianFloorTTC(this, 0);
    }
  }
  public List<ObsidianFloorTTC> AllObsidianFloorTTC() {
    List<ObsidianFloorTTC> result = new List<ObsidianFloorTTC>(rootIncarnation.incarnationsObsidianFloorTTC.Count);
    foreach (var id in rootIncarnation.incarnationsObsidianFloorTTC.Keys) {
      result.Add(new ObsidianFloorTTC(this, id));
    }
    return result;
  }
  public IEnumerator<ObsidianFloorTTC> EnumAllObsidianFloorTTC() {
    foreach (var id in rootIncarnation.incarnationsObsidianFloorTTC.Keys) {
      yield return GetObsidianFloorTTC(id);
    }
  }
  public void CheckHasObsidianFloorTTC(ObsidianFloorTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasObsidianFloorTTC(thing.id);
  }
  public void CheckHasObsidianFloorTTC(int id) {
    if (!rootIncarnation.incarnationsObsidianFloorTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid ObsidianFloorTTC: " + id);
    }
  }
  public ObsidianFloorTTC EffectObsidianFloorTTCCreate(
) {
    return TrustedEffectObsidianFloorTTCCreateWithId(NewId()
    );
  }
  public ObsidianFloorTTC TrustedEffectObsidianFloorTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new ObsidianFloorTTCIncarnation(

            );
    var effect = InternalEffectCreateObsidianFloorTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new ObsidianFloorTTC(this, id);
  }
  public ObsidianFloorTTCCreateEffect InternalEffectCreateObsidianFloorTTC(
      int id,
      int incarnationVersion,
      ObsidianFloorTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsObsidianFloorTTC.Add(
        id,
        new VersionAndIncarnation<ObsidianFloorTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new ObsidianFloorTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectObsidianFloorTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectObsidianFloorTTCDelete(id);
    NotifyEffect(effect);
  }
  public ObsidianFloorTTCDeleteEffect InternalEffectObsidianFloorTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsObsidianFloorTTC[id];

    rootIncarnation.incarnationsObsidianFloorTTC.Remove(id);
    return new ObsidianFloorTTCDeleteEffect(id);
  }

     
  public int GetObsidianFloorTTCHash(int id, int version, ObsidianFloorTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public MagmaTTCIncarnation GetMagmaTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsMagmaTTC[id].incarnation;
  }
  public bool MagmaTTCExists(int id) {
    return rootIncarnation.incarnationsMagmaTTC.ContainsKey(id);
  }
  public MagmaTTC GetMagmaTTC(int id) {
    CheckHasMagmaTTC(id);
    return new MagmaTTC(this, id);
  }
  public MagmaTTC GetMagmaTTCOrNull(int id) {
    if (MagmaTTCExists(id)) {
      return new MagmaTTC(this, id);
    } else {
      return new MagmaTTC(this, 0);
    }
  }
  public List<MagmaTTC> AllMagmaTTC() {
    List<MagmaTTC> result = new List<MagmaTTC>(rootIncarnation.incarnationsMagmaTTC.Count);
    foreach (var id in rootIncarnation.incarnationsMagmaTTC.Keys) {
      result.Add(new MagmaTTC(this, id));
    }
    return result;
  }
  public IEnumerator<MagmaTTC> EnumAllMagmaTTC() {
    foreach (var id in rootIncarnation.incarnationsMagmaTTC.Keys) {
      yield return GetMagmaTTC(id);
    }
  }
  public void CheckHasMagmaTTC(MagmaTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasMagmaTTC(thing.id);
  }
  public void CheckHasMagmaTTC(int id) {
    if (!rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid MagmaTTC: " + id);
    }
  }
  public MagmaTTC EffectMagmaTTCCreate(
) {
    return TrustedEffectMagmaTTCCreateWithId(NewId()
    );
  }
  public MagmaTTC TrustedEffectMagmaTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new MagmaTTCIncarnation(

            );
    var effect = InternalEffectCreateMagmaTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new MagmaTTC(this, id);
  }
  public MagmaTTCCreateEffect InternalEffectCreateMagmaTTC(
      int id,
      int incarnationVersion,
      MagmaTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsMagmaTTC.Add(
        id,
        new VersionAndIncarnation<MagmaTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new MagmaTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectMagmaTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectMagmaTTCDelete(id);
    NotifyEffect(effect);
  }
  public MagmaTTCDeleteEffect InternalEffectMagmaTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsMagmaTTC[id];

    rootIncarnation.incarnationsMagmaTTC.Remove(id);
    return new MagmaTTCDeleteEffect(id);
  }

     
  public int GetMagmaTTCHash(int id, int version, MagmaTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public CliffTTCIncarnation GetCliffTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCliffTTC[id].incarnation;
  }
  public bool CliffTTCExists(int id) {
    return rootIncarnation.incarnationsCliffTTC.ContainsKey(id);
  }
  public CliffTTC GetCliffTTC(int id) {
    CheckHasCliffTTC(id);
    return new CliffTTC(this, id);
  }
  public CliffTTC GetCliffTTCOrNull(int id) {
    if (CliffTTCExists(id)) {
      return new CliffTTC(this, id);
    } else {
      return new CliffTTC(this, 0);
    }
  }
  public List<CliffTTC> AllCliffTTC() {
    List<CliffTTC> result = new List<CliffTTC>(rootIncarnation.incarnationsCliffTTC.Count);
    foreach (var id in rootIncarnation.incarnationsCliffTTC.Keys) {
      result.Add(new CliffTTC(this, id));
    }
    return result;
  }
  public IEnumerator<CliffTTC> EnumAllCliffTTC() {
    foreach (var id in rootIncarnation.incarnationsCliffTTC.Keys) {
      yield return GetCliffTTC(id);
    }
  }
  public void CheckHasCliffTTC(CliffTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCliffTTC(thing.id);
  }
  public void CheckHasCliffTTC(int id) {
    if (!rootIncarnation.incarnationsCliffTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid CliffTTC: " + id);
    }
  }
  public CliffTTC EffectCliffTTCCreate(
) {
    return TrustedEffectCliffTTCCreateWithId(NewId()
    );
  }
  public CliffTTC TrustedEffectCliffTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new CliffTTCIncarnation(

            );
    var effect = InternalEffectCreateCliffTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new CliffTTC(this, id);
  }
  public CliffTTCCreateEffect InternalEffectCreateCliffTTC(
      int id,
      int incarnationVersion,
      CliffTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsCliffTTC.Add(
        id,
        new VersionAndIncarnation<CliffTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new CliffTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectCliffTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectCliffTTCDelete(id);
    NotifyEffect(effect);
  }
  public CliffTTCDeleteEffect InternalEffectCliffTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCliffTTC[id];

    rootIncarnation.incarnationsCliffTTC.Remove(id);
    return new CliffTTCDeleteEffect(id);
  }

     
  public int GetCliffTTCHash(int id, int version, CliffTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public RavaNestTTCIncarnation GetRavaNestTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsRavaNestTTC[id].incarnation;
  }
  public bool RavaNestTTCExists(int id) {
    return rootIncarnation.incarnationsRavaNestTTC.ContainsKey(id);
  }
  public RavaNestTTC GetRavaNestTTC(int id) {
    CheckHasRavaNestTTC(id);
    return new RavaNestTTC(this, id);
  }
  public RavaNestTTC GetRavaNestTTCOrNull(int id) {
    if (RavaNestTTCExists(id)) {
      return new RavaNestTTC(this, id);
    } else {
      return new RavaNestTTC(this, 0);
    }
  }
  public List<RavaNestTTC> AllRavaNestTTC() {
    List<RavaNestTTC> result = new List<RavaNestTTC>(rootIncarnation.incarnationsRavaNestTTC.Count);
    foreach (var id in rootIncarnation.incarnationsRavaNestTTC.Keys) {
      result.Add(new RavaNestTTC(this, id));
    }
    return result;
  }
  public IEnumerator<RavaNestTTC> EnumAllRavaNestTTC() {
    foreach (var id in rootIncarnation.incarnationsRavaNestTTC.Keys) {
      yield return GetRavaNestTTC(id);
    }
  }
  public void CheckHasRavaNestTTC(RavaNestTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasRavaNestTTC(thing.id);
  }
  public void CheckHasRavaNestTTC(int id) {
    if (!rootIncarnation.incarnationsRavaNestTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid RavaNestTTC: " + id);
    }
  }
  public RavaNestTTC EffectRavaNestTTCCreate(
) {
    return TrustedEffectRavaNestTTCCreateWithId(NewId()
    );
  }
  public RavaNestTTC TrustedEffectRavaNestTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new RavaNestTTCIncarnation(

            );
    var effect = InternalEffectCreateRavaNestTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new RavaNestTTC(this, id);
  }
  public RavaNestTTCCreateEffect InternalEffectCreateRavaNestTTC(
      int id,
      int incarnationVersion,
      RavaNestTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsRavaNestTTC.Add(
        id,
        new VersionAndIncarnation<RavaNestTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new RavaNestTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectRavaNestTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectRavaNestTTCDelete(id);
    NotifyEffect(effect);
  }
  public RavaNestTTCDeleteEffect InternalEffectRavaNestTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsRavaNestTTC[id];

    rootIncarnation.incarnationsRavaNestTTC.Remove(id);
    return new RavaNestTTCDeleteEffect(id);
  }

     
  public int GetRavaNestTTCHash(int id, int version, RavaNestTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public CliffLandingTTCIncarnation GetCliffLandingTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCliffLandingTTC[id].incarnation;
  }
  public bool CliffLandingTTCExists(int id) {
    return rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(id);
  }
  public CliffLandingTTC GetCliffLandingTTC(int id) {
    CheckHasCliffLandingTTC(id);
    return new CliffLandingTTC(this, id);
  }
  public CliffLandingTTC GetCliffLandingTTCOrNull(int id) {
    if (CliffLandingTTCExists(id)) {
      return new CliffLandingTTC(this, id);
    } else {
      return new CliffLandingTTC(this, 0);
    }
  }
  public List<CliffLandingTTC> AllCliffLandingTTC() {
    List<CliffLandingTTC> result = new List<CliffLandingTTC>(rootIncarnation.incarnationsCliffLandingTTC.Count);
    foreach (var id in rootIncarnation.incarnationsCliffLandingTTC.Keys) {
      result.Add(new CliffLandingTTC(this, id));
    }
    return result;
  }
  public IEnumerator<CliffLandingTTC> EnumAllCliffLandingTTC() {
    foreach (var id in rootIncarnation.incarnationsCliffLandingTTC.Keys) {
      yield return GetCliffLandingTTC(id);
    }
  }
  public void CheckHasCliffLandingTTC(CliffLandingTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCliffLandingTTC(thing.id);
  }
  public void CheckHasCliffLandingTTC(int id) {
    if (!rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid CliffLandingTTC: " + id);
    }
  }
  public CliffLandingTTC EffectCliffLandingTTCCreate(
) {
    return TrustedEffectCliffLandingTTCCreateWithId(NewId()
    );
  }
  public CliffLandingTTC TrustedEffectCliffLandingTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new CliffLandingTTCIncarnation(

            );
    var effect = InternalEffectCreateCliffLandingTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new CliffLandingTTC(this, id);
  }
  public CliffLandingTTCCreateEffect InternalEffectCreateCliffLandingTTC(
      int id,
      int incarnationVersion,
      CliffLandingTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsCliffLandingTTC.Add(
        id,
        new VersionAndIncarnation<CliffLandingTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new CliffLandingTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectCliffLandingTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectCliffLandingTTCDelete(id);
    NotifyEffect(effect);
  }
  public CliffLandingTTCDeleteEffect InternalEffectCliffLandingTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCliffLandingTTC[id];

    rootIncarnation.incarnationsCliffLandingTTC.Remove(id);
    return new CliffLandingTTCDeleteEffect(id);
  }

     
  public int GetCliffLandingTTCHash(int id, int version, CliffLandingTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public StoneTTCIncarnation GetStoneTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsStoneTTC[id].incarnation;
  }
  public bool StoneTTCExists(int id) {
    return rootIncarnation.incarnationsStoneTTC.ContainsKey(id);
  }
  public StoneTTC GetStoneTTC(int id) {
    CheckHasStoneTTC(id);
    return new StoneTTC(this, id);
  }
  public StoneTTC GetStoneTTCOrNull(int id) {
    if (StoneTTCExists(id)) {
      return new StoneTTC(this, id);
    } else {
      return new StoneTTC(this, 0);
    }
  }
  public List<StoneTTC> AllStoneTTC() {
    List<StoneTTC> result = new List<StoneTTC>(rootIncarnation.incarnationsStoneTTC.Count);
    foreach (var id in rootIncarnation.incarnationsStoneTTC.Keys) {
      result.Add(new StoneTTC(this, id));
    }
    return result;
  }
  public IEnumerator<StoneTTC> EnumAllStoneTTC() {
    foreach (var id in rootIncarnation.incarnationsStoneTTC.Keys) {
      yield return GetStoneTTC(id);
    }
  }
  public void CheckHasStoneTTC(StoneTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasStoneTTC(thing.id);
  }
  public void CheckHasStoneTTC(int id) {
    if (!rootIncarnation.incarnationsStoneTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid StoneTTC: " + id);
    }
  }
  public StoneTTC EffectStoneTTCCreate(
) {
    return TrustedEffectStoneTTCCreateWithId(NewId()
    );
  }
  public StoneTTC TrustedEffectStoneTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new StoneTTCIncarnation(

            );
    var effect = InternalEffectCreateStoneTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new StoneTTC(this, id);
  }
  public StoneTTCCreateEffect InternalEffectCreateStoneTTC(
      int id,
      int incarnationVersion,
      StoneTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsStoneTTC.Add(
        id,
        new VersionAndIncarnation<StoneTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new StoneTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectStoneTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectStoneTTCDelete(id);
    NotifyEffect(effect);
  }
  public StoneTTCDeleteEffect InternalEffectStoneTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsStoneTTC[id];

    rootIncarnation.incarnationsStoneTTC.Remove(id);
    return new StoneTTCDeleteEffect(id);
  }

     
  public int GetStoneTTCHash(int id, int version, StoneTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public GrassTTCIncarnation GetGrassTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsGrassTTC[id].incarnation;
  }
  public bool GrassTTCExists(int id) {
    return rootIncarnation.incarnationsGrassTTC.ContainsKey(id);
  }
  public GrassTTC GetGrassTTC(int id) {
    CheckHasGrassTTC(id);
    return new GrassTTC(this, id);
  }
  public GrassTTC GetGrassTTCOrNull(int id) {
    if (GrassTTCExists(id)) {
      return new GrassTTC(this, id);
    } else {
      return new GrassTTC(this, 0);
    }
  }
  public List<GrassTTC> AllGrassTTC() {
    List<GrassTTC> result = new List<GrassTTC>(rootIncarnation.incarnationsGrassTTC.Count);
    foreach (var id in rootIncarnation.incarnationsGrassTTC.Keys) {
      result.Add(new GrassTTC(this, id));
    }
    return result;
  }
  public IEnumerator<GrassTTC> EnumAllGrassTTC() {
    foreach (var id in rootIncarnation.incarnationsGrassTTC.Keys) {
      yield return GetGrassTTC(id);
    }
  }
  public void CheckHasGrassTTC(GrassTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasGrassTTC(thing.id);
  }
  public void CheckHasGrassTTC(int id) {
    if (!rootIncarnation.incarnationsGrassTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid GrassTTC: " + id);
    }
  }
  public GrassTTC EffectGrassTTCCreate(
) {
    return TrustedEffectGrassTTCCreateWithId(NewId()
    );
  }
  public GrassTTC TrustedEffectGrassTTCCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new GrassTTCIncarnation(

            );
    var effect = InternalEffectCreateGrassTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new GrassTTC(this, id);
  }
  public GrassTTCCreateEffect InternalEffectCreateGrassTTC(
      int id,
      int incarnationVersion,
      GrassTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsGrassTTC.Add(
        id,
        new VersionAndIncarnation<GrassTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new GrassTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectGrassTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectGrassTTCDelete(id);
    NotifyEffect(effect);
  }
  public GrassTTCDeleteEffect InternalEffectGrassTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsGrassTTC[id];

    rootIncarnation.incarnationsGrassTTC.Remove(id);
    return new GrassTTCDeleteEffect(id);
  }

     
  public int GetGrassTTCHash(int id, int version, GrassTTCIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public LevelIncarnation GetLevelIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsLevel[id].incarnation;
  }
  public bool LevelExists(int id) {
    return rootIncarnation.incarnationsLevel.ContainsKey(id);
  }
  public Level GetLevel(int id) {
    CheckHasLevel(id);
    return new Level(this, id);
  }
  public Level GetLevelOrNull(int id) {
    if (LevelExists(id)) {
      return new Level(this, id);
    } else {
      return new Level(this, 0);
    }
  }
  public List<Level> AllLevel() {
    List<Level> result = new List<Level>(rootIncarnation.incarnationsLevel.Count);
    foreach (var id in rootIncarnation.incarnationsLevel.Keys) {
      result.Add(new Level(this, id));
    }
    return result;
  }
  public IEnumerator<Level> EnumAllLevel() {
    foreach (var id in rootIncarnation.incarnationsLevel.Keys) {
      yield return GetLevel(id);
    }
  }
  public void CheckHasLevel(Level thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasLevel(thing.id);
  }
  public void CheckHasLevel(int id) {
    if (!rootIncarnation.incarnationsLevel.ContainsKey(id)) {
      throw new System.Exception("Invalid Level: " + id);
    }
  }
  public Level EffectLevelCreate(
      Vec3 cameraAngle,
      Terrain terrain,
      UnitMutSet units,
      ILevelController controller,
      int time) {
    CheckHasTerrain(terrain);
    CheckHasUnitMutSet(units);
    return TrustedEffectLevelCreateWithId(NewId()
            ,cameraAngle
            ,terrain.id
            ,units.id
            ,controller.id
            ,time    );
  }
  public Level TrustedEffectLevelCreateWithId(int id
,      Vec3 cameraAngle
,      int terrain
,      int units
,      int controller
,      int time) {
    CheckUnlocked();

    var incarnation =
        new LevelIncarnation(
            cameraAngle,
            terrain,
            units,
            controller,
            time
            );
    var effect = InternalEffectCreateLevel(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new Level(this, id);
  }
  public LevelCreateEffect InternalEffectCreateLevel(
      int id,
      int incarnationVersion,
      LevelIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsLevel.Add(
        id,
        new VersionAndIncarnation<LevelIncarnation>(
            incarnationVersion,
            incarnation));
    return new LevelCreateEffect(id, incarnation.Copy());
  }

  public void EffectLevelDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectLevelDelete(id);
    NotifyEffect(effect);
  }
  public LevelDeleteEffect InternalEffectLevelDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsLevel[id];

    rootIncarnation.incarnationsLevel.Remove(id);
    return new LevelDeleteEffect(id);
  }

     
  public int GetLevelHash(int id, int version, LevelIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.cameraAngle.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.terrain.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.units.GetDeterministicHashCode();
    if (!object.ReferenceEquals(incarnation.controller, null)) {
      result += id * version * 4 * incarnation.controller.GetDeterministicHashCode();
    }
    result += id * version * 5 * incarnation.time.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectLevelSetController(
      int id, ILevelController newValue) {
    CheckUnlocked();
    CheckHasLevel(id);
    var effect = InternalEffectLevelSetController(id, newValue);
    NotifyEffect(effect);
  }
  public LevelSetControllerEffect InternalEffectLevelSetController(int id, ILevelController newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsLevel[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldId = oldIncarnationAndVersion.incarnation.controller;
      oldIncarnationAndVersion.incarnation.controller = newValue.id;

    } else {
      var newIncarnation =
          new LevelIncarnation(
              oldIncarnationAndVersion.incarnation.cameraAngle,
              oldIncarnationAndVersion.incarnation.terrain,
              oldIncarnationAndVersion.incarnation.units,
              newValue.id,
              oldIncarnationAndVersion.incarnation.time);
      rootIncarnation.incarnationsLevel[id] =
          new VersionAndIncarnation<LevelIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new LevelSetControllerEffect(id, newValue.id);
  }

  public void EffectLevelSetTime(
      int id, int newValue) {
    CheckUnlocked();
    CheckHasLevel(id);
    var effect = InternalEffectLevelSetTime(id, newValue);
    NotifyEffect(effect);
  }
  public LevelSetTimeEffect InternalEffectLevelSetTime(int id, int newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsLevel[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.time;
      oldIncarnationAndVersion.incarnation.time = newValue;

    } else {
      var newIncarnation =
          new LevelIncarnation(
              oldIncarnationAndVersion.incarnation.cameraAngle,
              oldIncarnationAndVersion.incarnation.terrain,
              oldIncarnationAndVersion.incarnation.units,
              oldIncarnationAndVersion.incarnation.controller,
              newValue);
      rootIncarnation.incarnationsLevel[id] =
          new VersionAndIncarnation<LevelIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new LevelSetTimeEffect(id, newValue);
  }
  public SpeedRingIncarnation GetSpeedRingIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsSpeedRing[id].incarnation;
  }
  public bool SpeedRingExists(int id) {
    return rootIncarnation.incarnationsSpeedRing.ContainsKey(id);
  }
  public SpeedRing GetSpeedRing(int id) {
    CheckHasSpeedRing(id);
    return new SpeedRing(this, id);
  }
  public SpeedRing GetSpeedRingOrNull(int id) {
    if (SpeedRingExists(id)) {
      return new SpeedRing(this, id);
    } else {
      return new SpeedRing(this, 0);
    }
  }
  public List<SpeedRing> AllSpeedRing() {
    List<SpeedRing> result = new List<SpeedRing>(rootIncarnation.incarnationsSpeedRing.Count);
    foreach (var id in rootIncarnation.incarnationsSpeedRing.Keys) {
      result.Add(new SpeedRing(this, id));
    }
    return result;
  }
  public IEnumerator<SpeedRing> EnumAllSpeedRing() {
    foreach (var id in rootIncarnation.incarnationsSpeedRing.Keys) {
      yield return GetSpeedRing(id);
    }
  }
  public void CheckHasSpeedRing(SpeedRing thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasSpeedRing(thing.id);
  }
  public void CheckHasSpeedRing(int id) {
    if (!rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      throw new System.Exception("Invalid SpeedRing: " + id);
    }
  }
  public SpeedRing EffectSpeedRingCreate(
) {
    return TrustedEffectSpeedRingCreateWithId(NewId()
    );
  }
  public SpeedRing TrustedEffectSpeedRingCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new SpeedRingIncarnation(

            );
    var effect = InternalEffectCreateSpeedRing(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new SpeedRing(this, id);
  }
  public SpeedRingCreateEffect InternalEffectCreateSpeedRing(
      int id,
      int incarnationVersion,
      SpeedRingIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsSpeedRing.Add(
        id,
        new VersionAndIncarnation<SpeedRingIncarnation>(
            incarnationVersion,
            incarnation));
    return new SpeedRingCreateEffect(id, incarnation.Copy());
  }

  public void EffectSpeedRingDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectSpeedRingDelete(id);
    NotifyEffect(effect);
  }
  public SpeedRingDeleteEffect InternalEffectSpeedRingDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsSpeedRing[id];

    rootIncarnation.incarnationsSpeedRing.Remove(id);
    return new SpeedRingDeleteEffect(id);
  }

     
  public int GetSpeedRingHash(int id, int version, SpeedRingIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public ManaPotionIncarnation GetManaPotionIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsManaPotion[id].incarnation;
  }
  public bool ManaPotionExists(int id) {
    return rootIncarnation.incarnationsManaPotion.ContainsKey(id);
  }
  public ManaPotion GetManaPotion(int id) {
    CheckHasManaPotion(id);
    return new ManaPotion(this, id);
  }
  public ManaPotion GetManaPotionOrNull(int id) {
    if (ManaPotionExists(id)) {
      return new ManaPotion(this, id);
    } else {
      return new ManaPotion(this, 0);
    }
  }
  public List<ManaPotion> AllManaPotion() {
    List<ManaPotion> result = new List<ManaPotion>(rootIncarnation.incarnationsManaPotion.Count);
    foreach (var id in rootIncarnation.incarnationsManaPotion.Keys) {
      result.Add(new ManaPotion(this, id));
    }
    return result;
  }
  public IEnumerator<ManaPotion> EnumAllManaPotion() {
    foreach (var id in rootIncarnation.incarnationsManaPotion.Keys) {
      yield return GetManaPotion(id);
    }
  }
  public void CheckHasManaPotion(ManaPotion thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasManaPotion(thing.id);
  }
  public void CheckHasManaPotion(int id) {
    if (!rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      throw new System.Exception("Invalid ManaPotion: " + id);
    }
  }
  public ManaPotion EffectManaPotionCreate(
) {
    return TrustedEffectManaPotionCreateWithId(NewId()
    );
  }
  public ManaPotion TrustedEffectManaPotionCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new ManaPotionIncarnation(

            );
    var effect = InternalEffectCreateManaPotion(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new ManaPotion(this, id);
  }
  public ManaPotionCreateEffect InternalEffectCreateManaPotion(
      int id,
      int incarnationVersion,
      ManaPotionIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsManaPotion.Add(
        id,
        new VersionAndIncarnation<ManaPotionIncarnation>(
            incarnationVersion,
            incarnation));
    return new ManaPotionCreateEffect(id, incarnation.Copy());
  }

  public void EffectManaPotionDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectManaPotionDelete(id);
    NotifyEffect(effect);
  }
  public ManaPotionDeleteEffect InternalEffectManaPotionDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsManaPotion[id];

    rootIncarnation.incarnationsManaPotion.Remove(id);
    return new ManaPotionDeleteEffect(id);
  }

     
  public int GetManaPotionHash(int id, int version, ManaPotionIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public WatIncarnation GetWatIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsWat[id].incarnation;
  }
  public bool WatExists(int id) {
    return rootIncarnation.incarnationsWat.ContainsKey(id);
  }
  public Wat GetWat(int id) {
    CheckHasWat(id);
    return new Wat(this, id);
  }
  public Wat GetWatOrNull(int id) {
    if (WatExists(id)) {
      return new Wat(this, id);
    } else {
      return new Wat(this, 0);
    }
  }
  public List<Wat> AllWat() {
    List<Wat> result = new List<Wat>(rootIncarnation.incarnationsWat.Count);
    foreach (var id in rootIncarnation.incarnationsWat.Keys) {
      result.Add(new Wat(this, id));
    }
    return result;
  }
  public IEnumerator<Wat> EnumAllWat() {
    foreach (var id in rootIncarnation.incarnationsWat.Keys) {
      yield return GetWat(id);
    }
  }
  public void CheckHasWat(Wat thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasWat(thing.id);
  }
  public void CheckHasWat(int id) {
    if (!rootIncarnation.incarnationsWat.ContainsKey(id)) {
      throw new System.Exception("Invalid Wat: " + id);
    }
  }
  public Wat EffectWatCreate(
      IItemStrongMutBunch items,
      IImpulseStrongMutBunch impulses,
      IPostActingUCWeakMutBunch blah,
      IPreActingUCWeakMutBunch bloop) {
    CheckHasIItemStrongMutBunch(items);
    CheckHasIImpulseStrongMutBunch(impulses);
    CheckHasIPostActingUCWeakMutBunch(blah);
    CheckHasIPreActingUCWeakMutBunch(bloop);
    return TrustedEffectWatCreateWithId(NewId()
            ,items.id
            ,impulses.id
            ,blah.id
            ,bloop.id    );
  }
  public Wat TrustedEffectWatCreateWithId(int id
,      int items
,      int impulses
,      int blah
,      int bloop) {
    CheckUnlocked();

    var incarnation =
        new WatIncarnation(
            items,
            impulses,
            blah,
            bloop
            );
    var effect = InternalEffectCreateWat(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new Wat(this, id);
  }
  public WatCreateEffect InternalEffectCreateWat(
      int id,
      int incarnationVersion,
      WatIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsWat.Add(
        id,
        new VersionAndIncarnation<WatIncarnation>(
            incarnationVersion,
            incarnation));
    return new WatCreateEffect(id, incarnation.Copy());
  }

  public void EffectWatDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectWatDelete(id);
    NotifyEffect(effect);
  }
  public WatDeleteEffect InternalEffectWatDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsWat[id];

    rootIncarnation.incarnationsWat.Remove(id);
    return new WatDeleteEffect(id);
  }

     
  public int GetWatHash(int id, int version, WatIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.items.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.impulses.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.blah.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.bloop.GetDeterministicHashCode();
    return result;
  }
       public IPreActingUCWeakMutBunchIncarnation GetIPreActingUCWeakMutBunchIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsIPreActingUCWeakMutBunch[id].incarnation;
  }
  public bool IPreActingUCWeakMutBunchExists(int id) {
    return rootIncarnation.incarnationsIPreActingUCWeakMutBunch.ContainsKey(id);
  }
  public IPreActingUCWeakMutBunch GetIPreActingUCWeakMutBunch(int id) {
    CheckHasIPreActingUCWeakMutBunch(id);
    return new IPreActingUCWeakMutBunch(this, id);
  }
  public IPreActingUCWeakMutBunch GetIPreActingUCWeakMutBunchOrNull(int id) {
    if (IPreActingUCWeakMutBunchExists(id)) {
      return new IPreActingUCWeakMutBunch(this, id);
    } else {
      return new IPreActingUCWeakMutBunch(this, 0);
    }
  }
  public List<IPreActingUCWeakMutBunch> AllIPreActingUCWeakMutBunch() {
    List<IPreActingUCWeakMutBunch> result = new List<IPreActingUCWeakMutBunch>(rootIncarnation.incarnationsIPreActingUCWeakMutBunch.Count);
    foreach (var id in rootIncarnation.incarnationsIPreActingUCWeakMutBunch.Keys) {
      result.Add(new IPreActingUCWeakMutBunch(this, id));
    }
    return result;
  }
  public IEnumerator<IPreActingUCWeakMutBunch> EnumAllIPreActingUCWeakMutBunch() {
    foreach (var id in rootIncarnation.incarnationsIPreActingUCWeakMutBunch.Keys) {
      yield return GetIPreActingUCWeakMutBunch(id);
    }
  }
  public void CheckHasIPreActingUCWeakMutBunch(IPreActingUCWeakMutBunch thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasIPreActingUCWeakMutBunch(thing.id);
  }
  public void CheckHasIPreActingUCWeakMutBunch(int id) {
    if (!rootIncarnation.incarnationsIPreActingUCWeakMutBunch.ContainsKey(id)) {
      throw new System.Exception("Invalid IPreActingUCWeakMutBunch: " + id);
    }
  }
  public IPreActingUCWeakMutBunch EffectIPreActingUCWeakMutBunchCreate(
      DoomedUCWeakMutSet membersDoomedUCWeakMutSet,
      MiredUCWeakMutSet membersMiredUCWeakMutSet,
      InvincibilityUCWeakMutSet membersInvincibilityUCWeakMutSet,
      OnFireUCWeakMutSet membersOnFireUCWeakMutSet,
      DefyingUCWeakMutSet membersDefyingUCWeakMutSet,
      CounteringUCWeakMutSet membersCounteringUCWeakMutSet,
      AttackAICapabilityUCWeakMutSet membersAttackAICapabilityUCWeakMutSet) {
    CheckHasDoomedUCWeakMutSet(membersDoomedUCWeakMutSet);
    CheckHasMiredUCWeakMutSet(membersMiredUCWeakMutSet);
    CheckHasInvincibilityUCWeakMutSet(membersInvincibilityUCWeakMutSet);
    CheckHasOnFireUCWeakMutSet(membersOnFireUCWeakMutSet);
    CheckHasDefyingUCWeakMutSet(membersDefyingUCWeakMutSet);
    CheckHasCounteringUCWeakMutSet(membersCounteringUCWeakMutSet);
    CheckHasAttackAICapabilityUCWeakMutSet(membersAttackAICapabilityUCWeakMutSet);
    return TrustedEffectIPreActingUCWeakMutBunchCreateWithId(NewId()
            ,membersDoomedUCWeakMutSet.id
            ,membersMiredUCWeakMutSet.id
            ,membersInvincibilityUCWeakMutSet.id
            ,membersOnFireUCWeakMutSet.id
            ,membersDefyingUCWeakMutSet.id
            ,membersCounteringUCWeakMutSet.id
            ,membersAttackAICapabilityUCWeakMutSet.id    );
  }
  public IPreActingUCWeakMutBunch TrustedEffectIPreActingUCWeakMutBunchCreateWithId(int id
,      int membersDoomedUCWeakMutSet
,      int membersMiredUCWeakMutSet
,      int membersInvincibilityUCWeakMutSet
,      int membersOnFireUCWeakMutSet
,      int membersDefyingUCWeakMutSet
,      int membersCounteringUCWeakMutSet
,      int membersAttackAICapabilityUCWeakMutSet) {
    CheckUnlocked();

    var incarnation =
        new IPreActingUCWeakMutBunchIncarnation(
            membersDoomedUCWeakMutSet,
            membersMiredUCWeakMutSet,
            membersInvincibilityUCWeakMutSet,
            membersOnFireUCWeakMutSet,
            membersDefyingUCWeakMutSet,
            membersCounteringUCWeakMutSet,
            membersAttackAICapabilityUCWeakMutSet
            );
    var effect = InternalEffectCreateIPreActingUCWeakMutBunch(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new IPreActingUCWeakMutBunch(this, id);
  }
  public IPreActingUCWeakMutBunchCreateEffect InternalEffectCreateIPreActingUCWeakMutBunch(
      int id,
      int incarnationVersion,
      IPreActingUCWeakMutBunchIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsIPreActingUCWeakMutBunch.Add(
        id,
        new VersionAndIncarnation<IPreActingUCWeakMutBunchIncarnation>(
            incarnationVersion,
            incarnation));
    return new IPreActingUCWeakMutBunchCreateEffect(id, incarnation.Copy());
  }

  public void EffectIPreActingUCWeakMutBunchDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectIPreActingUCWeakMutBunchDelete(id);
    NotifyEffect(effect);
  }
  public IPreActingUCWeakMutBunchDeleteEffect InternalEffectIPreActingUCWeakMutBunchDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsIPreActingUCWeakMutBunch[id];

    rootIncarnation.incarnationsIPreActingUCWeakMutBunch.Remove(id);
    return new IPreActingUCWeakMutBunchDeleteEffect(id);
  }

     
  public int GetIPreActingUCWeakMutBunchHash(int id, int version, IPreActingUCWeakMutBunchIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.membersDoomedUCWeakMutSet.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.membersMiredUCWeakMutSet.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.membersInvincibilityUCWeakMutSet.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.membersOnFireUCWeakMutSet.GetDeterministicHashCode();
    result += id * version * 5 * incarnation.membersDefyingUCWeakMutSet.GetDeterministicHashCode();
    result += id * version * 6 * incarnation.membersCounteringUCWeakMutSet.GetDeterministicHashCode();
    result += id * version * 7 * incarnation.membersAttackAICapabilityUCWeakMutSet.GetDeterministicHashCode();
    return result;
  }
       public IPostActingUCWeakMutBunchIncarnation GetIPostActingUCWeakMutBunchIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsIPostActingUCWeakMutBunch[id].incarnation;
  }
  public bool IPostActingUCWeakMutBunchExists(int id) {
    return rootIncarnation.incarnationsIPostActingUCWeakMutBunch.ContainsKey(id);
  }
  public IPostActingUCWeakMutBunch GetIPostActingUCWeakMutBunch(int id) {
    CheckHasIPostActingUCWeakMutBunch(id);
    return new IPostActingUCWeakMutBunch(this, id);
  }
  public IPostActingUCWeakMutBunch GetIPostActingUCWeakMutBunchOrNull(int id) {
    if (IPostActingUCWeakMutBunchExists(id)) {
      return new IPostActingUCWeakMutBunch(this, id);
    } else {
      return new IPostActingUCWeakMutBunch(this, 0);
    }
  }
  public List<IPostActingUCWeakMutBunch> AllIPostActingUCWeakMutBunch() {
    List<IPostActingUCWeakMutBunch> result = new List<IPostActingUCWeakMutBunch>(rootIncarnation.incarnationsIPostActingUCWeakMutBunch.Count);
    foreach (var id in rootIncarnation.incarnationsIPostActingUCWeakMutBunch.Keys) {
      result.Add(new IPostActingUCWeakMutBunch(this, id));
    }
    return result;
  }
  public IEnumerator<IPostActingUCWeakMutBunch> EnumAllIPostActingUCWeakMutBunch() {
    foreach (var id in rootIncarnation.incarnationsIPostActingUCWeakMutBunch.Keys) {
      yield return GetIPostActingUCWeakMutBunch(id);
    }
  }
  public void CheckHasIPostActingUCWeakMutBunch(IPostActingUCWeakMutBunch thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasIPostActingUCWeakMutBunch(thing.id);
  }
  public void CheckHasIPostActingUCWeakMutBunch(int id) {
    if (!rootIncarnation.incarnationsIPostActingUCWeakMutBunch.ContainsKey(id)) {
      throw new System.Exception("Invalid IPostActingUCWeakMutBunch: " + id);
    }
  }
  public IPostActingUCWeakMutBunch EffectIPostActingUCWeakMutBunchCreate(
      LightningChargedUCWeakMutSet membersLightningChargedUCWeakMutSet,
      TimeCloneAICapabilityUCWeakMutSet membersTimeCloneAICapabilityUCWeakMutSet) {
    CheckHasLightningChargedUCWeakMutSet(membersLightningChargedUCWeakMutSet);
    CheckHasTimeCloneAICapabilityUCWeakMutSet(membersTimeCloneAICapabilityUCWeakMutSet);
    return TrustedEffectIPostActingUCWeakMutBunchCreateWithId(NewId()
            ,membersLightningChargedUCWeakMutSet.id
            ,membersTimeCloneAICapabilityUCWeakMutSet.id    );
  }
  public IPostActingUCWeakMutBunch TrustedEffectIPostActingUCWeakMutBunchCreateWithId(int id
,      int membersLightningChargedUCWeakMutSet
,      int membersTimeCloneAICapabilityUCWeakMutSet) {
    CheckUnlocked();

    var incarnation =
        new IPostActingUCWeakMutBunchIncarnation(
            membersLightningChargedUCWeakMutSet,
            membersTimeCloneAICapabilityUCWeakMutSet
            );
    var effect = InternalEffectCreateIPostActingUCWeakMutBunch(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new IPostActingUCWeakMutBunch(this, id);
  }
  public IPostActingUCWeakMutBunchCreateEffect InternalEffectCreateIPostActingUCWeakMutBunch(
      int id,
      int incarnationVersion,
      IPostActingUCWeakMutBunchIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsIPostActingUCWeakMutBunch.Add(
        id,
        new VersionAndIncarnation<IPostActingUCWeakMutBunchIncarnation>(
            incarnationVersion,
            incarnation));
    return new IPostActingUCWeakMutBunchCreateEffect(id, incarnation.Copy());
  }

  public void EffectIPostActingUCWeakMutBunchDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectIPostActingUCWeakMutBunchDelete(id);
    NotifyEffect(effect);
  }
  public IPostActingUCWeakMutBunchDeleteEffect InternalEffectIPostActingUCWeakMutBunchDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsIPostActingUCWeakMutBunch[id];

    rootIncarnation.incarnationsIPostActingUCWeakMutBunch.Remove(id);
    return new IPostActingUCWeakMutBunchDeleteEffect(id);
  }

     
  public int GetIPostActingUCWeakMutBunchHash(int id, int version, IPostActingUCWeakMutBunchIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.membersLightningChargedUCWeakMutSet.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.membersTimeCloneAICapabilityUCWeakMutSet.GetDeterministicHashCode();
    return result;
  }
       public IImpulseStrongMutBunchIncarnation GetIImpulseStrongMutBunchIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsIImpulseStrongMutBunch[id].incarnation;
  }
  public bool IImpulseStrongMutBunchExists(int id) {
    return rootIncarnation.incarnationsIImpulseStrongMutBunch.ContainsKey(id);
  }
  public IImpulseStrongMutBunch GetIImpulseStrongMutBunch(int id) {
    CheckHasIImpulseStrongMutBunch(id);
    return new IImpulseStrongMutBunch(this, id);
  }
  public IImpulseStrongMutBunch GetIImpulseStrongMutBunchOrNull(int id) {
    if (IImpulseStrongMutBunchExists(id)) {
      return new IImpulseStrongMutBunch(this, id);
    } else {
      return new IImpulseStrongMutBunch(this, 0);
    }
  }
  public List<IImpulseStrongMutBunch> AllIImpulseStrongMutBunch() {
    List<IImpulseStrongMutBunch> result = new List<IImpulseStrongMutBunch>(rootIncarnation.incarnationsIImpulseStrongMutBunch.Count);
    foreach (var id in rootIncarnation.incarnationsIImpulseStrongMutBunch.Keys) {
      result.Add(new IImpulseStrongMutBunch(this, id));
    }
    return result;
  }
  public IEnumerator<IImpulseStrongMutBunch> EnumAllIImpulseStrongMutBunch() {
    foreach (var id in rootIncarnation.incarnationsIImpulseStrongMutBunch.Keys) {
      yield return GetIImpulseStrongMutBunch(id);
    }
  }
  public void CheckHasIImpulseStrongMutBunch(IImpulseStrongMutBunch thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasIImpulseStrongMutBunch(thing.id);
  }
  public void CheckHasIImpulseStrongMutBunch(int id) {
    if (!rootIncarnation.incarnationsIImpulseStrongMutBunch.ContainsKey(id)) {
      throw new System.Exception("Invalid IImpulseStrongMutBunch: " + id);
    }
  }
  public IImpulseStrongMutBunch EffectIImpulseStrongMutBunchCreate(
      HoldPositionImpulseStrongMutSet membersHoldPositionImpulseStrongMutSet,
      TemporaryCloneImpulseStrongMutSet membersTemporaryCloneImpulseStrongMutSet,
      SummonImpulseStrongMutSet membersSummonImpulseStrongMutSet,
      MireImpulseStrongMutSet membersMireImpulseStrongMutSet,
      EvaporateImpulseStrongMutSet membersEvaporateImpulseStrongMutSet,
      MoveImpulseStrongMutSet membersMoveImpulseStrongMutSet,
      KamikazeJumpImpulseStrongMutSet membersKamikazeJumpImpulseStrongMutSet,
      KamikazeTargetImpulseStrongMutSet membersKamikazeTargetImpulseStrongMutSet,
      NoImpulseStrongMutSet membersNoImpulseStrongMutSet,
      EvolvifyImpulseStrongMutSet membersEvolvifyImpulseStrongMutSet,
      FireImpulseStrongMutSet membersFireImpulseStrongMutSet,
      DefyImpulseStrongMutSet membersDefyImpulseStrongMutSet,
      CounterImpulseStrongMutSet membersCounterImpulseStrongMutSet,
      UnleashBideImpulseStrongMutSet membersUnleashBideImpulseStrongMutSet,
      ContinueBidingImpulseStrongMutSet membersContinueBidingImpulseStrongMutSet,
      StartBidingImpulseStrongMutSet membersStartBidingImpulseStrongMutSet,
      AttackImpulseStrongMutSet membersAttackImpulseStrongMutSet,
      PursueImpulseStrongMutSet membersPursueImpulseStrongMutSet,
      FireBombImpulseStrongMutSet membersFireBombImpulseStrongMutSet) {
    CheckHasHoldPositionImpulseStrongMutSet(membersHoldPositionImpulseStrongMutSet);
    CheckHasTemporaryCloneImpulseStrongMutSet(membersTemporaryCloneImpulseStrongMutSet);
    CheckHasSummonImpulseStrongMutSet(membersSummonImpulseStrongMutSet);
    CheckHasMireImpulseStrongMutSet(membersMireImpulseStrongMutSet);
    CheckHasEvaporateImpulseStrongMutSet(membersEvaporateImpulseStrongMutSet);
    CheckHasMoveImpulseStrongMutSet(membersMoveImpulseStrongMutSet);
    CheckHasKamikazeJumpImpulseStrongMutSet(membersKamikazeJumpImpulseStrongMutSet);
    CheckHasKamikazeTargetImpulseStrongMutSet(membersKamikazeTargetImpulseStrongMutSet);
    CheckHasNoImpulseStrongMutSet(membersNoImpulseStrongMutSet);
    CheckHasEvolvifyImpulseStrongMutSet(membersEvolvifyImpulseStrongMutSet);
    CheckHasFireImpulseStrongMutSet(membersFireImpulseStrongMutSet);
    CheckHasDefyImpulseStrongMutSet(membersDefyImpulseStrongMutSet);
    CheckHasCounterImpulseStrongMutSet(membersCounterImpulseStrongMutSet);
    CheckHasUnleashBideImpulseStrongMutSet(membersUnleashBideImpulseStrongMutSet);
    CheckHasContinueBidingImpulseStrongMutSet(membersContinueBidingImpulseStrongMutSet);
    CheckHasStartBidingImpulseStrongMutSet(membersStartBidingImpulseStrongMutSet);
    CheckHasAttackImpulseStrongMutSet(membersAttackImpulseStrongMutSet);
    CheckHasPursueImpulseStrongMutSet(membersPursueImpulseStrongMutSet);
    CheckHasFireBombImpulseStrongMutSet(membersFireBombImpulseStrongMutSet);
    return TrustedEffectIImpulseStrongMutBunchCreateWithId(NewId()
            ,membersHoldPositionImpulseStrongMutSet.id
            ,membersTemporaryCloneImpulseStrongMutSet.id
            ,membersSummonImpulseStrongMutSet.id
            ,membersMireImpulseStrongMutSet.id
            ,membersEvaporateImpulseStrongMutSet.id
            ,membersMoveImpulseStrongMutSet.id
            ,membersKamikazeJumpImpulseStrongMutSet.id
            ,membersKamikazeTargetImpulseStrongMutSet.id
            ,membersNoImpulseStrongMutSet.id
            ,membersEvolvifyImpulseStrongMutSet.id
            ,membersFireImpulseStrongMutSet.id
            ,membersDefyImpulseStrongMutSet.id
            ,membersCounterImpulseStrongMutSet.id
            ,membersUnleashBideImpulseStrongMutSet.id
            ,membersContinueBidingImpulseStrongMutSet.id
            ,membersStartBidingImpulseStrongMutSet.id
            ,membersAttackImpulseStrongMutSet.id
            ,membersPursueImpulseStrongMutSet.id
            ,membersFireBombImpulseStrongMutSet.id    );
  }
  public IImpulseStrongMutBunch TrustedEffectIImpulseStrongMutBunchCreateWithId(int id
,      int membersHoldPositionImpulseStrongMutSet
,      int membersTemporaryCloneImpulseStrongMutSet
,      int membersSummonImpulseStrongMutSet
,      int membersMireImpulseStrongMutSet
,      int membersEvaporateImpulseStrongMutSet
,      int membersMoveImpulseStrongMutSet
,      int membersKamikazeJumpImpulseStrongMutSet
,      int membersKamikazeTargetImpulseStrongMutSet
,      int membersNoImpulseStrongMutSet
,      int membersEvolvifyImpulseStrongMutSet
,      int membersFireImpulseStrongMutSet
,      int membersDefyImpulseStrongMutSet
,      int membersCounterImpulseStrongMutSet
,      int membersUnleashBideImpulseStrongMutSet
,      int membersContinueBidingImpulseStrongMutSet
,      int membersStartBidingImpulseStrongMutSet
,      int membersAttackImpulseStrongMutSet
,      int membersPursueImpulseStrongMutSet
,      int membersFireBombImpulseStrongMutSet) {
    CheckUnlocked();

    var incarnation =
        new IImpulseStrongMutBunchIncarnation(
            membersHoldPositionImpulseStrongMutSet,
            membersTemporaryCloneImpulseStrongMutSet,
            membersSummonImpulseStrongMutSet,
            membersMireImpulseStrongMutSet,
            membersEvaporateImpulseStrongMutSet,
            membersMoveImpulseStrongMutSet,
            membersKamikazeJumpImpulseStrongMutSet,
            membersKamikazeTargetImpulseStrongMutSet,
            membersNoImpulseStrongMutSet,
            membersEvolvifyImpulseStrongMutSet,
            membersFireImpulseStrongMutSet,
            membersDefyImpulseStrongMutSet,
            membersCounterImpulseStrongMutSet,
            membersUnleashBideImpulseStrongMutSet,
            membersContinueBidingImpulseStrongMutSet,
            membersStartBidingImpulseStrongMutSet,
            membersAttackImpulseStrongMutSet,
            membersPursueImpulseStrongMutSet,
            membersFireBombImpulseStrongMutSet
            );
    var effect = InternalEffectCreateIImpulseStrongMutBunch(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new IImpulseStrongMutBunch(this, id);
  }
  public IImpulseStrongMutBunchCreateEffect InternalEffectCreateIImpulseStrongMutBunch(
      int id,
      int incarnationVersion,
      IImpulseStrongMutBunchIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsIImpulseStrongMutBunch.Add(
        id,
        new VersionAndIncarnation<IImpulseStrongMutBunchIncarnation>(
            incarnationVersion,
            incarnation));
    return new IImpulseStrongMutBunchCreateEffect(id, incarnation.Copy());
  }

  public void EffectIImpulseStrongMutBunchDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectIImpulseStrongMutBunchDelete(id);
    NotifyEffect(effect);
  }
  public IImpulseStrongMutBunchDeleteEffect InternalEffectIImpulseStrongMutBunchDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsIImpulseStrongMutBunch[id];

    rootIncarnation.incarnationsIImpulseStrongMutBunch.Remove(id);
    return new IImpulseStrongMutBunchDeleteEffect(id);
  }

     
  public int GetIImpulseStrongMutBunchHash(int id, int version, IImpulseStrongMutBunchIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.membersHoldPositionImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.membersTemporaryCloneImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.membersSummonImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.membersMireImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 5 * incarnation.membersEvaporateImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 6 * incarnation.membersMoveImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 7 * incarnation.membersKamikazeJumpImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 8 * incarnation.membersKamikazeTargetImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 9 * incarnation.membersNoImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 10 * incarnation.membersEvolvifyImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 11 * incarnation.membersFireImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 12 * incarnation.membersDefyImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 13 * incarnation.membersCounterImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 14 * incarnation.membersUnleashBideImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 15 * incarnation.membersContinueBidingImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 16 * incarnation.membersStartBidingImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 17 * incarnation.membersAttackImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 18 * incarnation.membersPursueImpulseStrongMutSet.GetDeterministicHashCode();
    result += id * version * 19 * incarnation.membersFireBombImpulseStrongMutSet.GetDeterministicHashCode();
    return result;
  }
       public IItemStrongMutBunchIncarnation GetIItemStrongMutBunchIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsIItemStrongMutBunch[id].incarnation;
  }
  public bool IItemStrongMutBunchExists(int id) {
    return rootIncarnation.incarnationsIItemStrongMutBunch.ContainsKey(id);
  }
  public IItemStrongMutBunch GetIItemStrongMutBunch(int id) {
    CheckHasIItemStrongMutBunch(id);
    return new IItemStrongMutBunch(this, id);
  }
  public IItemStrongMutBunch GetIItemStrongMutBunchOrNull(int id) {
    if (IItemStrongMutBunchExists(id)) {
      return new IItemStrongMutBunch(this, id);
    } else {
      return new IItemStrongMutBunch(this, 0);
    }
  }
  public List<IItemStrongMutBunch> AllIItemStrongMutBunch() {
    List<IItemStrongMutBunch> result = new List<IItemStrongMutBunch>(rootIncarnation.incarnationsIItemStrongMutBunch.Count);
    foreach (var id in rootIncarnation.incarnationsIItemStrongMutBunch.Keys) {
      result.Add(new IItemStrongMutBunch(this, id));
    }
    return result;
  }
  public IEnumerator<IItemStrongMutBunch> EnumAllIItemStrongMutBunch() {
    foreach (var id in rootIncarnation.incarnationsIItemStrongMutBunch.Keys) {
      yield return GetIItemStrongMutBunch(id);
    }
  }
  public void CheckHasIItemStrongMutBunch(IItemStrongMutBunch thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasIItemStrongMutBunch(thing.id);
  }
  public void CheckHasIItemStrongMutBunch(int id) {
    if (!rootIncarnation.incarnationsIItemStrongMutBunch.ContainsKey(id)) {
      throw new System.Exception("Invalid IItemStrongMutBunch: " + id);
    }
  }
  public IItemStrongMutBunch EffectIItemStrongMutBunchCreate(
      ManaPotionStrongMutSet membersManaPotionStrongMutSet,
      HealthPotionStrongMutSet membersHealthPotionStrongMutSet,
      SpeedRingStrongMutSet membersSpeedRingStrongMutSet,
      GlaiveStrongMutSet membersGlaiveStrongMutSet,
      SlowRodStrongMutSet membersSlowRodStrongMutSet,
      ExplosionRodStrongMutSet membersExplosionRodStrongMutSet,
      BlazeRodStrongMutSet membersBlazeRodStrongMutSet,
      BlastRodStrongMutSet membersBlastRodStrongMutSet,
      ArmorStrongMutSet membersArmorStrongMutSet) {
    CheckHasManaPotionStrongMutSet(membersManaPotionStrongMutSet);
    CheckHasHealthPotionStrongMutSet(membersHealthPotionStrongMutSet);
    CheckHasSpeedRingStrongMutSet(membersSpeedRingStrongMutSet);
    CheckHasGlaiveStrongMutSet(membersGlaiveStrongMutSet);
    CheckHasSlowRodStrongMutSet(membersSlowRodStrongMutSet);
    CheckHasExplosionRodStrongMutSet(membersExplosionRodStrongMutSet);
    CheckHasBlazeRodStrongMutSet(membersBlazeRodStrongMutSet);
    CheckHasBlastRodStrongMutSet(membersBlastRodStrongMutSet);
    CheckHasArmorStrongMutSet(membersArmorStrongMutSet);
    return TrustedEffectIItemStrongMutBunchCreateWithId(NewId()
            ,membersManaPotionStrongMutSet.id
            ,membersHealthPotionStrongMutSet.id
            ,membersSpeedRingStrongMutSet.id
            ,membersGlaiveStrongMutSet.id
            ,membersSlowRodStrongMutSet.id
            ,membersExplosionRodStrongMutSet.id
            ,membersBlazeRodStrongMutSet.id
            ,membersBlastRodStrongMutSet.id
            ,membersArmorStrongMutSet.id    );
  }
  public IItemStrongMutBunch TrustedEffectIItemStrongMutBunchCreateWithId(int id
,      int membersManaPotionStrongMutSet
,      int membersHealthPotionStrongMutSet
,      int membersSpeedRingStrongMutSet
,      int membersGlaiveStrongMutSet
,      int membersSlowRodStrongMutSet
,      int membersExplosionRodStrongMutSet
,      int membersBlazeRodStrongMutSet
,      int membersBlastRodStrongMutSet
,      int membersArmorStrongMutSet) {
    CheckUnlocked();

    var incarnation =
        new IItemStrongMutBunchIncarnation(
            membersManaPotionStrongMutSet,
            membersHealthPotionStrongMutSet,
            membersSpeedRingStrongMutSet,
            membersGlaiveStrongMutSet,
            membersSlowRodStrongMutSet,
            membersExplosionRodStrongMutSet,
            membersBlazeRodStrongMutSet,
            membersBlastRodStrongMutSet,
            membersArmorStrongMutSet
            );
    var effect = InternalEffectCreateIItemStrongMutBunch(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new IItemStrongMutBunch(this, id);
  }
  public IItemStrongMutBunchCreateEffect InternalEffectCreateIItemStrongMutBunch(
      int id,
      int incarnationVersion,
      IItemStrongMutBunchIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsIItemStrongMutBunch.Add(
        id,
        new VersionAndIncarnation<IItemStrongMutBunchIncarnation>(
            incarnationVersion,
            incarnation));
    return new IItemStrongMutBunchCreateEffect(id, incarnation.Copy());
  }

  public void EffectIItemStrongMutBunchDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectIItemStrongMutBunchDelete(id);
    NotifyEffect(effect);
  }
  public IItemStrongMutBunchDeleteEffect InternalEffectIItemStrongMutBunchDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsIItemStrongMutBunch[id];

    rootIncarnation.incarnationsIItemStrongMutBunch.Remove(id);
    return new IItemStrongMutBunchDeleteEffect(id);
  }

     
  public int GetIItemStrongMutBunchHash(int id, int version, IItemStrongMutBunchIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.membersManaPotionStrongMutSet.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.membersHealthPotionStrongMutSet.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.membersSpeedRingStrongMutSet.GetDeterministicHashCode();
    result += id * version * 4 * incarnation.membersGlaiveStrongMutSet.GetDeterministicHashCode();
    result += id * version * 5 * incarnation.membersSlowRodStrongMutSet.GetDeterministicHashCode();
    result += id * version * 6 * incarnation.membersExplosionRodStrongMutSet.GetDeterministicHashCode();
    result += id * version * 7 * incarnation.membersBlazeRodStrongMutSet.GetDeterministicHashCode();
    result += id * version * 8 * incarnation.membersBlastRodStrongMutSet.GetDeterministicHashCode();
    result += id * version * 9 * incarnation.membersArmorStrongMutSet.GetDeterministicHashCode();
    return result;
  }
       public ItemTTCIncarnation GetItemTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsItemTTC[id].incarnation;
  }
  public bool ItemTTCExists(int id) {
    return rootIncarnation.incarnationsItemTTC.ContainsKey(id);
  }
  public ItemTTC GetItemTTC(int id) {
    CheckHasItemTTC(id);
    return new ItemTTC(this, id);
  }
  public ItemTTC GetItemTTCOrNull(int id) {
    if (ItemTTCExists(id)) {
      return new ItemTTC(this, id);
    } else {
      return new ItemTTC(this, 0);
    }
  }
  public List<ItemTTC> AllItemTTC() {
    List<ItemTTC> result = new List<ItemTTC>(rootIncarnation.incarnationsItemTTC.Count);
    foreach (var id in rootIncarnation.incarnationsItemTTC.Keys) {
      result.Add(new ItemTTC(this, id));
    }
    return result;
  }
  public IEnumerator<ItemTTC> EnumAllItemTTC() {
    foreach (var id in rootIncarnation.incarnationsItemTTC.Keys) {
      yield return GetItemTTC(id);
    }
  }
  public void CheckHasItemTTC(ItemTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasItemTTC(thing.id);
  }
  public void CheckHasItemTTC(int id) {
    if (!rootIncarnation.incarnationsItemTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid ItemTTC: " + id);
    }
  }
  public ItemTTC EffectItemTTCCreate(
      IItem item) {
    CheckHasIItem(item);
    return TrustedEffectItemTTCCreateWithId(NewId()
            ,item.id    );
  }
  public ItemTTC TrustedEffectItemTTCCreateWithId(int id
,      int item) {
    CheckUnlocked();

    var incarnation =
        new ItemTTCIncarnation(
            item
            );
    var effect = InternalEffectCreateItemTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new ItemTTC(this, id);
  }
  public ItemTTCCreateEffect InternalEffectCreateItemTTC(
      int id,
      int incarnationVersion,
      ItemTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsItemTTC.Add(
        id,
        new VersionAndIncarnation<ItemTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new ItemTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectItemTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectItemTTCDelete(id);
    NotifyEffect(effect);
  }
  public ItemTTCDeleteEffect InternalEffectItemTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsItemTTC[id];

    rootIncarnation.incarnationsItemTTC.Remove(id);
    return new ItemTTCDeleteEffect(id);
  }

     
  public int GetItemTTCHash(int id, int version, ItemTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.item.GetDeterministicHashCode();
    return result;
  }
       public HealthPotionIncarnation GetHealthPotionIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsHealthPotion[id].incarnation;
  }
  public bool HealthPotionExists(int id) {
    return rootIncarnation.incarnationsHealthPotion.ContainsKey(id);
  }
  public HealthPotion GetHealthPotion(int id) {
    CheckHasHealthPotion(id);
    return new HealthPotion(this, id);
  }
  public HealthPotion GetHealthPotionOrNull(int id) {
    if (HealthPotionExists(id)) {
      return new HealthPotion(this, id);
    } else {
      return new HealthPotion(this, 0);
    }
  }
  public List<HealthPotion> AllHealthPotion() {
    List<HealthPotion> result = new List<HealthPotion>(rootIncarnation.incarnationsHealthPotion.Count);
    foreach (var id in rootIncarnation.incarnationsHealthPotion.Keys) {
      result.Add(new HealthPotion(this, id));
    }
    return result;
  }
  public IEnumerator<HealthPotion> EnumAllHealthPotion() {
    foreach (var id in rootIncarnation.incarnationsHealthPotion.Keys) {
      yield return GetHealthPotion(id);
    }
  }
  public void CheckHasHealthPotion(HealthPotion thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasHealthPotion(thing.id);
  }
  public void CheckHasHealthPotion(int id) {
    if (!rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      throw new System.Exception("Invalid HealthPotion: " + id);
    }
  }
  public HealthPotion EffectHealthPotionCreate(
) {
    return TrustedEffectHealthPotionCreateWithId(NewId()
    );
  }
  public HealthPotion TrustedEffectHealthPotionCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new HealthPotionIncarnation(

            );
    var effect = InternalEffectCreateHealthPotion(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new HealthPotion(this, id);
  }
  public HealthPotionCreateEffect InternalEffectCreateHealthPotion(
      int id,
      int incarnationVersion,
      HealthPotionIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsHealthPotion.Add(
        id,
        new VersionAndIncarnation<HealthPotionIncarnation>(
            incarnationVersion,
            incarnation));
    return new HealthPotionCreateEffect(id, incarnation.Copy());
  }

  public void EffectHealthPotionDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectHealthPotionDelete(id);
    NotifyEffect(effect);
  }
  public HealthPotionDeleteEffect InternalEffectHealthPotionDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsHealthPotion[id];

    rootIncarnation.incarnationsHealthPotion.Remove(id);
    return new HealthPotionDeleteEffect(id);
  }

     
  public int GetHealthPotionHash(int id, int version, HealthPotionIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public GlaiveIncarnation GetGlaiveIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsGlaive[id].incarnation;
  }
  public bool GlaiveExists(int id) {
    return rootIncarnation.incarnationsGlaive.ContainsKey(id);
  }
  public Glaive GetGlaive(int id) {
    CheckHasGlaive(id);
    return new Glaive(this, id);
  }
  public Glaive GetGlaiveOrNull(int id) {
    if (GlaiveExists(id)) {
      return new Glaive(this, id);
    } else {
      return new Glaive(this, 0);
    }
  }
  public List<Glaive> AllGlaive() {
    List<Glaive> result = new List<Glaive>(rootIncarnation.incarnationsGlaive.Count);
    foreach (var id in rootIncarnation.incarnationsGlaive.Keys) {
      result.Add(new Glaive(this, id));
    }
    return result;
  }
  public IEnumerator<Glaive> EnumAllGlaive() {
    foreach (var id in rootIncarnation.incarnationsGlaive.Keys) {
      yield return GetGlaive(id);
    }
  }
  public void CheckHasGlaive(Glaive thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasGlaive(thing.id);
  }
  public void CheckHasGlaive(int id) {
    if (!rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      throw new System.Exception("Invalid Glaive: " + id);
    }
  }
  public Glaive EffectGlaiveCreate(
) {
    return TrustedEffectGlaiveCreateWithId(NewId()
    );
  }
  public Glaive TrustedEffectGlaiveCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new GlaiveIncarnation(

            );
    var effect = InternalEffectCreateGlaive(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new Glaive(this, id);
  }
  public GlaiveCreateEffect InternalEffectCreateGlaive(
      int id,
      int incarnationVersion,
      GlaiveIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsGlaive.Add(
        id,
        new VersionAndIncarnation<GlaiveIncarnation>(
            incarnationVersion,
            incarnation));
    return new GlaiveCreateEffect(id, incarnation.Copy());
  }

  public void EffectGlaiveDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectGlaiveDelete(id);
    NotifyEffect(effect);
  }
  public GlaiveDeleteEffect InternalEffectGlaiveDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsGlaive[id];

    rootIncarnation.incarnationsGlaive.Remove(id);
    return new GlaiveDeleteEffect(id);
  }

     
  public int GetGlaiveHash(int id, int version, GlaiveIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public SlowRodIncarnation GetSlowRodIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsSlowRod[id].incarnation;
  }
  public bool SlowRodExists(int id) {
    return rootIncarnation.incarnationsSlowRod.ContainsKey(id);
  }
  public SlowRod GetSlowRod(int id) {
    CheckHasSlowRod(id);
    return new SlowRod(this, id);
  }
  public SlowRod GetSlowRodOrNull(int id) {
    if (SlowRodExists(id)) {
      return new SlowRod(this, id);
    } else {
      return new SlowRod(this, 0);
    }
  }
  public List<SlowRod> AllSlowRod() {
    List<SlowRod> result = new List<SlowRod>(rootIncarnation.incarnationsSlowRod.Count);
    foreach (var id in rootIncarnation.incarnationsSlowRod.Keys) {
      result.Add(new SlowRod(this, id));
    }
    return result;
  }
  public IEnumerator<SlowRod> EnumAllSlowRod() {
    foreach (var id in rootIncarnation.incarnationsSlowRod.Keys) {
      yield return GetSlowRod(id);
    }
  }
  public void CheckHasSlowRod(SlowRod thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasSlowRod(thing.id);
  }
  public void CheckHasSlowRod(int id) {
    if (!rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      throw new System.Exception("Invalid SlowRod: " + id);
    }
  }
  public SlowRod EffectSlowRodCreate(
) {
    return TrustedEffectSlowRodCreateWithId(NewId()
    );
  }
  public SlowRod TrustedEffectSlowRodCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new SlowRodIncarnation(

            );
    var effect = InternalEffectCreateSlowRod(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new SlowRod(this, id);
  }
  public SlowRodCreateEffect InternalEffectCreateSlowRod(
      int id,
      int incarnationVersion,
      SlowRodIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsSlowRod.Add(
        id,
        new VersionAndIncarnation<SlowRodIncarnation>(
            incarnationVersion,
            incarnation));
    return new SlowRodCreateEffect(id, incarnation.Copy());
  }

  public void EffectSlowRodDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectSlowRodDelete(id);
    NotifyEffect(effect);
  }
  public SlowRodDeleteEffect InternalEffectSlowRodDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsSlowRod[id];

    rootIncarnation.incarnationsSlowRod.Remove(id);
    return new SlowRodDeleteEffect(id);
  }

     
  public int GetSlowRodHash(int id, int version, SlowRodIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public ExplosionRodIncarnation GetExplosionRodIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsExplosionRod[id].incarnation;
  }
  public bool ExplosionRodExists(int id) {
    return rootIncarnation.incarnationsExplosionRod.ContainsKey(id);
  }
  public ExplosionRod GetExplosionRod(int id) {
    CheckHasExplosionRod(id);
    return new ExplosionRod(this, id);
  }
  public ExplosionRod GetExplosionRodOrNull(int id) {
    if (ExplosionRodExists(id)) {
      return new ExplosionRod(this, id);
    } else {
      return new ExplosionRod(this, 0);
    }
  }
  public List<ExplosionRod> AllExplosionRod() {
    List<ExplosionRod> result = new List<ExplosionRod>(rootIncarnation.incarnationsExplosionRod.Count);
    foreach (var id in rootIncarnation.incarnationsExplosionRod.Keys) {
      result.Add(new ExplosionRod(this, id));
    }
    return result;
  }
  public IEnumerator<ExplosionRod> EnumAllExplosionRod() {
    foreach (var id in rootIncarnation.incarnationsExplosionRod.Keys) {
      yield return GetExplosionRod(id);
    }
  }
  public void CheckHasExplosionRod(ExplosionRod thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasExplosionRod(thing.id);
  }
  public void CheckHasExplosionRod(int id) {
    if (!rootIncarnation.incarnationsExplosionRod.ContainsKey(id)) {
      throw new System.Exception("Invalid ExplosionRod: " + id);
    }
  }
  public ExplosionRod EffectExplosionRodCreate(
) {
    return TrustedEffectExplosionRodCreateWithId(NewId()
    );
  }
  public ExplosionRod TrustedEffectExplosionRodCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new ExplosionRodIncarnation(

            );
    var effect = InternalEffectCreateExplosionRod(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new ExplosionRod(this, id);
  }
  public ExplosionRodCreateEffect InternalEffectCreateExplosionRod(
      int id,
      int incarnationVersion,
      ExplosionRodIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsExplosionRod.Add(
        id,
        new VersionAndIncarnation<ExplosionRodIncarnation>(
            incarnationVersion,
            incarnation));
    return new ExplosionRodCreateEffect(id, incarnation.Copy());
  }

  public void EffectExplosionRodDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectExplosionRodDelete(id);
    NotifyEffect(effect);
  }
  public ExplosionRodDeleteEffect InternalEffectExplosionRodDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsExplosionRod[id];

    rootIncarnation.incarnationsExplosionRod.Remove(id);
    return new ExplosionRodDeleteEffect(id);
  }

     
  public int GetExplosionRodHash(int id, int version, ExplosionRodIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public BlazeRodIncarnation GetBlazeRodIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBlazeRod[id].incarnation;
  }
  public bool BlazeRodExists(int id) {
    return rootIncarnation.incarnationsBlazeRod.ContainsKey(id);
  }
  public BlazeRod GetBlazeRod(int id) {
    CheckHasBlazeRod(id);
    return new BlazeRod(this, id);
  }
  public BlazeRod GetBlazeRodOrNull(int id) {
    if (BlazeRodExists(id)) {
      return new BlazeRod(this, id);
    } else {
      return new BlazeRod(this, 0);
    }
  }
  public List<BlazeRod> AllBlazeRod() {
    List<BlazeRod> result = new List<BlazeRod>(rootIncarnation.incarnationsBlazeRod.Count);
    foreach (var id in rootIncarnation.incarnationsBlazeRod.Keys) {
      result.Add(new BlazeRod(this, id));
    }
    return result;
  }
  public IEnumerator<BlazeRod> EnumAllBlazeRod() {
    foreach (var id in rootIncarnation.incarnationsBlazeRod.Keys) {
      yield return GetBlazeRod(id);
    }
  }
  public void CheckHasBlazeRod(BlazeRod thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBlazeRod(thing.id);
  }
  public void CheckHasBlazeRod(int id) {
    if (!rootIncarnation.incarnationsBlazeRod.ContainsKey(id)) {
      throw new System.Exception("Invalid BlazeRod: " + id);
    }
  }
  public BlazeRod EffectBlazeRodCreate(
) {
    return TrustedEffectBlazeRodCreateWithId(NewId()
    );
  }
  public BlazeRod TrustedEffectBlazeRodCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new BlazeRodIncarnation(

            );
    var effect = InternalEffectCreateBlazeRod(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new BlazeRod(this, id);
  }
  public BlazeRodCreateEffect InternalEffectCreateBlazeRod(
      int id,
      int incarnationVersion,
      BlazeRodIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsBlazeRod.Add(
        id,
        new VersionAndIncarnation<BlazeRodIncarnation>(
            incarnationVersion,
            incarnation));
    return new BlazeRodCreateEffect(id, incarnation.Copy());
  }

  public void EffectBlazeRodDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectBlazeRodDelete(id);
    NotifyEffect(effect);
  }
  public BlazeRodDeleteEffect InternalEffectBlazeRodDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBlazeRod[id];

    rootIncarnation.incarnationsBlazeRod.Remove(id);
    return new BlazeRodDeleteEffect(id);
  }

     
  public int GetBlazeRodHash(int id, int version, BlazeRodIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public BlastRodIncarnation GetBlastRodIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBlastRod[id].incarnation;
  }
  public bool BlastRodExists(int id) {
    return rootIncarnation.incarnationsBlastRod.ContainsKey(id);
  }
  public BlastRod GetBlastRod(int id) {
    CheckHasBlastRod(id);
    return new BlastRod(this, id);
  }
  public BlastRod GetBlastRodOrNull(int id) {
    if (BlastRodExists(id)) {
      return new BlastRod(this, id);
    } else {
      return new BlastRod(this, 0);
    }
  }
  public List<BlastRod> AllBlastRod() {
    List<BlastRod> result = new List<BlastRod>(rootIncarnation.incarnationsBlastRod.Count);
    foreach (var id in rootIncarnation.incarnationsBlastRod.Keys) {
      result.Add(new BlastRod(this, id));
    }
    return result;
  }
  public IEnumerator<BlastRod> EnumAllBlastRod() {
    foreach (var id in rootIncarnation.incarnationsBlastRod.Keys) {
      yield return GetBlastRod(id);
    }
  }
  public void CheckHasBlastRod(BlastRod thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBlastRod(thing.id);
  }
  public void CheckHasBlastRod(int id) {
    if (!rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      throw new System.Exception("Invalid BlastRod: " + id);
    }
  }
  public BlastRod EffectBlastRodCreate(
) {
    return TrustedEffectBlastRodCreateWithId(NewId()
    );
  }
  public BlastRod TrustedEffectBlastRodCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new BlastRodIncarnation(

            );
    var effect = InternalEffectCreateBlastRod(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new BlastRod(this, id);
  }
  public BlastRodCreateEffect InternalEffectCreateBlastRod(
      int id,
      int incarnationVersion,
      BlastRodIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsBlastRod.Add(
        id,
        new VersionAndIncarnation<BlastRodIncarnation>(
            incarnationVersion,
            incarnation));
    return new BlastRodCreateEffect(id, incarnation.Copy());
  }

  public void EffectBlastRodDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectBlastRodDelete(id);
    NotifyEffect(effect);
  }
  public BlastRodDeleteEffect InternalEffectBlastRodDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBlastRod[id];

    rootIncarnation.incarnationsBlastRod.Remove(id);
    return new BlastRodDeleteEffect(id);
  }

     
  public int GetBlastRodHash(int id, int version, BlastRodIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public ArmorIncarnation GetArmorIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsArmor[id].incarnation;
  }
  public bool ArmorExists(int id) {
    return rootIncarnation.incarnationsArmor.ContainsKey(id);
  }
  public Armor GetArmor(int id) {
    CheckHasArmor(id);
    return new Armor(this, id);
  }
  public Armor GetArmorOrNull(int id) {
    if (ArmorExists(id)) {
      return new Armor(this, id);
    } else {
      return new Armor(this, 0);
    }
  }
  public List<Armor> AllArmor() {
    List<Armor> result = new List<Armor>(rootIncarnation.incarnationsArmor.Count);
    foreach (var id in rootIncarnation.incarnationsArmor.Keys) {
      result.Add(new Armor(this, id));
    }
    return result;
  }
  public IEnumerator<Armor> EnumAllArmor() {
    foreach (var id in rootIncarnation.incarnationsArmor.Keys) {
      yield return GetArmor(id);
    }
  }
  public void CheckHasArmor(Armor thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasArmor(thing.id);
  }
  public void CheckHasArmor(int id) {
    if (!rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      throw new System.Exception("Invalid Armor: " + id);
    }
  }
  public Armor EffectArmorCreate(
) {
    return TrustedEffectArmorCreateWithId(NewId()
    );
  }
  public Armor TrustedEffectArmorCreateWithId(int id
) {
    CheckUnlocked();

    var incarnation =
        new ArmorIncarnation(

            );
    var effect = InternalEffectCreateArmor(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new Armor(this, id);
  }
  public ArmorCreateEffect InternalEffectCreateArmor(
      int id,
      int incarnationVersion,
      ArmorIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsArmor.Add(
        id,
        new VersionAndIncarnation<ArmorIncarnation>(
            incarnationVersion,
            incarnation));
    return new ArmorCreateEffect(id, incarnation.Copy());
  }

  public void EffectArmorDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectArmorDelete(id);
    NotifyEffect(effect);
  }
  public ArmorDeleteEffect InternalEffectArmorDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsArmor[id];

    rootIncarnation.incarnationsArmor.Remove(id);
    return new ArmorDeleteEffect(id);
  }

     
  public int GetArmorHash(int id, int version, ArmorIncarnation incarnation) {
    int result = id * version;
    return result;
  }
       public VolcaetusLevelControllerIncarnation GetVolcaetusLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsVolcaetusLevelController[id].incarnation;
  }
  public bool VolcaetusLevelControllerExists(int id) {
    return rootIncarnation.incarnationsVolcaetusLevelController.ContainsKey(id);
  }
  public VolcaetusLevelController GetVolcaetusLevelController(int id) {
    CheckHasVolcaetusLevelController(id);
    return new VolcaetusLevelController(this, id);
  }
  public VolcaetusLevelController GetVolcaetusLevelControllerOrNull(int id) {
    if (VolcaetusLevelControllerExists(id)) {
      return new VolcaetusLevelController(this, id);
    } else {
      return new VolcaetusLevelController(this, 0);
    }
  }
  public List<VolcaetusLevelController> AllVolcaetusLevelController() {
    List<VolcaetusLevelController> result = new List<VolcaetusLevelController>(rootIncarnation.incarnationsVolcaetusLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsVolcaetusLevelController.Keys) {
      result.Add(new VolcaetusLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<VolcaetusLevelController> EnumAllVolcaetusLevelController() {
    foreach (var id in rootIncarnation.incarnationsVolcaetusLevelController.Keys) {
      yield return GetVolcaetusLevelController(id);
    }
  }
  public void CheckHasVolcaetusLevelController(VolcaetusLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasVolcaetusLevelController(thing.id);
  }
  public void CheckHasVolcaetusLevelController(int id) {
    if (!rootIncarnation.incarnationsVolcaetusLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid VolcaetusLevelController: " + id);
    }
  }
  public VolcaetusLevelController EffectVolcaetusLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectVolcaetusLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public VolcaetusLevelController TrustedEffectVolcaetusLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new VolcaetusLevelControllerIncarnation(
            level
            );
    var effect = InternalEffectCreateVolcaetusLevelController(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new VolcaetusLevelController(this, id);
  }
  public VolcaetusLevelControllerCreateEffect InternalEffectCreateVolcaetusLevelController(
      int id,
      int incarnationVersion,
      VolcaetusLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsVolcaetusLevelController.Add(
        id,
        new VersionAndIncarnation<VolcaetusLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    return new VolcaetusLevelControllerCreateEffect(id, incarnation.Copy());
  }

  public void EffectVolcaetusLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectVolcaetusLevelControllerDelete(id);
    NotifyEffect(effect);
  }
  public VolcaetusLevelControllerDeleteEffect InternalEffectVolcaetusLevelControllerDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsVolcaetusLevelController[id];

    rootIncarnation.incarnationsVolcaetusLevelController.Remove(id);
    return new VolcaetusLevelControllerDeleteEffect(id);
  }

     
  public int GetVolcaetusLevelControllerHash(int id, int version, VolcaetusLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public Tutorial2LevelControllerIncarnation GetTutorial2LevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTutorial2LevelController[id].incarnation;
  }
  public bool Tutorial2LevelControllerExists(int id) {
    return rootIncarnation.incarnationsTutorial2LevelController.ContainsKey(id);
  }
  public Tutorial2LevelController GetTutorial2LevelController(int id) {
    CheckHasTutorial2LevelController(id);
    return new Tutorial2LevelController(this, id);
  }
  public Tutorial2LevelController GetTutorial2LevelControllerOrNull(int id) {
    if (Tutorial2LevelControllerExists(id)) {
      return new Tutorial2LevelController(this, id);
    } else {
      return new Tutorial2LevelController(this, 0);
    }
  }
  public List<Tutorial2LevelController> AllTutorial2LevelController() {
    List<Tutorial2LevelController> result = new List<Tutorial2LevelController>(rootIncarnation.incarnationsTutorial2LevelController.Count);
    foreach (var id in rootIncarnation.incarnationsTutorial2LevelController.Keys) {
      result.Add(new Tutorial2LevelController(this, id));
    }
    return result;
  }
  public IEnumerator<Tutorial2LevelController> EnumAllTutorial2LevelController() {
    foreach (var id in rootIncarnation.incarnationsTutorial2LevelController.Keys) {
      yield return GetTutorial2LevelController(id);
    }
  }
  public void CheckHasTutorial2LevelController(Tutorial2LevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTutorial2LevelController(thing.id);
  }
  public void CheckHasTutorial2LevelController(int id) {
    if (!rootIncarnation.incarnationsTutorial2LevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid Tutorial2LevelController: " + id);
    }
  }
  public Tutorial2LevelController EffectTutorial2LevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectTutorial2LevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public Tutorial2LevelController TrustedEffectTutorial2LevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new Tutorial2LevelControllerIncarnation(
            level
            );
    var effect = InternalEffectCreateTutorial2LevelController(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new Tutorial2LevelController(this, id);
  }
  public Tutorial2LevelControllerCreateEffect InternalEffectCreateTutorial2LevelController(
      int id,
      int incarnationVersion,
      Tutorial2LevelControllerIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsTutorial2LevelController.Add(
        id,
        new VersionAndIncarnation<Tutorial2LevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    return new Tutorial2LevelControllerCreateEffect(id, incarnation.Copy());
  }

  public void EffectTutorial2LevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectTutorial2LevelControllerDelete(id);
    NotifyEffect(effect);
  }
  public Tutorial2LevelControllerDeleteEffect InternalEffectTutorial2LevelControllerDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTutorial2LevelController[id];

    rootIncarnation.incarnationsTutorial2LevelController.Remove(id);
    return new Tutorial2LevelControllerDeleteEffect(id);
  }

     
  public int GetTutorial2LevelControllerHash(int id, int version, Tutorial2LevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public Tutorial1LevelControllerIncarnation GetTutorial1LevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsTutorial1LevelController[id].incarnation;
  }
  public bool Tutorial1LevelControllerExists(int id) {
    return rootIncarnation.incarnationsTutorial1LevelController.ContainsKey(id);
  }
  public Tutorial1LevelController GetTutorial1LevelController(int id) {
    CheckHasTutorial1LevelController(id);
    return new Tutorial1LevelController(this, id);
  }
  public Tutorial1LevelController GetTutorial1LevelControllerOrNull(int id) {
    if (Tutorial1LevelControllerExists(id)) {
      return new Tutorial1LevelController(this, id);
    } else {
      return new Tutorial1LevelController(this, 0);
    }
  }
  public List<Tutorial1LevelController> AllTutorial1LevelController() {
    List<Tutorial1LevelController> result = new List<Tutorial1LevelController>(rootIncarnation.incarnationsTutorial1LevelController.Count);
    foreach (var id in rootIncarnation.incarnationsTutorial1LevelController.Keys) {
      result.Add(new Tutorial1LevelController(this, id));
    }
    return result;
  }
  public IEnumerator<Tutorial1LevelController> EnumAllTutorial1LevelController() {
    foreach (var id in rootIncarnation.incarnationsTutorial1LevelController.Keys) {
      yield return GetTutorial1LevelController(id);
    }
  }
  public void CheckHasTutorial1LevelController(Tutorial1LevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasTutorial1LevelController(thing.id);
  }
  public void CheckHasTutorial1LevelController(int id) {
    if (!rootIncarnation.incarnationsTutorial1LevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid Tutorial1LevelController: " + id);
    }
  }
  public Tutorial1LevelController EffectTutorial1LevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectTutorial1LevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public Tutorial1LevelController TrustedEffectTutorial1LevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new Tutorial1LevelControllerIncarnation(
            level
            );
    var effect = InternalEffectCreateTutorial1LevelController(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new Tutorial1LevelController(this, id);
  }
  public Tutorial1LevelControllerCreateEffect InternalEffectCreateTutorial1LevelController(
      int id,
      int incarnationVersion,
      Tutorial1LevelControllerIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsTutorial1LevelController.Add(
        id,
        new VersionAndIncarnation<Tutorial1LevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    return new Tutorial1LevelControllerCreateEffect(id, incarnation.Copy());
  }

  public void EffectTutorial1LevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectTutorial1LevelControllerDelete(id);
    NotifyEffect(effect);
  }
  public Tutorial1LevelControllerDeleteEffect InternalEffectTutorial1LevelControllerDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsTutorial1LevelController[id];

    rootIncarnation.incarnationsTutorial1LevelController.Remove(id);
    return new Tutorial1LevelControllerDeleteEffect(id);
  }

     
  public int GetTutorial1LevelControllerHash(int id, int version, Tutorial1LevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public RetreatLevelControllerIncarnation GetRetreatLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsRetreatLevelController[id].incarnation;
  }
  public bool RetreatLevelControllerExists(int id) {
    return rootIncarnation.incarnationsRetreatLevelController.ContainsKey(id);
  }
  public RetreatLevelController GetRetreatLevelController(int id) {
    CheckHasRetreatLevelController(id);
    return new RetreatLevelController(this, id);
  }
  public RetreatLevelController GetRetreatLevelControllerOrNull(int id) {
    if (RetreatLevelControllerExists(id)) {
      return new RetreatLevelController(this, id);
    } else {
      return new RetreatLevelController(this, 0);
    }
  }
  public List<RetreatLevelController> AllRetreatLevelController() {
    List<RetreatLevelController> result = new List<RetreatLevelController>(rootIncarnation.incarnationsRetreatLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsRetreatLevelController.Keys) {
      result.Add(new RetreatLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<RetreatLevelController> EnumAllRetreatLevelController() {
    foreach (var id in rootIncarnation.incarnationsRetreatLevelController.Keys) {
      yield return GetRetreatLevelController(id);
    }
  }
  public void CheckHasRetreatLevelController(RetreatLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasRetreatLevelController(thing.id);
  }
  public void CheckHasRetreatLevelController(int id) {
    if (!rootIncarnation.incarnationsRetreatLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid RetreatLevelController: " + id);
    }
  }
  public RetreatLevelController EffectRetreatLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectRetreatLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public RetreatLevelController TrustedEffectRetreatLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new RetreatLevelControllerIncarnation(
            level
            );
    var effect = InternalEffectCreateRetreatLevelController(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new RetreatLevelController(this, id);
  }
  public RetreatLevelControllerCreateEffect InternalEffectCreateRetreatLevelController(
      int id,
      int incarnationVersion,
      RetreatLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsRetreatLevelController.Add(
        id,
        new VersionAndIncarnation<RetreatLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    return new RetreatLevelControllerCreateEffect(id, incarnation.Copy());
  }

  public void EffectRetreatLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectRetreatLevelControllerDelete(id);
    NotifyEffect(effect);
  }
  public RetreatLevelControllerDeleteEffect InternalEffectRetreatLevelControllerDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsRetreatLevelController[id];

    rootIncarnation.incarnationsRetreatLevelController.Remove(id);
    return new RetreatLevelControllerDeleteEffect(id);
  }

     
  public int GetRetreatLevelControllerHash(int id, int version, RetreatLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public SotaventoLevelControllerIncarnation GetSotaventoLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsSotaventoLevelController[id].incarnation;
  }
  public bool SotaventoLevelControllerExists(int id) {
    return rootIncarnation.incarnationsSotaventoLevelController.ContainsKey(id);
  }
  public SotaventoLevelController GetSotaventoLevelController(int id) {
    CheckHasSotaventoLevelController(id);
    return new SotaventoLevelController(this, id);
  }
  public SotaventoLevelController GetSotaventoLevelControllerOrNull(int id) {
    if (SotaventoLevelControllerExists(id)) {
      return new SotaventoLevelController(this, id);
    } else {
      return new SotaventoLevelController(this, 0);
    }
  }
  public List<SotaventoLevelController> AllSotaventoLevelController() {
    List<SotaventoLevelController> result = new List<SotaventoLevelController>(rootIncarnation.incarnationsSotaventoLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsSotaventoLevelController.Keys) {
      result.Add(new SotaventoLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<SotaventoLevelController> EnumAllSotaventoLevelController() {
    foreach (var id in rootIncarnation.incarnationsSotaventoLevelController.Keys) {
      yield return GetSotaventoLevelController(id);
    }
  }
  public void CheckHasSotaventoLevelController(SotaventoLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasSotaventoLevelController(thing.id);
  }
  public void CheckHasSotaventoLevelController(int id) {
    if (!rootIncarnation.incarnationsSotaventoLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid SotaventoLevelController: " + id);
    }
  }
  public SotaventoLevelController EffectSotaventoLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectSotaventoLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public SotaventoLevelController TrustedEffectSotaventoLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new SotaventoLevelControllerIncarnation(
            level
            );
    var effect = InternalEffectCreateSotaventoLevelController(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new SotaventoLevelController(this, id);
  }
  public SotaventoLevelControllerCreateEffect InternalEffectCreateSotaventoLevelController(
      int id,
      int incarnationVersion,
      SotaventoLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsSotaventoLevelController.Add(
        id,
        new VersionAndIncarnation<SotaventoLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    return new SotaventoLevelControllerCreateEffect(id, incarnation.Copy());
  }

  public void EffectSotaventoLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectSotaventoLevelControllerDelete(id);
    NotifyEffect(effect);
  }
  public SotaventoLevelControllerDeleteEffect InternalEffectSotaventoLevelControllerDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsSotaventoLevelController[id];

    rootIncarnation.incarnationsSotaventoLevelController.Remove(id);
    return new SotaventoLevelControllerDeleteEffect(id);
  }

     
  public int GetSotaventoLevelControllerHash(int id, int version, SotaventoLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public NestLevelControllerIncarnation GetNestLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsNestLevelController[id].incarnation;
  }
  public bool NestLevelControllerExists(int id) {
    return rootIncarnation.incarnationsNestLevelController.ContainsKey(id);
  }
  public NestLevelController GetNestLevelController(int id) {
    CheckHasNestLevelController(id);
    return new NestLevelController(this, id);
  }
  public NestLevelController GetNestLevelControllerOrNull(int id) {
    if (NestLevelControllerExists(id)) {
      return new NestLevelController(this, id);
    } else {
      return new NestLevelController(this, 0);
    }
  }
  public List<NestLevelController> AllNestLevelController() {
    List<NestLevelController> result = new List<NestLevelController>(rootIncarnation.incarnationsNestLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsNestLevelController.Keys) {
      result.Add(new NestLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<NestLevelController> EnumAllNestLevelController() {
    foreach (var id in rootIncarnation.incarnationsNestLevelController.Keys) {
      yield return GetNestLevelController(id);
    }
  }
  public void CheckHasNestLevelController(NestLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasNestLevelController(thing.id);
  }
  public void CheckHasNestLevelController(int id) {
    if (!rootIncarnation.incarnationsNestLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid NestLevelController: " + id);
    }
  }
  public NestLevelController EffectNestLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectNestLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public NestLevelController TrustedEffectNestLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new NestLevelControllerIncarnation(
            level
            );
    var effect = InternalEffectCreateNestLevelController(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new NestLevelController(this, id);
  }
  public NestLevelControllerCreateEffect InternalEffectCreateNestLevelController(
      int id,
      int incarnationVersion,
      NestLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsNestLevelController.Add(
        id,
        new VersionAndIncarnation<NestLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    return new NestLevelControllerCreateEffect(id, incarnation.Copy());
  }

  public void EffectNestLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectNestLevelControllerDelete(id);
    NotifyEffect(effect);
  }
  public NestLevelControllerDeleteEffect InternalEffectNestLevelControllerDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsNestLevelController[id];

    rootIncarnation.incarnationsNestLevelController.Remove(id);
    return new NestLevelControllerDeleteEffect(id);
  }

     
  public int GetNestLevelControllerHash(int id, int version, NestLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public LakeLevelControllerIncarnation GetLakeLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsLakeLevelController[id].incarnation;
  }
  public bool LakeLevelControllerExists(int id) {
    return rootIncarnation.incarnationsLakeLevelController.ContainsKey(id);
  }
  public LakeLevelController GetLakeLevelController(int id) {
    CheckHasLakeLevelController(id);
    return new LakeLevelController(this, id);
  }
  public LakeLevelController GetLakeLevelControllerOrNull(int id) {
    if (LakeLevelControllerExists(id)) {
      return new LakeLevelController(this, id);
    } else {
      return new LakeLevelController(this, 0);
    }
  }
  public List<LakeLevelController> AllLakeLevelController() {
    List<LakeLevelController> result = new List<LakeLevelController>(rootIncarnation.incarnationsLakeLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsLakeLevelController.Keys) {
      result.Add(new LakeLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<LakeLevelController> EnumAllLakeLevelController() {
    foreach (var id in rootIncarnation.incarnationsLakeLevelController.Keys) {
      yield return GetLakeLevelController(id);
    }
  }
  public void CheckHasLakeLevelController(LakeLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasLakeLevelController(thing.id);
  }
  public void CheckHasLakeLevelController(int id) {
    if (!rootIncarnation.incarnationsLakeLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid LakeLevelController: " + id);
    }
  }
  public LakeLevelController EffectLakeLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectLakeLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public LakeLevelController TrustedEffectLakeLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new LakeLevelControllerIncarnation(
            level
            );
    var effect = InternalEffectCreateLakeLevelController(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new LakeLevelController(this, id);
  }
  public LakeLevelControllerCreateEffect InternalEffectCreateLakeLevelController(
      int id,
      int incarnationVersion,
      LakeLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsLakeLevelController.Add(
        id,
        new VersionAndIncarnation<LakeLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    return new LakeLevelControllerCreateEffect(id, incarnation.Copy());
  }

  public void EffectLakeLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectLakeLevelControllerDelete(id);
    NotifyEffect(effect);
  }
  public LakeLevelControllerDeleteEffect InternalEffectLakeLevelControllerDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsLakeLevelController[id];

    rootIncarnation.incarnationsLakeLevelController.Remove(id);
    return new LakeLevelControllerDeleteEffect(id);
  }

     
  public int GetLakeLevelControllerHash(int id, int version, LakeLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public EmberDeepLevelLinkerTTCIncarnation GetEmberDeepLevelLinkerTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsEmberDeepLevelLinkerTTC[id].incarnation;
  }
  public bool EmberDeepLevelLinkerTTCExists(int id) {
    return rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(id);
  }
  public EmberDeepLevelLinkerTTC GetEmberDeepLevelLinkerTTC(int id) {
    CheckHasEmberDeepLevelLinkerTTC(id);
    return new EmberDeepLevelLinkerTTC(this, id);
  }
  public EmberDeepLevelLinkerTTC GetEmberDeepLevelLinkerTTCOrNull(int id) {
    if (EmberDeepLevelLinkerTTCExists(id)) {
      return new EmberDeepLevelLinkerTTC(this, id);
    } else {
      return new EmberDeepLevelLinkerTTC(this, 0);
    }
  }
  public List<EmberDeepLevelLinkerTTC> AllEmberDeepLevelLinkerTTC() {
    List<EmberDeepLevelLinkerTTC> result = new List<EmberDeepLevelLinkerTTC>(rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.Count);
    foreach (var id in rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.Keys) {
      result.Add(new EmberDeepLevelLinkerTTC(this, id));
    }
    return result;
  }
  public IEnumerator<EmberDeepLevelLinkerTTC> EnumAllEmberDeepLevelLinkerTTC() {
    foreach (var id in rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.Keys) {
      yield return GetEmberDeepLevelLinkerTTC(id);
    }
  }
  public void CheckHasEmberDeepLevelLinkerTTC(EmberDeepLevelLinkerTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasEmberDeepLevelLinkerTTC(thing.id);
  }
  public void CheckHasEmberDeepLevelLinkerTTC(int id) {
    if (!rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid EmberDeepLevelLinkerTTC: " + id);
    }
  }
  public EmberDeepLevelLinkerTTC EffectEmberDeepLevelLinkerTTCCreate(
      int nextLevelDepth) {
    return TrustedEffectEmberDeepLevelLinkerTTCCreateWithId(NewId()
            ,nextLevelDepth    );
  }
  public EmberDeepLevelLinkerTTC TrustedEffectEmberDeepLevelLinkerTTCCreateWithId(int id
,      int nextLevelDepth) {
    CheckUnlocked();

    var incarnation =
        new EmberDeepLevelLinkerTTCIncarnation(
            nextLevelDepth
            );
    var effect = InternalEffectCreateEmberDeepLevelLinkerTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new EmberDeepLevelLinkerTTC(this, id);
  }
  public EmberDeepLevelLinkerTTCCreateEffect InternalEffectCreateEmberDeepLevelLinkerTTC(
      int id,
      int incarnationVersion,
      EmberDeepLevelLinkerTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.Add(
        id,
        new VersionAndIncarnation<EmberDeepLevelLinkerTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new EmberDeepLevelLinkerTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectEmberDeepLevelLinkerTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectEmberDeepLevelLinkerTTCDelete(id);
    NotifyEffect(effect);
  }
  public EmberDeepLevelLinkerTTCDeleteEffect InternalEffectEmberDeepLevelLinkerTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsEmberDeepLevelLinkerTTC[id];

    rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.Remove(id);
    return new EmberDeepLevelLinkerTTCDeleteEffect(id);
  }

     
  public int GetEmberDeepLevelLinkerTTCHash(int id, int version, EmberDeepLevelLinkerTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.nextLevelDepth.GetDeterministicHashCode();
    return result;
  }
       public DirtRoadLevelControllerIncarnation GetDirtRoadLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsDirtRoadLevelController[id].incarnation;
  }
  public bool DirtRoadLevelControllerExists(int id) {
    return rootIncarnation.incarnationsDirtRoadLevelController.ContainsKey(id);
  }
  public DirtRoadLevelController GetDirtRoadLevelController(int id) {
    CheckHasDirtRoadLevelController(id);
    return new DirtRoadLevelController(this, id);
  }
  public DirtRoadLevelController GetDirtRoadLevelControllerOrNull(int id) {
    if (DirtRoadLevelControllerExists(id)) {
      return new DirtRoadLevelController(this, id);
    } else {
      return new DirtRoadLevelController(this, 0);
    }
  }
  public List<DirtRoadLevelController> AllDirtRoadLevelController() {
    List<DirtRoadLevelController> result = new List<DirtRoadLevelController>(rootIncarnation.incarnationsDirtRoadLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsDirtRoadLevelController.Keys) {
      result.Add(new DirtRoadLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<DirtRoadLevelController> EnumAllDirtRoadLevelController() {
    foreach (var id in rootIncarnation.incarnationsDirtRoadLevelController.Keys) {
      yield return GetDirtRoadLevelController(id);
    }
  }
  public void CheckHasDirtRoadLevelController(DirtRoadLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasDirtRoadLevelController(thing.id);
  }
  public void CheckHasDirtRoadLevelController(int id) {
    if (!rootIncarnation.incarnationsDirtRoadLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid DirtRoadLevelController: " + id);
    }
  }
  public DirtRoadLevelController EffectDirtRoadLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectDirtRoadLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public DirtRoadLevelController TrustedEffectDirtRoadLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new DirtRoadLevelControllerIncarnation(
            level
            );
    var effect = InternalEffectCreateDirtRoadLevelController(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new DirtRoadLevelController(this, id);
  }
  public DirtRoadLevelControllerCreateEffect InternalEffectCreateDirtRoadLevelController(
      int id,
      int incarnationVersion,
      DirtRoadLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsDirtRoadLevelController.Add(
        id,
        new VersionAndIncarnation<DirtRoadLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    return new DirtRoadLevelControllerCreateEffect(id, incarnation.Copy());
  }

  public void EffectDirtRoadLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectDirtRoadLevelControllerDelete(id);
    NotifyEffect(effect);
  }
  public DirtRoadLevelControllerDeleteEffect InternalEffectDirtRoadLevelControllerDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsDirtRoadLevelController[id];

    rootIncarnation.incarnationsDirtRoadLevelController.Remove(id);
    return new DirtRoadLevelControllerDeleteEffect(id);
  }

     
  public int GetDirtRoadLevelControllerHash(int id, int version, DirtRoadLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public CaveLevelControllerIncarnation GetCaveLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCaveLevelController[id].incarnation;
  }
  public bool CaveLevelControllerExists(int id) {
    return rootIncarnation.incarnationsCaveLevelController.ContainsKey(id);
  }
  public CaveLevelController GetCaveLevelController(int id) {
    CheckHasCaveLevelController(id);
    return new CaveLevelController(this, id);
  }
  public CaveLevelController GetCaveLevelControllerOrNull(int id) {
    if (CaveLevelControllerExists(id)) {
      return new CaveLevelController(this, id);
    } else {
      return new CaveLevelController(this, 0);
    }
  }
  public List<CaveLevelController> AllCaveLevelController() {
    List<CaveLevelController> result = new List<CaveLevelController>(rootIncarnation.incarnationsCaveLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsCaveLevelController.Keys) {
      result.Add(new CaveLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<CaveLevelController> EnumAllCaveLevelController() {
    foreach (var id in rootIncarnation.incarnationsCaveLevelController.Keys) {
      yield return GetCaveLevelController(id);
    }
  }
  public void CheckHasCaveLevelController(CaveLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCaveLevelController(thing.id);
  }
  public void CheckHasCaveLevelController(int id) {
    if (!rootIncarnation.incarnationsCaveLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid CaveLevelController: " + id);
    }
  }
  public CaveLevelController EffectCaveLevelControllerCreate(
      Level level,
      int depth) {
    CheckHasLevel(level);
    return TrustedEffectCaveLevelControllerCreateWithId(NewId()
            ,level.id
            ,depth    );
  }
  public CaveLevelController TrustedEffectCaveLevelControllerCreateWithId(int id
,      int level
,      int depth) {
    CheckUnlocked();

    var incarnation =
        new CaveLevelControllerIncarnation(
            level,
            depth
            );
    var effect = InternalEffectCreateCaveLevelController(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new CaveLevelController(this, id);
  }
  public CaveLevelControllerCreateEffect InternalEffectCreateCaveLevelController(
      int id,
      int incarnationVersion,
      CaveLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsCaveLevelController.Add(
        id,
        new VersionAndIncarnation<CaveLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    return new CaveLevelControllerCreateEffect(id, incarnation.Copy());
  }

  public void EffectCaveLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectCaveLevelControllerDelete(id);
    NotifyEffect(effect);
  }
  public CaveLevelControllerDeleteEffect InternalEffectCaveLevelControllerDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCaveLevelController[id];

    rootIncarnation.incarnationsCaveLevelController.Remove(id);
    return new CaveLevelControllerDeleteEffect(id);
  }

     
  public int GetCaveLevelControllerHash(int id, int version, CaveLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.depth.GetDeterministicHashCode();
    return result;
  }
       public BridgesLevelControllerIncarnation GetBridgesLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsBridgesLevelController[id].incarnation;
  }
  public bool BridgesLevelControllerExists(int id) {
    return rootIncarnation.incarnationsBridgesLevelController.ContainsKey(id);
  }
  public BridgesLevelController GetBridgesLevelController(int id) {
    CheckHasBridgesLevelController(id);
    return new BridgesLevelController(this, id);
  }
  public BridgesLevelController GetBridgesLevelControllerOrNull(int id) {
    if (BridgesLevelControllerExists(id)) {
      return new BridgesLevelController(this, id);
    } else {
      return new BridgesLevelController(this, 0);
    }
  }
  public List<BridgesLevelController> AllBridgesLevelController() {
    List<BridgesLevelController> result = new List<BridgesLevelController>(rootIncarnation.incarnationsBridgesLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsBridgesLevelController.Keys) {
      result.Add(new BridgesLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<BridgesLevelController> EnumAllBridgesLevelController() {
    foreach (var id in rootIncarnation.incarnationsBridgesLevelController.Keys) {
      yield return GetBridgesLevelController(id);
    }
  }
  public void CheckHasBridgesLevelController(BridgesLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasBridgesLevelController(thing.id);
  }
  public void CheckHasBridgesLevelController(int id) {
    if (!rootIncarnation.incarnationsBridgesLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid BridgesLevelController: " + id);
    }
  }
  public BridgesLevelController EffectBridgesLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectBridgesLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public BridgesLevelController TrustedEffectBridgesLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new BridgesLevelControllerIncarnation(
            level
            );
    var effect = InternalEffectCreateBridgesLevelController(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new BridgesLevelController(this, id);
  }
  public BridgesLevelControllerCreateEffect InternalEffectCreateBridgesLevelController(
      int id,
      int incarnationVersion,
      BridgesLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsBridgesLevelController.Add(
        id,
        new VersionAndIncarnation<BridgesLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    return new BridgesLevelControllerCreateEffect(id, incarnation.Copy());
  }

  public void EffectBridgesLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectBridgesLevelControllerDelete(id);
    NotifyEffect(effect);
  }
  public BridgesLevelControllerDeleteEffect InternalEffectBridgesLevelControllerDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsBridgesLevelController[id];

    rootIncarnation.incarnationsBridgesLevelController.Remove(id);
    return new BridgesLevelControllerDeleteEffect(id);
  }

     
  public int GetBridgesLevelControllerHash(int id, int version, BridgesLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public AncientTownLevelControllerIncarnation GetAncientTownLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsAncientTownLevelController[id].incarnation;
  }
  public bool AncientTownLevelControllerExists(int id) {
    return rootIncarnation.incarnationsAncientTownLevelController.ContainsKey(id);
  }
  public AncientTownLevelController GetAncientTownLevelController(int id) {
    CheckHasAncientTownLevelController(id);
    return new AncientTownLevelController(this, id);
  }
  public AncientTownLevelController GetAncientTownLevelControllerOrNull(int id) {
    if (AncientTownLevelControllerExists(id)) {
      return new AncientTownLevelController(this, id);
    } else {
      return new AncientTownLevelController(this, 0);
    }
  }
  public List<AncientTownLevelController> AllAncientTownLevelController() {
    List<AncientTownLevelController> result = new List<AncientTownLevelController>(rootIncarnation.incarnationsAncientTownLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsAncientTownLevelController.Keys) {
      result.Add(new AncientTownLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<AncientTownLevelController> EnumAllAncientTownLevelController() {
    foreach (var id in rootIncarnation.incarnationsAncientTownLevelController.Keys) {
      yield return GetAncientTownLevelController(id);
    }
  }
  public void CheckHasAncientTownLevelController(AncientTownLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasAncientTownLevelController(thing.id);
  }
  public void CheckHasAncientTownLevelController(int id) {
    if (!rootIncarnation.incarnationsAncientTownLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid AncientTownLevelController: " + id);
    }
  }
  public AncientTownLevelController EffectAncientTownLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectAncientTownLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public AncientTownLevelController TrustedEffectAncientTownLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new AncientTownLevelControllerIncarnation(
            level
            );
    var effect = InternalEffectCreateAncientTownLevelController(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new AncientTownLevelController(this, id);
  }
  public AncientTownLevelControllerCreateEffect InternalEffectCreateAncientTownLevelController(
      int id,
      int incarnationVersion,
      AncientTownLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsAncientTownLevelController.Add(
        id,
        new VersionAndIncarnation<AncientTownLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    return new AncientTownLevelControllerCreateEffect(id, incarnation.Copy());
  }

  public void EffectAncientTownLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectAncientTownLevelControllerDelete(id);
    NotifyEffect(effect);
  }
  public AncientTownLevelControllerDeleteEffect InternalEffectAncientTownLevelControllerDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsAncientTownLevelController[id];

    rootIncarnation.incarnationsAncientTownLevelController.Remove(id);
    return new AncientTownLevelControllerDeleteEffect(id);
  }

     
  public int GetAncientTownLevelControllerHash(int id, int version, AncientTownLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public SquareCaveLevelControllerIncarnation GetSquareCaveLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsSquareCaveLevelController[id].incarnation;
  }
  public bool SquareCaveLevelControllerExists(int id) {
    return rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(id);
  }
  public SquareCaveLevelController GetSquareCaveLevelController(int id) {
    CheckHasSquareCaveLevelController(id);
    return new SquareCaveLevelController(this, id);
  }
  public SquareCaveLevelController GetSquareCaveLevelControllerOrNull(int id) {
    if (SquareCaveLevelControllerExists(id)) {
      return new SquareCaveLevelController(this, id);
    } else {
      return new SquareCaveLevelController(this, 0);
    }
  }
  public List<SquareCaveLevelController> AllSquareCaveLevelController() {
    List<SquareCaveLevelController> result = new List<SquareCaveLevelController>(rootIncarnation.incarnationsSquareCaveLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsSquareCaveLevelController.Keys) {
      result.Add(new SquareCaveLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<SquareCaveLevelController> EnumAllSquareCaveLevelController() {
    foreach (var id in rootIncarnation.incarnationsSquareCaveLevelController.Keys) {
      yield return GetSquareCaveLevelController(id);
    }
  }
  public void CheckHasSquareCaveLevelController(SquareCaveLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasSquareCaveLevelController(thing.id);
  }
  public void CheckHasSquareCaveLevelController(int id) {
    if (!rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid SquareCaveLevelController: " + id);
    }
  }
  public SquareCaveLevelController EffectSquareCaveLevelControllerCreate(
      Level level,
      int depth) {
    CheckHasLevel(level);
    return TrustedEffectSquareCaveLevelControllerCreateWithId(NewId()
            ,level.id
            ,depth    );
  }
  public SquareCaveLevelController TrustedEffectSquareCaveLevelControllerCreateWithId(int id
,      int level
,      int depth) {
    CheckUnlocked();

    var incarnation =
        new SquareCaveLevelControllerIncarnation(
            level,
            depth
            );
    var effect = InternalEffectCreateSquareCaveLevelController(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new SquareCaveLevelController(this, id);
  }
  public SquareCaveLevelControllerCreateEffect InternalEffectCreateSquareCaveLevelController(
      int id,
      int incarnationVersion,
      SquareCaveLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsSquareCaveLevelController.Add(
        id,
        new VersionAndIncarnation<SquareCaveLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    return new SquareCaveLevelControllerCreateEffect(id, incarnation.Copy());
  }

  public void EffectSquareCaveLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectSquareCaveLevelControllerDelete(id);
    NotifyEffect(effect);
  }
  public SquareCaveLevelControllerDeleteEffect InternalEffectSquareCaveLevelControllerDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsSquareCaveLevelController[id];

    rootIncarnation.incarnationsSquareCaveLevelController.Remove(id);
    return new SquareCaveLevelControllerDeleteEffect(id);
  }

     
  public int GetSquareCaveLevelControllerHash(int id, int version, SquareCaveLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.depth.GetDeterministicHashCode();
    return result;
  }
       public RavashrikeLevelControllerIncarnation GetRavashrikeLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsRavashrikeLevelController[id].incarnation;
  }
  public bool RavashrikeLevelControllerExists(int id) {
    return rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(id);
  }
  public RavashrikeLevelController GetRavashrikeLevelController(int id) {
    CheckHasRavashrikeLevelController(id);
    return new RavashrikeLevelController(this, id);
  }
  public RavashrikeLevelController GetRavashrikeLevelControllerOrNull(int id) {
    if (RavashrikeLevelControllerExists(id)) {
      return new RavashrikeLevelController(this, id);
    } else {
      return new RavashrikeLevelController(this, 0);
    }
  }
  public List<RavashrikeLevelController> AllRavashrikeLevelController() {
    List<RavashrikeLevelController> result = new List<RavashrikeLevelController>(rootIncarnation.incarnationsRavashrikeLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsRavashrikeLevelController.Keys) {
      result.Add(new RavashrikeLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<RavashrikeLevelController> EnumAllRavashrikeLevelController() {
    foreach (var id in rootIncarnation.incarnationsRavashrikeLevelController.Keys) {
      yield return GetRavashrikeLevelController(id);
    }
  }
  public void CheckHasRavashrikeLevelController(RavashrikeLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasRavashrikeLevelController(thing.id);
  }
  public void CheckHasRavashrikeLevelController(int id) {
    if (!rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid RavashrikeLevelController: " + id);
    }
  }
  public RavashrikeLevelController EffectRavashrikeLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectRavashrikeLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public RavashrikeLevelController TrustedEffectRavashrikeLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new RavashrikeLevelControllerIncarnation(
            level
            );
    var effect = InternalEffectCreateRavashrikeLevelController(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new RavashrikeLevelController(this, id);
  }
  public RavashrikeLevelControllerCreateEffect InternalEffectCreateRavashrikeLevelController(
      int id,
      int incarnationVersion,
      RavashrikeLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsRavashrikeLevelController.Add(
        id,
        new VersionAndIncarnation<RavashrikeLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    return new RavashrikeLevelControllerCreateEffect(id, incarnation.Copy());
  }

  public void EffectRavashrikeLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectRavashrikeLevelControllerDelete(id);
    NotifyEffect(effect);
  }
  public RavashrikeLevelControllerDeleteEffect InternalEffectRavashrikeLevelControllerDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsRavashrikeLevelController[id];

    rootIncarnation.incarnationsRavashrikeLevelController.Remove(id);
    return new RavashrikeLevelControllerDeleteEffect(id);
  }

     
  public int GetRavashrikeLevelControllerHash(int id, int version, RavashrikeLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public PentagonalCaveLevelControllerIncarnation GetPentagonalCaveLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsPentagonalCaveLevelController[id].incarnation;
  }
  public bool PentagonalCaveLevelControllerExists(int id) {
    return rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(id);
  }
  public PentagonalCaveLevelController GetPentagonalCaveLevelController(int id) {
    CheckHasPentagonalCaveLevelController(id);
    return new PentagonalCaveLevelController(this, id);
  }
  public PentagonalCaveLevelController GetPentagonalCaveLevelControllerOrNull(int id) {
    if (PentagonalCaveLevelControllerExists(id)) {
      return new PentagonalCaveLevelController(this, id);
    } else {
      return new PentagonalCaveLevelController(this, 0);
    }
  }
  public List<PentagonalCaveLevelController> AllPentagonalCaveLevelController() {
    List<PentagonalCaveLevelController> result = new List<PentagonalCaveLevelController>(rootIncarnation.incarnationsPentagonalCaveLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsPentagonalCaveLevelController.Keys) {
      result.Add(new PentagonalCaveLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<PentagonalCaveLevelController> EnumAllPentagonalCaveLevelController() {
    foreach (var id in rootIncarnation.incarnationsPentagonalCaveLevelController.Keys) {
      yield return GetPentagonalCaveLevelController(id);
    }
  }
  public void CheckHasPentagonalCaveLevelController(PentagonalCaveLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasPentagonalCaveLevelController(thing.id);
  }
  public void CheckHasPentagonalCaveLevelController(int id) {
    if (!rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid PentagonalCaveLevelController: " + id);
    }
  }
  public PentagonalCaveLevelController EffectPentagonalCaveLevelControllerCreate(
      Level level,
      int depth) {
    CheckHasLevel(level);
    return TrustedEffectPentagonalCaveLevelControllerCreateWithId(NewId()
            ,level.id
            ,depth    );
  }
  public PentagonalCaveLevelController TrustedEffectPentagonalCaveLevelControllerCreateWithId(int id
,      int level
,      int depth) {
    CheckUnlocked();

    var incarnation =
        new PentagonalCaveLevelControllerIncarnation(
            level,
            depth
            );
    var effect = InternalEffectCreatePentagonalCaveLevelController(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new PentagonalCaveLevelController(this, id);
  }
  public PentagonalCaveLevelControllerCreateEffect InternalEffectCreatePentagonalCaveLevelController(
      int id,
      int incarnationVersion,
      PentagonalCaveLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsPentagonalCaveLevelController.Add(
        id,
        new VersionAndIncarnation<PentagonalCaveLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    return new PentagonalCaveLevelControllerCreateEffect(id, incarnation.Copy());
  }

  public void EffectPentagonalCaveLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectPentagonalCaveLevelControllerDelete(id);
    NotifyEffect(effect);
  }
  public PentagonalCaveLevelControllerDeleteEffect InternalEffectPentagonalCaveLevelControllerDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsPentagonalCaveLevelController[id];

    rootIncarnation.incarnationsPentagonalCaveLevelController.Remove(id);
    return new PentagonalCaveLevelControllerDeleteEffect(id);
  }

     
  public int GetPentagonalCaveLevelControllerHash(int id, int version, PentagonalCaveLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.depth.GetDeterministicHashCode();
    return result;
  }
       public IncendianFallsLevelLinkerTTCIncarnation GetIncendianFallsLevelLinkerTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC[id].incarnation;
  }
  public bool IncendianFallsLevelLinkerTTCExists(int id) {
    return rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(id);
  }
  public IncendianFallsLevelLinkerTTC GetIncendianFallsLevelLinkerTTC(int id) {
    CheckHasIncendianFallsLevelLinkerTTC(id);
    return new IncendianFallsLevelLinkerTTC(this, id);
  }
  public IncendianFallsLevelLinkerTTC GetIncendianFallsLevelLinkerTTCOrNull(int id) {
    if (IncendianFallsLevelLinkerTTCExists(id)) {
      return new IncendianFallsLevelLinkerTTC(this, id);
    } else {
      return new IncendianFallsLevelLinkerTTC(this, 0);
    }
  }
  public List<IncendianFallsLevelLinkerTTC> AllIncendianFallsLevelLinkerTTC() {
    List<IncendianFallsLevelLinkerTTC> result = new List<IncendianFallsLevelLinkerTTC>(rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.Count);
    foreach (var id in rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.Keys) {
      result.Add(new IncendianFallsLevelLinkerTTC(this, id));
    }
    return result;
  }
  public IEnumerator<IncendianFallsLevelLinkerTTC> EnumAllIncendianFallsLevelLinkerTTC() {
    foreach (var id in rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.Keys) {
      yield return GetIncendianFallsLevelLinkerTTC(id);
    }
  }
  public void CheckHasIncendianFallsLevelLinkerTTC(IncendianFallsLevelLinkerTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasIncendianFallsLevelLinkerTTC(thing.id);
  }
  public void CheckHasIncendianFallsLevelLinkerTTC(int id) {
    if (!rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid IncendianFallsLevelLinkerTTC: " + id);
    }
  }
  public IncendianFallsLevelLinkerTTC EffectIncendianFallsLevelLinkerTTCCreate(
      int thisLevelDepth) {
    return TrustedEffectIncendianFallsLevelLinkerTTCCreateWithId(NewId()
            ,thisLevelDepth    );
  }
  public IncendianFallsLevelLinkerTTC TrustedEffectIncendianFallsLevelLinkerTTCCreateWithId(int id
,      int thisLevelDepth) {
    CheckUnlocked();

    var incarnation =
        new IncendianFallsLevelLinkerTTCIncarnation(
            thisLevelDepth
            );
    var effect = InternalEffectCreateIncendianFallsLevelLinkerTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new IncendianFallsLevelLinkerTTC(this, id);
  }
  public IncendianFallsLevelLinkerTTCCreateEffect InternalEffectCreateIncendianFallsLevelLinkerTTC(
      int id,
      int incarnationVersion,
      IncendianFallsLevelLinkerTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.Add(
        id,
        new VersionAndIncarnation<IncendianFallsLevelLinkerTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new IncendianFallsLevelLinkerTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectIncendianFallsLevelLinkerTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectIncendianFallsLevelLinkerTTCDelete(id);
    NotifyEffect(effect);
  }
  public IncendianFallsLevelLinkerTTCDeleteEffect InternalEffectIncendianFallsLevelLinkerTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC[id];

    rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.Remove(id);
    return new IncendianFallsLevelLinkerTTCDeleteEffect(id);
  }

     
  public int GetIncendianFallsLevelLinkerTTCHash(int id, int version, IncendianFallsLevelLinkerTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.thisLevelDepth.GetDeterministicHashCode();
    return result;
  }
       public CliffLevelControllerIncarnation GetCliffLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsCliffLevelController[id].incarnation;
  }
  public bool CliffLevelControllerExists(int id) {
    return rootIncarnation.incarnationsCliffLevelController.ContainsKey(id);
  }
  public CliffLevelController GetCliffLevelController(int id) {
    CheckHasCliffLevelController(id);
    return new CliffLevelController(this, id);
  }
  public CliffLevelController GetCliffLevelControllerOrNull(int id) {
    if (CliffLevelControllerExists(id)) {
      return new CliffLevelController(this, id);
    } else {
      return new CliffLevelController(this, 0);
    }
  }
  public List<CliffLevelController> AllCliffLevelController() {
    List<CliffLevelController> result = new List<CliffLevelController>(rootIncarnation.incarnationsCliffLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsCliffLevelController.Keys) {
      result.Add(new CliffLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<CliffLevelController> EnumAllCliffLevelController() {
    foreach (var id in rootIncarnation.incarnationsCliffLevelController.Keys) {
      yield return GetCliffLevelController(id);
    }
  }
  public void CheckHasCliffLevelController(CliffLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasCliffLevelController(thing.id);
  }
  public void CheckHasCliffLevelController(int id) {
    if (!rootIncarnation.incarnationsCliffLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid CliffLevelController: " + id);
    }
  }
  public CliffLevelController EffectCliffLevelControllerCreate(
      Level level,
      int depth) {
    CheckHasLevel(level);
    return TrustedEffectCliffLevelControllerCreateWithId(NewId()
            ,level.id
            ,depth    );
  }
  public CliffLevelController TrustedEffectCliffLevelControllerCreateWithId(int id
,      int level
,      int depth) {
    CheckUnlocked();

    var incarnation =
        new CliffLevelControllerIncarnation(
            level,
            depth
            );
    var effect = InternalEffectCreateCliffLevelController(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new CliffLevelController(this, id);
  }
  public CliffLevelControllerCreateEffect InternalEffectCreateCliffLevelController(
      int id,
      int incarnationVersion,
      CliffLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsCliffLevelController.Add(
        id,
        new VersionAndIncarnation<CliffLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    return new CliffLevelControllerCreateEffect(id, incarnation.Copy());
  }

  public void EffectCliffLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectCliffLevelControllerDelete(id);
    NotifyEffect(effect);
  }
  public CliffLevelControllerDeleteEffect InternalEffectCliffLevelControllerDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsCliffLevelController[id];

    rootIncarnation.incarnationsCliffLevelController.Remove(id);
    return new CliffLevelControllerDeleteEffect(id);
  }

     
  public int GetCliffLevelControllerHash(int id, int version, CliffLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.depth.GetDeterministicHashCode();
    return result;
  }
       public PreGauntletLevelControllerIncarnation GetPreGauntletLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsPreGauntletLevelController[id].incarnation;
  }
  public bool PreGauntletLevelControllerExists(int id) {
    return rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(id);
  }
  public PreGauntletLevelController GetPreGauntletLevelController(int id) {
    CheckHasPreGauntletLevelController(id);
    return new PreGauntletLevelController(this, id);
  }
  public PreGauntletLevelController GetPreGauntletLevelControllerOrNull(int id) {
    if (PreGauntletLevelControllerExists(id)) {
      return new PreGauntletLevelController(this, id);
    } else {
      return new PreGauntletLevelController(this, 0);
    }
  }
  public List<PreGauntletLevelController> AllPreGauntletLevelController() {
    List<PreGauntletLevelController> result = new List<PreGauntletLevelController>(rootIncarnation.incarnationsPreGauntletLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsPreGauntletLevelController.Keys) {
      result.Add(new PreGauntletLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<PreGauntletLevelController> EnumAllPreGauntletLevelController() {
    foreach (var id in rootIncarnation.incarnationsPreGauntletLevelController.Keys) {
      yield return GetPreGauntletLevelController(id);
    }
  }
  public void CheckHasPreGauntletLevelController(PreGauntletLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasPreGauntletLevelController(thing.id);
  }
  public void CheckHasPreGauntletLevelController(int id) {
    if (!rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid PreGauntletLevelController: " + id);
    }
  }
  public PreGauntletLevelController EffectPreGauntletLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectPreGauntletLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public PreGauntletLevelController TrustedEffectPreGauntletLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new PreGauntletLevelControllerIncarnation(
            level
            );
    var effect = InternalEffectCreatePreGauntletLevelController(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new PreGauntletLevelController(this, id);
  }
  public PreGauntletLevelControllerCreateEffect InternalEffectCreatePreGauntletLevelController(
      int id,
      int incarnationVersion,
      PreGauntletLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsPreGauntletLevelController.Add(
        id,
        new VersionAndIncarnation<PreGauntletLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    return new PreGauntletLevelControllerCreateEffect(id, incarnation.Copy());
  }

  public void EffectPreGauntletLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectPreGauntletLevelControllerDelete(id);
    NotifyEffect(effect);
  }
  public PreGauntletLevelControllerDeleteEffect InternalEffectPreGauntletLevelControllerDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsPreGauntletLevelController[id];

    rootIncarnation.incarnationsPreGauntletLevelController.Remove(id);
    return new PreGauntletLevelControllerDeleteEffect(id);
  }

     
  public int GetPreGauntletLevelControllerHash(int id, int version, PreGauntletLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public GauntletLevelControllerIncarnation GetGauntletLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsGauntletLevelController[id].incarnation;
  }
  public bool GauntletLevelControllerExists(int id) {
    return rootIncarnation.incarnationsGauntletLevelController.ContainsKey(id);
  }
  public GauntletLevelController GetGauntletLevelController(int id) {
    CheckHasGauntletLevelController(id);
    return new GauntletLevelController(this, id);
  }
  public GauntletLevelController GetGauntletLevelControllerOrNull(int id) {
    if (GauntletLevelControllerExists(id)) {
      return new GauntletLevelController(this, id);
    } else {
      return new GauntletLevelController(this, 0);
    }
  }
  public List<GauntletLevelController> AllGauntletLevelController() {
    List<GauntletLevelController> result = new List<GauntletLevelController>(rootIncarnation.incarnationsGauntletLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsGauntletLevelController.Keys) {
      result.Add(new GauntletLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<GauntletLevelController> EnumAllGauntletLevelController() {
    foreach (var id in rootIncarnation.incarnationsGauntletLevelController.Keys) {
      yield return GetGauntletLevelController(id);
    }
  }
  public void CheckHasGauntletLevelController(GauntletLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasGauntletLevelController(thing.id);
  }
  public void CheckHasGauntletLevelController(int id) {
    if (!rootIncarnation.incarnationsGauntletLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid GauntletLevelController: " + id);
    }
  }
  public GauntletLevelController EffectGauntletLevelControllerCreate(
      Level level) {
    CheckHasLevel(level);
    return TrustedEffectGauntletLevelControllerCreateWithId(NewId()
            ,level.id    );
  }
  public GauntletLevelController TrustedEffectGauntletLevelControllerCreateWithId(int id
,      int level) {
    CheckUnlocked();

    var incarnation =
        new GauntletLevelControllerIncarnation(
            level
            );
    var effect = InternalEffectCreateGauntletLevelController(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new GauntletLevelController(this, id);
  }
  public GauntletLevelControllerCreateEffect InternalEffectCreateGauntletLevelController(
      int id,
      int incarnationVersion,
      GauntletLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsGauntletLevelController.Add(
        id,
        new VersionAndIncarnation<GauntletLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    return new GauntletLevelControllerCreateEffect(id, incarnation.Copy());
  }

  public void EffectGauntletLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectGauntletLevelControllerDelete(id);
    NotifyEffect(effect);
  }
  public GauntletLevelControllerDeleteEffect InternalEffectGauntletLevelControllerDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsGauntletLevelController[id];

    rootIncarnation.incarnationsGauntletLevelController.Remove(id);
    return new GauntletLevelControllerDeleteEffect(id);
  }

     
  public int GetGauntletLevelControllerHash(int id, int version, GauntletLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    return result;
  }
       public RavaArcanaLevelLinkerTTCIncarnation GetRavaArcanaLevelLinkerTTCIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC[id].incarnation;
  }
  public bool RavaArcanaLevelLinkerTTCExists(int id) {
    return rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC.ContainsKey(id);
  }
  public RavaArcanaLevelLinkerTTC GetRavaArcanaLevelLinkerTTC(int id) {
    CheckHasRavaArcanaLevelLinkerTTC(id);
    return new RavaArcanaLevelLinkerTTC(this, id);
  }
  public RavaArcanaLevelLinkerTTC GetRavaArcanaLevelLinkerTTCOrNull(int id) {
    if (RavaArcanaLevelLinkerTTCExists(id)) {
      return new RavaArcanaLevelLinkerTTC(this, id);
    } else {
      return new RavaArcanaLevelLinkerTTC(this, 0);
    }
  }
  public List<RavaArcanaLevelLinkerTTC> AllRavaArcanaLevelLinkerTTC() {
    List<RavaArcanaLevelLinkerTTC> result = new List<RavaArcanaLevelLinkerTTC>(rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC.Count);
    foreach (var id in rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC.Keys) {
      result.Add(new RavaArcanaLevelLinkerTTC(this, id));
    }
    return result;
  }
  public IEnumerator<RavaArcanaLevelLinkerTTC> EnumAllRavaArcanaLevelLinkerTTC() {
    foreach (var id in rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC.Keys) {
      yield return GetRavaArcanaLevelLinkerTTC(id);
    }
  }
  public void CheckHasRavaArcanaLevelLinkerTTC(RavaArcanaLevelLinkerTTC thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasRavaArcanaLevelLinkerTTC(thing.id);
  }
  public void CheckHasRavaArcanaLevelLinkerTTC(int id) {
    if (!rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC.ContainsKey(id)) {
      throw new System.Exception("Invalid RavaArcanaLevelLinkerTTC: " + id);
    }
  }
  public RavaArcanaLevelLinkerTTC EffectRavaArcanaLevelLinkerTTCCreate(
      int nextLevelDepth) {
    return TrustedEffectRavaArcanaLevelLinkerTTCCreateWithId(NewId()
            ,nextLevelDepth    );
  }
  public RavaArcanaLevelLinkerTTC TrustedEffectRavaArcanaLevelLinkerTTCCreateWithId(int id
,      int nextLevelDepth) {
    CheckUnlocked();

    var incarnation =
        new RavaArcanaLevelLinkerTTCIncarnation(
            nextLevelDepth
            );
    var effect = InternalEffectCreateRavaArcanaLevelLinkerTTC(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new RavaArcanaLevelLinkerTTC(this, id);
  }
  public RavaArcanaLevelLinkerTTCCreateEffect InternalEffectCreateRavaArcanaLevelLinkerTTC(
      int id,
      int incarnationVersion,
      RavaArcanaLevelLinkerTTCIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC.Add(
        id,
        new VersionAndIncarnation<RavaArcanaLevelLinkerTTCIncarnation>(
            incarnationVersion,
            incarnation));
    return new RavaArcanaLevelLinkerTTCCreateEffect(id, incarnation.Copy());
  }

  public void EffectRavaArcanaLevelLinkerTTCDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectRavaArcanaLevelLinkerTTCDelete(id);
    NotifyEffect(effect);
  }
  public RavaArcanaLevelLinkerTTCDeleteEffect InternalEffectRavaArcanaLevelLinkerTTCDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC[id];

    rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC.Remove(id);
    return new RavaArcanaLevelLinkerTTCDeleteEffect(id);
  }

     
  public int GetRavaArcanaLevelLinkerTTCHash(int id, int version, RavaArcanaLevelLinkerTTCIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.nextLevelDepth.GetDeterministicHashCode();
    return result;
  }
       public JumpingCaveLevelControllerIncarnation GetJumpingCaveLevelControllerIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsJumpingCaveLevelController[id].incarnation;
  }
  public bool JumpingCaveLevelControllerExists(int id) {
    return rootIncarnation.incarnationsJumpingCaveLevelController.ContainsKey(id);
  }
  public JumpingCaveLevelController GetJumpingCaveLevelController(int id) {
    CheckHasJumpingCaveLevelController(id);
    return new JumpingCaveLevelController(this, id);
  }
  public JumpingCaveLevelController GetJumpingCaveLevelControllerOrNull(int id) {
    if (JumpingCaveLevelControllerExists(id)) {
      return new JumpingCaveLevelController(this, id);
    } else {
      return new JumpingCaveLevelController(this, 0);
    }
  }
  public List<JumpingCaveLevelController> AllJumpingCaveLevelController() {
    List<JumpingCaveLevelController> result = new List<JumpingCaveLevelController>(rootIncarnation.incarnationsJumpingCaveLevelController.Count);
    foreach (var id in rootIncarnation.incarnationsJumpingCaveLevelController.Keys) {
      result.Add(new JumpingCaveLevelController(this, id));
    }
    return result;
  }
  public IEnumerator<JumpingCaveLevelController> EnumAllJumpingCaveLevelController() {
    foreach (var id in rootIncarnation.incarnationsJumpingCaveLevelController.Keys) {
      yield return GetJumpingCaveLevelController(id);
    }
  }
  public void CheckHasJumpingCaveLevelController(JumpingCaveLevelController thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasJumpingCaveLevelController(thing.id);
  }
  public void CheckHasJumpingCaveLevelController(int id) {
    if (!rootIncarnation.incarnationsJumpingCaveLevelController.ContainsKey(id)) {
      throw new System.Exception("Invalid JumpingCaveLevelController: " + id);
    }
  }
  public JumpingCaveLevelController EffectJumpingCaveLevelControllerCreate(
      Level level,
      int depth) {
    CheckHasLevel(level);
    return TrustedEffectJumpingCaveLevelControllerCreateWithId(NewId()
            ,level.id
            ,depth    );
  }
  public JumpingCaveLevelController TrustedEffectJumpingCaveLevelControllerCreateWithId(int id
,      int level
,      int depth) {
    CheckUnlocked();

    var incarnation =
        new JumpingCaveLevelControllerIncarnation(
            level,
            depth
            );
    var effect = InternalEffectCreateJumpingCaveLevelController(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new JumpingCaveLevelController(this, id);
  }
  public JumpingCaveLevelControllerCreateEffect InternalEffectCreateJumpingCaveLevelController(
      int id,
      int incarnationVersion,
      JumpingCaveLevelControllerIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsJumpingCaveLevelController.Add(
        id,
        new VersionAndIncarnation<JumpingCaveLevelControllerIncarnation>(
            incarnationVersion,
            incarnation));
    return new JumpingCaveLevelControllerCreateEffect(id, incarnation.Copy());
  }

  public void EffectJumpingCaveLevelControllerDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectJumpingCaveLevelControllerDelete(id);
    NotifyEffect(effect);
  }
  public JumpingCaveLevelControllerDeleteEffect InternalEffectJumpingCaveLevelControllerDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsJumpingCaveLevelController[id];

    rootIncarnation.incarnationsJumpingCaveLevelController.Remove(id);
    return new JumpingCaveLevelControllerDeleteEffect(id);
  }

     
  public int GetJumpingCaveLevelControllerHash(int id, int version, JumpingCaveLevelControllerIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.level.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.depth.GetDeterministicHashCode();
    return result;
  }
       public CommIncarnation GetCommIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsComm[id].incarnation;
  }
  public bool CommExists(int id) {
    return rootIncarnation.incarnationsComm.ContainsKey(id);
  }
  public Comm GetComm(int id) {
    CheckHasComm(id);
    return new Comm(this, id);
  }
  public Comm GetCommOrNull(int id) {
    if (CommExists(id)) {
      return new Comm(this, id);
    } else {
      return new Comm(this, 0);
    }
  }
  public List<Comm> AllComm() {
    List<Comm> result = new List<Comm>(rootIncarnation.incarnationsComm.Count);
    foreach (var id in rootIncarnation.incarnationsComm.Keys) {
      result.Add(new Comm(this, id));
    }
    return result;
  }
  public IEnumerator<Comm> EnumAllComm() {
    foreach (var id in rootIncarnation.incarnationsComm.Keys) {
      yield return GetComm(id);
    }
  }
  public void CheckHasComm(Comm thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasComm(thing.id);
  }
  public void CheckHasComm(int id) {
    if (!rootIncarnation.incarnationsComm.ContainsKey(id)) {
      throw new System.Exception("Invalid Comm: " + id);
    }
  }
  public Comm EffectCommCreate(
      ICommTemplate template,
      CommActionImmList actions,
      CommTextImmList texts) {
    return TrustedEffectCommCreateWithId(NewId()
            ,template
            ,actions
            ,texts    );
  }
  public Comm TrustedEffectCommCreateWithId(int id
,      ICommTemplate template
,      CommActionImmList actions
,      CommTextImmList texts) {
    CheckUnlocked();

    var incarnation =
        new CommIncarnation(
            template,
            actions,
            texts
            );
    var effect = InternalEffectCreateComm(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new Comm(this, id);
  }
  public CommCreateEffect InternalEffectCreateComm(
      int id,
      int incarnationVersion,
      CommIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsComm.Add(
        id,
        new VersionAndIncarnation<CommIncarnation>(
            incarnationVersion,
            incarnation));
    return new CommCreateEffect(id, incarnation.Copy());
  }

  public void EffectCommDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectCommDelete(id);
    NotifyEffect(effect);
  }
  public CommDeleteEffect InternalEffectCommDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsComm[id];

    rootIncarnation.incarnationsComm.Remove(id);
    return new CommDeleteEffect(id);
  }

     
  public int GetCommHash(int id, int version, CommIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.template.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.actions.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.texts.GetDeterministicHashCode();
    return result;
  }
       public GameIncarnation GetGameIncarnation(int id) {
    if (id == 0) {
      throw new Exception("Tried dereferencing null!");
    }
    return rootIncarnation.incarnationsGame[id].incarnation;
  }
  public bool GameExists(int id) {
    return rootIncarnation.incarnationsGame.ContainsKey(id);
  }
  public Game GetGame(int id) {
    CheckHasGame(id);
    return new Game(this, id);
  }
  public Game GetGameOrNull(int id) {
    if (GameExists(id)) {
      return new Game(this, id);
    } else {
      return new Game(this, 0);
    }
  }
  public List<Game> AllGame() {
    List<Game> result = new List<Game>(rootIncarnation.incarnationsGame.Count);
    foreach (var id in rootIncarnation.incarnationsGame.Keys) {
      result.Add(new Game(this, id));
    }
    return result;
  }
  public IEnumerator<Game> EnumAllGame() {
    foreach (var id in rootIncarnation.incarnationsGame.Keys) {
      yield return GetGame(id);
    }
  }
  public void CheckHasGame(Game thing) {
    CheckRootsEqual(this, thing.root);
    CheckHasGame(thing.id);
  }
  public void CheckHasGame(int id) {
    if (!rootIncarnation.incarnationsGame.ContainsKey(id)) {
      throw new System.Exception("Invalid Game: " + id);
    }
  }
  public Game EffectGameCreate(
      Rand rand,
      bool squareLevelsOnly,
      LevelMutSet levels,
      Unit player,
      Level level,
      int time,
      Unit actingUnit,
      bool pauseBeforeNextUnit,
      int actionNum,
      string instructions,
      bool hideInput,
      IGameEvent evvent,
      CommMutList comms) {
    CheckHasRand(rand);
    CheckHasLevelMutSet(levels);
    CheckHasCommMutList(comms);
    return TrustedEffectGameCreateWithId(NewId()
            ,rand.id
            ,squareLevelsOnly
            ,levels.id
            ,player.id
            ,level.id
            ,time
            ,actingUnit.id
            ,pauseBeforeNextUnit
            ,actionNum
            ,instructions
            ,hideInput
            ,evvent
            ,comms.id    );
  }
  public Game TrustedEffectGameCreateWithId(int id
,      int rand
,      bool squareLevelsOnly
,      int levels
,      int player
,      int level
,      int time
,      int actingUnit
,      bool pauseBeforeNextUnit
,      int actionNum
,      string instructions
,      bool hideInput
,      IGameEvent evvent
,      int comms) {
    CheckUnlocked();

    var incarnation =
        new GameIncarnation(
            rand,
            squareLevelsOnly,
            levels,
            player,
            level,
            time,
            actingUnit,
            pauseBeforeNextUnit,
            actionNum,
            instructions,
            hideInput,
            evvent,
            comms
            );
    var effect = InternalEffectCreateGame(id, rootIncarnation.version, incarnation);
    NotifyEffect(effect);
    return new Game(this, id);
  }
  public GameCreateEffect InternalEffectCreateGame(
      int id,
      int incarnationVersion,
      GameIncarnation incarnation) {
    CheckUnlocked();
    rootIncarnation.incarnationsGame.Add(
        id,
        new VersionAndIncarnation<GameIncarnation>(
            incarnationVersion,
            incarnation));
    return new GameCreateEffect(id, incarnation.Copy());
  }

  public void EffectGameDelete(int id) {
    CheckUnlocked();
    var effect = InternalEffectGameDelete(id);
    NotifyEffect(effect);
  }
  public GameDeleteEffect InternalEffectGameDelete(int id) {
    var oldIncarnationAndVersion =
        rootIncarnation.incarnationsGame[id];

    rootIncarnation.incarnationsGame.Remove(id);
    return new GameDeleteEffect(id);
  }

     
  public int GetGameHash(int id, int version, GameIncarnation incarnation) {
    int result = id * version;
    result += id * version * 1 * incarnation.rand.GetDeterministicHashCode();
    result += id * version * 2 * incarnation.squareLevelsOnly.GetDeterministicHashCode();
    result += id * version * 3 * incarnation.levels.GetDeterministicHashCode();
    if (!object.ReferenceEquals(incarnation.player, null)) {
      result += id * version * 4 * incarnation.player.GetDeterministicHashCode();
    }
    if (!object.ReferenceEquals(incarnation.level, null)) {
      result += id * version * 5 * incarnation.level.GetDeterministicHashCode();
    }
    result += id * version * 6 * incarnation.time.GetDeterministicHashCode();
    if (!object.ReferenceEquals(incarnation.actingUnit, null)) {
      result += id * version * 7 * incarnation.actingUnit.GetDeterministicHashCode();
    }
    result += id * version * 8 * incarnation.pauseBeforeNextUnit.GetDeterministicHashCode();
    result += id * version * 9 * incarnation.actionNum.GetDeterministicHashCode();
    result += id * version * 10 * incarnation.instructions.GetDeterministicHashCode();
    result += id * version * 11 * incarnation.hideInput.GetDeterministicHashCode();
    if (!object.ReferenceEquals(incarnation.evvent, null)) {
      result += id * version * 12 * incarnation.evvent.GetDeterministicHashCode();
    }
    result += id * version * 13 * incarnation.comms.GetDeterministicHashCode();
    return result;
  }
     
  public void EffectGameSetPlayer(
      int id, Unit newValue) {
    CheckUnlocked();
    CheckHasGame(id);
    var effect = InternalEffectGameSetPlayer(id, newValue);
    NotifyEffect(effect);
  }
  public GameSetPlayerEffect InternalEffectGameSetPlayer(int id, Unit newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldId = oldIncarnationAndVersion.incarnation.player;
      oldIncarnationAndVersion.incarnation.player = newValue.id;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.levels,
              newValue.id,
              oldIncarnationAndVersion.incarnation.level,
              oldIncarnationAndVersion.incarnation.time,
              oldIncarnationAndVersion.incarnation.actingUnit,
              oldIncarnationAndVersion.incarnation.pauseBeforeNextUnit,
              oldIncarnationAndVersion.incarnation.actionNum,
              oldIncarnationAndVersion.incarnation.instructions,
              oldIncarnationAndVersion.incarnation.hideInput,
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.comms);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new GameSetPlayerEffect(id, newValue.id);
  }

  public void EffectGameSetLevel(
      int id, Level newValue) {
    CheckUnlocked();
    CheckHasGame(id);
    var effect = InternalEffectGameSetLevel(id, newValue);
    NotifyEffect(effect);
  }
  public GameSetLevelEffect InternalEffectGameSetLevel(int id, Level newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldId = oldIncarnationAndVersion.incarnation.level;
      oldIncarnationAndVersion.incarnation.level = newValue.id;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.levels,
              oldIncarnationAndVersion.incarnation.player,
              newValue.id,
              oldIncarnationAndVersion.incarnation.time,
              oldIncarnationAndVersion.incarnation.actingUnit,
              oldIncarnationAndVersion.incarnation.pauseBeforeNextUnit,
              oldIncarnationAndVersion.incarnation.actionNum,
              oldIncarnationAndVersion.incarnation.instructions,
              oldIncarnationAndVersion.incarnation.hideInput,
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.comms);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new GameSetLevelEffect(id, newValue.id);
  }

  public void EffectGameSetTime(
      int id, int newValue) {
    CheckUnlocked();
    CheckHasGame(id);
    var effect = InternalEffectGameSetTime(id, newValue);
    NotifyEffect(effect);
  }
  public GameSetTimeEffect InternalEffectGameSetTime(int id, int newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.time;
      oldIncarnationAndVersion.incarnation.time = newValue;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.levels,
              oldIncarnationAndVersion.incarnation.player,
              oldIncarnationAndVersion.incarnation.level,
              newValue,
              oldIncarnationAndVersion.incarnation.actingUnit,
              oldIncarnationAndVersion.incarnation.pauseBeforeNextUnit,
              oldIncarnationAndVersion.incarnation.actionNum,
              oldIncarnationAndVersion.incarnation.instructions,
              oldIncarnationAndVersion.incarnation.hideInput,
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.comms);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new GameSetTimeEffect(id, newValue);
  }

  public void EffectGameSetActingUnit(
      int id, Unit newValue) {
    CheckUnlocked();
    CheckHasGame(id);
    var effect = InternalEffectGameSetActingUnit(id, newValue);
    NotifyEffect(effect);
  }
  public GameSetActingUnitEffect InternalEffectGameSetActingUnit(int id, Unit newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldId = oldIncarnationAndVersion.incarnation.actingUnit;
      oldIncarnationAndVersion.incarnation.actingUnit = newValue.id;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.levels,
              oldIncarnationAndVersion.incarnation.player,
              oldIncarnationAndVersion.incarnation.level,
              oldIncarnationAndVersion.incarnation.time,
              newValue.id,
              oldIncarnationAndVersion.incarnation.pauseBeforeNextUnit,
              oldIncarnationAndVersion.incarnation.actionNum,
              oldIncarnationAndVersion.incarnation.instructions,
              oldIncarnationAndVersion.incarnation.hideInput,
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.comms);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new GameSetActingUnitEffect(id, newValue.id);
  }

  public void EffectGameSetPauseBeforeNextUnit(
      int id, bool newValue) {
    CheckUnlocked();
    CheckHasGame(id);
    var effect = InternalEffectGameSetPauseBeforeNextUnit(id, newValue);
    NotifyEffect(effect);
  }
  public GameSetPauseBeforeNextUnitEffect InternalEffectGameSetPauseBeforeNextUnit(int id, bool newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.pauseBeforeNextUnit;
      oldIncarnationAndVersion.incarnation.pauseBeforeNextUnit = newValue;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.levels,
              oldIncarnationAndVersion.incarnation.player,
              oldIncarnationAndVersion.incarnation.level,
              oldIncarnationAndVersion.incarnation.time,
              oldIncarnationAndVersion.incarnation.actingUnit,
              newValue,
              oldIncarnationAndVersion.incarnation.actionNum,
              oldIncarnationAndVersion.incarnation.instructions,
              oldIncarnationAndVersion.incarnation.hideInput,
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.comms);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new GameSetPauseBeforeNextUnitEffect(id, newValue);
  }

  public void EffectGameSetActionNum(
      int id, int newValue) {
    CheckUnlocked();
    CheckHasGame(id);
    var effect = InternalEffectGameSetActionNum(id, newValue);
    NotifyEffect(effect);
  }
  public GameSetActionNumEffect InternalEffectGameSetActionNum(int id, int newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.actionNum;
      oldIncarnationAndVersion.incarnation.actionNum = newValue;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.levels,
              oldIncarnationAndVersion.incarnation.player,
              oldIncarnationAndVersion.incarnation.level,
              oldIncarnationAndVersion.incarnation.time,
              oldIncarnationAndVersion.incarnation.actingUnit,
              oldIncarnationAndVersion.incarnation.pauseBeforeNextUnit,
              newValue,
              oldIncarnationAndVersion.incarnation.instructions,
              oldIncarnationAndVersion.incarnation.hideInput,
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.comms);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new GameSetActionNumEffect(id, newValue);
  }

  public void EffectGameSetInstructions(
      int id, string newValue) {
    CheckUnlocked();
    CheckHasGame(id);
    var effect = InternalEffectGameSetInstructions(id, newValue);
    NotifyEffect(effect);
  }
  public GameSetInstructionsEffect InternalEffectGameSetInstructions(int id, string newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.instructions;
      oldIncarnationAndVersion.incarnation.instructions = newValue;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.levels,
              oldIncarnationAndVersion.incarnation.player,
              oldIncarnationAndVersion.incarnation.level,
              oldIncarnationAndVersion.incarnation.time,
              oldIncarnationAndVersion.incarnation.actingUnit,
              oldIncarnationAndVersion.incarnation.pauseBeforeNextUnit,
              oldIncarnationAndVersion.incarnation.actionNum,
              newValue,
              oldIncarnationAndVersion.incarnation.hideInput,
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.comms);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new GameSetInstructionsEffect(id, newValue);
  }

  public void EffectGameSetHideInput(
      int id, bool newValue) {
    CheckUnlocked();
    CheckHasGame(id);
    var effect = InternalEffectGameSetHideInput(id, newValue);
    NotifyEffect(effect);
  }
  public GameSetHideInputEffect InternalEffectGameSetHideInput(int id, bool newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.hideInput;
      oldIncarnationAndVersion.incarnation.hideInput = newValue;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.levels,
              oldIncarnationAndVersion.incarnation.player,
              oldIncarnationAndVersion.incarnation.level,
              oldIncarnationAndVersion.incarnation.time,
              oldIncarnationAndVersion.incarnation.actingUnit,
              oldIncarnationAndVersion.incarnation.pauseBeforeNextUnit,
              oldIncarnationAndVersion.incarnation.actionNum,
              oldIncarnationAndVersion.incarnation.instructions,
              newValue,
              oldIncarnationAndVersion.incarnation.evvent,
              oldIncarnationAndVersion.incarnation.comms);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new GameSetHideInputEffect(id, newValue);
  }

  public void EffectGameSetEvvent(
      int id, IGameEvent newValue) {
    CheckUnlocked();
    CheckHasGame(id);
    var effect = InternalEffectGameSetEvvent(id, newValue);
    NotifyEffect(effect);
  }
  public GameSetEvventEffect InternalEffectGameSetEvvent(int id, IGameEvent newValue) {
    var oldIncarnationAndVersion = rootIncarnation.incarnationsGame[id];
    if (oldIncarnationAndVersion.version == rootIncarnation.version) {
      var oldValue = oldIncarnationAndVersion.incarnation.evvent;
      oldIncarnationAndVersion.incarnation.evvent = newValue;

    } else {
      var newIncarnation =
          new GameIncarnation(
              oldIncarnationAndVersion.incarnation.rand,
              oldIncarnationAndVersion.incarnation.squareLevelsOnly,
              oldIncarnationAndVersion.incarnation.levels,
              oldIncarnationAndVersion.incarnation.player,
              oldIncarnationAndVersion.incarnation.level,
              oldIncarnationAndVersion.incarnation.time,
              oldIncarnationAndVersion.incarnation.actingUnit,
              oldIncarnationAndVersion.incarnation.pauseBeforeNextUnit,
              oldIncarnationAndVersion.incarnation.actionNum,
              oldIncarnationAndVersion.incarnation.instructions,
              oldIncarnationAndVersion.incarnation.hideInput,
              newValue,
              oldIncarnationAndVersion.incarnation.comms);
      rootIncarnation.incarnationsGame[id] =
          new VersionAndIncarnation<GameIncarnation>(
              rootIncarnation.version,
              newIncarnation);
    }

return new GameSetEvventEffect(id, newValue);
  }

  public IDeathPreReactor GetIDeathPreReactor(int id) {
    if (rootIncarnation.incarnationsDeathTriggerUC.ContainsKey(id)) {
      return new DeathTriggerUCAsIDeathPreReactor(new DeathTriggerUC(this, id));
    }
    if (rootIncarnation.incarnationsBequeathUC.ContainsKey(id)) {
      return new BequeathUCAsIDeathPreReactor(new BequeathUC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      return new KamikazeAICapabilityUCAsIDeathPreReactor(new KamikazeAICapabilityUC(this, id));
    }
    throw new Exception("Unknown IDeathPreReactor: " + id);
  }
  public IDeathPreReactor GetIDeathPreReactorOrNull(int id) {
    if (rootIncarnation.incarnationsDeathTriggerUC.ContainsKey(id)) {
      return new DeathTriggerUCAsIDeathPreReactor(new DeathTriggerUC(this, id));
    }
    if (rootIncarnation.incarnationsBequeathUC.ContainsKey(id)) {
      return new BequeathUCAsIDeathPreReactor(new BequeathUC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      return new KamikazeAICapabilityUCAsIDeathPreReactor(new KamikazeAICapabilityUC(this, id));
    }
    return NullIDeathPreReactor.Null;
  }
  public bool IDeathPreReactorExists(int id) {
    return GetIDeathPreReactorOrNull(id) != null;
  }
  public void CheckHasIDeathPreReactor(IDeathPreReactor thing) {
    GetIDeathPreReactor(thing.id);
  }
  public void CheckHasIDeathPreReactor(int id) {
    GetIDeathPreReactor(id);
  }

  public IImpulsePostReactor GetIImpulsePostReactor(int id) {
    if (rootIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(id)) {
      return new TutorialDefyCounterUCAsIImpulsePostReactor(new TutorialDefyCounterUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIImpulsePostReactor(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIImpulsePostReactor(new AttackAICapabilityUC(this, id));
    }
    throw new Exception("Unknown IImpulsePostReactor: " + id);
  }
  public IImpulsePostReactor GetIImpulsePostReactorOrNull(int id) {
    if (rootIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(id)) {
      return new TutorialDefyCounterUCAsIImpulsePostReactor(new TutorialDefyCounterUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIImpulsePostReactor(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIImpulsePostReactor(new AttackAICapabilityUC(this, id));
    }
    return NullIImpulsePostReactor.Null;
  }
  public bool IImpulsePostReactorExists(int id) {
    return GetIImpulsePostReactorOrNull(id) != null;
  }
  public void CheckHasIImpulsePostReactor(IImpulsePostReactor thing) {
    GetIImpulsePostReactor(thing.id);
  }
  public void CheckHasIImpulsePostReactor(int id) {
    GetIImpulsePostReactor(id);
  }

  public IImpulsePreReactor GetIImpulsePreReactor(int id) {
    if (rootIncarnation.incarnationsLightningChargingUC.ContainsKey(id)) {
      return new LightningChargingUCAsIImpulsePreReactor(new LightningChargingUC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      return new KamikazeAICapabilityUCAsIImpulsePreReactor(new KamikazeAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIImpulsePreReactor(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIImpulsePreReactor(new AttackAICapabilityUC(this, id));
    }
    throw new Exception("Unknown IImpulsePreReactor: " + id);
  }
  public IImpulsePreReactor GetIImpulsePreReactorOrNull(int id) {
    if (rootIncarnation.incarnationsLightningChargingUC.ContainsKey(id)) {
      return new LightningChargingUCAsIImpulsePreReactor(new LightningChargingUC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      return new KamikazeAICapabilityUCAsIImpulsePreReactor(new KamikazeAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIImpulsePreReactor(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIImpulsePreReactor(new AttackAICapabilityUC(this, id));
    }
    return NullIImpulsePreReactor.Null;
  }
  public bool IImpulsePreReactorExists(int id) {
    return GetIImpulsePreReactorOrNull(id) != null;
  }
  public void CheckHasIImpulsePreReactor(IImpulsePreReactor thing) {
    GetIImpulsePreReactor(thing.id);
  }
  public void CheckHasIImpulsePreReactor(int id) {
    GetIImpulsePreReactor(id);
  }

  public IAICapabilityUC GetIAICapabilityUC(int id) {
    if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      return new WanderAICapabilityUCAsIAICapabilityUC(new WanderAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(id)) {
      return new TemporaryCloneAICapabilityUCAsIAICapabilityUC(new TemporaryCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(id)) {
      return new SummonAICapabilityUCAsIAICapabilityUC(new SummonAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIAICapabilityUC(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      return new KamikazeAICapabilityUCAsIAICapabilityUC(new KamikazeAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(id)) {
      return new GuardAICapabilityUCAsIAICapabilityUC(new GuardAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsEvolvifyAICapabilityUC.ContainsKey(id)) {
      return new EvolvifyAICapabilityUCAsIAICapabilityUC(new EvolvifyAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIAICapabilityUC(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIAICapabilityUC(new AttackAICapabilityUC(this, id));
    }
    throw new Exception("Unknown IAICapabilityUC: " + id);
  }
  public IAICapabilityUC GetIAICapabilityUCOrNull(int id) {
    if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      return new WanderAICapabilityUCAsIAICapabilityUC(new WanderAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(id)) {
      return new TemporaryCloneAICapabilityUCAsIAICapabilityUC(new TemporaryCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(id)) {
      return new SummonAICapabilityUCAsIAICapabilityUC(new SummonAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIAICapabilityUC(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      return new KamikazeAICapabilityUCAsIAICapabilityUC(new KamikazeAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(id)) {
      return new GuardAICapabilityUCAsIAICapabilityUC(new GuardAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsEvolvifyAICapabilityUC.ContainsKey(id)) {
      return new EvolvifyAICapabilityUCAsIAICapabilityUC(new EvolvifyAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIAICapabilityUC(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIAICapabilityUC(new AttackAICapabilityUC(this, id));
    }
    return NullIAICapabilityUC.Null;
  }
  public bool IAICapabilityUCExists(int id) {
    return GetIAICapabilityUCOrNull(id) != null;
  }
  public void CheckHasIAICapabilityUC(IAICapabilityUC thing) {
    GetIAICapabilityUC(thing.id);
  }
  public void CheckHasIAICapabilityUC(int id) {
    GetIAICapabilityUC(id);
  }

  public IPostActingUC GetIPostActingUC(int id) {
    if (rootIncarnation.incarnationsLightningChargedUC.ContainsKey(id)) {
      return new LightningChargedUCAsIPostActingUC(new LightningChargedUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIPostActingUC(new TimeCloneAICapabilityUC(this, id));
    }
    throw new Exception("Unknown IPostActingUC: " + id);
  }
  public IPostActingUC GetIPostActingUCOrNull(int id) {
    if (rootIncarnation.incarnationsLightningChargedUC.ContainsKey(id)) {
      return new LightningChargedUCAsIPostActingUC(new LightningChargedUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIPostActingUC(new TimeCloneAICapabilityUC(this, id));
    }
    return NullIPostActingUC.Null;
  }
  public bool IPostActingUCExists(int id) {
    return GetIPostActingUCOrNull(id) != null;
  }
  public void CheckHasIPostActingUC(IPostActingUC thing) {
    GetIPostActingUC(thing.id);
  }
  public void CheckHasIPostActingUC(int id) {
    GetIPostActingUC(id);
  }

  public IPreActingUC GetIPreActingUC(int id) {
    if (rootIncarnation.incarnationsDoomedUC.ContainsKey(id)) {
      return new DoomedUCAsIPreActingUC(new DoomedUC(this, id));
    }
    if (rootIncarnation.incarnationsMiredUC.ContainsKey(id)) {
      return new MiredUCAsIPreActingUC(new MiredUC(this, id));
    }
    if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      return new InvincibilityUCAsIPreActingUC(new InvincibilityUC(this, id));
    }
    if (rootIncarnation.incarnationsOnFireUC.ContainsKey(id)) {
      return new OnFireUCAsIPreActingUC(new OnFireUC(this, id));
    }
    if (rootIncarnation.incarnationsDefyingUC.ContainsKey(id)) {
      return new DefyingUCAsIPreActingUC(new DefyingUC(this, id));
    }
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIPreActingUC(new CounteringUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIPreActingUC(new AttackAICapabilityUC(this, id));
    }
    throw new Exception("Unknown IPreActingUC: " + id);
  }
  public IPreActingUC GetIPreActingUCOrNull(int id) {
    if (rootIncarnation.incarnationsDoomedUC.ContainsKey(id)) {
      return new DoomedUCAsIPreActingUC(new DoomedUC(this, id));
    }
    if (rootIncarnation.incarnationsMiredUC.ContainsKey(id)) {
      return new MiredUCAsIPreActingUC(new MiredUC(this, id));
    }
    if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      return new InvincibilityUCAsIPreActingUC(new InvincibilityUC(this, id));
    }
    if (rootIncarnation.incarnationsOnFireUC.ContainsKey(id)) {
      return new OnFireUCAsIPreActingUC(new OnFireUC(this, id));
    }
    if (rootIncarnation.incarnationsDefyingUC.ContainsKey(id)) {
      return new DefyingUCAsIPreActingUC(new DefyingUC(this, id));
    }
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIPreActingUC(new CounteringUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIPreActingUC(new AttackAICapabilityUC(this, id));
    }
    return NullIPreActingUC.Null;
  }
  public bool IPreActingUCExists(int id) {
    return GetIPreActingUCOrNull(id) != null;
  }
  public void CheckHasIPreActingUC(IPreActingUC thing) {
    GetIPreActingUC(thing.id);
  }
  public void CheckHasIPreActingUC(int id) {
    GetIPreActingUC(id);
  }

  public IReactingToAttacksUC GetIReactingToAttacksUC(int id) {
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIReactingToAttacksUC(new CounteringUC(this, id));
    }
    throw new Exception("Unknown IReactingToAttacksUC: " + id);
  }
  public IReactingToAttacksUC GetIReactingToAttacksUCOrNull(int id) {
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIReactingToAttacksUC(new CounteringUC(this, id));
    }
    return NullIReactingToAttacksUC.Null;
  }
  public bool IReactingToAttacksUCExists(int id) {
    return GetIReactingToAttacksUCOrNull(id) != null;
  }
  public void CheckHasIReactingToAttacksUC(IReactingToAttacksUC thing) {
    GetIReactingToAttacksUC(thing.id);
  }
  public void CheckHasIReactingToAttacksUC(int id) {
    GetIReactingToAttacksUC(id);
  }

  public IUnitComponent GetIUnitComponent(int id) {
    if (rootIncarnation.incarnationsDeathTriggerUC.ContainsKey(id)) {
      return new DeathTriggerUCAsIUnitComponent(new DeathTriggerUC(this, id));
    }
    if (rootIncarnation.incarnationsBequeathUC.ContainsKey(id)) {
      return new BequeathUCAsIUnitComponent(new BequeathUC(this, id));
    }
    if (rootIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(id)) {
      return new TutorialDefyCounterUCAsIUnitComponent(new TutorialDefyCounterUC(this, id));
    }
    if (rootIncarnation.incarnationsLightningChargingUC.ContainsKey(id)) {
      return new LightningChargingUCAsIUnitComponent(new LightningChargingUC(this, id));
    }
    if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      return new WanderAICapabilityUCAsIUnitComponent(new WanderAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(id)) {
      return new TemporaryCloneAICapabilityUCAsIUnitComponent(new TemporaryCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(id)) {
      return new SummonAICapabilityUCAsIUnitComponent(new SummonAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      return new KamikazeAICapabilityUCAsIUnitComponent(new KamikazeAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(id)) {
      return new GuardAICapabilityUCAsIUnitComponent(new GuardAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsEvolvifyAICapabilityUC.ContainsKey(id)) {
      return new EvolvifyAICapabilityUCAsIUnitComponent(new EvolvifyAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIUnitComponent(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDoomedUC.ContainsKey(id)) {
      return new DoomedUCAsIUnitComponent(new DoomedUC(this, id));
    }
    if (rootIncarnation.incarnationsMiredUC.ContainsKey(id)) {
      return new MiredUCAsIUnitComponent(new MiredUC(this, id));
    }
    if (rootIncarnation.incarnationsOnFireUC.ContainsKey(id)) {
      return new OnFireUCAsIUnitComponent(new OnFireUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIUnitComponent(new AttackAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIUnitComponent(new CounteringUC(this, id));
    }
    if (rootIncarnation.incarnationsLightningChargedUC.ContainsKey(id)) {
      return new LightningChargedUCAsIUnitComponent(new LightningChargedUC(this, id));
    }
    if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      return new InvincibilityUCAsIUnitComponent(new InvincibilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDefyingUC.ContainsKey(id)) {
      return new DefyingUCAsIUnitComponent(new DefyingUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIUnitComponent(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(id)) {
      return new BaseSightRangeUCAsIUnitComponent(new BaseSightRangeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(id)) {
      return new BaseMovementTimeUCAsIUnitComponent(new BaseMovementTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(id)) {
      return new BaseCombatTimeUCAsIUnitComponent(new BaseCombatTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIUnitComponent(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIUnitComponent(new HealthPotion(this, id));
    }
    if (rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      return new SpeedRingAsIUnitComponent(new SpeedRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIUnitComponent(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      return new SlowRodAsIUnitComponent(new SlowRod(this, id));
    }
    if (rootIncarnation.incarnationsExplosionRod.ContainsKey(id)) {
      return new ExplosionRodAsIUnitComponent(new ExplosionRod(this, id));
    }
    if (rootIncarnation.incarnationsBlazeRod.ContainsKey(id)) {
      return new BlazeRodAsIUnitComponent(new BlazeRod(this, id));
    }
    if (rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      return new BlastRodAsIUnitComponent(new BlastRod(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIUnitComponent(new Armor(this, id));
    }
    if (rootIncarnation.incarnationsSorcerousUC.ContainsKey(id)) {
      return new SorcerousUCAsIUnitComponent(new SorcerousUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(id)) {
      return new BaseOffenseUCAsIUnitComponent(new BaseOffenseUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(id)) {
      return new BaseDefenseUCAsIUnitComponent(new BaseDefenseUC(this, id));
    }
    throw new Exception("Unknown IUnitComponent: " + id);
  }
  public IUnitComponent GetIUnitComponentOrNull(int id) {
    if (rootIncarnation.incarnationsDeathTriggerUC.ContainsKey(id)) {
      return new DeathTriggerUCAsIUnitComponent(new DeathTriggerUC(this, id));
    }
    if (rootIncarnation.incarnationsBequeathUC.ContainsKey(id)) {
      return new BequeathUCAsIUnitComponent(new BequeathUC(this, id));
    }
    if (rootIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(id)) {
      return new TutorialDefyCounterUCAsIUnitComponent(new TutorialDefyCounterUC(this, id));
    }
    if (rootIncarnation.incarnationsLightningChargingUC.ContainsKey(id)) {
      return new LightningChargingUCAsIUnitComponent(new LightningChargingUC(this, id));
    }
    if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      return new WanderAICapabilityUCAsIUnitComponent(new WanderAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(id)) {
      return new TemporaryCloneAICapabilityUCAsIUnitComponent(new TemporaryCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(id)) {
      return new SummonAICapabilityUCAsIUnitComponent(new SummonAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      return new KamikazeAICapabilityUCAsIUnitComponent(new KamikazeAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(id)) {
      return new GuardAICapabilityUCAsIUnitComponent(new GuardAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsEvolvifyAICapabilityUC.ContainsKey(id)) {
      return new EvolvifyAICapabilityUCAsIUnitComponent(new EvolvifyAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIUnitComponent(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDoomedUC.ContainsKey(id)) {
      return new DoomedUCAsIUnitComponent(new DoomedUC(this, id));
    }
    if (rootIncarnation.incarnationsMiredUC.ContainsKey(id)) {
      return new MiredUCAsIUnitComponent(new MiredUC(this, id));
    }
    if (rootIncarnation.incarnationsOnFireUC.ContainsKey(id)) {
      return new OnFireUCAsIUnitComponent(new OnFireUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIUnitComponent(new AttackAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIUnitComponent(new CounteringUC(this, id));
    }
    if (rootIncarnation.incarnationsLightningChargedUC.ContainsKey(id)) {
      return new LightningChargedUCAsIUnitComponent(new LightningChargedUC(this, id));
    }
    if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      return new InvincibilityUCAsIUnitComponent(new InvincibilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDefyingUC.ContainsKey(id)) {
      return new DefyingUCAsIUnitComponent(new DefyingUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIUnitComponent(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(id)) {
      return new BaseSightRangeUCAsIUnitComponent(new BaseSightRangeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(id)) {
      return new BaseMovementTimeUCAsIUnitComponent(new BaseMovementTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(id)) {
      return new BaseCombatTimeUCAsIUnitComponent(new BaseCombatTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIUnitComponent(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIUnitComponent(new HealthPotion(this, id));
    }
    if (rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      return new SpeedRingAsIUnitComponent(new SpeedRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIUnitComponent(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      return new SlowRodAsIUnitComponent(new SlowRod(this, id));
    }
    if (rootIncarnation.incarnationsExplosionRod.ContainsKey(id)) {
      return new ExplosionRodAsIUnitComponent(new ExplosionRod(this, id));
    }
    if (rootIncarnation.incarnationsBlazeRod.ContainsKey(id)) {
      return new BlazeRodAsIUnitComponent(new BlazeRod(this, id));
    }
    if (rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      return new BlastRodAsIUnitComponent(new BlastRod(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIUnitComponent(new Armor(this, id));
    }
    if (rootIncarnation.incarnationsSorcerousUC.ContainsKey(id)) {
      return new SorcerousUCAsIUnitComponent(new SorcerousUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(id)) {
      return new BaseOffenseUCAsIUnitComponent(new BaseOffenseUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(id)) {
      return new BaseDefenseUCAsIUnitComponent(new BaseDefenseUC(this, id));
    }
    return NullIUnitComponent.Null;
  }
  public bool IUnitComponentExists(int id) {
    return GetIUnitComponentOrNull(id) != null;
  }
  public void CheckHasIUnitComponent(IUnitComponent thing) {
    GetIUnitComponent(thing.id);
  }
  public void CheckHasIUnitComponent(int id) {
    GetIUnitComponent(id);
  }

  public IOffenseFactorUC GetIOffenseFactorUC(int id) {
    if (rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(id)) {
      return new BaseOffenseUCAsIOffenseFactorUC(new BaseOffenseUC(this, id));
    }
    if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      return new InvincibilityUCAsIOffenseFactorUC(new InvincibilityUC(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIOffenseFactorUC(new Glaive(this, id));
    }
    throw new Exception("Unknown IOffenseFactorUC: " + id);
  }
  public IOffenseFactorUC GetIOffenseFactorUCOrNull(int id) {
    if (rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(id)) {
      return new BaseOffenseUCAsIOffenseFactorUC(new BaseOffenseUC(this, id));
    }
    if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      return new InvincibilityUCAsIOffenseFactorUC(new InvincibilityUC(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIOffenseFactorUC(new Glaive(this, id));
    }
    return NullIOffenseFactorUC.Null;
  }
  public bool IOffenseFactorUCExists(int id) {
    return GetIOffenseFactorUCOrNull(id) != null;
  }
  public void CheckHasIOffenseFactorUC(IOffenseFactorUC thing) {
    GetIOffenseFactorUC(thing.id);
  }
  public void CheckHasIOffenseFactorUC(int id) {
    GetIOffenseFactorUC(id);
  }

  public ISightRangeFactorUC GetISightRangeFactorUC(int id) {
    if (rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(id)) {
      return new BaseSightRangeUCAsISightRangeFactorUC(new BaseSightRangeUC(this, id));
    }
    throw new Exception("Unknown ISightRangeFactorUC: " + id);
  }
  public ISightRangeFactorUC GetISightRangeFactorUCOrNull(int id) {
    if (rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(id)) {
      return new BaseSightRangeUCAsISightRangeFactorUC(new BaseSightRangeUC(this, id));
    }
    return NullISightRangeFactorUC.Null;
  }
  public bool ISightRangeFactorUCExists(int id) {
    return GetISightRangeFactorUCOrNull(id) != null;
  }
  public void CheckHasISightRangeFactorUC(ISightRangeFactorUC thing) {
    GetISightRangeFactorUC(thing.id);
  }
  public void CheckHasISightRangeFactorUC(int id) {
    GetISightRangeFactorUC(id);
  }

  public IMovementTimeFactorUC GetIMovementTimeFactorUC(int id) {
    if (rootIncarnation.incarnationsLightningChargedUC.ContainsKey(id)) {
      return new LightningChargedUCAsIMovementTimeFactorUC(new LightningChargedUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(id)) {
      return new BaseMovementTimeUCAsIMovementTimeFactorUC(new BaseMovementTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      return new SpeedRingAsIMovementTimeFactorUC(new SpeedRing(this, id));
    }
    throw new Exception("Unknown IMovementTimeFactorUC: " + id);
  }
  public IMovementTimeFactorUC GetIMovementTimeFactorUCOrNull(int id) {
    if (rootIncarnation.incarnationsLightningChargedUC.ContainsKey(id)) {
      return new LightningChargedUCAsIMovementTimeFactorUC(new LightningChargedUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(id)) {
      return new BaseMovementTimeUCAsIMovementTimeFactorUC(new BaseMovementTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      return new SpeedRingAsIMovementTimeFactorUC(new SpeedRing(this, id));
    }
    return NullIMovementTimeFactorUC.Null;
  }
  public bool IMovementTimeFactorUCExists(int id) {
    return GetIMovementTimeFactorUCOrNull(id) != null;
  }
  public void CheckHasIMovementTimeFactorUC(IMovementTimeFactorUC thing) {
    GetIMovementTimeFactorUC(thing.id);
  }
  public void CheckHasIMovementTimeFactorUC(int id) {
    GetIMovementTimeFactorUC(id);
  }

  public IDefenseFactorUC GetIDefenseFactorUC(int id) {
    if (rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(id)) {
      return new BaseDefenseUCAsIDefenseFactorUC(new BaseDefenseUC(this, id));
    }
    if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      return new InvincibilityUCAsIDefenseFactorUC(new InvincibilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDefyingUC.ContainsKey(id)) {
      return new DefyingUCAsIDefenseFactorUC(new DefyingUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIDefenseFactorUC(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIDefenseFactorUC(new Armor(this, id));
    }
    throw new Exception("Unknown IDefenseFactorUC: " + id);
  }
  public IDefenseFactorUC GetIDefenseFactorUCOrNull(int id) {
    if (rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(id)) {
      return new BaseDefenseUCAsIDefenseFactorUC(new BaseDefenseUC(this, id));
    }
    if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      return new InvincibilityUCAsIDefenseFactorUC(new InvincibilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDefyingUC.ContainsKey(id)) {
      return new DefyingUCAsIDefenseFactorUC(new DefyingUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIDefenseFactorUC(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIDefenseFactorUC(new Armor(this, id));
    }
    return NullIDefenseFactorUC.Null;
  }
  public bool IDefenseFactorUCExists(int id) {
    return GetIDefenseFactorUCOrNull(id) != null;
  }
  public void CheckHasIDefenseFactorUC(IDefenseFactorUC thing) {
    GetIDefenseFactorUC(thing.id);
  }
  public void CheckHasIDefenseFactorUC(int id) {
    GetIDefenseFactorUC(id);
  }

  public ICombatTimeFactorUC GetICombatTimeFactorUC(int id) {
    if (rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(id)) {
      return new BaseCombatTimeUCAsICombatTimeFactorUC(new BaseCombatTimeUC(this, id));
    }
    throw new Exception("Unknown ICombatTimeFactorUC: " + id);
  }
  public ICombatTimeFactorUC GetICombatTimeFactorUCOrNull(int id) {
    if (rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(id)) {
      return new BaseCombatTimeUCAsICombatTimeFactorUC(new BaseCombatTimeUC(this, id));
    }
    return NullICombatTimeFactorUC.Null;
  }
  public bool ICombatTimeFactorUCExists(int id) {
    return GetICombatTimeFactorUCOrNull(id) != null;
  }
  public void CheckHasICombatTimeFactorUC(ICombatTimeFactorUC thing) {
    GetICombatTimeFactorUC(thing.id);
  }
  public void CheckHasICombatTimeFactorUC(int id) {
    GetICombatTimeFactorUC(id);
  }

  public IImpulse GetIImpulse(int id) {
    if (rootIncarnation.incarnationsHoldPositionImpulse.ContainsKey(id)) {
      return new HoldPositionImpulseAsIImpulse(new HoldPositionImpulse(this, id));
    }
    if (rootIncarnation.incarnationsTemporaryCloneImpulse.ContainsKey(id)) {
      return new TemporaryCloneImpulseAsIImpulse(new TemporaryCloneImpulse(this, id));
    }
    if (rootIncarnation.incarnationsSummonImpulse.ContainsKey(id)) {
      return new SummonImpulseAsIImpulse(new SummonImpulse(this, id));
    }
    if (rootIncarnation.incarnationsMireImpulse.ContainsKey(id)) {
      return new MireImpulseAsIImpulse(new MireImpulse(this, id));
    }
    if (rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(id)) {
      return new EvaporateImpulseAsIImpulse(new EvaporateImpulse(this, id));
    }
    if (rootIncarnation.incarnationsMoveImpulse.ContainsKey(id)) {
      return new MoveImpulseAsIImpulse(new MoveImpulse(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeJumpImpulse.ContainsKey(id)) {
      return new KamikazeJumpImpulseAsIImpulse(new KamikazeJumpImpulse(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeTargetImpulse.ContainsKey(id)) {
      return new KamikazeTargetImpulseAsIImpulse(new KamikazeTargetImpulse(this, id));
    }
    if (rootIncarnation.incarnationsNoImpulse.ContainsKey(id)) {
      return new NoImpulseAsIImpulse(new NoImpulse(this, id));
    }
    if (rootIncarnation.incarnationsEvolvifyImpulse.ContainsKey(id)) {
      return new EvolvifyImpulseAsIImpulse(new EvolvifyImpulse(this, id));
    }
    if (rootIncarnation.incarnationsFireImpulse.ContainsKey(id)) {
      return new FireImpulseAsIImpulse(new FireImpulse(this, id));
    }
    if (rootIncarnation.incarnationsDefyImpulse.ContainsKey(id)) {
      return new DefyImpulseAsIImpulse(new DefyImpulse(this, id));
    }
    if (rootIncarnation.incarnationsCounterImpulse.ContainsKey(id)) {
      return new CounterImpulseAsIImpulse(new CounterImpulse(this, id));
    }
    if (rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(id)) {
      return new UnleashBideImpulseAsIImpulse(new UnleashBideImpulse(this, id));
    }
    if (rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(id)) {
      return new ContinueBidingImpulseAsIImpulse(new ContinueBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(id)) {
      return new StartBidingImpulseAsIImpulse(new StartBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsAttackImpulse.ContainsKey(id)) {
      return new AttackImpulseAsIImpulse(new AttackImpulse(this, id));
    }
    if (rootIncarnation.incarnationsPursueImpulse.ContainsKey(id)) {
      return new PursueImpulseAsIImpulse(new PursueImpulse(this, id));
    }
    if (rootIncarnation.incarnationsFireBombImpulse.ContainsKey(id)) {
      return new FireBombImpulseAsIImpulse(new FireBombImpulse(this, id));
    }
    throw new Exception("Unknown IImpulse: " + id);
  }
  public IImpulse GetIImpulseOrNull(int id) {
    if (rootIncarnation.incarnationsHoldPositionImpulse.ContainsKey(id)) {
      return new HoldPositionImpulseAsIImpulse(new HoldPositionImpulse(this, id));
    }
    if (rootIncarnation.incarnationsTemporaryCloneImpulse.ContainsKey(id)) {
      return new TemporaryCloneImpulseAsIImpulse(new TemporaryCloneImpulse(this, id));
    }
    if (rootIncarnation.incarnationsSummonImpulse.ContainsKey(id)) {
      return new SummonImpulseAsIImpulse(new SummonImpulse(this, id));
    }
    if (rootIncarnation.incarnationsMireImpulse.ContainsKey(id)) {
      return new MireImpulseAsIImpulse(new MireImpulse(this, id));
    }
    if (rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(id)) {
      return new EvaporateImpulseAsIImpulse(new EvaporateImpulse(this, id));
    }
    if (rootIncarnation.incarnationsMoveImpulse.ContainsKey(id)) {
      return new MoveImpulseAsIImpulse(new MoveImpulse(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeJumpImpulse.ContainsKey(id)) {
      return new KamikazeJumpImpulseAsIImpulse(new KamikazeJumpImpulse(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeTargetImpulse.ContainsKey(id)) {
      return new KamikazeTargetImpulseAsIImpulse(new KamikazeTargetImpulse(this, id));
    }
    if (rootIncarnation.incarnationsNoImpulse.ContainsKey(id)) {
      return new NoImpulseAsIImpulse(new NoImpulse(this, id));
    }
    if (rootIncarnation.incarnationsEvolvifyImpulse.ContainsKey(id)) {
      return new EvolvifyImpulseAsIImpulse(new EvolvifyImpulse(this, id));
    }
    if (rootIncarnation.incarnationsFireImpulse.ContainsKey(id)) {
      return new FireImpulseAsIImpulse(new FireImpulse(this, id));
    }
    if (rootIncarnation.incarnationsDefyImpulse.ContainsKey(id)) {
      return new DefyImpulseAsIImpulse(new DefyImpulse(this, id));
    }
    if (rootIncarnation.incarnationsCounterImpulse.ContainsKey(id)) {
      return new CounterImpulseAsIImpulse(new CounterImpulse(this, id));
    }
    if (rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(id)) {
      return new UnleashBideImpulseAsIImpulse(new UnleashBideImpulse(this, id));
    }
    if (rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(id)) {
      return new ContinueBidingImpulseAsIImpulse(new ContinueBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(id)) {
      return new StartBidingImpulseAsIImpulse(new StartBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsAttackImpulse.ContainsKey(id)) {
      return new AttackImpulseAsIImpulse(new AttackImpulse(this, id));
    }
    if (rootIncarnation.incarnationsPursueImpulse.ContainsKey(id)) {
      return new PursueImpulseAsIImpulse(new PursueImpulse(this, id));
    }
    if (rootIncarnation.incarnationsFireBombImpulse.ContainsKey(id)) {
      return new FireBombImpulseAsIImpulse(new FireBombImpulse(this, id));
    }
    return NullIImpulse.Null;
  }
  public bool IImpulseExists(int id) {
    return GetIImpulseOrNull(id) != null;
  }
  public void CheckHasIImpulse(IImpulse thing) {
    GetIImpulse(thing.id);
  }
  public void CheckHasIImpulse(int id) {
    GetIImpulse(id);
  }

  public IActingTTC GetIActingTTC(int id) {
    if (rootIncarnation.incarnationsFireBombTTC.ContainsKey(id)) {
      return new FireBombTTCAsIActingTTC(new FireBombTTC(this, id));
    }
    if (rootIncarnation.incarnationsOnFireTTC.ContainsKey(id)) {
      return new OnFireTTCAsIActingTTC(new OnFireTTC(this, id));
    }
    throw new Exception("Unknown IActingTTC: " + id);
  }
  public IActingTTC GetIActingTTCOrNull(int id) {
    if (rootIncarnation.incarnationsFireBombTTC.ContainsKey(id)) {
      return new FireBombTTCAsIActingTTC(new FireBombTTC(this, id));
    }
    if (rootIncarnation.incarnationsOnFireTTC.ContainsKey(id)) {
      return new OnFireTTCAsIActingTTC(new OnFireTTC(this, id));
    }
    return NullIActingTTC.Null;
  }
  public bool IActingTTCExists(int id) {
    return GetIActingTTCOrNull(id) != null;
  }
  public void CheckHasIActingTTC(IActingTTC thing) {
    GetIActingTTC(thing.id);
  }
  public void CheckHasIActingTTC(int id) {
    GetIActingTTC(id);
  }

  public IPresenceTriggerTTC GetIPresenceTriggerTTC(int id) {
    if (rootIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(id)) {
      return new SimplePresenceTriggerTTCAsIPresenceTriggerTTC(new SimplePresenceTriggerTTC(this, id));
    }
    throw new Exception("Unknown IPresenceTriggerTTC: " + id);
  }
  public IPresenceTriggerTTC GetIPresenceTriggerTTCOrNull(int id) {
    if (rootIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(id)) {
      return new SimplePresenceTriggerTTCAsIPresenceTriggerTTC(new SimplePresenceTriggerTTC(this, id));
    }
    return NullIPresenceTriggerTTC.Null;
  }
  public bool IPresenceTriggerTTCExists(int id) {
    return GetIPresenceTriggerTTCOrNull(id) != null;
  }
  public void CheckHasIPresenceTriggerTTC(IPresenceTriggerTTC thing) {
    GetIPresenceTriggerTTC(thing.id);
  }
  public void CheckHasIPresenceTriggerTTC(int id) {
    GetIPresenceTriggerTTC(id);
  }

  public IInteractableTTC GetIInteractableTTC(int id) {
    if (rootIncarnation.incarnationsWarperTTC.ContainsKey(id)) {
      return new WarperTTCAsIInteractableTTC(new WarperTTC(this, id));
    }
    if (rootIncarnation.incarnationsLevelLinkTTC.ContainsKey(id)) {
      return new LevelLinkTTCAsIInteractableTTC(new LevelLinkTTC(this, id));
    }
    if (rootIncarnation.incarnationsItemTTC.ContainsKey(id)) {
      return new ItemTTCAsIInteractableTTC(new ItemTTC(this, id));
    }
    if (rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(id)) {
      return new EmberDeepLevelLinkerTTCAsIInteractableTTC(new EmberDeepLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(id)) {
      return new IncendianFallsLevelLinkerTTCAsIInteractableTTC(new IncendianFallsLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC.ContainsKey(id)) {
      return new RavaArcanaLevelLinkerTTCAsIInteractableTTC(new RavaArcanaLevelLinkerTTC(this, id));
    }
    throw new Exception("Unknown IInteractableTTC: " + id);
  }
  public IInteractableTTC GetIInteractableTTCOrNull(int id) {
    if (rootIncarnation.incarnationsWarperTTC.ContainsKey(id)) {
      return new WarperTTCAsIInteractableTTC(new WarperTTC(this, id));
    }
    if (rootIncarnation.incarnationsLevelLinkTTC.ContainsKey(id)) {
      return new LevelLinkTTCAsIInteractableTTC(new LevelLinkTTC(this, id));
    }
    if (rootIncarnation.incarnationsItemTTC.ContainsKey(id)) {
      return new ItemTTCAsIInteractableTTC(new ItemTTC(this, id));
    }
    if (rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(id)) {
      return new EmberDeepLevelLinkerTTCAsIInteractableTTC(new EmberDeepLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(id)) {
      return new IncendianFallsLevelLinkerTTCAsIInteractableTTC(new IncendianFallsLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC.ContainsKey(id)) {
      return new RavaArcanaLevelLinkerTTCAsIInteractableTTC(new RavaArcanaLevelLinkerTTC(this, id));
    }
    return NullIInteractableTTC.Null;
  }
  public bool IInteractableTTCExists(int id) {
    return GetIInteractableTTCOrNull(id) != null;
  }
  public void CheckHasIInteractableTTC(IInteractableTTC thing) {
    GetIInteractableTTC(thing.id);
  }
  public void CheckHasIInteractableTTC(int id) {
    GetIInteractableTTC(id);
  }

  public IBlocksSightTTC GetIBlocksSightTTC(int id) {
    if (rootIncarnation.incarnationsTreeTTC.ContainsKey(id)) {
      return new TreeTTCAsIBlocksSightTTC(new TreeTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveWallTTC.ContainsKey(id)) {
      return new CaveWallTTCAsIBlocksSightTTC(new CaveWallTTC(this, id));
    }
    throw new Exception("Unknown IBlocksSightTTC: " + id);
  }
  public IBlocksSightTTC GetIBlocksSightTTCOrNull(int id) {
    if (rootIncarnation.incarnationsTreeTTC.ContainsKey(id)) {
      return new TreeTTCAsIBlocksSightTTC(new TreeTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveWallTTC.ContainsKey(id)) {
      return new CaveWallTTCAsIBlocksSightTTC(new CaveWallTTC(this, id));
    }
    return NullIBlocksSightTTC.Null;
  }
  public bool IBlocksSightTTCExists(int id) {
    return GetIBlocksSightTTCOrNull(id) != null;
  }
  public void CheckHasIBlocksSightTTC(IBlocksSightTTC thing) {
    GetIBlocksSightTTC(thing.id);
  }
  public void CheckHasIBlocksSightTTC(int id) {
    GetIBlocksSightTTC(id);
  }

  public IUnwalkableTTC GetIUnwalkableTTC(int id) {
    if (rootIncarnation.incarnationsTreeTTC.ContainsKey(id)) {
      return new TreeTTCAsIUnwalkableTTC(new TreeTTC(this, id));
    }
    if (rootIncarnation.incarnationsWaterTTC.ContainsKey(id)) {
      return new WaterTTCAsIUnwalkableTTC(new WaterTTC(this, id));
    }
    if (rootIncarnation.incarnationsFloorTTC.ContainsKey(id)) {
      return new FloorTTCAsIUnwalkableTTC(new FloorTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveWallTTC.ContainsKey(id)) {
      return new CaveWallTTCAsIUnwalkableTTC(new CaveWallTTC(this, id));
    }
    if (rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      return new FallsTTCAsIUnwalkableTTC(new FallsTTC(this, id));
    }
    if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      return new MagmaTTCAsIUnwalkableTTC(new MagmaTTC(this, id));
    }
    throw new Exception("Unknown IUnwalkableTTC: " + id);
  }
  public IUnwalkableTTC GetIUnwalkableTTCOrNull(int id) {
    if (rootIncarnation.incarnationsTreeTTC.ContainsKey(id)) {
      return new TreeTTCAsIUnwalkableTTC(new TreeTTC(this, id));
    }
    if (rootIncarnation.incarnationsWaterTTC.ContainsKey(id)) {
      return new WaterTTCAsIUnwalkableTTC(new WaterTTC(this, id));
    }
    if (rootIncarnation.incarnationsFloorTTC.ContainsKey(id)) {
      return new FloorTTCAsIUnwalkableTTC(new FloorTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveWallTTC.ContainsKey(id)) {
      return new CaveWallTTCAsIUnwalkableTTC(new CaveWallTTC(this, id));
    }
    if (rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      return new FallsTTCAsIUnwalkableTTC(new FallsTTC(this, id));
    }
    if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      return new MagmaTTCAsIUnwalkableTTC(new MagmaTTC(this, id));
    }
    return NullIUnwalkableTTC.Null;
  }
  public bool IUnwalkableTTCExists(int id) {
    return GetIUnwalkableTTCOrNull(id) != null;
  }
  public void CheckHasIUnwalkableTTC(IUnwalkableTTC thing) {
    GetIUnwalkableTTC(thing.id);
  }
  public void CheckHasIUnwalkableTTC(int id) {
    GetIUnwalkableTTC(id);
  }

  public ITerrainTileComponent GetITerrainTileComponent(int id) {
    if (rootIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(id)) {
      return new SimplePresenceTriggerTTCAsITerrainTileComponent(new SimplePresenceTriggerTTC(this, id));
    }
    if (rootIncarnation.incarnationsItemTTC.ContainsKey(id)) {
      return new ItemTTCAsITerrainTileComponent(new ItemTTC(this, id));
    }
    if (rootIncarnation.incarnationsFlowerTTC.ContainsKey(id)) {
      return new FlowerTTCAsITerrainTileComponent(new FlowerTTC(this, id));
    }
    if (rootIncarnation.incarnationsLotusTTC.ContainsKey(id)) {
      return new LotusTTCAsITerrainTileComponent(new LotusTTC(this, id));
    }
    if (rootIncarnation.incarnationsRoseTTC.ContainsKey(id)) {
      return new RoseTTCAsITerrainTileComponent(new RoseTTC(this, id));
    }
    if (rootIncarnation.incarnationsLeafTTC.ContainsKey(id)) {
      return new LeafTTCAsITerrainTileComponent(new LeafTTC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeTargetTTC.ContainsKey(id)) {
      return new KamikazeTargetTTCAsITerrainTileComponent(new KamikazeTargetTTC(this, id));
    }
    if (rootIncarnation.incarnationsWarperTTC.ContainsKey(id)) {
      return new WarperTTCAsITerrainTileComponent(new WarperTTC(this, id));
    }
    if (rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(id)) {
      return new TimeAnchorTTCAsITerrainTileComponent(new TimeAnchorTTC(this, id));
    }
    if (rootIncarnation.incarnationsFireBombTTC.ContainsKey(id)) {
      return new FireBombTTCAsITerrainTileComponent(new FireBombTTC(this, id));
    }
    if (rootIncarnation.incarnationsOnFireTTC.ContainsKey(id)) {
      return new OnFireTTCAsITerrainTileComponent(new OnFireTTC(this, id));
    }
    if (rootIncarnation.incarnationsMarkerTTC.ContainsKey(id)) {
      return new MarkerTTCAsITerrainTileComponent(new MarkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsLevelLinkTTC.ContainsKey(id)) {
      return new LevelLinkTTCAsITerrainTileComponent(new LevelLinkTTC(this, id));
    }
    if (rootIncarnation.incarnationsMudTTC.ContainsKey(id)) {
      return new MudTTCAsITerrainTileComponent(new MudTTC(this, id));
    }
    if (rootIncarnation.incarnationsDirtTTC.ContainsKey(id)) {
      return new DirtTTCAsITerrainTileComponent(new DirtTTC(this, id));
    }
    if (rootIncarnation.incarnationsObsidianTTC.ContainsKey(id)) {
      return new ObsidianTTCAsITerrainTileComponent(new ObsidianTTC(this, id));
    }
    if (rootIncarnation.incarnationsDownStairsTTC.ContainsKey(id)) {
      return new DownStairsTTCAsITerrainTileComponent(new DownStairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsUpStairsTTC.ContainsKey(id)) {
      return new UpStairsTTCAsITerrainTileComponent(new UpStairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsWallTTC.ContainsKey(id)) {
      return new WallTTCAsITerrainTileComponent(new WallTTC(this, id));
    }
    if (rootIncarnation.incarnationsBloodTTC.ContainsKey(id)) {
      return new BloodTTCAsITerrainTileComponent(new BloodTTC(this, id));
    }
    if (rootIncarnation.incarnationsRocksTTC.ContainsKey(id)) {
      return new RocksTTCAsITerrainTileComponent(new RocksTTC(this, id));
    }
    if (rootIncarnation.incarnationsTreeTTC.ContainsKey(id)) {
      return new TreeTTCAsITerrainTileComponent(new TreeTTC(this, id));
    }
    if (rootIncarnation.incarnationsWaterTTC.ContainsKey(id)) {
      return new WaterTTCAsITerrainTileComponent(new WaterTTC(this, id));
    }
    if (rootIncarnation.incarnationsFloorTTC.ContainsKey(id)) {
      return new FloorTTCAsITerrainTileComponent(new FloorTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveWallTTC.ContainsKey(id)) {
      return new CaveWallTTCAsITerrainTileComponent(new CaveWallTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveTTC.ContainsKey(id)) {
      return new CaveTTCAsITerrainTileComponent(new CaveTTC(this, id));
    }
    if (rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      return new FallsTTCAsITerrainTileComponent(new FallsTTC(this, id));
    }
    if (rootIncarnation.incarnationsObsidianFloorTTC.ContainsKey(id)) {
      return new ObsidianFloorTTCAsITerrainTileComponent(new ObsidianFloorTTC(this, id));
    }
    if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      return new MagmaTTCAsITerrainTileComponent(new MagmaTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffTTC.ContainsKey(id)) {
      return new CliffTTCAsITerrainTileComponent(new CliffTTC(this, id));
    }
    if (rootIncarnation.incarnationsRavaNestTTC.ContainsKey(id)) {
      return new RavaNestTTCAsITerrainTileComponent(new RavaNestTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(id)) {
      return new CliffLandingTTCAsITerrainTileComponent(new CliffLandingTTC(this, id));
    }
    if (rootIncarnation.incarnationsStoneTTC.ContainsKey(id)) {
      return new StoneTTCAsITerrainTileComponent(new StoneTTC(this, id));
    }
    if (rootIncarnation.incarnationsGrassTTC.ContainsKey(id)) {
      return new GrassTTCAsITerrainTileComponent(new GrassTTC(this, id));
    }
    if (rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(id)) {
      return new EmberDeepLevelLinkerTTCAsITerrainTileComponent(new EmberDeepLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(id)) {
      return new IncendianFallsLevelLinkerTTCAsITerrainTileComponent(new IncendianFallsLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC.ContainsKey(id)) {
      return new RavaArcanaLevelLinkerTTCAsITerrainTileComponent(new RavaArcanaLevelLinkerTTC(this, id));
    }
    throw new Exception("Unknown ITerrainTileComponent: " + id);
  }
  public ITerrainTileComponent GetITerrainTileComponentOrNull(int id) {
    if (rootIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(id)) {
      return new SimplePresenceTriggerTTCAsITerrainTileComponent(new SimplePresenceTriggerTTC(this, id));
    }
    if (rootIncarnation.incarnationsItemTTC.ContainsKey(id)) {
      return new ItemTTCAsITerrainTileComponent(new ItemTTC(this, id));
    }
    if (rootIncarnation.incarnationsFlowerTTC.ContainsKey(id)) {
      return new FlowerTTCAsITerrainTileComponent(new FlowerTTC(this, id));
    }
    if (rootIncarnation.incarnationsLotusTTC.ContainsKey(id)) {
      return new LotusTTCAsITerrainTileComponent(new LotusTTC(this, id));
    }
    if (rootIncarnation.incarnationsRoseTTC.ContainsKey(id)) {
      return new RoseTTCAsITerrainTileComponent(new RoseTTC(this, id));
    }
    if (rootIncarnation.incarnationsLeafTTC.ContainsKey(id)) {
      return new LeafTTCAsITerrainTileComponent(new LeafTTC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeTargetTTC.ContainsKey(id)) {
      return new KamikazeTargetTTCAsITerrainTileComponent(new KamikazeTargetTTC(this, id));
    }
    if (rootIncarnation.incarnationsWarperTTC.ContainsKey(id)) {
      return new WarperTTCAsITerrainTileComponent(new WarperTTC(this, id));
    }
    if (rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(id)) {
      return new TimeAnchorTTCAsITerrainTileComponent(new TimeAnchorTTC(this, id));
    }
    if (rootIncarnation.incarnationsFireBombTTC.ContainsKey(id)) {
      return new FireBombTTCAsITerrainTileComponent(new FireBombTTC(this, id));
    }
    if (rootIncarnation.incarnationsOnFireTTC.ContainsKey(id)) {
      return new OnFireTTCAsITerrainTileComponent(new OnFireTTC(this, id));
    }
    if (rootIncarnation.incarnationsMarkerTTC.ContainsKey(id)) {
      return new MarkerTTCAsITerrainTileComponent(new MarkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsLevelLinkTTC.ContainsKey(id)) {
      return new LevelLinkTTCAsITerrainTileComponent(new LevelLinkTTC(this, id));
    }
    if (rootIncarnation.incarnationsMudTTC.ContainsKey(id)) {
      return new MudTTCAsITerrainTileComponent(new MudTTC(this, id));
    }
    if (rootIncarnation.incarnationsDirtTTC.ContainsKey(id)) {
      return new DirtTTCAsITerrainTileComponent(new DirtTTC(this, id));
    }
    if (rootIncarnation.incarnationsObsidianTTC.ContainsKey(id)) {
      return new ObsidianTTCAsITerrainTileComponent(new ObsidianTTC(this, id));
    }
    if (rootIncarnation.incarnationsDownStairsTTC.ContainsKey(id)) {
      return new DownStairsTTCAsITerrainTileComponent(new DownStairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsUpStairsTTC.ContainsKey(id)) {
      return new UpStairsTTCAsITerrainTileComponent(new UpStairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsWallTTC.ContainsKey(id)) {
      return new WallTTCAsITerrainTileComponent(new WallTTC(this, id));
    }
    if (rootIncarnation.incarnationsBloodTTC.ContainsKey(id)) {
      return new BloodTTCAsITerrainTileComponent(new BloodTTC(this, id));
    }
    if (rootIncarnation.incarnationsRocksTTC.ContainsKey(id)) {
      return new RocksTTCAsITerrainTileComponent(new RocksTTC(this, id));
    }
    if (rootIncarnation.incarnationsTreeTTC.ContainsKey(id)) {
      return new TreeTTCAsITerrainTileComponent(new TreeTTC(this, id));
    }
    if (rootIncarnation.incarnationsWaterTTC.ContainsKey(id)) {
      return new WaterTTCAsITerrainTileComponent(new WaterTTC(this, id));
    }
    if (rootIncarnation.incarnationsFloorTTC.ContainsKey(id)) {
      return new FloorTTCAsITerrainTileComponent(new FloorTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveWallTTC.ContainsKey(id)) {
      return new CaveWallTTCAsITerrainTileComponent(new CaveWallTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveTTC.ContainsKey(id)) {
      return new CaveTTCAsITerrainTileComponent(new CaveTTC(this, id));
    }
    if (rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      return new FallsTTCAsITerrainTileComponent(new FallsTTC(this, id));
    }
    if (rootIncarnation.incarnationsObsidianFloorTTC.ContainsKey(id)) {
      return new ObsidianFloorTTCAsITerrainTileComponent(new ObsidianFloorTTC(this, id));
    }
    if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      return new MagmaTTCAsITerrainTileComponent(new MagmaTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffTTC.ContainsKey(id)) {
      return new CliffTTCAsITerrainTileComponent(new CliffTTC(this, id));
    }
    if (rootIncarnation.incarnationsRavaNestTTC.ContainsKey(id)) {
      return new RavaNestTTCAsITerrainTileComponent(new RavaNestTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(id)) {
      return new CliffLandingTTCAsITerrainTileComponent(new CliffLandingTTC(this, id));
    }
    if (rootIncarnation.incarnationsStoneTTC.ContainsKey(id)) {
      return new StoneTTCAsITerrainTileComponent(new StoneTTC(this, id));
    }
    if (rootIncarnation.incarnationsGrassTTC.ContainsKey(id)) {
      return new GrassTTCAsITerrainTileComponent(new GrassTTC(this, id));
    }
    if (rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(id)) {
      return new EmberDeepLevelLinkerTTCAsITerrainTileComponent(new EmberDeepLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(id)) {
      return new IncendianFallsLevelLinkerTTCAsITerrainTileComponent(new IncendianFallsLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC.ContainsKey(id)) {
      return new RavaArcanaLevelLinkerTTCAsITerrainTileComponent(new RavaArcanaLevelLinkerTTC(this, id));
    }
    return NullITerrainTileComponent.Null;
  }
  public bool ITerrainTileComponentExists(int id) {
    return GetITerrainTileComponentOrNull(id) != null;
  }
  public void CheckHasITerrainTileComponent(ITerrainTileComponent thing) {
    GetITerrainTileComponent(thing.id);
  }
  public void CheckHasITerrainTileComponent(int id) {
    GetITerrainTileComponent(id);
  }

  public IPlantTTC GetIPlantTTC(int id) {
    if (rootIncarnation.incarnationsFlowerTTC.ContainsKey(id)) {
      return new FlowerTTCAsIPlantTTC(new FlowerTTC(this, id));
    }
    if (rootIncarnation.incarnationsLotusTTC.ContainsKey(id)) {
      return new LotusTTCAsIPlantTTC(new LotusTTC(this, id));
    }
    if (rootIncarnation.incarnationsRoseTTC.ContainsKey(id)) {
      return new RoseTTCAsIPlantTTC(new RoseTTC(this, id));
    }
    if (rootIncarnation.incarnationsLeafTTC.ContainsKey(id)) {
      return new LeafTTCAsIPlantTTC(new LeafTTC(this, id));
    }
    throw new Exception("Unknown IPlantTTC: " + id);
  }
  public IPlantTTC GetIPlantTTCOrNull(int id) {
    if (rootIncarnation.incarnationsFlowerTTC.ContainsKey(id)) {
      return new FlowerTTCAsIPlantTTC(new FlowerTTC(this, id));
    }
    if (rootIncarnation.incarnationsLotusTTC.ContainsKey(id)) {
      return new LotusTTCAsIPlantTTC(new LotusTTC(this, id));
    }
    if (rootIncarnation.incarnationsRoseTTC.ContainsKey(id)) {
      return new RoseTTCAsIPlantTTC(new RoseTTC(this, id));
    }
    if (rootIncarnation.incarnationsLeafTTC.ContainsKey(id)) {
      return new LeafTTCAsIPlantTTC(new LeafTTC(this, id));
    }
    return NullIPlantTTC.Null;
  }
  public bool IPlantTTCExists(int id) {
    return GetIPlantTTCOrNull(id) != null;
  }
  public void CheckHasIPlantTTC(IPlantTTC thing) {
    GetIPlantTTC(thing.id);
  }
  public void CheckHasIPlantTTC(int id) {
    GetIPlantTTC(id);
  }

  public ILevelController GetILevelController(int id) {
    if (rootIncarnation.incarnationsVolcaetusLevelController.ContainsKey(id)) {
      return new VolcaetusLevelControllerAsILevelController(new VolcaetusLevelController(this, id));
    }
    if (rootIncarnation.incarnationsTutorial2LevelController.ContainsKey(id)) {
      return new Tutorial2LevelControllerAsILevelController(new Tutorial2LevelController(this, id));
    }
    if (rootIncarnation.incarnationsTutorial1LevelController.ContainsKey(id)) {
      return new Tutorial1LevelControllerAsILevelController(new Tutorial1LevelController(this, id));
    }
    if (rootIncarnation.incarnationsRetreatLevelController.ContainsKey(id)) {
      return new RetreatLevelControllerAsILevelController(new RetreatLevelController(this, id));
    }
    if (rootIncarnation.incarnationsSotaventoLevelController.ContainsKey(id)) {
      return new SotaventoLevelControllerAsILevelController(new SotaventoLevelController(this, id));
    }
    if (rootIncarnation.incarnationsNestLevelController.ContainsKey(id)) {
      return new NestLevelControllerAsILevelController(new NestLevelController(this, id));
    }
    if (rootIncarnation.incarnationsLakeLevelController.ContainsKey(id)) {
      return new LakeLevelControllerAsILevelController(new LakeLevelController(this, id));
    }
    if (rootIncarnation.incarnationsDirtRoadLevelController.ContainsKey(id)) {
      return new DirtRoadLevelControllerAsILevelController(new DirtRoadLevelController(this, id));
    }
    if (rootIncarnation.incarnationsCaveLevelController.ContainsKey(id)) {
      return new CaveLevelControllerAsILevelController(new CaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsBridgesLevelController.ContainsKey(id)) {
      return new BridgesLevelControllerAsILevelController(new BridgesLevelController(this, id));
    }
    if (rootIncarnation.incarnationsAncientTownLevelController.ContainsKey(id)) {
      return new AncientTownLevelControllerAsILevelController(new AncientTownLevelController(this, id));
    }
    if (rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(id)) {
      return new SquareCaveLevelControllerAsILevelController(new SquareCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(id)) {
      return new RavashrikeLevelControllerAsILevelController(new RavashrikeLevelController(this, id));
    }
    if (rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(id)) {
      return new PentagonalCaveLevelControllerAsILevelController(new PentagonalCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsCliffLevelController.ContainsKey(id)) {
      return new CliffLevelControllerAsILevelController(new CliffLevelController(this, id));
    }
    if (rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(id)) {
      return new PreGauntletLevelControllerAsILevelController(new PreGauntletLevelController(this, id));
    }
    if (rootIncarnation.incarnationsGauntletLevelController.ContainsKey(id)) {
      return new GauntletLevelControllerAsILevelController(new GauntletLevelController(this, id));
    }
    if (rootIncarnation.incarnationsJumpingCaveLevelController.ContainsKey(id)) {
      return new JumpingCaveLevelControllerAsILevelController(new JumpingCaveLevelController(this, id));
    }
    throw new Exception("Unknown ILevelController: " + id);
  }
  public ILevelController GetILevelControllerOrNull(int id) {
    if (rootIncarnation.incarnationsVolcaetusLevelController.ContainsKey(id)) {
      return new VolcaetusLevelControllerAsILevelController(new VolcaetusLevelController(this, id));
    }
    if (rootIncarnation.incarnationsTutorial2LevelController.ContainsKey(id)) {
      return new Tutorial2LevelControllerAsILevelController(new Tutorial2LevelController(this, id));
    }
    if (rootIncarnation.incarnationsTutorial1LevelController.ContainsKey(id)) {
      return new Tutorial1LevelControllerAsILevelController(new Tutorial1LevelController(this, id));
    }
    if (rootIncarnation.incarnationsRetreatLevelController.ContainsKey(id)) {
      return new RetreatLevelControllerAsILevelController(new RetreatLevelController(this, id));
    }
    if (rootIncarnation.incarnationsSotaventoLevelController.ContainsKey(id)) {
      return new SotaventoLevelControllerAsILevelController(new SotaventoLevelController(this, id));
    }
    if (rootIncarnation.incarnationsNestLevelController.ContainsKey(id)) {
      return new NestLevelControllerAsILevelController(new NestLevelController(this, id));
    }
    if (rootIncarnation.incarnationsLakeLevelController.ContainsKey(id)) {
      return new LakeLevelControllerAsILevelController(new LakeLevelController(this, id));
    }
    if (rootIncarnation.incarnationsDirtRoadLevelController.ContainsKey(id)) {
      return new DirtRoadLevelControllerAsILevelController(new DirtRoadLevelController(this, id));
    }
    if (rootIncarnation.incarnationsCaveLevelController.ContainsKey(id)) {
      return new CaveLevelControllerAsILevelController(new CaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsBridgesLevelController.ContainsKey(id)) {
      return new BridgesLevelControllerAsILevelController(new BridgesLevelController(this, id));
    }
    if (rootIncarnation.incarnationsAncientTownLevelController.ContainsKey(id)) {
      return new AncientTownLevelControllerAsILevelController(new AncientTownLevelController(this, id));
    }
    if (rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(id)) {
      return new SquareCaveLevelControllerAsILevelController(new SquareCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(id)) {
      return new RavashrikeLevelControllerAsILevelController(new RavashrikeLevelController(this, id));
    }
    if (rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(id)) {
      return new PentagonalCaveLevelControllerAsILevelController(new PentagonalCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsCliffLevelController.ContainsKey(id)) {
      return new CliffLevelControllerAsILevelController(new CliffLevelController(this, id));
    }
    if (rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(id)) {
      return new PreGauntletLevelControllerAsILevelController(new PreGauntletLevelController(this, id));
    }
    if (rootIncarnation.incarnationsGauntletLevelController.ContainsKey(id)) {
      return new GauntletLevelControllerAsILevelController(new GauntletLevelController(this, id));
    }
    if (rootIncarnation.incarnationsJumpingCaveLevelController.ContainsKey(id)) {
      return new JumpingCaveLevelControllerAsILevelController(new JumpingCaveLevelController(this, id));
    }
    return NullILevelController.Null;
  }
  public bool ILevelControllerExists(int id) {
    return GetILevelControllerOrNull(id) != null;
  }
  public void CheckHasILevelController(ILevelController thing) {
    GetILevelController(thing.id);
  }
  public void CheckHasILevelController(int id) {
    GetILevelController(id);
  }

  public IPickUpReactorItem GetIPickUpReactorItem(int id) {
    if (rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      return new SlowRodAsIPickUpReactorItem(new SlowRod(this, id));
    }
    if (rootIncarnation.incarnationsExplosionRod.ContainsKey(id)) {
      return new ExplosionRodAsIPickUpReactorItem(new ExplosionRod(this, id));
    }
    if (rootIncarnation.incarnationsBlazeRod.ContainsKey(id)) {
      return new BlazeRodAsIPickUpReactorItem(new BlazeRod(this, id));
    }
    if (rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      return new BlastRodAsIPickUpReactorItem(new BlastRod(this, id));
    }
    throw new Exception("Unknown IPickUpReactorItem: " + id);
  }
  public IPickUpReactorItem GetIPickUpReactorItemOrNull(int id) {
    if (rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      return new SlowRodAsIPickUpReactorItem(new SlowRod(this, id));
    }
    if (rootIncarnation.incarnationsExplosionRod.ContainsKey(id)) {
      return new ExplosionRodAsIPickUpReactorItem(new ExplosionRod(this, id));
    }
    if (rootIncarnation.incarnationsBlazeRod.ContainsKey(id)) {
      return new BlazeRodAsIPickUpReactorItem(new BlazeRod(this, id));
    }
    if (rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      return new BlastRodAsIPickUpReactorItem(new BlastRod(this, id));
    }
    return NullIPickUpReactorItem.Null;
  }
  public bool IPickUpReactorItemExists(int id) {
    return GetIPickUpReactorItemOrNull(id) != null;
  }
  public void CheckHasIPickUpReactorItem(IPickUpReactorItem thing) {
    GetIPickUpReactorItem(thing.id);
  }
  public void CheckHasIPickUpReactorItem(int id) {
    GetIPickUpReactorItem(id);
  }

  public IImmediatelyUseItem GetIImmediatelyUseItem(int id) {
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIImmediatelyUseItem(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIImmediatelyUseItem(new HealthPotion(this, id));
    }
    throw new Exception("Unknown IImmediatelyUseItem: " + id);
  }
  public IImmediatelyUseItem GetIImmediatelyUseItemOrNull(int id) {
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIImmediatelyUseItem(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIImmediatelyUseItem(new HealthPotion(this, id));
    }
    return NullIImmediatelyUseItem.Null;
  }
  public bool IImmediatelyUseItemExists(int id) {
    return GetIImmediatelyUseItemOrNull(id) != null;
  }
  public void CheckHasIImmediatelyUseItem(IImmediatelyUseItem thing) {
    GetIImmediatelyUseItem(thing.id);
  }
  public void CheckHasIImmediatelyUseItem(int id) {
    GetIImmediatelyUseItem(id);
  }

  public IUsableItem GetIUsableItem(int id) {
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIUsableItem(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIUsableItem(new HealthPotion(this, id));
    }
    throw new Exception("Unknown IUsableItem: " + id);
  }
  public IUsableItem GetIUsableItemOrNull(int id) {
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIUsableItem(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIUsableItem(new HealthPotion(this, id));
    }
    return NullIUsableItem.Null;
  }
  public bool IUsableItemExists(int id) {
    return GetIUsableItemOrNull(id) != null;
  }
  public void CheckHasIUsableItem(IUsableItem thing) {
    GetIUsableItem(thing.id);
  }
  public void CheckHasIUsableItem(int id) {
    GetIUsableItem(id);
  }

  public ICloneableUC GetICloneableUC(int id) {
    if (rootIncarnation.incarnationsSorcerousUC.ContainsKey(id)) {
      return new SorcerousUCAsICloneableUC(new SorcerousUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(id)) {
      return new BaseOffenseUCAsICloneableUC(new BaseOffenseUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(id)) {
      return new BaseSightRangeUCAsICloneableUC(new BaseSightRangeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(id)) {
      return new BaseMovementTimeUCAsICloneableUC(new BaseMovementTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(id)) {
      return new BaseDefenseUCAsICloneableUC(new BaseDefenseUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(id)) {
      return new BaseCombatTimeUCAsICloneableUC(new BaseCombatTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      return new SpeedRingAsICloneableUC(new SpeedRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsICloneableUC(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      return new SlowRodAsICloneableUC(new SlowRod(this, id));
    }
    if (rootIncarnation.incarnationsExplosionRod.ContainsKey(id)) {
      return new ExplosionRodAsICloneableUC(new ExplosionRod(this, id));
    }
    if (rootIncarnation.incarnationsBlazeRod.ContainsKey(id)) {
      return new BlazeRodAsICloneableUC(new BlazeRod(this, id));
    }
    if (rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      return new BlastRodAsICloneableUC(new BlastRod(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsICloneableUC(new Armor(this, id));
    }
    throw new Exception("Unknown ICloneableUC: " + id);
  }
  public ICloneableUC GetICloneableUCOrNull(int id) {
    if (rootIncarnation.incarnationsSorcerousUC.ContainsKey(id)) {
      return new SorcerousUCAsICloneableUC(new SorcerousUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(id)) {
      return new BaseOffenseUCAsICloneableUC(new BaseOffenseUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(id)) {
      return new BaseSightRangeUCAsICloneableUC(new BaseSightRangeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(id)) {
      return new BaseMovementTimeUCAsICloneableUC(new BaseMovementTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(id)) {
      return new BaseDefenseUCAsICloneableUC(new BaseDefenseUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(id)) {
      return new BaseCombatTimeUCAsICloneableUC(new BaseCombatTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      return new SpeedRingAsICloneableUC(new SpeedRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsICloneableUC(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      return new SlowRodAsICloneableUC(new SlowRod(this, id));
    }
    if (rootIncarnation.incarnationsExplosionRod.ContainsKey(id)) {
      return new ExplosionRodAsICloneableUC(new ExplosionRod(this, id));
    }
    if (rootIncarnation.incarnationsBlazeRod.ContainsKey(id)) {
      return new BlazeRodAsICloneableUC(new BlazeRod(this, id));
    }
    if (rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      return new BlastRodAsICloneableUC(new BlastRod(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsICloneableUC(new Armor(this, id));
    }
    return NullICloneableUC.Null;
  }
  public bool ICloneableUCExists(int id) {
    return GetICloneableUCOrNull(id) != null;
  }
  public void CheckHasICloneableUC(ICloneableUC thing) {
    GetICloneableUC(thing.id);
  }
  public void CheckHasICloneableUC(int id) {
    GetICloneableUC(id);
  }

  public IItem GetIItem(int id) {
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIItem(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIItem(new HealthPotion(this, id));
    }
    if (rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      return new SpeedRingAsIItem(new SpeedRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIItem(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      return new SlowRodAsIItem(new SlowRod(this, id));
    }
    if (rootIncarnation.incarnationsExplosionRod.ContainsKey(id)) {
      return new ExplosionRodAsIItem(new ExplosionRod(this, id));
    }
    if (rootIncarnation.incarnationsBlazeRod.ContainsKey(id)) {
      return new BlazeRodAsIItem(new BlazeRod(this, id));
    }
    if (rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      return new BlastRodAsIItem(new BlastRod(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIItem(new Armor(this, id));
    }
    throw new Exception("Unknown IItem: " + id);
  }
  public IItem GetIItemOrNull(int id) {
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIItem(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIItem(new HealthPotion(this, id));
    }
    if (rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      return new SpeedRingAsIItem(new SpeedRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIItem(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      return new SlowRodAsIItem(new SlowRod(this, id));
    }
    if (rootIncarnation.incarnationsExplosionRod.ContainsKey(id)) {
      return new ExplosionRodAsIItem(new ExplosionRod(this, id));
    }
    if (rootIncarnation.incarnationsBlazeRod.ContainsKey(id)) {
      return new BlazeRodAsIItem(new BlazeRod(this, id));
    }
    if (rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      return new BlastRodAsIItem(new BlastRod(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIItem(new Armor(this, id));
    }
    return NullIItem.Null;
  }
  public bool IItemExists(int id) {
    return GetIItemOrNull(id) != null;
  }
  public void CheckHasIItem(IItem thing) {
    GetIItem(thing.id);
  }
  public void CheckHasIItem(int id) {
    GetIItem(id);
  }

  public IDestructible GetIDestructible(int id) {
    if (rootIncarnation.incarnationsDeathTriggerUC.ContainsKey(id)) {
      return new DeathTriggerUCAsIDestructible(new DeathTriggerUC(this, id));
    }
    if (rootIncarnation.incarnationsBequeathUC.ContainsKey(id)) {
      return new BequeathUCAsIDestructible(new BequeathUC(this, id));
    }
    if (rootIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(id)) {
      return new TutorialDefyCounterUCAsIDestructible(new TutorialDefyCounterUC(this, id));
    }
    if (rootIncarnation.incarnationsLightningChargingUC.ContainsKey(id)) {
      return new LightningChargingUCAsIDestructible(new LightningChargingUC(this, id));
    }
    if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      return new WanderAICapabilityUCAsIDestructible(new WanderAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(id)) {
      return new TemporaryCloneAICapabilityUCAsIDestructible(new TemporaryCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(id)) {
      return new SummonAICapabilityUCAsIDestructible(new SummonAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      return new KamikazeAICapabilityUCAsIDestructible(new KamikazeAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(id)) {
      return new GuardAICapabilityUCAsIDestructible(new GuardAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsEvolvifyAICapabilityUC.ContainsKey(id)) {
      return new EvolvifyAICapabilityUCAsIDestructible(new EvolvifyAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIDestructible(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDoomedUC.ContainsKey(id)) {
      return new DoomedUCAsIDestructible(new DoomedUC(this, id));
    }
    if (rootIncarnation.incarnationsMiredUC.ContainsKey(id)) {
      return new MiredUCAsIDestructible(new MiredUC(this, id));
    }
    if (rootIncarnation.incarnationsOnFireUC.ContainsKey(id)) {
      return new OnFireUCAsIDestructible(new OnFireUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIDestructible(new AttackAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIDestructible(new CounteringUC(this, id));
    }
    if (rootIncarnation.incarnationsLightningChargedUC.ContainsKey(id)) {
      return new LightningChargedUCAsIDestructible(new LightningChargedUC(this, id));
    }
    if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      return new InvincibilityUCAsIDestructible(new InvincibilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDefyingUC.ContainsKey(id)) {
      return new DefyingUCAsIDestructible(new DefyingUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIDestructible(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(id)) {
      return new BaseSightRangeUCAsIDestructible(new BaseSightRangeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(id)) {
      return new BaseMovementTimeUCAsIDestructible(new BaseMovementTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(id)) {
      return new BaseCombatTimeUCAsIDestructible(new BaseCombatTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIDestructible(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIDestructible(new HealthPotion(this, id));
    }
    if (rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      return new SpeedRingAsIDestructible(new SpeedRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIDestructible(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      return new SlowRodAsIDestructible(new SlowRod(this, id));
    }
    if (rootIncarnation.incarnationsExplosionRod.ContainsKey(id)) {
      return new ExplosionRodAsIDestructible(new ExplosionRod(this, id));
    }
    if (rootIncarnation.incarnationsBlazeRod.ContainsKey(id)) {
      return new BlazeRodAsIDestructible(new BlazeRod(this, id));
    }
    if (rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      return new BlastRodAsIDestructible(new BlastRod(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIDestructible(new Armor(this, id));
    }
    if (rootIncarnation.incarnationsSorcerousUC.ContainsKey(id)) {
      return new SorcerousUCAsIDestructible(new SorcerousUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(id)) {
      return new BaseOffenseUCAsIDestructible(new BaseOffenseUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(id)) {
      return new BaseDefenseUCAsIDestructible(new BaseDefenseUC(this, id));
    }
    if (rootIncarnation.incarnationsHoldPositionImpulse.ContainsKey(id)) {
      return new HoldPositionImpulseAsIDestructible(new HoldPositionImpulse(this, id));
    }
    if (rootIncarnation.incarnationsTemporaryCloneImpulse.ContainsKey(id)) {
      return new TemporaryCloneImpulseAsIDestructible(new TemporaryCloneImpulse(this, id));
    }
    if (rootIncarnation.incarnationsSummonImpulse.ContainsKey(id)) {
      return new SummonImpulseAsIDestructible(new SummonImpulse(this, id));
    }
    if (rootIncarnation.incarnationsMireImpulse.ContainsKey(id)) {
      return new MireImpulseAsIDestructible(new MireImpulse(this, id));
    }
    if (rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(id)) {
      return new EvaporateImpulseAsIDestructible(new EvaporateImpulse(this, id));
    }
    if (rootIncarnation.incarnationsMoveImpulse.ContainsKey(id)) {
      return new MoveImpulseAsIDestructible(new MoveImpulse(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeJumpImpulse.ContainsKey(id)) {
      return new KamikazeJumpImpulseAsIDestructible(new KamikazeJumpImpulse(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeTargetImpulse.ContainsKey(id)) {
      return new KamikazeTargetImpulseAsIDestructible(new KamikazeTargetImpulse(this, id));
    }
    if (rootIncarnation.incarnationsNoImpulse.ContainsKey(id)) {
      return new NoImpulseAsIDestructible(new NoImpulse(this, id));
    }
    if (rootIncarnation.incarnationsEvolvifyImpulse.ContainsKey(id)) {
      return new EvolvifyImpulseAsIDestructible(new EvolvifyImpulse(this, id));
    }
    if (rootIncarnation.incarnationsFireImpulse.ContainsKey(id)) {
      return new FireImpulseAsIDestructible(new FireImpulse(this, id));
    }
    if (rootIncarnation.incarnationsDefyImpulse.ContainsKey(id)) {
      return new DefyImpulseAsIDestructible(new DefyImpulse(this, id));
    }
    if (rootIncarnation.incarnationsCounterImpulse.ContainsKey(id)) {
      return new CounterImpulseAsIDestructible(new CounterImpulse(this, id));
    }
    if (rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(id)) {
      return new UnleashBideImpulseAsIDestructible(new UnleashBideImpulse(this, id));
    }
    if (rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(id)) {
      return new ContinueBidingImpulseAsIDestructible(new ContinueBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(id)) {
      return new StartBidingImpulseAsIDestructible(new StartBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsAttackImpulse.ContainsKey(id)) {
      return new AttackImpulseAsIDestructible(new AttackImpulse(this, id));
    }
    if (rootIncarnation.incarnationsPursueImpulse.ContainsKey(id)) {
      return new PursueImpulseAsIDestructible(new PursueImpulse(this, id));
    }
    if (rootIncarnation.incarnationsFireBombImpulse.ContainsKey(id)) {
      return new FireBombImpulseAsIDestructible(new FireBombImpulse(this, id));
    }
    if (rootIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(id)) {
      return new SimplePresenceTriggerTTCAsIDestructible(new SimplePresenceTriggerTTC(this, id));
    }
    if (rootIncarnation.incarnationsItemTTC.ContainsKey(id)) {
      return new ItemTTCAsIDestructible(new ItemTTC(this, id));
    }
    if (rootIncarnation.incarnationsFlowerTTC.ContainsKey(id)) {
      return new FlowerTTCAsIDestructible(new FlowerTTC(this, id));
    }
    if (rootIncarnation.incarnationsLotusTTC.ContainsKey(id)) {
      return new LotusTTCAsIDestructible(new LotusTTC(this, id));
    }
    if (rootIncarnation.incarnationsRoseTTC.ContainsKey(id)) {
      return new RoseTTCAsIDestructible(new RoseTTC(this, id));
    }
    if (rootIncarnation.incarnationsLeafTTC.ContainsKey(id)) {
      return new LeafTTCAsIDestructible(new LeafTTC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeTargetTTC.ContainsKey(id)) {
      return new KamikazeTargetTTCAsIDestructible(new KamikazeTargetTTC(this, id));
    }
    if (rootIncarnation.incarnationsWarperTTC.ContainsKey(id)) {
      return new WarperTTCAsIDestructible(new WarperTTC(this, id));
    }
    if (rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(id)) {
      return new TimeAnchorTTCAsIDestructible(new TimeAnchorTTC(this, id));
    }
    if (rootIncarnation.incarnationsFireBombTTC.ContainsKey(id)) {
      return new FireBombTTCAsIDestructible(new FireBombTTC(this, id));
    }
    if (rootIncarnation.incarnationsOnFireTTC.ContainsKey(id)) {
      return new OnFireTTCAsIDestructible(new OnFireTTC(this, id));
    }
    if (rootIncarnation.incarnationsMarkerTTC.ContainsKey(id)) {
      return new MarkerTTCAsIDestructible(new MarkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsLevelLinkTTC.ContainsKey(id)) {
      return new LevelLinkTTCAsIDestructible(new LevelLinkTTC(this, id));
    }
    if (rootIncarnation.incarnationsMudTTC.ContainsKey(id)) {
      return new MudTTCAsIDestructible(new MudTTC(this, id));
    }
    if (rootIncarnation.incarnationsDirtTTC.ContainsKey(id)) {
      return new DirtTTCAsIDestructible(new DirtTTC(this, id));
    }
    if (rootIncarnation.incarnationsObsidianTTC.ContainsKey(id)) {
      return new ObsidianTTCAsIDestructible(new ObsidianTTC(this, id));
    }
    if (rootIncarnation.incarnationsDownStairsTTC.ContainsKey(id)) {
      return new DownStairsTTCAsIDestructible(new DownStairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsUpStairsTTC.ContainsKey(id)) {
      return new UpStairsTTCAsIDestructible(new UpStairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsWallTTC.ContainsKey(id)) {
      return new WallTTCAsIDestructible(new WallTTC(this, id));
    }
    if (rootIncarnation.incarnationsBloodTTC.ContainsKey(id)) {
      return new BloodTTCAsIDestructible(new BloodTTC(this, id));
    }
    if (rootIncarnation.incarnationsRocksTTC.ContainsKey(id)) {
      return new RocksTTCAsIDestructible(new RocksTTC(this, id));
    }
    if (rootIncarnation.incarnationsTreeTTC.ContainsKey(id)) {
      return new TreeTTCAsIDestructible(new TreeTTC(this, id));
    }
    if (rootIncarnation.incarnationsWaterTTC.ContainsKey(id)) {
      return new WaterTTCAsIDestructible(new WaterTTC(this, id));
    }
    if (rootIncarnation.incarnationsFloorTTC.ContainsKey(id)) {
      return new FloorTTCAsIDestructible(new FloorTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveWallTTC.ContainsKey(id)) {
      return new CaveWallTTCAsIDestructible(new CaveWallTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveTTC.ContainsKey(id)) {
      return new CaveTTCAsIDestructible(new CaveTTC(this, id));
    }
    if (rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      return new FallsTTCAsIDestructible(new FallsTTC(this, id));
    }
    if (rootIncarnation.incarnationsObsidianFloorTTC.ContainsKey(id)) {
      return new ObsidianFloorTTCAsIDestructible(new ObsidianFloorTTC(this, id));
    }
    if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      return new MagmaTTCAsIDestructible(new MagmaTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffTTC.ContainsKey(id)) {
      return new CliffTTCAsIDestructible(new CliffTTC(this, id));
    }
    if (rootIncarnation.incarnationsRavaNestTTC.ContainsKey(id)) {
      return new RavaNestTTCAsIDestructible(new RavaNestTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(id)) {
      return new CliffLandingTTCAsIDestructible(new CliffLandingTTC(this, id));
    }
    if (rootIncarnation.incarnationsStoneTTC.ContainsKey(id)) {
      return new StoneTTCAsIDestructible(new StoneTTC(this, id));
    }
    if (rootIncarnation.incarnationsGrassTTC.ContainsKey(id)) {
      return new GrassTTCAsIDestructible(new GrassTTC(this, id));
    }
    if (rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(id)) {
      return new EmberDeepLevelLinkerTTCAsIDestructible(new EmberDeepLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(id)) {
      return new IncendianFallsLevelLinkerTTCAsIDestructible(new IncendianFallsLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC.ContainsKey(id)) {
      return new RavaArcanaLevelLinkerTTCAsIDestructible(new RavaArcanaLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsVolcaetusLevelController.ContainsKey(id)) {
      return new VolcaetusLevelControllerAsIDestructible(new VolcaetusLevelController(this, id));
    }
    if (rootIncarnation.incarnationsTutorial2LevelController.ContainsKey(id)) {
      return new Tutorial2LevelControllerAsIDestructible(new Tutorial2LevelController(this, id));
    }
    if (rootIncarnation.incarnationsTutorial1LevelController.ContainsKey(id)) {
      return new Tutorial1LevelControllerAsIDestructible(new Tutorial1LevelController(this, id));
    }
    if (rootIncarnation.incarnationsRetreatLevelController.ContainsKey(id)) {
      return new RetreatLevelControllerAsIDestructible(new RetreatLevelController(this, id));
    }
    if (rootIncarnation.incarnationsSotaventoLevelController.ContainsKey(id)) {
      return new SotaventoLevelControllerAsIDestructible(new SotaventoLevelController(this, id));
    }
    if (rootIncarnation.incarnationsNestLevelController.ContainsKey(id)) {
      return new NestLevelControllerAsIDestructible(new NestLevelController(this, id));
    }
    if (rootIncarnation.incarnationsLakeLevelController.ContainsKey(id)) {
      return new LakeLevelControllerAsIDestructible(new LakeLevelController(this, id));
    }
    if (rootIncarnation.incarnationsDirtRoadLevelController.ContainsKey(id)) {
      return new DirtRoadLevelControllerAsIDestructible(new DirtRoadLevelController(this, id));
    }
    if (rootIncarnation.incarnationsCaveLevelController.ContainsKey(id)) {
      return new CaveLevelControllerAsIDestructible(new CaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsBridgesLevelController.ContainsKey(id)) {
      return new BridgesLevelControllerAsIDestructible(new BridgesLevelController(this, id));
    }
    if (rootIncarnation.incarnationsAncientTownLevelController.ContainsKey(id)) {
      return new AncientTownLevelControllerAsIDestructible(new AncientTownLevelController(this, id));
    }
    if (rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(id)) {
      return new SquareCaveLevelControllerAsIDestructible(new SquareCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(id)) {
      return new RavashrikeLevelControllerAsIDestructible(new RavashrikeLevelController(this, id));
    }
    if (rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(id)) {
      return new PentagonalCaveLevelControllerAsIDestructible(new PentagonalCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsCliffLevelController.ContainsKey(id)) {
      return new CliffLevelControllerAsIDestructible(new CliffLevelController(this, id));
    }
    if (rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(id)) {
      return new PreGauntletLevelControllerAsIDestructible(new PreGauntletLevelController(this, id));
    }
    if (rootIncarnation.incarnationsGauntletLevelController.ContainsKey(id)) {
      return new GauntletLevelControllerAsIDestructible(new GauntletLevelController(this, id));
    }
    if (rootIncarnation.incarnationsJumpingCaveLevelController.ContainsKey(id)) {
      return new JumpingCaveLevelControllerAsIDestructible(new JumpingCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsUnit.ContainsKey(id)) {
      return new UnitAsIDestructible(new Unit(this, id));
    }
    throw new Exception("Unknown IDestructible: " + id);
  }
  public IDestructible GetIDestructibleOrNull(int id) {
    if (rootIncarnation.incarnationsDeathTriggerUC.ContainsKey(id)) {
      return new DeathTriggerUCAsIDestructible(new DeathTriggerUC(this, id));
    }
    if (rootIncarnation.incarnationsBequeathUC.ContainsKey(id)) {
      return new BequeathUCAsIDestructible(new BequeathUC(this, id));
    }
    if (rootIncarnation.incarnationsTutorialDefyCounterUC.ContainsKey(id)) {
      return new TutorialDefyCounterUCAsIDestructible(new TutorialDefyCounterUC(this, id));
    }
    if (rootIncarnation.incarnationsLightningChargingUC.ContainsKey(id)) {
      return new LightningChargingUCAsIDestructible(new LightningChargingUC(this, id));
    }
    if (rootIncarnation.incarnationsWanderAICapabilityUC.ContainsKey(id)) {
      return new WanderAICapabilityUCAsIDestructible(new WanderAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTemporaryCloneAICapabilityUC.ContainsKey(id)) {
      return new TemporaryCloneAICapabilityUCAsIDestructible(new TemporaryCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsSummonAICapabilityUC.ContainsKey(id)) {
      return new SummonAICapabilityUCAsIDestructible(new SummonAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeAICapabilityUC.ContainsKey(id)) {
      return new KamikazeAICapabilityUCAsIDestructible(new KamikazeAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsGuardAICapabilityUC.ContainsKey(id)) {
      return new GuardAICapabilityUCAsIDestructible(new GuardAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsEvolvifyAICapabilityUC.ContainsKey(id)) {
      return new EvolvifyAICapabilityUCAsIDestructible(new EvolvifyAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsTimeCloneAICapabilityUC.ContainsKey(id)) {
      return new TimeCloneAICapabilityUCAsIDestructible(new TimeCloneAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDoomedUC.ContainsKey(id)) {
      return new DoomedUCAsIDestructible(new DoomedUC(this, id));
    }
    if (rootIncarnation.incarnationsMiredUC.ContainsKey(id)) {
      return new MiredUCAsIDestructible(new MiredUC(this, id));
    }
    if (rootIncarnation.incarnationsOnFireUC.ContainsKey(id)) {
      return new OnFireUCAsIDestructible(new OnFireUC(this, id));
    }
    if (rootIncarnation.incarnationsAttackAICapabilityUC.ContainsKey(id)) {
      return new AttackAICapabilityUCAsIDestructible(new AttackAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsCounteringUC.ContainsKey(id)) {
      return new CounteringUCAsIDestructible(new CounteringUC(this, id));
    }
    if (rootIncarnation.incarnationsLightningChargedUC.ContainsKey(id)) {
      return new LightningChargedUCAsIDestructible(new LightningChargedUC(this, id));
    }
    if (rootIncarnation.incarnationsInvincibilityUC.ContainsKey(id)) {
      return new InvincibilityUCAsIDestructible(new InvincibilityUC(this, id));
    }
    if (rootIncarnation.incarnationsDefyingUC.ContainsKey(id)) {
      return new DefyingUCAsIDestructible(new DefyingUC(this, id));
    }
    if (rootIncarnation.incarnationsBideAICapabilityUC.ContainsKey(id)) {
      return new BideAICapabilityUCAsIDestructible(new BideAICapabilityUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseSightRangeUC.ContainsKey(id)) {
      return new BaseSightRangeUCAsIDestructible(new BaseSightRangeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseMovementTimeUC.ContainsKey(id)) {
      return new BaseMovementTimeUCAsIDestructible(new BaseMovementTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseCombatTimeUC.ContainsKey(id)) {
      return new BaseCombatTimeUCAsIDestructible(new BaseCombatTimeUC(this, id));
    }
    if (rootIncarnation.incarnationsManaPotion.ContainsKey(id)) {
      return new ManaPotionAsIDestructible(new ManaPotion(this, id));
    }
    if (rootIncarnation.incarnationsHealthPotion.ContainsKey(id)) {
      return new HealthPotionAsIDestructible(new HealthPotion(this, id));
    }
    if (rootIncarnation.incarnationsSpeedRing.ContainsKey(id)) {
      return new SpeedRingAsIDestructible(new SpeedRing(this, id));
    }
    if (rootIncarnation.incarnationsGlaive.ContainsKey(id)) {
      return new GlaiveAsIDestructible(new Glaive(this, id));
    }
    if (rootIncarnation.incarnationsSlowRod.ContainsKey(id)) {
      return new SlowRodAsIDestructible(new SlowRod(this, id));
    }
    if (rootIncarnation.incarnationsExplosionRod.ContainsKey(id)) {
      return new ExplosionRodAsIDestructible(new ExplosionRod(this, id));
    }
    if (rootIncarnation.incarnationsBlazeRod.ContainsKey(id)) {
      return new BlazeRodAsIDestructible(new BlazeRod(this, id));
    }
    if (rootIncarnation.incarnationsBlastRod.ContainsKey(id)) {
      return new BlastRodAsIDestructible(new BlastRod(this, id));
    }
    if (rootIncarnation.incarnationsArmor.ContainsKey(id)) {
      return new ArmorAsIDestructible(new Armor(this, id));
    }
    if (rootIncarnation.incarnationsSorcerousUC.ContainsKey(id)) {
      return new SorcerousUCAsIDestructible(new SorcerousUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseOffenseUC.ContainsKey(id)) {
      return new BaseOffenseUCAsIDestructible(new BaseOffenseUC(this, id));
    }
    if (rootIncarnation.incarnationsBaseDefenseUC.ContainsKey(id)) {
      return new BaseDefenseUCAsIDestructible(new BaseDefenseUC(this, id));
    }
    if (rootIncarnation.incarnationsHoldPositionImpulse.ContainsKey(id)) {
      return new HoldPositionImpulseAsIDestructible(new HoldPositionImpulse(this, id));
    }
    if (rootIncarnation.incarnationsTemporaryCloneImpulse.ContainsKey(id)) {
      return new TemporaryCloneImpulseAsIDestructible(new TemporaryCloneImpulse(this, id));
    }
    if (rootIncarnation.incarnationsSummonImpulse.ContainsKey(id)) {
      return new SummonImpulseAsIDestructible(new SummonImpulse(this, id));
    }
    if (rootIncarnation.incarnationsMireImpulse.ContainsKey(id)) {
      return new MireImpulseAsIDestructible(new MireImpulse(this, id));
    }
    if (rootIncarnation.incarnationsEvaporateImpulse.ContainsKey(id)) {
      return new EvaporateImpulseAsIDestructible(new EvaporateImpulse(this, id));
    }
    if (rootIncarnation.incarnationsMoveImpulse.ContainsKey(id)) {
      return new MoveImpulseAsIDestructible(new MoveImpulse(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeJumpImpulse.ContainsKey(id)) {
      return new KamikazeJumpImpulseAsIDestructible(new KamikazeJumpImpulse(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeTargetImpulse.ContainsKey(id)) {
      return new KamikazeTargetImpulseAsIDestructible(new KamikazeTargetImpulse(this, id));
    }
    if (rootIncarnation.incarnationsNoImpulse.ContainsKey(id)) {
      return new NoImpulseAsIDestructible(new NoImpulse(this, id));
    }
    if (rootIncarnation.incarnationsEvolvifyImpulse.ContainsKey(id)) {
      return new EvolvifyImpulseAsIDestructible(new EvolvifyImpulse(this, id));
    }
    if (rootIncarnation.incarnationsFireImpulse.ContainsKey(id)) {
      return new FireImpulseAsIDestructible(new FireImpulse(this, id));
    }
    if (rootIncarnation.incarnationsDefyImpulse.ContainsKey(id)) {
      return new DefyImpulseAsIDestructible(new DefyImpulse(this, id));
    }
    if (rootIncarnation.incarnationsCounterImpulse.ContainsKey(id)) {
      return new CounterImpulseAsIDestructible(new CounterImpulse(this, id));
    }
    if (rootIncarnation.incarnationsUnleashBideImpulse.ContainsKey(id)) {
      return new UnleashBideImpulseAsIDestructible(new UnleashBideImpulse(this, id));
    }
    if (rootIncarnation.incarnationsContinueBidingImpulse.ContainsKey(id)) {
      return new ContinueBidingImpulseAsIDestructible(new ContinueBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsStartBidingImpulse.ContainsKey(id)) {
      return new StartBidingImpulseAsIDestructible(new StartBidingImpulse(this, id));
    }
    if (rootIncarnation.incarnationsAttackImpulse.ContainsKey(id)) {
      return new AttackImpulseAsIDestructible(new AttackImpulse(this, id));
    }
    if (rootIncarnation.incarnationsPursueImpulse.ContainsKey(id)) {
      return new PursueImpulseAsIDestructible(new PursueImpulse(this, id));
    }
    if (rootIncarnation.incarnationsFireBombImpulse.ContainsKey(id)) {
      return new FireBombImpulseAsIDestructible(new FireBombImpulse(this, id));
    }
    if (rootIncarnation.incarnationsSimplePresenceTriggerTTC.ContainsKey(id)) {
      return new SimplePresenceTriggerTTCAsIDestructible(new SimplePresenceTriggerTTC(this, id));
    }
    if (rootIncarnation.incarnationsItemTTC.ContainsKey(id)) {
      return new ItemTTCAsIDestructible(new ItemTTC(this, id));
    }
    if (rootIncarnation.incarnationsFlowerTTC.ContainsKey(id)) {
      return new FlowerTTCAsIDestructible(new FlowerTTC(this, id));
    }
    if (rootIncarnation.incarnationsLotusTTC.ContainsKey(id)) {
      return new LotusTTCAsIDestructible(new LotusTTC(this, id));
    }
    if (rootIncarnation.incarnationsRoseTTC.ContainsKey(id)) {
      return new RoseTTCAsIDestructible(new RoseTTC(this, id));
    }
    if (rootIncarnation.incarnationsLeafTTC.ContainsKey(id)) {
      return new LeafTTCAsIDestructible(new LeafTTC(this, id));
    }
    if (rootIncarnation.incarnationsKamikazeTargetTTC.ContainsKey(id)) {
      return new KamikazeTargetTTCAsIDestructible(new KamikazeTargetTTC(this, id));
    }
    if (rootIncarnation.incarnationsWarperTTC.ContainsKey(id)) {
      return new WarperTTCAsIDestructible(new WarperTTC(this, id));
    }
    if (rootIncarnation.incarnationsTimeAnchorTTC.ContainsKey(id)) {
      return new TimeAnchorTTCAsIDestructible(new TimeAnchorTTC(this, id));
    }
    if (rootIncarnation.incarnationsFireBombTTC.ContainsKey(id)) {
      return new FireBombTTCAsIDestructible(new FireBombTTC(this, id));
    }
    if (rootIncarnation.incarnationsOnFireTTC.ContainsKey(id)) {
      return new OnFireTTCAsIDestructible(new OnFireTTC(this, id));
    }
    if (rootIncarnation.incarnationsMarkerTTC.ContainsKey(id)) {
      return new MarkerTTCAsIDestructible(new MarkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsLevelLinkTTC.ContainsKey(id)) {
      return new LevelLinkTTCAsIDestructible(new LevelLinkTTC(this, id));
    }
    if (rootIncarnation.incarnationsMudTTC.ContainsKey(id)) {
      return new MudTTCAsIDestructible(new MudTTC(this, id));
    }
    if (rootIncarnation.incarnationsDirtTTC.ContainsKey(id)) {
      return new DirtTTCAsIDestructible(new DirtTTC(this, id));
    }
    if (rootIncarnation.incarnationsObsidianTTC.ContainsKey(id)) {
      return new ObsidianTTCAsIDestructible(new ObsidianTTC(this, id));
    }
    if (rootIncarnation.incarnationsDownStairsTTC.ContainsKey(id)) {
      return new DownStairsTTCAsIDestructible(new DownStairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsUpStairsTTC.ContainsKey(id)) {
      return new UpStairsTTCAsIDestructible(new UpStairsTTC(this, id));
    }
    if (rootIncarnation.incarnationsWallTTC.ContainsKey(id)) {
      return new WallTTCAsIDestructible(new WallTTC(this, id));
    }
    if (rootIncarnation.incarnationsBloodTTC.ContainsKey(id)) {
      return new BloodTTCAsIDestructible(new BloodTTC(this, id));
    }
    if (rootIncarnation.incarnationsRocksTTC.ContainsKey(id)) {
      return new RocksTTCAsIDestructible(new RocksTTC(this, id));
    }
    if (rootIncarnation.incarnationsTreeTTC.ContainsKey(id)) {
      return new TreeTTCAsIDestructible(new TreeTTC(this, id));
    }
    if (rootIncarnation.incarnationsWaterTTC.ContainsKey(id)) {
      return new WaterTTCAsIDestructible(new WaterTTC(this, id));
    }
    if (rootIncarnation.incarnationsFloorTTC.ContainsKey(id)) {
      return new FloorTTCAsIDestructible(new FloorTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveWallTTC.ContainsKey(id)) {
      return new CaveWallTTCAsIDestructible(new CaveWallTTC(this, id));
    }
    if (rootIncarnation.incarnationsCaveTTC.ContainsKey(id)) {
      return new CaveTTCAsIDestructible(new CaveTTC(this, id));
    }
    if (rootIncarnation.incarnationsFallsTTC.ContainsKey(id)) {
      return new FallsTTCAsIDestructible(new FallsTTC(this, id));
    }
    if (rootIncarnation.incarnationsObsidianFloorTTC.ContainsKey(id)) {
      return new ObsidianFloorTTCAsIDestructible(new ObsidianFloorTTC(this, id));
    }
    if (rootIncarnation.incarnationsMagmaTTC.ContainsKey(id)) {
      return new MagmaTTCAsIDestructible(new MagmaTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffTTC.ContainsKey(id)) {
      return new CliffTTCAsIDestructible(new CliffTTC(this, id));
    }
    if (rootIncarnation.incarnationsRavaNestTTC.ContainsKey(id)) {
      return new RavaNestTTCAsIDestructible(new RavaNestTTC(this, id));
    }
    if (rootIncarnation.incarnationsCliffLandingTTC.ContainsKey(id)) {
      return new CliffLandingTTCAsIDestructible(new CliffLandingTTC(this, id));
    }
    if (rootIncarnation.incarnationsStoneTTC.ContainsKey(id)) {
      return new StoneTTCAsIDestructible(new StoneTTC(this, id));
    }
    if (rootIncarnation.incarnationsGrassTTC.ContainsKey(id)) {
      return new GrassTTCAsIDestructible(new GrassTTC(this, id));
    }
    if (rootIncarnation.incarnationsEmberDeepLevelLinkerTTC.ContainsKey(id)) {
      return new EmberDeepLevelLinkerTTCAsIDestructible(new EmberDeepLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsIncendianFallsLevelLinkerTTC.ContainsKey(id)) {
      return new IncendianFallsLevelLinkerTTCAsIDestructible(new IncendianFallsLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsRavaArcanaLevelLinkerTTC.ContainsKey(id)) {
      return new RavaArcanaLevelLinkerTTCAsIDestructible(new RavaArcanaLevelLinkerTTC(this, id));
    }
    if (rootIncarnation.incarnationsVolcaetusLevelController.ContainsKey(id)) {
      return new VolcaetusLevelControllerAsIDestructible(new VolcaetusLevelController(this, id));
    }
    if (rootIncarnation.incarnationsTutorial2LevelController.ContainsKey(id)) {
      return new Tutorial2LevelControllerAsIDestructible(new Tutorial2LevelController(this, id));
    }
    if (rootIncarnation.incarnationsTutorial1LevelController.ContainsKey(id)) {
      return new Tutorial1LevelControllerAsIDestructible(new Tutorial1LevelController(this, id));
    }
    if (rootIncarnation.incarnationsRetreatLevelController.ContainsKey(id)) {
      return new RetreatLevelControllerAsIDestructible(new RetreatLevelController(this, id));
    }
    if (rootIncarnation.incarnationsSotaventoLevelController.ContainsKey(id)) {
      return new SotaventoLevelControllerAsIDestructible(new SotaventoLevelController(this, id));
    }
    if (rootIncarnation.incarnationsNestLevelController.ContainsKey(id)) {
      return new NestLevelControllerAsIDestructible(new NestLevelController(this, id));
    }
    if (rootIncarnation.incarnationsLakeLevelController.ContainsKey(id)) {
      return new LakeLevelControllerAsIDestructible(new LakeLevelController(this, id));
    }
    if (rootIncarnation.incarnationsDirtRoadLevelController.ContainsKey(id)) {
      return new DirtRoadLevelControllerAsIDestructible(new DirtRoadLevelController(this, id));
    }
    if (rootIncarnation.incarnationsCaveLevelController.ContainsKey(id)) {
      return new CaveLevelControllerAsIDestructible(new CaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsBridgesLevelController.ContainsKey(id)) {
      return new BridgesLevelControllerAsIDestructible(new BridgesLevelController(this, id));
    }
    if (rootIncarnation.incarnationsAncientTownLevelController.ContainsKey(id)) {
      return new AncientTownLevelControllerAsIDestructible(new AncientTownLevelController(this, id));
    }
    if (rootIncarnation.incarnationsSquareCaveLevelController.ContainsKey(id)) {
      return new SquareCaveLevelControllerAsIDestructible(new SquareCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsRavashrikeLevelController.ContainsKey(id)) {
      return new RavashrikeLevelControllerAsIDestructible(new RavashrikeLevelController(this, id));
    }
    if (rootIncarnation.incarnationsPentagonalCaveLevelController.ContainsKey(id)) {
      return new PentagonalCaveLevelControllerAsIDestructible(new PentagonalCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsCliffLevelController.ContainsKey(id)) {
      return new CliffLevelControllerAsIDestructible(new CliffLevelController(this, id));
    }
    if (rootIncarnation.incarnationsPreGauntletLevelController.ContainsKey(id)) {
      return new PreGauntletLevelControllerAsIDestructible(new PreGauntletLevelController(this, id));
    }
    if (rootIncarnation.incarnationsGauntletLevelController.ContainsKey(id)) {
      return new GauntletLevelControllerAsIDestructible(new GauntletLevelController(this, id));
    }
    if (rootIncarnation.incarnationsJumpingCaveLevelController.ContainsKey(id)) {
      return new JumpingCaveLevelControllerAsIDestructible(new JumpingCaveLevelController(this, id));
    }
    if (rootIncarnation.incarnationsUnit.ContainsKey(id)) {
      return new UnitAsIDestructible(new Unit(this, id));
    }
    return NullIDestructible.Null;
  }
  public bool IDestructibleExists(int id) {
    return GetIDestructibleOrNull(id) != null;
  }
  public void CheckHasIDestructible(IDestructible thing) {
    GetIDestructible(thing.id);
  }
  public void CheckHasIDestructible(int id) {
    GetIDestructible(id);
  }

    public int GetCommMutListHash(int id, int version, CommMutListIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CommMutListIncarnation GetCommMutListIncarnation(int id) {
      return rootIncarnation.incarnationsCommMutList[id].incarnation;
    }
    public CommMutList GetCommMutList(int id) {
      CheckHasCommMutList(id);
      return new CommMutList(this, id);
    }
    public CommMutList GetCommMutListOrNull(int id) {
      if (CommMutListExists(id)) {
        return new CommMutList(this, id);
      } else {
        return new CommMutList(this, 0);
      }
    }
    public List<CommMutList> AllCommMutList() {
      List<CommMutList> result = new List<CommMutList>(rootIncarnation.incarnationsCommMutList.Count);
      foreach (var id in rootIncarnation.incarnationsCommMutList.Keys) {
        result.Add(new CommMutList(this, id));
      }
      return result;
    }
    public bool CommMutListExists(int id) {
      return rootIncarnation.incarnationsCommMutList.ContainsKey(id);
    }
    public void CheckHasCommMutList(CommMutList thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCommMutList(thing.id);
    }
    public void CheckHasCommMutList(int id) {
      if (!rootIncarnation.incarnationsCommMutList.ContainsKey(id)) {
        throw new System.Exception("Invalid CommMutList}: " + id);
      }
    }
    public CommMutList EffectCommMutListCreate() {
      return TrustedEffectCommMutListCreateWithId(NewId());
    }
    public CommMutList TrustedEffectCommMutListCreateWithId(int id) {
      CheckUnlocked();
      Asserts.Assert(!rootIncarnation.incarnationsCommMutList.ContainsKey(id));
      var effect = InternalEffectCreateCommMutList(id, rootIncarnation.version, new CommMutListIncarnation(new List<int>()));
      NotifyEffect(effect);
      return new CommMutList(this, id);
    }
    public CommMutList EffectCommMutListCreate(IEnumerable<Comm> elements) {
      var list = EffectCommMutListCreate();
      foreach (var element in elements) {
        list.Add(element);
      }
      return list;
    }
    public CommMutListCreateEffect InternalEffectCreateCommMutList(int id, int incarnationVersion, CommMutListIncarnation incarnation) {
      rootIncarnation.incarnationsCommMutList
          .Add(
              id,
              new VersionAndIncarnation<CommMutListIncarnation>(
                  incarnationVersion,
                  incarnation));
      return new CommMutListCreateEffect(id);
    }
    public void EffectCommMutListDelete(int id) {
      var effect = InternalEffectCommMutListDelete(id);
      NotifyEffect(effect);
    }
    public CommMutListDeleteEffect InternalEffectCommMutListDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsCommMutList[id];
      rootIncarnation.incarnationsCommMutList.Remove(id);
      return new CommMutListDeleteEffect(id);
    }
    public void EffectCommMutListAdd(int instanceId, int addIndex, int element) {
      CheckUnlocked();
      CheckHasCommMutList(instanceId);
          CheckHasComm(element);
      var effect = InternalEffectCommMutListAdd(instanceId, addIndex, element);
      NotifyEffect(effect);
    }
    public CommMutListAddEffect InternalEffectCommMutListAdd(int instanceId, int addIndex, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsCommMutList[instanceId];

      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Insert(addIndex, element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new List<int>(oldMap);
        newMap.Insert(addIndex, element);
        var newIncarnation = new CommMutListIncarnation(newMap);
        rootIncarnation.incarnationsCommMutList[instanceId] =
            new VersionAndIncarnation<CommMutListIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new CommMutListAddEffect(instanceId, addIndex, element);
    }
    public void EffectCommMutListRemoveAt(int instanceId, int index) {
      CheckUnlocked();
      CheckHasCommMutList(instanceId);
      var effect = InternalEffectCommMutListRemoveAt(instanceId, index);
      NotifyEffect(effect);
    }
    public CommMutListRemoveEffect InternalEffectCommMutListRemoveAt(int instanceId, int index) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsCommMutList[instanceId];
      // Check that its there
      var oldElement = oldIncarnationAndVersion.incarnation.elements[index];

      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.RemoveAt(index);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new List<int>(oldMap);
        newMap.RemoveAt(index);
        var newIncarnation = new CommMutListIncarnation(newMap);
        rootIncarnation.incarnationsCommMutList[instanceId] =
            new VersionAndIncarnation<CommMutListIncarnation>(
                rootIncarnation.version, newIncarnation);

      }
      return new CommMutListRemoveEffect(instanceId, index);
    }
       
    public int GetLocationMutListHash(int id, int version, LocationMutListIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public LocationMutListIncarnation GetLocationMutListIncarnation(int id) {
      return rootIncarnation.incarnationsLocationMutList[id].incarnation;
    }
    public LocationMutList GetLocationMutList(int id) {
      CheckHasLocationMutList(id);
      return new LocationMutList(this, id);
    }
    public LocationMutList GetLocationMutListOrNull(int id) {
      if (LocationMutListExists(id)) {
        return new LocationMutList(this, id);
      } else {
        return new LocationMutList(this, 0);
      }
    }
    public List<LocationMutList> AllLocationMutList() {
      List<LocationMutList> result = new List<LocationMutList>(rootIncarnation.incarnationsLocationMutList.Count);
      foreach (var id in rootIncarnation.incarnationsLocationMutList.Keys) {
        result.Add(new LocationMutList(this, id));
      }
      return result;
    }
    public bool LocationMutListExists(int id) {
      return rootIncarnation.incarnationsLocationMutList.ContainsKey(id);
    }
    public void CheckHasLocationMutList(LocationMutList thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasLocationMutList(thing.id);
    }
    public void CheckHasLocationMutList(int id) {
      if (!rootIncarnation.incarnationsLocationMutList.ContainsKey(id)) {
        throw new System.Exception("Invalid LocationMutList}: " + id);
      }
    }
    public LocationMutList EffectLocationMutListCreate() {
      return TrustedEffectLocationMutListCreateWithId(NewId());
    }
    public LocationMutList TrustedEffectLocationMutListCreateWithId(int id) {
      CheckUnlocked();
      Asserts.Assert(!rootIncarnation.incarnationsLocationMutList.ContainsKey(id));
      var effect = InternalEffectCreateLocationMutList(id, rootIncarnation.version, new LocationMutListIncarnation(new List<Location>()));
      NotifyEffect(effect);
      return new LocationMutList(this, id);
    }
    public LocationMutList EffectLocationMutListCreate(IEnumerable<Location> elements) {
      var list = EffectLocationMutListCreate();
      foreach (var element in elements) {
        list.Add(element);
      }
      return list;
    }
    public LocationMutListCreateEffect InternalEffectCreateLocationMutList(int id, int incarnationVersion, LocationMutListIncarnation incarnation) {
      rootIncarnation.incarnationsLocationMutList
          .Add(
              id,
              new VersionAndIncarnation<LocationMutListIncarnation>(
                  incarnationVersion,
                  incarnation));
      return new LocationMutListCreateEffect(id);
    }
    public void EffectLocationMutListDelete(int id) {
      var effect = InternalEffectLocationMutListDelete(id);
      NotifyEffect(effect);
    }
    public LocationMutListDeleteEffect InternalEffectLocationMutListDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsLocationMutList[id];
      rootIncarnation.incarnationsLocationMutList.Remove(id);
      return new LocationMutListDeleteEffect(id);
    }
    public void EffectLocationMutListAdd(int instanceId, int addIndex, Location element) {
      CheckUnlocked();
      CheckHasLocationMutList(instanceId);
    
      var effect = InternalEffectLocationMutListAdd(instanceId, addIndex, element);
      NotifyEffect(effect);
    }
    public LocationMutListAddEffect InternalEffectLocationMutListAdd(int instanceId, int addIndex, Location element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsLocationMutList[instanceId];

      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Insert(addIndex, element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new List<Location>(oldMap);
        newMap.Insert(addIndex, element);
        var newIncarnation = new LocationMutListIncarnation(newMap);
        rootIncarnation.incarnationsLocationMutList[instanceId] =
            new VersionAndIncarnation<LocationMutListIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new LocationMutListAddEffect(instanceId, addIndex, element);
    }
    public void EffectLocationMutListRemoveAt(int instanceId, int index) {
      CheckUnlocked();
      CheckHasLocationMutList(instanceId);
      var effect = InternalEffectLocationMutListRemoveAt(instanceId, index);
      NotifyEffect(effect);
    }
    public LocationMutListRemoveEffect InternalEffectLocationMutListRemoveAt(int instanceId, int index) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsLocationMutList[instanceId];
      // Check that its there
      var oldElement = oldIncarnationAndVersion.incarnation.elements[index];

      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.RemoveAt(index);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new List<Location>(oldMap);
        newMap.RemoveAt(index);
        var newIncarnation = new LocationMutListIncarnation(newMap);
        rootIncarnation.incarnationsLocationMutList[instanceId] =
            new VersionAndIncarnation<LocationMutListIncarnation>(
                rootIncarnation.version, newIncarnation);

      }
      return new LocationMutListRemoveEffect(instanceId, index);
    }
       
    public int GetIRequestMutListHash(int id, int version, IRequestMutListIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public IRequestMutListIncarnation GetIRequestMutListIncarnation(int id) {
      return rootIncarnation.incarnationsIRequestMutList[id].incarnation;
    }
    public IRequestMutList GetIRequestMutList(int id) {
      CheckHasIRequestMutList(id);
      return new IRequestMutList(this, id);
    }
    public IRequestMutList GetIRequestMutListOrNull(int id) {
      if (IRequestMutListExists(id)) {
        return new IRequestMutList(this, id);
      } else {
        return new IRequestMutList(this, 0);
      }
    }
    public List<IRequestMutList> AllIRequestMutList() {
      List<IRequestMutList> result = new List<IRequestMutList>(rootIncarnation.incarnationsIRequestMutList.Count);
      foreach (var id in rootIncarnation.incarnationsIRequestMutList.Keys) {
        result.Add(new IRequestMutList(this, id));
      }
      return result;
    }
    public bool IRequestMutListExists(int id) {
      return rootIncarnation.incarnationsIRequestMutList.ContainsKey(id);
    }
    public void CheckHasIRequestMutList(IRequestMutList thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasIRequestMutList(thing.id);
    }
    public void CheckHasIRequestMutList(int id) {
      if (!rootIncarnation.incarnationsIRequestMutList.ContainsKey(id)) {
        throw new System.Exception("Invalid IRequestMutList}: " + id);
      }
    }
    public IRequestMutList EffectIRequestMutListCreate() {
      return TrustedEffectIRequestMutListCreateWithId(NewId());
    }
    public IRequestMutList TrustedEffectIRequestMutListCreateWithId(int id) {
      CheckUnlocked();
      Asserts.Assert(!rootIncarnation.incarnationsIRequestMutList.ContainsKey(id));
      var effect = InternalEffectCreateIRequestMutList(id, rootIncarnation.version, new IRequestMutListIncarnation(new List<IRequest>()));
      NotifyEffect(effect);
      return new IRequestMutList(this, id);
    }
    public IRequestMutList EffectIRequestMutListCreate(IEnumerable<IRequest> elements) {
      var list = EffectIRequestMutListCreate();
      foreach (var element in elements) {
        list.Add(element);
      }
      return list;
    }
    public IRequestMutListCreateEffect InternalEffectCreateIRequestMutList(int id, int incarnationVersion, IRequestMutListIncarnation incarnation) {
      rootIncarnation.incarnationsIRequestMutList
          .Add(
              id,
              new VersionAndIncarnation<IRequestMutListIncarnation>(
                  incarnationVersion,
                  incarnation));
      return new IRequestMutListCreateEffect(id);
    }
    public void EffectIRequestMutListDelete(int id) {
      var effect = InternalEffectIRequestMutListDelete(id);
      NotifyEffect(effect);
    }
    public IRequestMutListDeleteEffect InternalEffectIRequestMutListDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsIRequestMutList[id];
      rootIncarnation.incarnationsIRequestMutList.Remove(id);
      return new IRequestMutListDeleteEffect(id);
    }
    public void EffectIRequestMutListAdd(int instanceId, int addIndex, IRequest element) {
      CheckUnlocked();
      CheckHasIRequestMutList(instanceId);
    
      var effect = InternalEffectIRequestMutListAdd(instanceId, addIndex, element);
      NotifyEffect(effect);
    }
    public IRequestMutListAddEffect InternalEffectIRequestMutListAdd(int instanceId, int addIndex, IRequest element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsIRequestMutList[instanceId];

      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Insert(addIndex, element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new List<IRequest>(oldMap);
        newMap.Insert(addIndex, element);
        var newIncarnation = new IRequestMutListIncarnation(newMap);
        rootIncarnation.incarnationsIRequestMutList[instanceId] =
            new VersionAndIncarnation<IRequestMutListIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new IRequestMutListAddEffect(instanceId, addIndex, element);
    }
    public void EffectIRequestMutListRemoveAt(int instanceId, int index) {
      CheckUnlocked();
      CheckHasIRequestMutList(instanceId);
      var effect = InternalEffectIRequestMutListRemoveAt(instanceId, index);
      NotifyEffect(effect);
    }
    public IRequestMutListRemoveEffect InternalEffectIRequestMutListRemoveAt(int instanceId, int index) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsIRequestMutList[instanceId];
      // Check that its there
      var oldElement = oldIncarnationAndVersion.incarnation.elements[index];

      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.RemoveAt(index);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new List<IRequest>(oldMap);
        newMap.RemoveAt(index);
        var newIncarnation = new IRequestMutListIncarnation(newMap);
        rootIncarnation.incarnationsIRequestMutList[instanceId] =
            new VersionAndIncarnation<IRequestMutListIncarnation>(
                rootIncarnation.version, newIncarnation);

      }
      return new IRequestMutListRemoveEffect(instanceId, index);
    }
       
    public int GetLevelMutSetHash(int id, int version, LevelMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public LevelMutSetIncarnation GetLevelMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsLevelMutSet[id].incarnation;
    }
    public LevelMutSet GetLevelMutSet(int id) {
      return new LevelMutSet(this, id);
    }
    public List<LevelMutSet> AllLevelMutSet() {
      List<LevelMutSet> result = new List<LevelMutSet>(rootIncarnation.incarnationsLevelMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsLevelMutSet.Keys) {
        result.Add(new LevelMutSet(this, id));
      }
      return result;
    }
    public bool LevelMutSetExists(int id) {
      return rootIncarnation.incarnationsLevelMutSet.ContainsKey(id);
    }
    public void CheckHasLevelMutSet(LevelMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasLevelMutSet(thing.id);
    }
    public void CheckHasLevelMutSet(int id) {
      if (!rootIncarnation.incarnationsLevelMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid LevelMutSet}: " + id);
      }
    }
    public LevelMutSet EffectLevelMutSetCreate() {
      return TrustedEffectLevelMutSetCreateWithId(NewId());
    }
    public LevelMutSet TrustedEffectLevelMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new LevelMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateLevelMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new LevelMutSet(this, id);
    }
    public LevelMutSetCreateEffect InternalEffectCreateLevelMutSet(int id, int incarnationVersion, LevelMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsLevelMutSet
          .Add(
              id,
              new VersionAndIncarnation<LevelMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new LevelMutSetCreateEffect(id);
    }
    public void EffectLevelMutSetDelete(int id) {
      var effect = InternalEffectLevelMutSetDelete(id);
      NotifyEffect(effect);
    }
    public LevelMutSetDeleteEffect InternalEffectLevelMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsLevelMutSet[id];
      rootIncarnation.incarnationsLevelMutSet.Remove(id);
      return new LevelMutSetDeleteEffect(id);
    }

       
    public void EffectLevelMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasLevelMutSet(instanceId);
      CheckHasLevel(element);
      var effect = InternalEffectLevelMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public LevelMutSetAddEffect InternalEffectLevelMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsLevelMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new LevelMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLevelMutSet[instanceId] =
            new VersionAndIncarnation<LevelMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new LevelMutSetAddEffect(instanceId, element);
    }
    public void EffectLevelMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasLevelMutSet(instanceId);
      CheckHasLevel(element);
      var effect = InternalEffectLevelMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public LevelMutSetRemoveEffect InternalEffectLevelMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsLevelMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new LevelMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLevelMutSet[instanceId] =
            new VersionAndIncarnation<LevelMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new LevelMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetManaPotionStrongMutSetHash(int id, int version, ManaPotionStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ManaPotionStrongMutSetIncarnation GetManaPotionStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsManaPotionStrongMutSet[id].incarnation;
    }
    public ManaPotionStrongMutSet GetManaPotionStrongMutSet(int id) {
      return new ManaPotionStrongMutSet(this, id);
    }
    public List<ManaPotionStrongMutSet> AllManaPotionStrongMutSet() {
      List<ManaPotionStrongMutSet> result = new List<ManaPotionStrongMutSet>(rootIncarnation.incarnationsManaPotionStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsManaPotionStrongMutSet.Keys) {
        result.Add(new ManaPotionStrongMutSet(this, id));
      }
      return result;
    }
    public bool ManaPotionStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsManaPotionStrongMutSet.ContainsKey(id);
    }
    public void CheckHasManaPotionStrongMutSet(ManaPotionStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasManaPotionStrongMutSet(thing.id);
    }
    public void CheckHasManaPotionStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsManaPotionStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ManaPotionStrongMutSet}: " + id);
      }
    }
    public ManaPotionStrongMutSet EffectManaPotionStrongMutSetCreate() {
      return TrustedEffectManaPotionStrongMutSetCreateWithId(NewId());
    }
    public ManaPotionStrongMutSet TrustedEffectManaPotionStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new ManaPotionStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateManaPotionStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new ManaPotionStrongMutSet(this, id);
    }
    public ManaPotionStrongMutSetCreateEffect InternalEffectCreateManaPotionStrongMutSet(int id, int incarnationVersion, ManaPotionStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsManaPotionStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<ManaPotionStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new ManaPotionStrongMutSetCreateEffect(id);
    }
    public void EffectManaPotionStrongMutSetDelete(int id) {
      var effect = InternalEffectManaPotionStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public ManaPotionStrongMutSetDeleteEffect InternalEffectManaPotionStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsManaPotionStrongMutSet[id];
      rootIncarnation.incarnationsManaPotionStrongMutSet.Remove(id);
      return new ManaPotionStrongMutSetDeleteEffect(id);
    }

       
    public void EffectManaPotionStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasManaPotionStrongMutSet(instanceId);
      CheckHasManaPotion(element);
      var effect = InternalEffectManaPotionStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public ManaPotionStrongMutSetAddEffect InternalEffectManaPotionStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsManaPotionStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new ManaPotionStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsManaPotionStrongMutSet[instanceId] =
            new VersionAndIncarnation<ManaPotionStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new ManaPotionStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectManaPotionStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasManaPotionStrongMutSet(instanceId);
      CheckHasManaPotion(element);
      var effect = InternalEffectManaPotionStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public ManaPotionStrongMutSetRemoveEffect InternalEffectManaPotionStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsManaPotionStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ManaPotionStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsManaPotionStrongMutSet[instanceId] =
            new VersionAndIncarnation<ManaPotionStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new ManaPotionStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetHealthPotionStrongMutSetHash(int id, int version, HealthPotionStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public HealthPotionStrongMutSetIncarnation GetHealthPotionStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsHealthPotionStrongMutSet[id].incarnation;
    }
    public HealthPotionStrongMutSet GetHealthPotionStrongMutSet(int id) {
      return new HealthPotionStrongMutSet(this, id);
    }
    public List<HealthPotionStrongMutSet> AllHealthPotionStrongMutSet() {
      List<HealthPotionStrongMutSet> result = new List<HealthPotionStrongMutSet>(rootIncarnation.incarnationsHealthPotionStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsHealthPotionStrongMutSet.Keys) {
        result.Add(new HealthPotionStrongMutSet(this, id));
      }
      return result;
    }
    public bool HealthPotionStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsHealthPotionStrongMutSet.ContainsKey(id);
    }
    public void CheckHasHealthPotionStrongMutSet(HealthPotionStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasHealthPotionStrongMutSet(thing.id);
    }
    public void CheckHasHealthPotionStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsHealthPotionStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid HealthPotionStrongMutSet}: " + id);
      }
    }
    public HealthPotionStrongMutSet EffectHealthPotionStrongMutSetCreate() {
      return TrustedEffectHealthPotionStrongMutSetCreateWithId(NewId());
    }
    public HealthPotionStrongMutSet TrustedEffectHealthPotionStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new HealthPotionStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateHealthPotionStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new HealthPotionStrongMutSet(this, id);
    }
    public HealthPotionStrongMutSetCreateEffect InternalEffectCreateHealthPotionStrongMutSet(int id, int incarnationVersion, HealthPotionStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsHealthPotionStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<HealthPotionStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new HealthPotionStrongMutSetCreateEffect(id);
    }
    public void EffectHealthPotionStrongMutSetDelete(int id) {
      var effect = InternalEffectHealthPotionStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public HealthPotionStrongMutSetDeleteEffect InternalEffectHealthPotionStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsHealthPotionStrongMutSet[id];
      rootIncarnation.incarnationsHealthPotionStrongMutSet.Remove(id);
      return new HealthPotionStrongMutSetDeleteEffect(id);
    }

       
    public void EffectHealthPotionStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasHealthPotionStrongMutSet(instanceId);
      CheckHasHealthPotion(element);
      var effect = InternalEffectHealthPotionStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public HealthPotionStrongMutSetAddEffect InternalEffectHealthPotionStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsHealthPotionStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new HealthPotionStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsHealthPotionStrongMutSet[instanceId] =
            new VersionAndIncarnation<HealthPotionStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new HealthPotionStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectHealthPotionStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasHealthPotionStrongMutSet(instanceId);
      CheckHasHealthPotion(element);
      var effect = InternalEffectHealthPotionStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public HealthPotionStrongMutSetRemoveEffect InternalEffectHealthPotionStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsHealthPotionStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new HealthPotionStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsHealthPotionStrongMutSet[instanceId] =
            new VersionAndIncarnation<HealthPotionStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new HealthPotionStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetSpeedRingStrongMutSetHash(int id, int version, SpeedRingStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public SpeedRingStrongMutSetIncarnation GetSpeedRingStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsSpeedRingStrongMutSet[id].incarnation;
    }
    public SpeedRingStrongMutSet GetSpeedRingStrongMutSet(int id) {
      return new SpeedRingStrongMutSet(this, id);
    }
    public List<SpeedRingStrongMutSet> AllSpeedRingStrongMutSet() {
      List<SpeedRingStrongMutSet> result = new List<SpeedRingStrongMutSet>(rootIncarnation.incarnationsSpeedRingStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsSpeedRingStrongMutSet.Keys) {
        result.Add(new SpeedRingStrongMutSet(this, id));
      }
      return result;
    }
    public bool SpeedRingStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsSpeedRingStrongMutSet.ContainsKey(id);
    }
    public void CheckHasSpeedRingStrongMutSet(SpeedRingStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasSpeedRingStrongMutSet(thing.id);
    }
    public void CheckHasSpeedRingStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsSpeedRingStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid SpeedRingStrongMutSet}: " + id);
      }
    }
    public SpeedRingStrongMutSet EffectSpeedRingStrongMutSetCreate() {
      return TrustedEffectSpeedRingStrongMutSetCreateWithId(NewId());
    }
    public SpeedRingStrongMutSet TrustedEffectSpeedRingStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new SpeedRingStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateSpeedRingStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new SpeedRingStrongMutSet(this, id);
    }
    public SpeedRingStrongMutSetCreateEffect InternalEffectCreateSpeedRingStrongMutSet(int id, int incarnationVersion, SpeedRingStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsSpeedRingStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<SpeedRingStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new SpeedRingStrongMutSetCreateEffect(id);
    }
    public void EffectSpeedRingStrongMutSetDelete(int id) {
      var effect = InternalEffectSpeedRingStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public SpeedRingStrongMutSetDeleteEffect InternalEffectSpeedRingStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsSpeedRingStrongMutSet[id];
      rootIncarnation.incarnationsSpeedRingStrongMutSet.Remove(id);
      return new SpeedRingStrongMutSetDeleteEffect(id);
    }

       
    public void EffectSpeedRingStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasSpeedRingStrongMutSet(instanceId);
      CheckHasSpeedRing(element);
      var effect = InternalEffectSpeedRingStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public SpeedRingStrongMutSetAddEffect InternalEffectSpeedRingStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsSpeedRingStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new SpeedRingStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSpeedRingStrongMutSet[instanceId] =
            new VersionAndIncarnation<SpeedRingStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new SpeedRingStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectSpeedRingStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasSpeedRingStrongMutSet(instanceId);
      CheckHasSpeedRing(element);
      var effect = InternalEffectSpeedRingStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public SpeedRingStrongMutSetRemoveEffect InternalEffectSpeedRingStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsSpeedRingStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new SpeedRingStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSpeedRingStrongMutSet[instanceId] =
            new VersionAndIncarnation<SpeedRingStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new SpeedRingStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetGlaiveStrongMutSetHash(int id, int version, GlaiveStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public GlaiveStrongMutSetIncarnation GetGlaiveStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsGlaiveStrongMutSet[id].incarnation;
    }
    public GlaiveStrongMutSet GetGlaiveStrongMutSet(int id) {
      return new GlaiveStrongMutSet(this, id);
    }
    public List<GlaiveStrongMutSet> AllGlaiveStrongMutSet() {
      List<GlaiveStrongMutSet> result = new List<GlaiveStrongMutSet>(rootIncarnation.incarnationsGlaiveStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsGlaiveStrongMutSet.Keys) {
        result.Add(new GlaiveStrongMutSet(this, id));
      }
      return result;
    }
    public bool GlaiveStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsGlaiveStrongMutSet.ContainsKey(id);
    }
    public void CheckHasGlaiveStrongMutSet(GlaiveStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasGlaiveStrongMutSet(thing.id);
    }
    public void CheckHasGlaiveStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsGlaiveStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid GlaiveStrongMutSet}: " + id);
      }
    }
    public GlaiveStrongMutSet EffectGlaiveStrongMutSetCreate() {
      return TrustedEffectGlaiveStrongMutSetCreateWithId(NewId());
    }
    public GlaiveStrongMutSet TrustedEffectGlaiveStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new GlaiveStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateGlaiveStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new GlaiveStrongMutSet(this, id);
    }
    public GlaiveStrongMutSetCreateEffect InternalEffectCreateGlaiveStrongMutSet(int id, int incarnationVersion, GlaiveStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsGlaiveStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<GlaiveStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new GlaiveStrongMutSetCreateEffect(id);
    }
    public void EffectGlaiveStrongMutSetDelete(int id) {
      var effect = InternalEffectGlaiveStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public GlaiveStrongMutSetDeleteEffect InternalEffectGlaiveStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsGlaiveStrongMutSet[id];
      rootIncarnation.incarnationsGlaiveStrongMutSet.Remove(id);
      return new GlaiveStrongMutSetDeleteEffect(id);
    }

       
    public void EffectGlaiveStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasGlaiveStrongMutSet(instanceId);
      CheckHasGlaive(element);
      var effect = InternalEffectGlaiveStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public GlaiveStrongMutSetAddEffect InternalEffectGlaiveStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsGlaiveStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new GlaiveStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsGlaiveStrongMutSet[instanceId] =
            new VersionAndIncarnation<GlaiveStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new GlaiveStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectGlaiveStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasGlaiveStrongMutSet(instanceId);
      CheckHasGlaive(element);
      var effect = InternalEffectGlaiveStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public GlaiveStrongMutSetRemoveEffect InternalEffectGlaiveStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsGlaiveStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new GlaiveStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsGlaiveStrongMutSet[instanceId] =
            new VersionAndIncarnation<GlaiveStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new GlaiveStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetSlowRodStrongMutSetHash(int id, int version, SlowRodStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public SlowRodStrongMutSetIncarnation GetSlowRodStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsSlowRodStrongMutSet[id].incarnation;
    }
    public SlowRodStrongMutSet GetSlowRodStrongMutSet(int id) {
      return new SlowRodStrongMutSet(this, id);
    }
    public List<SlowRodStrongMutSet> AllSlowRodStrongMutSet() {
      List<SlowRodStrongMutSet> result = new List<SlowRodStrongMutSet>(rootIncarnation.incarnationsSlowRodStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsSlowRodStrongMutSet.Keys) {
        result.Add(new SlowRodStrongMutSet(this, id));
      }
      return result;
    }
    public bool SlowRodStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsSlowRodStrongMutSet.ContainsKey(id);
    }
    public void CheckHasSlowRodStrongMutSet(SlowRodStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasSlowRodStrongMutSet(thing.id);
    }
    public void CheckHasSlowRodStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsSlowRodStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid SlowRodStrongMutSet}: " + id);
      }
    }
    public SlowRodStrongMutSet EffectSlowRodStrongMutSetCreate() {
      return TrustedEffectSlowRodStrongMutSetCreateWithId(NewId());
    }
    public SlowRodStrongMutSet TrustedEffectSlowRodStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new SlowRodStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateSlowRodStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new SlowRodStrongMutSet(this, id);
    }
    public SlowRodStrongMutSetCreateEffect InternalEffectCreateSlowRodStrongMutSet(int id, int incarnationVersion, SlowRodStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsSlowRodStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<SlowRodStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new SlowRodStrongMutSetCreateEffect(id);
    }
    public void EffectSlowRodStrongMutSetDelete(int id) {
      var effect = InternalEffectSlowRodStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public SlowRodStrongMutSetDeleteEffect InternalEffectSlowRodStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsSlowRodStrongMutSet[id];
      rootIncarnation.incarnationsSlowRodStrongMutSet.Remove(id);
      return new SlowRodStrongMutSetDeleteEffect(id);
    }

       
    public void EffectSlowRodStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasSlowRodStrongMutSet(instanceId);
      CheckHasSlowRod(element);
      var effect = InternalEffectSlowRodStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public SlowRodStrongMutSetAddEffect InternalEffectSlowRodStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsSlowRodStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new SlowRodStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSlowRodStrongMutSet[instanceId] =
            new VersionAndIncarnation<SlowRodStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new SlowRodStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectSlowRodStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasSlowRodStrongMutSet(instanceId);
      CheckHasSlowRod(element);
      var effect = InternalEffectSlowRodStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public SlowRodStrongMutSetRemoveEffect InternalEffectSlowRodStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsSlowRodStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new SlowRodStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSlowRodStrongMutSet[instanceId] =
            new VersionAndIncarnation<SlowRodStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new SlowRodStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetExplosionRodStrongMutSetHash(int id, int version, ExplosionRodStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ExplosionRodStrongMutSetIncarnation GetExplosionRodStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsExplosionRodStrongMutSet[id].incarnation;
    }
    public ExplosionRodStrongMutSet GetExplosionRodStrongMutSet(int id) {
      return new ExplosionRodStrongMutSet(this, id);
    }
    public List<ExplosionRodStrongMutSet> AllExplosionRodStrongMutSet() {
      List<ExplosionRodStrongMutSet> result = new List<ExplosionRodStrongMutSet>(rootIncarnation.incarnationsExplosionRodStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsExplosionRodStrongMutSet.Keys) {
        result.Add(new ExplosionRodStrongMutSet(this, id));
      }
      return result;
    }
    public bool ExplosionRodStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsExplosionRodStrongMutSet.ContainsKey(id);
    }
    public void CheckHasExplosionRodStrongMutSet(ExplosionRodStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasExplosionRodStrongMutSet(thing.id);
    }
    public void CheckHasExplosionRodStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsExplosionRodStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ExplosionRodStrongMutSet}: " + id);
      }
    }
    public ExplosionRodStrongMutSet EffectExplosionRodStrongMutSetCreate() {
      return TrustedEffectExplosionRodStrongMutSetCreateWithId(NewId());
    }
    public ExplosionRodStrongMutSet TrustedEffectExplosionRodStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new ExplosionRodStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateExplosionRodStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new ExplosionRodStrongMutSet(this, id);
    }
    public ExplosionRodStrongMutSetCreateEffect InternalEffectCreateExplosionRodStrongMutSet(int id, int incarnationVersion, ExplosionRodStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsExplosionRodStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<ExplosionRodStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new ExplosionRodStrongMutSetCreateEffect(id);
    }
    public void EffectExplosionRodStrongMutSetDelete(int id) {
      var effect = InternalEffectExplosionRodStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public ExplosionRodStrongMutSetDeleteEffect InternalEffectExplosionRodStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsExplosionRodStrongMutSet[id];
      rootIncarnation.incarnationsExplosionRodStrongMutSet.Remove(id);
      return new ExplosionRodStrongMutSetDeleteEffect(id);
    }

       
    public void EffectExplosionRodStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasExplosionRodStrongMutSet(instanceId);
      CheckHasExplosionRod(element);
      var effect = InternalEffectExplosionRodStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public ExplosionRodStrongMutSetAddEffect InternalEffectExplosionRodStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsExplosionRodStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new ExplosionRodStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsExplosionRodStrongMutSet[instanceId] =
            new VersionAndIncarnation<ExplosionRodStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new ExplosionRodStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectExplosionRodStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasExplosionRodStrongMutSet(instanceId);
      CheckHasExplosionRod(element);
      var effect = InternalEffectExplosionRodStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public ExplosionRodStrongMutSetRemoveEffect InternalEffectExplosionRodStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsExplosionRodStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ExplosionRodStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsExplosionRodStrongMutSet[instanceId] =
            new VersionAndIncarnation<ExplosionRodStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new ExplosionRodStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetBlazeRodStrongMutSetHash(int id, int version, BlazeRodStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BlazeRodStrongMutSetIncarnation GetBlazeRodStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBlazeRodStrongMutSet[id].incarnation;
    }
    public BlazeRodStrongMutSet GetBlazeRodStrongMutSet(int id) {
      return new BlazeRodStrongMutSet(this, id);
    }
    public List<BlazeRodStrongMutSet> AllBlazeRodStrongMutSet() {
      List<BlazeRodStrongMutSet> result = new List<BlazeRodStrongMutSet>(rootIncarnation.incarnationsBlazeRodStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBlazeRodStrongMutSet.Keys) {
        result.Add(new BlazeRodStrongMutSet(this, id));
      }
      return result;
    }
    public bool BlazeRodStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsBlazeRodStrongMutSet.ContainsKey(id);
    }
    public void CheckHasBlazeRodStrongMutSet(BlazeRodStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBlazeRodStrongMutSet(thing.id);
    }
    public void CheckHasBlazeRodStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsBlazeRodStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BlazeRodStrongMutSet}: " + id);
      }
    }
    public BlazeRodStrongMutSet EffectBlazeRodStrongMutSetCreate() {
      return TrustedEffectBlazeRodStrongMutSetCreateWithId(NewId());
    }
    public BlazeRodStrongMutSet TrustedEffectBlazeRodStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BlazeRodStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateBlazeRodStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new BlazeRodStrongMutSet(this, id);
    }
    public BlazeRodStrongMutSetCreateEffect InternalEffectCreateBlazeRodStrongMutSet(int id, int incarnationVersion, BlazeRodStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsBlazeRodStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<BlazeRodStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new BlazeRodStrongMutSetCreateEffect(id);
    }
    public void EffectBlazeRodStrongMutSetDelete(int id) {
      var effect = InternalEffectBlazeRodStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public BlazeRodStrongMutSetDeleteEffect InternalEffectBlazeRodStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsBlazeRodStrongMutSet[id];
      rootIncarnation.incarnationsBlazeRodStrongMutSet.Remove(id);
      return new BlazeRodStrongMutSetDeleteEffect(id);
    }

       
    public void EffectBlazeRodStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBlazeRodStrongMutSet(instanceId);
      CheckHasBlazeRod(element);
      var effect = InternalEffectBlazeRodStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public BlazeRodStrongMutSetAddEffect InternalEffectBlazeRodStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBlazeRodStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BlazeRodStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBlazeRodStrongMutSet[instanceId] =
            new VersionAndIncarnation<BlazeRodStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new BlazeRodStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectBlazeRodStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBlazeRodStrongMutSet(instanceId);
      CheckHasBlazeRod(element);
      var effect = InternalEffectBlazeRodStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public BlazeRodStrongMutSetRemoveEffect InternalEffectBlazeRodStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBlazeRodStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BlazeRodStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBlazeRodStrongMutSet[instanceId] =
            new VersionAndIncarnation<BlazeRodStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new BlazeRodStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetBlastRodStrongMutSetHash(int id, int version, BlastRodStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BlastRodStrongMutSetIncarnation GetBlastRodStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBlastRodStrongMutSet[id].incarnation;
    }
    public BlastRodStrongMutSet GetBlastRodStrongMutSet(int id) {
      return new BlastRodStrongMutSet(this, id);
    }
    public List<BlastRodStrongMutSet> AllBlastRodStrongMutSet() {
      List<BlastRodStrongMutSet> result = new List<BlastRodStrongMutSet>(rootIncarnation.incarnationsBlastRodStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBlastRodStrongMutSet.Keys) {
        result.Add(new BlastRodStrongMutSet(this, id));
      }
      return result;
    }
    public bool BlastRodStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsBlastRodStrongMutSet.ContainsKey(id);
    }
    public void CheckHasBlastRodStrongMutSet(BlastRodStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBlastRodStrongMutSet(thing.id);
    }
    public void CheckHasBlastRodStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsBlastRodStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BlastRodStrongMutSet}: " + id);
      }
    }
    public BlastRodStrongMutSet EffectBlastRodStrongMutSetCreate() {
      return TrustedEffectBlastRodStrongMutSetCreateWithId(NewId());
    }
    public BlastRodStrongMutSet TrustedEffectBlastRodStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BlastRodStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateBlastRodStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new BlastRodStrongMutSet(this, id);
    }
    public BlastRodStrongMutSetCreateEffect InternalEffectCreateBlastRodStrongMutSet(int id, int incarnationVersion, BlastRodStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsBlastRodStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<BlastRodStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new BlastRodStrongMutSetCreateEffect(id);
    }
    public void EffectBlastRodStrongMutSetDelete(int id) {
      var effect = InternalEffectBlastRodStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public BlastRodStrongMutSetDeleteEffect InternalEffectBlastRodStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsBlastRodStrongMutSet[id];
      rootIncarnation.incarnationsBlastRodStrongMutSet.Remove(id);
      return new BlastRodStrongMutSetDeleteEffect(id);
    }

       
    public void EffectBlastRodStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBlastRodStrongMutSet(instanceId);
      CheckHasBlastRod(element);
      var effect = InternalEffectBlastRodStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public BlastRodStrongMutSetAddEffect InternalEffectBlastRodStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBlastRodStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BlastRodStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBlastRodStrongMutSet[instanceId] =
            new VersionAndIncarnation<BlastRodStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new BlastRodStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectBlastRodStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBlastRodStrongMutSet(instanceId);
      CheckHasBlastRod(element);
      var effect = InternalEffectBlastRodStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public BlastRodStrongMutSetRemoveEffect InternalEffectBlastRodStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBlastRodStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BlastRodStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBlastRodStrongMutSet[instanceId] =
            new VersionAndIncarnation<BlastRodStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new BlastRodStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetArmorStrongMutSetHash(int id, int version, ArmorStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ArmorStrongMutSetIncarnation GetArmorStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsArmorStrongMutSet[id].incarnation;
    }
    public ArmorStrongMutSet GetArmorStrongMutSet(int id) {
      return new ArmorStrongMutSet(this, id);
    }
    public List<ArmorStrongMutSet> AllArmorStrongMutSet() {
      List<ArmorStrongMutSet> result = new List<ArmorStrongMutSet>(rootIncarnation.incarnationsArmorStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsArmorStrongMutSet.Keys) {
        result.Add(new ArmorStrongMutSet(this, id));
      }
      return result;
    }
    public bool ArmorStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsArmorStrongMutSet.ContainsKey(id);
    }
    public void CheckHasArmorStrongMutSet(ArmorStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasArmorStrongMutSet(thing.id);
    }
    public void CheckHasArmorStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsArmorStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ArmorStrongMutSet}: " + id);
      }
    }
    public ArmorStrongMutSet EffectArmorStrongMutSetCreate() {
      return TrustedEffectArmorStrongMutSetCreateWithId(NewId());
    }
    public ArmorStrongMutSet TrustedEffectArmorStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new ArmorStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateArmorStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new ArmorStrongMutSet(this, id);
    }
    public ArmorStrongMutSetCreateEffect InternalEffectCreateArmorStrongMutSet(int id, int incarnationVersion, ArmorStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsArmorStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<ArmorStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new ArmorStrongMutSetCreateEffect(id);
    }
    public void EffectArmorStrongMutSetDelete(int id) {
      var effect = InternalEffectArmorStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public ArmorStrongMutSetDeleteEffect InternalEffectArmorStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsArmorStrongMutSet[id];
      rootIncarnation.incarnationsArmorStrongMutSet.Remove(id);
      return new ArmorStrongMutSetDeleteEffect(id);
    }

       
    public void EffectArmorStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasArmorStrongMutSet(instanceId);
      CheckHasArmor(element);
      var effect = InternalEffectArmorStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public ArmorStrongMutSetAddEffect InternalEffectArmorStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsArmorStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new ArmorStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsArmorStrongMutSet[instanceId] =
            new VersionAndIncarnation<ArmorStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new ArmorStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectArmorStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasArmorStrongMutSet(instanceId);
      CheckHasArmor(element);
      var effect = InternalEffectArmorStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public ArmorStrongMutSetRemoveEffect InternalEffectArmorStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsArmorStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ArmorStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsArmorStrongMutSet[instanceId] =
            new VersionAndIncarnation<ArmorStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new ArmorStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetHoldPositionImpulseStrongMutSetHash(int id, int version, HoldPositionImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public HoldPositionImpulseStrongMutSetIncarnation GetHoldPositionImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet[id].incarnation;
    }
    public HoldPositionImpulseStrongMutSet GetHoldPositionImpulseStrongMutSet(int id) {
      return new HoldPositionImpulseStrongMutSet(this, id);
    }
    public List<HoldPositionImpulseStrongMutSet> AllHoldPositionImpulseStrongMutSet() {
      List<HoldPositionImpulseStrongMutSet> result = new List<HoldPositionImpulseStrongMutSet>(rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet.Keys) {
        result.Add(new HoldPositionImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool HoldPositionImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasHoldPositionImpulseStrongMutSet(HoldPositionImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasHoldPositionImpulseStrongMutSet(thing.id);
    }
    public void CheckHasHoldPositionImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid HoldPositionImpulseStrongMutSet}: " + id);
      }
    }
    public HoldPositionImpulseStrongMutSet EffectHoldPositionImpulseStrongMutSetCreate() {
      return TrustedEffectHoldPositionImpulseStrongMutSetCreateWithId(NewId());
    }
    public HoldPositionImpulseStrongMutSet TrustedEffectHoldPositionImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new HoldPositionImpulseStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateHoldPositionImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new HoldPositionImpulseStrongMutSet(this, id);
    }
    public HoldPositionImpulseStrongMutSetCreateEffect InternalEffectCreateHoldPositionImpulseStrongMutSet(int id, int incarnationVersion, HoldPositionImpulseStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<HoldPositionImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new HoldPositionImpulseStrongMutSetCreateEffect(id);
    }
    public void EffectHoldPositionImpulseStrongMutSetDelete(int id) {
      var effect = InternalEffectHoldPositionImpulseStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public HoldPositionImpulseStrongMutSetDeleteEffect InternalEffectHoldPositionImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet[id];
      rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet.Remove(id);
      return new HoldPositionImpulseStrongMutSetDeleteEffect(id);
    }

       
    public void EffectHoldPositionImpulseStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasHoldPositionImpulseStrongMutSet(instanceId);
      CheckHasHoldPositionImpulse(element);
      var effect = InternalEffectHoldPositionImpulseStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public HoldPositionImpulseStrongMutSetAddEffect InternalEffectHoldPositionImpulseStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new HoldPositionImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<HoldPositionImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new HoldPositionImpulseStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectHoldPositionImpulseStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasHoldPositionImpulseStrongMutSet(instanceId);
      CheckHasHoldPositionImpulse(element);
      var effect = InternalEffectHoldPositionImpulseStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public HoldPositionImpulseStrongMutSetRemoveEffect InternalEffectHoldPositionImpulseStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new HoldPositionImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsHoldPositionImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<HoldPositionImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new HoldPositionImpulseStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetTemporaryCloneImpulseStrongMutSetHash(int id, int version, TemporaryCloneImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public TemporaryCloneImpulseStrongMutSetIncarnation GetTemporaryCloneImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet[id].incarnation;
    }
    public TemporaryCloneImpulseStrongMutSet GetTemporaryCloneImpulseStrongMutSet(int id) {
      return new TemporaryCloneImpulseStrongMutSet(this, id);
    }
    public List<TemporaryCloneImpulseStrongMutSet> AllTemporaryCloneImpulseStrongMutSet() {
      List<TemporaryCloneImpulseStrongMutSet> result = new List<TemporaryCloneImpulseStrongMutSet>(rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet.Keys) {
        result.Add(new TemporaryCloneImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool TemporaryCloneImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasTemporaryCloneImpulseStrongMutSet(TemporaryCloneImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasTemporaryCloneImpulseStrongMutSet(thing.id);
    }
    public void CheckHasTemporaryCloneImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid TemporaryCloneImpulseStrongMutSet}: " + id);
      }
    }
    public TemporaryCloneImpulseStrongMutSet EffectTemporaryCloneImpulseStrongMutSetCreate() {
      return TrustedEffectTemporaryCloneImpulseStrongMutSetCreateWithId(NewId());
    }
    public TemporaryCloneImpulseStrongMutSet TrustedEffectTemporaryCloneImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new TemporaryCloneImpulseStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateTemporaryCloneImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new TemporaryCloneImpulseStrongMutSet(this, id);
    }
    public TemporaryCloneImpulseStrongMutSetCreateEffect InternalEffectCreateTemporaryCloneImpulseStrongMutSet(int id, int incarnationVersion, TemporaryCloneImpulseStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<TemporaryCloneImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new TemporaryCloneImpulseStrongMutSetCreateEffect(id);
    }
    public void EffectTemporaryCloneImpulseStrongMutSetDelete(int id) {
      var effect = InternalEffectTemporaryCloneImpulseStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public TemporaryCloneImpulseStrongMutSetDeleteEffect InternalEffectTemporaryCloneImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet[id];
      rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet.Remove(id);
      return new TemporaryCloneImpulseStrongMutSetDeleteEffect(id);
    }

       
    public void EffectTemporaryCloneImpulseStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasTemporaryCloneImpulseStrongMutSet(instanceId);
      CheckHasTemporaryCloneImpulse(element);
      var effect = InternalEffectTemporaryCloneImpulseStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public TemporaryCloneImpulseStrongMutSetAddEffect InternalEffectTemporaryCloneImpulseStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new TemporaryCloneImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<TemporaryCloneImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new TemporaryCloneImpulseStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectTemporaryCloneImpulseStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasTemporaryCloneImpulseStrongMutSet(instanceId);
      CheckHasTemporaryCloneImpulse(element);
      var effect = InternalEffectTemporaryCloneImpulseStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public TemporaryCloneImpulseStrongMutSetRemoveEffect InternalEffectTemporaryCloneImpulseStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new TemporaryCloneImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTemporaryCloneImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<TemporaryCloneImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new TemporaryCloneImpulseStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetSummonImpulseStrongMutSetHash(int id, int version, SummonImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public SummonImpulseStrongMutSetIncarnation GetSummonImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsSummonImpulseStrongMutSet[id].incarnation;
    }
    public SummonImpulseStrongMutSet GetSummonImpulseStrongMutSet(int id) {
      return new SummonImpulseStrongMutSet(this, id);
    }
    public List<SummonImpulseStrongMutSet> AllSummonImpulseStrongMutSet() {
      List<SummonImpulseStrongMutSet> result = new List<SummonImpulseStrongMutSet>(rootIncarnation.incarnationsSummonImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsSummonImpulseStrongMutSet.Keys) {
        result.Add(new SummonImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool SummonImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsSummonImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasSummonImpulseStrongMutSet(SummonImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasSummonImpulseStrongMutSet(thing.id);
    }
    public void CheckHasSummonImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsSummonImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid SummonImpulseStrongMutSet}: " + id);
      }
    }
    public SummonImpulseStrongMutSet EffectSummonImpulseStrongMutSetCreate() {
      return TrustedEffectSummonImpulseStrongMutSetCreateWithId(NewId());
    }
    public SummonImpulseStrongMutSet TrustedEffectSummonImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new SummonImpulseStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateSummonImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new SummonImpulseStrongMutSet(this, id);
    }
    public SummonImpulseStrongMutSetCreateEffect InternalEffectCreateSummonImpulseStrongMutSet(int id, int incarnationVersion, SummonImpulseStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsSummonImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<SummonImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new SummonImpulseStrongMutSetCreateEffect(id);
    }
    public void EffectSummonImpulseStrongMutSetDelete(int id) {
      var effect = InternalEffectSummonImpulseStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public SummonImpulseStrongMutSetDeleteEffect InternalEffectSummonImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsSummonImpulseStrongMutSet[id];
      rootIncarnation.incarnationsSummonImpulseStrongMutSet.Remove(id);
      return new SummonImpulseStrongMutSetDeleteEffect(id);
    }

       
    public void EffectSummonImpulseStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasSummonImpulseStrongMutSet(instanceId);
      CheckHasSummonImpulse(element);
      var effect = InternalEffectSummonImpulseStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public SummonImpulseStrongMutSetAddEffect InternalEffectSummonImpulseStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsSummonImpulseStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new SummonImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSummonImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<SummonImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new SummonImpulseStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectSummonImpulseStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasSummonImpulseStrongMutSet(instanceId);
      CheckHasSummonImpulse(element);
      var effect = InternalEffectSummonImpulseStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public SummonImpulseStrongMutSetRemoveEffect InternalEffectSummonImpulseStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsSummonImpulseStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new SummonImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSummonImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<SummonImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new SummonImpulseStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetMireImpulseStrongMutSetHash(int id, int version, MireImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public MireImpulseStrongMutSetIncarnation GetMireImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsMireImpulseStrongMutSet[id].incarnation;
    }
    public MireImpulseStrongMutSet GetMireImpulseStrongMutSet(int id) {
      return new MireImpulseStrongMutSet(this, id);
    }
    public List<MireImpulseStrongMutSet> AllMireImpulseStrongMutSet() {
      List<MireImpulseStrongMutSet> result = new List<MireImpulseStrongMutSet>(rootIncarnation.incarnationsMireImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsMireImpulseStrongMutSet.Keys) {
        result.Add(new MireImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool MireImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsMireImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasMireImpulseStrongMutSet(MireImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasMireImpulseStrongMutSet(thing.id);
    }
    public void CheckHasMireImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsMireImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid MireImpulseStrongMutSet}: " + id);
      }
    }
    public MireImpulseStrongMutSet EffectMireImpulseStrongMutSetCreate() {
      return TrustedEffectMireImpulseStrongMutSetCreateWithId(NewId());
    }
    public MireImpulseStrongMutSet TrustedEffectMireImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new MireImpulseStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateMireImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new MireImpulseStrongMutSet(this, id);
    }
    public MireImpulseStrongMutSetCreateEffect InternalEffectCreateMireImpulseStrongMutSet(int id, int incarnationVersion, MireImpulseStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsMireImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<MireImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new MireImpulseStrongMutSetCreateEffect(id);
    }
    public void EffectMireImpulseStrongMutSetDelete(int id) {
      var effect = InternalEffectMireImpulseStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public MireImpulseStrongMutSetDeleteEffect InternalEffectMireImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsMireImpulseStrongMutSet[id];
      rootIncarnation.incarnationsMireImpulseStrongMutSet.Remove(id);
      return new MireImpulseStrongMutSetDeleteEffect(id);
    }

       
    public void EffectMireImpulseStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasMireImpulseStrongMutSet(instanceId);
      CheckHasMireImpulse(element);
      var effect = InternalEffectMireImpulseStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public MireImpulseStrongMutSetAddEffect InternalEffectMireImpulseStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsMireImpulseStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new MireImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMireImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<MireImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new MireImpulseStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectMireImpulseStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasMireImpulseStrongMutSet(instanceId);
      CheckHasMireImpulse(element);
      var effect = InternalEffectMireImpulseStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public MireImpulseStrongMutSetRemoveEffect InternalEffectMireImpulseStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsMireImpulseStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new MireImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMireImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<MireImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new MireImpulseStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetEvaporateImpulseStrongMutSetHash(int id, int version, EvaporateImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public EvaporateImpulseStrongMutSetIncarnation GetEvaporateImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsEvaporateImpulseStrongMutSet[id].incarnation;
    }
    public EvaporateImpulseStrongMutSet GetEvaporateImpulseStrongMutSet(int id) {
      return new EvaporateImpulseStrongMutSet(this, id);
    }
    public List<EvaporateImpulseStrongMutSet> AllEvaporateImpulseStrongMutSet() {
      List<EvaporateImpulseStrongMutSet> result = new List<EvaporateImpulseStrongMutSet>(rootIncarnation.incarnationsEvaporateImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsEvaporateImpulseStrongMutSet.Keys) {
        result.Add(new EvaporateImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool EvaporateImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsEvaporateImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasEvaporateImpulseStrongMutSet(EvaporateImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasEvaporateImpulseStrongMutSet(thing.id);
    }
    public void CheckHasEvaporateImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsEvaporateImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid EvaporateImpulseStrongMutSet}: " + id);
      }
    }
    public EvaporateImpulseStrongMutSet EffectEvaporateImpulseStrongMutSetCreate() {
      return TrustedEffectEvaporateImpulseStrongMutSetCreateWithId(NewId());
    }
    public EvaporateImpulseStrongMutSet TrustedEffectEvaporateImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new EvaporateImpulseStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateEvaporateImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new EvaporateImpulseStrongMutSet(this, id);
    }
    public EvaporateImpulseStrongMutSetCreateEffect InternalEffectCreateEvaporateImpulseStrongMutSet(int id, int incarnationVersion, EvaporateImpulseStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsEvaporateImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<EvaporateImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new EvaporateImpulseStrongMutSetCreateEffect(id);
    }
    public void EffectEvaporateImpulseStrongMutSetDelete(int id) {
      var effect = InternalEffectEvaporateImpulseStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public EvaporateImpulseStrongMutSetDeleteEffect InternalEffectEvaporateImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsEvaporateImpulseStrongMutSet[id];
      rootIncarnation.incarnationsEvaporateImpulseStrongMutSet.Remove(id);
      return new EvaporateImpulseStrongMutSetDeleteEffect(id);
    }

       
    public void EffectEvaporateImpulseStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasEvaporateImpulseStrongMutSet(instanceId);
      CheckHasEvaporateImpulse(element);
      var effect = InternalEffectEvaporateImpulseStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public EvaporateImpulseStrongMutSetAddEffect InternalEffectEvaporateImpulseStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsEvaporateImpulseStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new EvaporateImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsEvaporateImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<EvaporateImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new EvaporateImpulseStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectEvaporateImpulseStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasEvaporateImpulseStrongMutSet(instanceId);
      CheckHasEvaporateImpulse(element);
      var effect = InternalEffectEvaporateImpulseStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public EvaporateImpulseStrongMutSetRemoveEffect InternalEffectEvaporateImpulseStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsEvaporateImpulseStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new EvaporateImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsEvaporateImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<EvaporateImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new EvaporateImpulseStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetMoveImpulseStrongMutSetHash(int id, int version, MoveImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public MoveImpulseStrongMutSetIncarnation GetMoveImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsMoveImpulseStrongMutSet[id].incarnation;
    }
    public MoveImpulseStrongMutSet GetMoveImpulseStrongMutSet(int id) {
      return new MoveImpulseStrongMutSet(this, id);
    }
    public List<MoveImpulseStrongMutSet> AllMoveImpulseStrongMutSet() {
      List<MoveImpulseStrongMutSet> result = new List<MoveImpulseStrongMutSet>(rootIncarnation.incarnationsMoveImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsMoveImpulseStrongMutSet.Keys) {
        result.Add(new MoveImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool MoveImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsMoveImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasMoveImpulseStrongMutSet(MoveImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasMoveImpulseStrongMutSet(thing.id);
    }
    public void CheckHasMoveImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsMoveImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid MoveImpulseStrongMutSet}: " + id);
      }
    }
    public MoveImpulseStrongMutSet EffectMoveImpulseStrongMutSetCreate() {
      return TrustedEffectMoveImpulseStrongMutSetCreateWithId(NewId());
    }
    public MoveImpulseStrongMutSet TrustedEffectMoveImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new MoveImpulseStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateMoveImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new MoveImpulseStrongMutSet(this, id);
    }
    public MoveImpulseStrongMutSetCreateEffect InternalEffectCreateMoveImpulseStrongMutSet(int id, int incarnationVersion, MoveImpulseStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsMoveImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<MoveImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new MoveImpulseStrongMutSetCreateEffect(id);
    }
    public void EffectMoveImpulseStrongMutSetDelete(int id) {
      var effect = InternalEffectMoveImpulseStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public MoveImpulseStrongMutSetDeleteEffect InternalEffectMoveImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsMoveImpulseStrongMutSet[id];
      rootIncarnation.incarnationsMoveImpulseStrongMutSet.Remove(id);
      return new MoveImpulseStrongMutSetDeleteEffect(id);
    }

       
    public void EffectMoveImpulseStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasMoveImpulseStrongMutSet(instanceId);
      CheckHasMoveImpulse(element);
      var effect = InternalEffectMoveImpulseStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public MoveImpulseStrongMutSetAddEffect InternalEffectMoveImpulseStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsMoveImpulseStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new MoveImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMoveImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<MoveImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new MoveImpulseStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectMoveImpulseStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasMoveImpulseStrongMutSet(instanceId);
      CheckHasMoveImpulse(element);
      var effect = InternalEffectMoveImpulseStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public MoveImpulseStrongMutSetRemoveEffect InternalEffectMoveImpulseStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsMoveImpulseStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new MoveImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMoveImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<MoveImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new MoveImpulseStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetKamikazeJumpImpulseStrongMutSetHash(int id, int version, KamikazeJumpImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public KamikazeJumpImpulseStrongMutSetIncarnation GetKamikazeJumpImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet[id].incarnation;
    }
    public KamikazeJumpImpulseStrongMutSet GetKamikazeJumpImpulseStrongMutSet(int id) {
      return new KamikazeJumpImpulseStrongMutSet(this, id);
    }
    public List<KamikazeJumpImpulseStrongMutSet> AllKamikazeJumpImpulseStrongMutSet() {
      List<KamikazeJumpImpulseStrongMutSet> result = new List<KamikazeJumpImpulseStrongMutSet>(rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet.Keys) {
        result.Add(new KamikazeJumpImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool KamikazeJumpImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasKamikazeJumpImpulseStrongMutSet(KamikazeJumpImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasKamikazeJumpImpulseStrongMutSet(thing.id);
    }
    public void CheckHasKamikazeJumpImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid KamikazeJumpImpulseStrongMutSet}: " + id);
      }
    }
    public KamikazeJumpImpulseStrongMutSet EffectKamikazeJumpImpulseStrongMutSetCreate() {
      return TrustedEffectKamikazeJumpImpulseStrongMutSetCreateWithId(NewId());
    }
    public KamikazeJumpImpulseStrongMutSet TrustedEffectKamikazeJumpImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new KamikazeJumpImpulseStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateKamikazeJumpImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new KamikazeJumpImpulseStrongMutSet(this, id);
    }
    public KamikazeJumpImpulseStrongMutSetCreateEffect InternalEffectCreateKamikazeJumpImpulseStrongMutSet(int id, int incarnationVersion, KamikazeJumpImpulseStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<KamikazeJumpImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new KamikazeJumpImpulseStrongMutSetCreateEffect(id);
    }
    public void EffectKamikazeJumpImpulseStrongMutSetDelete(int id) {
      var effect = InternalEffectKamikazeJumpImpulseStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public KamikazeJumpImpulseStrongMutSetDeleteEffect InternalEffectKamikazeJumpImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet[id];
      rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet.Remove(id);
      return new KamikazeJumpImpulseStrongMutSetDeleteEffect(id);
    }

       
    public void EffectKamikazeJumpImpulseStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasKamikazeJumpImpulseStrongMutSet(instanceId);
      CheckHasKamikazeJumpImpulse(element);
      var effect = InternalEffectKamikazeJumpImpulseStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public KamikazeJumpImpulseStrongMutSetAddEffect InternalEffectKamikazeJumpImpulseStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new KamikazeJumpImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<KamikazeJumpImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new KamikazeJumpImpulseStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectKamikazeJumpImpulseStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasKamikazeJumpImpulseStrongMutSet(instanceId);
      CheckHasKamikazeJumpImpulse(element);
      var effect = InternalEffectKamikazeJumpImpulseStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public KamikazeJumpImpulseStrongMutSetRemoveEffect InternalEffectKamikazeJumpImpulseStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new KamikazeJumpImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsKamikazeJumpImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<KamikazeJumpImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new KamikazeJumpImpulseStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetKamikazeTargetImpulseStrongMutSetHash(int id, int version, KamikazeTargetImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public KamikazeTargetImpulseStrongMutSetIncarnation GetKamikazeTargetImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet[id].incarnation;
    }
    public KamikazeTargetImpulseStrongMutSet GetKamikazeTargetImpulseStrongMutSet(int id) {
      return new KamikazeTargetImpulseStrongMutSet(this, id);
    }
    public List<KamikazeTargetImpulseStrongMutSet> AllKamikazeTargetImpulseStrongMutSet() {
      List<KamikazeTargetImpulseStrongMutSet> result = new List<KamikazeTargetImpulseStrongMutSet>(rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet.Keys) {
        result.Add(new KamikazeTargetImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool KamikazeTargetImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasKamikazeTargetImpulseStrongMutSet(KamikazeTargetImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasKamikazeTargetImpulseStrongMutSet(thing.id);
    }
    public void CheckHasKamikazeTargetImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid KamikazeTargetImpulseStrongMutSet}: " + id);
      }
    }
    public KamikazeTargetImpulseStrongMutSet EffectKamikazeTargetImpulseStrongMutSetCreate() {
      return TrustedEffectKamikazeTargetImpulseStrongMutSetCreateWithId(NewId());
    }
    public KamikazeTargetImpulseStrongMutSet TrustedEffectKamikazeTargetImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new KamikazeTargetImpulseStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateKamikazeTargetImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new KamikazeTargetImpulseStrongMutSet(this, id);
    }
    public KamikazeTargetImpulseStrongMutSetCreateEffect InternalEffectCreateKamikazeTargetImpulseStrongMutSet(int id, int incarnationVersion, KamikazeTargetImpulseStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<KamikazeTargetImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new KamikazeTargetImpulseStrongMutSetCreateEffect(id);
    }
    public void EffectKamikazeTargetImpulseStrongMutSetDelete(int id) {
      var effect = InternalEffectKamikazeTargetImpulseStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public KamikazeTargetImpulseStrongMutSetDeleteEffect InternalEffectKamikazeTargetImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet[id];
      rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet.Remove(id);
      return new KamikazeTargetImpulseStrongMutSetDeleteEffect(id);
    }

       
    public void EffectKamikazeTargetImpulseStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasKamikazeTargetImpulseStrongMutSet(instanceId);
      CheckHasKamikazeTargetImpulse(element);
      var effect = InternalEffectKamikazeTargetImpulseStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public KamikazeTargetImpulseStrongMutSetAddEffect InternalEffectKamikazeTargetImpulseStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new KamikazeTargetImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<KamikazeTargetImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new KamikazeTargetImpulseStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectKamikazeTargetImpulseStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasKamikazeTargetImpulseStrongMutSet(instanceId);
      CheckHasKamikazeTargetImpulse(element);
      var effect = InternalEffectKamikazeTargetImpulseStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public KamikazeTargetImpulseStrongMutSetRemoveEffect InternalEffectKamikazeTargetImpulseStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new KamikazeTargetImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsKamikazeTargetImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<KamikazeTargetImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new KamikazeTargetImpulseStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetNoImpulseStrongMutSetHash(int id, int version, NoImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public NoImpulseStrongMutSetIncarnation GetNoImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsNoImpulseStrongMutSet[id].incarnation;
    }
    public NoImpulseStrongMutSet GetNoImpulseStrongMutSet(int id) {
      return new NoImpulseStrongMutSet(this, id);
    }
    public List<NoImpulseStrongMutSet> AllNoImpulseStrongMutSet() {
      List<NoImpulseStrongMutSet> result = new List<NoImpulseStrongMutSet>(rootIncarnation.incarnationsNoImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsNoImpulseStrongMutSet.Keys) {
        result.Add(new NoImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool NoImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsNoImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasNoImpulseStrongMutSet(NoImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasNoImpulseStrongMutSet(thing.id);
    }
    public void CheckHasNoImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsNoImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid NoImpulseStrongMutSet}: " + id);
      }
    }
    public NoImpulseStrongMutSet EffectNoImpulseStrongMutSetCreate() {
      return TrustedEffectNoImpulseStrongMutSetCreateWithId(NewId());
    }
    public NoImpulseStrongMutSet TrustedEffectNoImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new NoImpulseStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateNoImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new NoImpulseStrongMutSet(this, id);
    }
    public NoImpulseStrongMutSetCreateEffect InternalEffectCreateNoImpulseStrongMutSet(int id, int incarnationVersion, NoImpulseStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsNoImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<NoImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new NoImpulseStrongMutSetCreateEffect(id);
    }
    public void EffectNoImpulseStrongMutSetDelete(int id) {
      var effect = InternalEffectNoImpulseStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public NoImpulseStrongMutSetDeleteEffect InternalEffectNoImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsNoImpulseStrongMutSet[id];
      rootIncarnation.incarnationsNoImpulseStrongMutSet.Remove(id);
      return new NoImpulseStrongMutSetDeleteEffect(id);
    }

       
    public void EffectNoImpulseStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasNoImpulseStrongMutSet(instanceId);
      CheckHasNoImpulse(element);
      var effect = InternalEffectNoImpulseStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public NoImpulseStrongMutSetAddEffect InternalEffectNoImpulseStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsNoImpulseStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new NoImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsNoImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<NoImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new NoImpulseStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectNoImpulseStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasNoImpulseStrongMutSet(instanceId);
      CheckHasNoImpulse(element);
      var effect = InternalEffectNoImpulseStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public NoImpulseStrongMutSetRemoveEffect InternalEffectNoImpulseStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsNoImpulseStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new NoImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsNoImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<NoImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new NoImpulseStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetEvolvifyImpulseStrongMutSetHash(int id, int version, EvolvifyImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public EvolvifyImpulseStrongMutSetIncarnation GetEvolvifyImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsEvolvifyImpulseStrongMutSet[id].incarnation;
    }
    public EvolvifyImpulseStrongMutSet GetEvolvifyImpulseStrongMutSet(int id) {
      return new EvolvifyImpulseStrongMutSet(this, id);
    }
    public List<EvolvifyImpulseStrongMutSet> AllEvolvifyImpulseStrongMutSet() {
      List<EvolvifyImpulseStrongMutSet> result = new List<EvolvifyImpulseStrongMutSet>(rootIncarnation.incarnationsEvolvifyImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsEvolvifyImpulseStrongMutSet.Keys) {
        result.Add(new EvolvifyImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool EvolvifyImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsEvolvifyImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasEvolvifyImpulseStrongMutSet(EvolvifyImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasEvolvifyImpulseStrongMutSet(thing.id);
    }
    public void CheckHasEvolvifyImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsEvolvifyImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid EvolvifyImpulseStrongMutSet}: " + id);
      }
    }
    public EvolvifyImpulseStrongMutSet EffectEvolvifyImpulseStrongMutSetCreate() {
      return TrustedEffectEvolvifyImpulseStrongMutSetCreateWithId(NewId());
    }
    public EvolvifyImpulseStrongMutSet TrustedEffectEvolvifyImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new EvolvifyImpulseStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateEvolvifyImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new EvolvifyImpulseStrongMutSet(this, id);
    }
    public EvolvifyImpulseStrongMutSetCreateEffect InternalEffectCreateEvolvifyImpulseStrongMutSet(int id, int incarnationVersion, EvolvifyImpulseStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsEvolvifyImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<EvolvifyImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new EvolvifyImpulseStrongMutSetCreateEffect(id);
    }
    public void EffectEvolvifyImpulseStrongMutSetDelete(int id) {
      var effect = InternalEffectEvolvifyImpulseStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public EvolvifyImpulseStrongMutSetDeleteEffect InternalEffectEvolvifyImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsEvolvifyImpulseStrongMutSet[id];
      rootIncarnation.incarnationsEvolvifyImpulseStrongMutSet.Remove(id);
      return new EvolvifyImpulseStrongMutSetDeleteEffect(id);
    }

       
    public void EffectEvolvifyImpulseStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasEvolvifyImpulseStrongMutSet(instanceId);
      CheckHasEvolvifyImpulse(element);
      var effect = InternalEffectEvolvifyImpulseStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public EvolvifyImpulseStrongMutSetAddEffect InternalEffectEvolvifyImpulseStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsEvolvifyImpulseStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new EvolvifyImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsEvolvifyImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<EvolvifyImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new EvolvifyImpulseStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectEvolvifyImpulseStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasEvolvifyImpulseStrongMutSet(instanceId);
      CheckHasEvolvifyImpulse(element);
      var effect = InternalEffectEvolvifyImpulseStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public EvolvifyImpulseStrongMutSetRemoveEffect InternalEffectEvolvifyImpulseStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsEvolvifyImpulseStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new EvolvifyImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsEvolvifyImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<EvolvifyImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new EvolvifyImpulseStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetFireImpulseStrongMutSetHash(int id, int version, FireImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public FireImpulseStrongMutSetIncarnation GetFireImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsFireImpulseStrongMutSet[id].incarnation;
    }
    public FireImpulseStrongMutSet GetFireImpulseStrongMutSet(int id) {
      return new FireImpulseStrongMutSet(this, id);
    }
    public List<FireImpulseStrongMutSet> AllFireImpulseStrongMutSet() {
      List<FireImpulseStrongMutSet> result = new List<FireImpulseStrongMutSet>(rootIncarnation.incarnationsFireImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsFireImpulseStrongMutSet.Keys) {
        result.Add(new FireImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool FireImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsFireImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasFireImpulseStrongMutSet(FireImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasFireImpulseStrongMutSet(thing.id);
    }
    public void CheckHasFireImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsFireImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid FireImpulseStrongMutSet}: " + id);
      }
    }
    public FireImpulseStrongMutSet EffectFireImpulseStrongMutSetCreate() {
      return TrustedEffectFireImpulseStrongMutSetCreateWithId(NewId());
    }
    public FireImpulseStrongMutSet TrustedEffectFireImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new FireImpulseStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateFireImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new FireImpulseStrongMutSet(this, id);
    }
    public FireImpulseStrongMutSetCreateEffect InternalEffectCreateFireImpulseStrongMutSet(int id, int incarnationVersion, FireImpulseStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsFireImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<FireImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new FireImpulseStrongMutSetCreateEffect(id);
    }
    public void EffectFireImpulseStrongMutSetDelete(int id) {
      var effect = InternalEffectFireImpulseStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public FireImpulseStrongMutSetDeleteEffect InternalEffectFireImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsFireImpulseStrongMutSet[id];
      rootIncarnation.incarnationsFireImpulseStrongMutSet.Remove(id);
      return new FireImpulseStrongMutSetDeleteEffect(id);
    }

       
    public void EffectFireImpulseStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasFireImpulseStrongMutSet(instanceId);
      CheckHasFireImpulse(element);
      var effect = InternalEffectFireImpulseStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public FireImpulseStrongMutSetAddEffect InternalEffectFireImpulseStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsFireImpulseStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new FireImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFireImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<FireImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new FireImpulseStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectFireImpulseStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasFireImpulseStrongMutSet(instanceId);
      CheckHasFireImpulse(element);
      var effect = InternalEffectFireImpulseStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public FireImpulseStrongMutSetRemoveEffect InternalEffectFireImpulseStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsFireImpulseStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new FireImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFireImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<FireImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new FireImpulseStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetDefyImpulseStrongMutSetHash(int id, int version, DefyImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public DefyImpulseStrongMutSetIncarnation GetDefyImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsDefyImpulseStrongMutSet[id].incarnation;
    }
    public DefyImpulseStrongMutSet GetDefyImpulseStrongMutSet(int id) {
      return new DefyImpulseStrongMutSet(this, id);
    }
    public List<DefyImpulseStrongMutSet> AllDefyImpulseStrongMutSet() {
      List<DefyImpulseStrongMutSet> result = new List<DefyImpulseStrongMutSet>(rootIncarnation.incarnationsDefyImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsDefyImpulseStrongMutSet.Keys) {
        result.Add(new DefyImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool DefyImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsDefyImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasDefyImpulseStrongMutSet(DefyImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasDefyImpulseStrongMutSet(thing.id);
    }
    public void CheckHasDefyImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsDefyImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid DefyImpulseStrongMutSet}: " + id);
      }
    }
    public DefyImpulseStrongMutSet EffectDefyImpulseStrongMutSetCreate() {
      return TrustedEffectDefyImpulseStrongMutSetCreateWithId(NewId());
    }
    public DefyImpulseStrongMutSet TrustedEffectDefyImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new DefyImpulseStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateDefyImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new DefyImpulseStrongMutSet(this, id);
    }
    public DefyImpulseStrongMutSetCreateEffect InternalEffectCreateDefyImpulseStrongMutSet(int id, int incarnationVersion, DefyImpulseStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsDefyImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<DefyImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new DefyImpulseStrongMutSetCreateEffect(id);
    }
    public void EffectDefyImpulseStrongMutSetDelete(int id) {
      var effect = InternalEffectDefyImpulseStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public DefyImpulseStrongMutSetDeleteEffect InternalEffectDefyImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsDefyImpulseStrongMutSet[id];
      rootIncarnation.incarnationsDefyImpulseStrongMutSet.Remove(id);
      return new DefyImpulseStrongMutSetDeleteEffect(id);
    }

       
    public void EffectDefyImpulseStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasDefyImpulseStrongMutSet(instanceId);
      CheckHasDefyImpulse(element);
      var effect = InternalEffectDefyImpulseStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public DefyImpulseStrongMutSetAddEffect InternalEffectDefyImpulseStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsDefyImpulseStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new DefyImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDefyImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<DefyImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new DefyImpulseStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectDefyImpulseStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasDefyImpulseStrongMutSet(instanceId);
      CheckHasDefyImpulse(element);
      var effect = InternalEffectDefyImpulseStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public DefyImpulseStrongMutSetRemoveEffect InternalEffectDefyImpulseStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsDefyImpulseStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new DefyImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDefyImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<DefyImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new DefyImpulseStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetCounterImpulseStrongMutSetHash(int id, int version, CounterImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CounterImpulseStrongMutSetIncarnation GetCounterImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsCounterImpulseStrongMutSet[id].incarnation;
    }
    public CounterImpulseStrongMutSet GetCounterImpulseStrongMutSet(int id) {
      return new CounterImpulseStrongMutSet(this, id);
    }
    public List<CounterImpulseStrongMutSet> AllCounterImpulseStrongMutSet() {
      List<CounterImpulseStrongMutSet> result = new List<CounterImpulseStrongMutSet>(rootIncarnation.incarnationsCounterImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsCounterImpulseStrongMutSet.Keys) {
        result.Add(new CounterImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool CounterImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsCounterImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasCounterImpulseStrongMutSet(CounterImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCounterImpulseStrongMutSet(thing.id);
    }
    public void CheckHasCounterImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsCounterImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid CounterImpulseStrongMutSet}: " + id);
      }
    }
    public CounterImpulseStrongMutSet EffectCounterImpulseStrongMutSetCreate() {
      return TrustedEffectCounterImpulseStrongMutSetCreateWithId(NewId());
    }
    public CounterImpulseStrongMutSet TrustedEffectCounterImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new CounterImpulseStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateCounterImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new CounterImpulseStrongMutSet(this, id);
    }
    public CounterImpulseStrongMutSetCreateEffect InternalEffectCreateCounterImpulseStrongMutSet(int id, int incarnationVersion, CounterImpulseStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsCounterImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<CounterImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new CounterImpulseStrongMutSetCreateEffect(id);
    }
    public void EffectCounterImpulseStrongMutSetDelete(int id) {
      var effect = InternalEffectCounterImpulseStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public CounterImpulseStrongMutSetDeleteEffect InternalEffectCounterImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsCounterImpulseStrongMutSet[id];
      rootIncarnation.incarnationsCounterImpulseStrongMutSet.Remove(id);
      return new CounterImpulseStrongMutSetDeleteEffect(id);
    }

       
    public void EffectCounterImpulseStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasCounterImpulseStrongMutSet(instanceId);
      CheckHasCounterImpulse(element);
      var effect = InternalEffectCounterImpulseStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public CounterImpulseStrongMutSetAddEffect InternalEffectCounterImpulseStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsCounterImpulseStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new CounterImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCounterImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<CounterImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new CounterImpulseStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectCounterImpulseStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasCounterImpulseStrongMutSet(instanceId);
      CheckHasCounterImpulse(element);
      var effect = InternalEffectCounterImpulseStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public CounterImpulseStrongMutSetRemoveEffect InternalEffectCounterImpulseStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsCounterImpulseStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new CounterImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCounterImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<CounterImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new CounterImpulseStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetUnleashBideImpulseStrongMutSetHash(int id, int version, UnleashBideImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public UnleashBideImpulseStrongMutSetIncarnation GetUnleashBideImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet[id].incarnation;
    }
    public UnleashBideImpulseStrongMutSet GetUnleashBideImpulseStrongMutSet(int id) {
      return new UnleashBideImpulseStrongMutSet(this, id);
    }
    public List<UnleashBideImpulseStrongMutSet> AllUnleashBideImpulseStrongMutSet() {
      List<UnleashBideImpulseStrongMutSet> result = new List<UnleashBideImpulseStrongMutSet>(rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet.Keys) {
        result.Add(new UnleashBideImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool UnleashBideImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasUnleashBideImpulseStrongMutSet(UnleashBideImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasUnleashBideImpulseStrongMutSet(thing.id);
    }
    public void CheckHasUnleashBideImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid UnleashBideImpulseStrongMutSet}: " + id);
      }
    }
    public UnleashBideImpulseStrongMutSet EffectUnleashBideImpulseStrongMutSetCreate() {
      return TrustedEffectUnleashBideImpulseStrongMutSetCreateWithId(NewId());
    }
    public UnleashBideImpulseStrongMutSet TrustedEffectUnleashBideImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new UnleashBideImpulseStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateUnleashBideImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new UnleashBideImpulseStrongMutSet(this, id);
    }
    public UnleashBideImpulseStrongMutSetCreateEffect InternalEffectCreateUnleashBideImpulseStrongMutSet(int id, int incarnationVersion, UnleashBideImpulseStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<UnleashBideImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new UnleashBideImpulseStrongMutSetCreateEffect(id);
    }
    public void EffectUnleashBideImpulseStrongMutSetDelete(int id) {
      var effect = InternalEffectUnleashBideImpulseStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public UnleashBideImpulseStrongMutSetDeleteEffect InternalEffectUnleashBideImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet[id];
      rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet.Remove(id);
      return new UnleashBideImpulseStrongMutSetDeleteEffect(id);
    }

       
    public void EffectUnleashBideImpulseStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasUnleashBideImpulseStrongMutSet(instanceId);
      CheckHasUnleashBideImpulse(element);
      var effect = InternalEffectUnleashBideImpulseStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public UnleashBideImpulseStrongMutSetAddEffect InternalEffectUnleashBideImpulseStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new UnleashBideImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<UnleashBideImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new UnleashBideImpulseStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectUnleashBideImpulseStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasUnleashBideImpulseStrongMutSet(instanceId);
      CheckHasUnleashBideImpulse(element);
      var effect = InternalEffectUnleashBideImpulseStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public UnleashBideImpulseStrongMutSetRemoveEffect InternalEffectUnleashBideImpulseStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new UnleashBideImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsUnleashBideImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<UnleashBideImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new UnleashBideImpulseStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetContinueBidingImpulseStrongMutSetHash(int id, int version, ContinueBidingImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ContinueBidingImpulseStrongMutSetIncarnation GetContinueBidingImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet[id].incarnation;
    }
    public ContinueBidingImpulseStrongMutSet GetContinueBidingImpulseStrongMutSet(int id) {
      return new ContinueBidingImpulseStrongMutSet(this, id);
    }
    public List<ContinueBidingImpulseStrongMutSet> AllContinueBidingImpulseStrongMutSet() {
      List<ContinueBidingImpulseStrongMutSet> result = new List<ContinueBidingImpulseStrongMutSet>(rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet.Keys) {
        result.Add(new ContinueBidingImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool ContinueBidingImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasContinueBidingImpulseStrongMutSet(ContinueBidingImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasContinueBidingImpulseStrongMutSet(thing.id);
    }
    public void CheckHasContinueBidingImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ContinueBidingImpulseStrongMutSet}: " + id);
      }
    }
    public ContinueBidingImpulseStrongMutSet EffectContinueBidingImpulseStrongMutSetCreate() {
      return TrustedEffectContinueBidingImpulseStrongMutSetCreateWithId(NewId());
    }
    public ContinueBidingImpulseStrongMutSet TrustedEffectContinueBidingImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new ContinueBidingImpulseStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateContinueBidingImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new ContinueBidingImpulseStrongMutSet(this, id);
    }
    public ContinueBidingImpulseStrongMutSetCreateEffect InternalEffectCreateContinueBidingImpulseStrongMutSet(int id, int incarnationVersion, ContinueBidingImpulseStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<ContinueBidingImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new ContinueBidingImpulseStrongMutSetCreateEffect(id);
    }
    public void EffectContinueBidingImpulseStrongMutSetDelete(int id) {
      var effect = InternalEffectContinueBidingImpulseStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public ContinueBidingImpulseStrongMutSetDeleteEffect InternalEffectContinueBidingImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet[id];
      rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet.Remove(id);
      return new ContinueBidingImpulseStrongMutSetDeleteEffect(id);
    }

       
    public void EffectContinueBidingImpulseStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasContinueBidingImpulseStrongMutSet(instanceId);
      CheckHasContinueBidingImpulse(element);
      var effect = InternalEffectContinueBidingImpulseStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public ContinueBidingImpulseStrongMutSetAddEffect InternalEffectContinueBidingImpulseStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new ContinueBidingImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<ContinueBidingImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new ContinueBidingImpulseStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectContinueBidingImpulseStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasContinueBidingImpulseStrongMutSet(instanceId);
      CheckHasContinueBidingImpulse(element);
      var effect = InternalEffectContinueBidingImpulseStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public ContinueBidingImpulseStrongMutSetRemoveEffect InternalEffectContinueBidingImpulseStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ContinueBidingImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsContinueBidingImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<ContinueBidingImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new ContinueBidingImpulseStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetStartBidingImpulseStrongMutSetHash(int id, int version, StartBidingImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public StartBidingImpulseStrongMutSetIncarnation GetStartBidingImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsStartBidingImpulseStrongMutSet[id].incarnation;
    }
    public StartBidingImpulseStrongMutSet GetStartBidingImpulseStrongMutSet(int id) {
      return new StartBidingImpulseStrongMutSet(this, id);
    }
    public List<StartBidingImpulseStrongMutSet> AllStartBidingImpulseStrongMutSet() {
      List<StartBidingImpulseStrongMutSet> result = new List<StartBidingImpulseStrongMutSet>(rootIncarnation.incarnationsStartBidingImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsStartBidingImpulseStrongMutSet.Keys) {
        result.Add(new StartBidingImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool StartBidingImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsStartBidingImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasStartBidingImpulseStrongMutSet(StartBidingImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasStartBidingImpulseStrongMutSet(thing.id);
    }
    public void CheckHasStartBidingImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsStartBidingImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid StartBidingImpulseStrongMutSet}: " + id);
      }
    }
    public StartBidingImpulseStrongMutSet EffectStartBidingImpulseStrongMutSetCreate() {
      return TrustedEffectStartBidingImpulseStrongMutSetCreateWithId(NewId());
    }
    public StartBidingImpulseStrongMutSet TrustedEffectStartBidingImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new StartBidingImpulseStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateStartBidingImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new StartBidingImpulseStrongMutSet(this, id);
    }
    public StartBidingImpulseStrongMutSetCreateEffect InternalEffectCreateStartBidingImpulseStrongMutSet(int id, int incarnationVersion, StartBidingImpulseStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsStartBidingImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<StartBidingImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new StartBidingImpulseStrongMutSetCreateEffect(id);
    }
    public void EffectStartBidingImpulseStrongMutSetDelete(int id) {
      var effect = InternalEffectStartBidingImpulseStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public StartBidingImpulseStrongMutSetDeleteEffect InternalEffectStartBidingImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsStartBidingImpulseStrongMutSet[id];
      rootIncarnation.incarnationsStartBidingImpulseStrongMutSet.Remove(id);
      return new StartBidingImpulseStrongMutSetDeleteEffect(id);
    }

       
    public void EffectStartBidingImpulseStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasStartBidingImpulseStrongMutSet(instanceId);
      CheckHasStartBidingImpulse(element);
      var effect = InternalEffectStartBidingImpulseStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public StartBidingImpulseStrongMutSetAddEffect InternalEffectStartBidingImpulseStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsStartBidingImpulseStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new StartBidingImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsStartBidingImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<StartBidingImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new StartBidingImpulseStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectStartBidingImpulseStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasStartBidingImpulseStrongMutSet(instanceId);
      CheckHasStartBidingImpulse(element);
      var effect = InternalEffectStartBidingImpulseStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public StartBidingImpulseStrongMutSetRemoveEffect InternalEffectStartBidingImpulseStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsStartBidingImpulseStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new StartBidingImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsStartBidingImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<StartBidingImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new StartBidingImpulseStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetAttackImpulseStrongMutSetHash(int id, int version, AttackImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public AttackImpulseStrongMutSetIncarnation GetAttackImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsAttackImpulseStrongMutSet[id].incarnation;
    }
    public AttackImpulseStrongMutSet GetAttackImpulseStrongMutSet(int id) {
      return new AttackImpulseStrongMutSet(this, id);
    }
    public List<AttackImpulseStrongMutSet> AllAttackImpulseStrongMutSet() {
      List<AttackImpulseStrongMutSet> result = new List<AttackImpulseStrongMutSet>(rootIncarnation.incarnationsAttackImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsAttackImpulseStrongMutSet.Keys) {
        result.Add(new AttackImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool AttackImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsAttackImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasAttackImpulseStrongMutSet(AttackImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasAttackImpulseStrongMutSet(thing.id);
    }
    public void CheckHasAttackImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsAttackImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid AttackImpulseStrongMutSet}: " + id);
      }
    }
    public AttackImpulseStrongMutSet EffectAttackImpulseStrongMutSetCreate() {
      return TrustedEffectAttackImpulseStrongMutSetCreateWithId(NewId());
    }
    public AttackImpulseStrongMutSet TrustedEffectAttackImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new AttackImpulseStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateAttackImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new AttackImpulseStrongMutSet(this, id);
    }
    public AttackImpulseStrongMutSetCreateEffect InternalEffectCreateAttackImpulseStrongMutSet(int id, int incarnationVersion, AttackImpulseStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsAttackImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<AttackImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new AttackImpulseStrongMutSetCreateEffect(id);
    }
    public void EffectAttackImpulseStrongMutSetDelete(int id) {
      var effect = InternalEffectAttackImpulseStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public AttackImpulseStrongMutSetDeleteEffect InternalEffectAttackImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsAttackImpulseStrongMutSet[id];
      rootIncarnation.incarnationsAttackImpulseStrongMutSet.Remove(id);
      return new AttackImpulseStrongMutSetDeleteEffect(id);
    }

       
    public void EffectAttackImpulseStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasAttackImpulseStrongMutSet(instanceId);
      CheckHasAttackImpulse(element);
      var effect = InternalEffectAttackImpulseStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public AttackImpulseStrongMutSetAddEffect InternalEffectAttackImpulseStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsAttackImpulseStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new AttackImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsAttackImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<AttackImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new AttackImpulseStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectAttackImpulseStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasAttackImpulseStrongMutSet(instanceId);
      CheckHasAttackImpulse(element);
      var effect = InternalEffectAttackImpulseStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public AttackImpulseStrongMutSetRemoveEffect InternalEffectAttackImpulseStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsAttackImpulseStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new AttackImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsAttackImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<AttackImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new AttackImpulseStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetPursueImpulseStrongMutSetHash(int id, int version, PursueImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public PursueImpulseStrongMutSetIncarnation GetPursueImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsPursueImpulseStrongMutSet[id].incarnation;
    }
    public PursueImpulseStrongMutSet GetPursueImpulseStrongMutSet(int id) {
      return new PursueImpulseStrongMutSet(this, id);
    }
    public List<PursueImpulseStrongMutSet> AllPursueImpulseStrongMutSet() {
      List<PursueImpulseStrongMutSet> result = new List<PursueImpulseStrongMutSet>(rootIncarnation.incarnationsPursueImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsPursueImpulseStrongMutSet.Keys) {
        result.Add(new PursueImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool PursueImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsPursueImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasPursueImpulseStrongMutSet(PursueImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasPursueImpulseStrongMutSet(thing.id);
    }
    public void CheckHasPursueImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsPursueImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid PursueImpulseStrongMutSet}: " + id);
      }
    }
    public PursueImpulseStrongMutSet EffectPursueImpulseStrongMutSetCreate() {
      return TrustedEffectPursueImpulseStrongMutSetCreateWithId(NewId());
    }
    public PursueImpulseStrongMutSet TrustedEffectPursueImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new PursueImpulseStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreatePursueImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new PursueImpulseStrongMutSet(this, id);
    }
    public PursueImpulseStrongMutSetCreateEffect InternalEffectCreatePursueImpulseStrongMutSet(int id, int incarnationVersion, PursueImpulseStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsPursueImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<PursueImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new PursueImpulseStrongMutSetCreateEffect(id);
    }
    public void EffectPursueImpulseStrongMutSetDelete(int id) {
      var effect = InternalEffectPursueImpulseStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public PursueImpulseStrongMutSetDeleteEffect InternalEffectPursueImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsPursueImpulseStrongMutSet[id];
      rootIncarnation.incarnationsPursueImpulseStrongMutSet.Remove(id);
      return new PursueImpulseStrongMutSetDeleteEffect(id);
    }

       
    public void EffectPursueImpulseStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasPursueImpulseStrongMutSet(instanceId);
      CheckHasPursueImpulse(element);
      var effect = InternalEffectPursueImpulseStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public PursueImpulseStrongMutSetAddEffect InternalEffectPursueImpulseStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsPursueImpulseStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new PursueImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsPursueImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<PursueImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new PursueImpulseStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectPursueImpulseStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasPursueImpulseStrongMutSet(instanceId);
      CheckHasPursueImpulse(element);
      var effect = InternalEffectPursueImpulseStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public PursueImpulseStrongMutSetRemoveEffect InternalEffectPursueImpulseStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsPursueImpulseStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new PursueImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsPursueImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<PursueImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new PursueImpulseStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetFireBombImpulseStrongMutSetHash(int id, int version, FireBombImpulseStrongMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public FireBombImpulseStrongMutSetIncarnation GetFireBombImpulseStrongMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsFireBombImpulseStrongMutSet[id].incarnation;
    }
    public FireBombImpulseStrongMutSet GetFireBombImpulseStrongMutSet(int id) {
      return new FireBombImpulseStrongMutSet(this, id);
    }
    public List<FireBombImpulseStrongMutSet> AllFireBombImpulseStrongMutSet() {
      List<FireBombImpulseStrongMutSet> result = new List<FireBombImpulseStrongMutSet>(rootIncarnation.incarnationsFireBombImpulseStrongMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsFireBombImpulseStrongMutSet.Keys) {
        result.Add(new FireBombImpulseStrongMutSet(this, id));
      }
      return result;
    }
    public bool FireBombImpulseStrongMutSetExists(int id) {
      return rootIncarnation.incarnationsFireBombImpulseStrongMutSet.ContainsKey(id);
    }
    public void CheckHasFireBombImpulseStrongMutSet(FireBombImpulseStrongMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasFireBombImpulseStrongMutSet(thing.id);
    }
    public void CheckHasFireBombImpulseStrongMutSet(int id) {
      if (!rootIncarnation.incarnationsFireBombImpulseStrongMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid FireBombImpulseStrongMutSet}: " + id);
      }
    }
    public FireBombImpulseStrongMutSet EffectFireBombImpulseStrongMutSetCreate() {
      return TrustedEffectFireBombImpulseStrongMutSetCreateWithId(NewId());
    }
    public FireBombImpulseStrongMutSet TrustedEffectFireBombImpulseStrongMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new FireBombImpulseStrongMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateFireBombImpulseStrongMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new FireBombImpulseStrongMutSet(this, id);
    }
    public FireBombImpulseStrongMutSetCreateEffect InternalEffectCreateFireBombImpulseStrongMutSet(int id, int incarnationVersion, FireBombImpulseStrongMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsFireBombImpulseStrongMutSet
          .Add(
              id,
              new VersionAndIncarnation<FireBombImpulseStrongMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new FireBombImpulseStrongMutSetCreateEffect(id);
    }
    public void EffectFireBombImpulseStrongMutSetDelete(int id) {
      var effect = InternalEffectFireBombImpulseStrongMutSetDelete(id);
      NotifyEffect(effect);
    }
    public FireBombImpulseStrongMutSetDeleteEffect InternalEffectFireBombImpulseStrongMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsFireBombImpulseStrongMutSet[id];
      rootIncarnation.incarnationsFireBombImpulseStrongMutSet.Remove(id);
      return new FireBombImpulseStrongMutSetDeleteEffect(id);
    }

       
    public void EffectFireBombImpulseStrongMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasFireBombImpulseStrongMutSet(instanceId);
      CheckHasFireBombImpulse(element);
      var effect = InternalEffectFireBombImpulseStrongMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public FireBombImpulseStrongMutSetAddEffect InternalEffectFireBombImpulseStrongMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsFireBombImpulseStrongMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new FireBombImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFireBombImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<FireBombImpulseStrongMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new FireBombImpulseStrongMutSetAddEffect(instanceId, element);
    }
    public void EffectFireBombImpulseStrongMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasFireBombImpulseStrongMutSet(instanceId);
      CheckHasFireBombImpulse(element);
      var effect = InternalEffectFireBombImpulseStrongMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public FireBombImpulseStrongMutSetRemoveEffect InternalEffectFireBombImpulseStrongMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsFireBombImpulseStrongMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new FireBombImpulseStrongMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFireBombImpulseStrongMutSet[instanceId] =
            new VersionAndIncarnation<FireBombImpulseStrongMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new FireBombImpulseStrongMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetLightningChargedUCWeakMutSetHash(int id, int version, LightningChargedUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public LightningChargedUCWeakMutSetIncarnation GetLightningChargedUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsLightningChargedUCWeakMutSet[id].incarnation;
    }
    public LightningChargedUCWeakMutSet GetLightningChargedUCWeakMutSet(int id) {
      return new LightningChargedUCWeakMutSet(this, id);
    }
    public List<LightningChargedUCWeakMutSet> AllLightningChargedUCWeakMutSet() {
      List<LightningChargedUCWeakMutSet> result = new List<LightningChargedUCWeakMutSet>(rootIncarnation.incarnationsLightningChargedUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsLightningChargedUCWeakMutSet.Keys) {
        result.Add(new LightningChargedUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool LightningChargedUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsLightningChargedUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasLightningChargedUCWeakMutSet(LightningChargedUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasLightningChargedUCWeakMutSet(thing.id);
    }
    public void CheckHasLightningChargedUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsLightningChargedUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid LightningChargedUCWeakMutSet}: " + id);
      }
    }
    public LightningChargedUCWeakMutSet EffectLightningChargedUCWeakMutSetCreate() {
      return TrustedEffectLightningChargedUCWeakMutSetCreateWithId(NewId());
    }
    public LightningChargedUCWeakMutSet TrustedEffectLightningChargedUCWeakMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new LightningChargedUCWeakMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateLightningChargedUCWeakMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new LightningChargedUCWeakMutSet(this, id);
    }
    public LightningChargedUCWeakMutSetCreateEffect InternalEffectCreateLightningChargedUCWeakMutSet(int id, int incarnationVersion, LightningChargedUCWeakMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsLightningChargedUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<LightningChargedUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new LightningChargedUCWeakMutSetCreateEffect(id);
    }
    public void EffectLightningChargedUCWeakMutSetDelete(int id) {
      var effect = InternalEffectLightningChargedUCWeakMutSetDelete(id);
      NotifyEffect(effect);
    }
    public LightningChargedUCWeakMutSetDeleteEffect InternalEffectLightningChargedUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsLightningChargedUCWeakMutSet[id];
      rootIncarnation.incarnationsLightningChargedUCWeakMutSet.Remove(id);
      return new LightningChargedUCWeakMutSetDeleteEffect(id);
    }

       
    public void EffectLightningChargedUCWeakMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasLightningChargedUCWeakMutSet(instanceId);
      CheckHasLightningChargedUC(element);
      var effect = InternalEffectLightningChargedUCWeakMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public LightningChargedUCWeakMutSetAddEffect InternalEffectLightningChargedUCWeakMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsLightningChargedUCWeakMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new LightningChargedUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLightningChargedUCWeakMutSet[instanceId] =
            new VersionAndIncarnation<LightningChargedUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new LightningChargedUCWeakMutSetAddEffect(instanceId, element);
    }
    public void EffectLightningChargedUCWeakMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasLightningChargedUCWeakMutSet(instanceId);
      CheckHasLightningChargedUC(element);
      var effect = InternalEffectLightningChargedUCWeakMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public LightningChargedUCWeakMutSetRemoveEffect InternalEffectLightningChargedUCWeakMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsLightningChargedUCWeakMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new LightningChargedUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLightningChargedUCWeakMutSet[instanceId] =
            new VersionAndIncarnation<LightningChargedUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new LightningChargedUCWeakMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetTimeCloneAICapabilityUCWeakMutSetHash(int id, int version, TimeCloneAICapabilityUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public TimeCloneAICapabilityUCWeakMutSetIncarnation GetTimeCloneAICapabilityUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[id].incarnation;
    }
    public TimeCloneAICapabilityUCWeakMutSet GetTimeCloneAICapabilityUCWeakMutSet(int id) {
      return new TimeCloneAICapabilityUCWeakMutSet(this, id);
    }
    public List<TimeCloneAICapabilityUCWeakMutSet> AllTimeCloneAICapabilityUCWeakMutSet() {
      List<TimeCloneAICapabilityUCWeakMutSet> result = new List<TimeCloneAICapabilityUCWeakMutSet>(rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.Keys) {
        result.Add(new TimeCloneAICapabilityUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool TimeCloneAICapabilityUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasTimeCloneAICapabilityUCWeakMutSet(TimeCloneAICapabilityUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasTimeCloneAICapabilityUCWeakMutSet(thing.id);
    }
    public void CheckHasTimeCloneAICapabilityUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid TimeCloneAICapabilityUCWeakMutSet}: " + id);
      }
    }
    public TimeCloneAICapabilityUCWeakMutSet EffectTimeCloneAICapabilityUCWeakMutSetCreate() {
      return TrustedEffectTimeCloneAICapabilityUCWeakMutSetCreateWithId(NewId());
    }
    public TimeCloneAICapabilityUCWeakMutSet TrustedEffectTimeCloneAICapabilityUCWeakMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new TimeCloneAICapabilityUCWeakMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateTimeCloneAICapabilityUCWeakMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new TimeCloneAICapabilityUCWeakMutSet(this, id);
    }
    public TimeCloneAICapabilityUCWeakMutSetCreateEffect InternalEffectCreateTimeCloneAICapabilityUCWeakMutSet(int id, int incarnationVersion, TimeCloneAICapabilityUCWeakMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<TimeCloneAICapabilityUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new TimeCloneAICapabilityUCWeakMutSetCreateEffect(id);
    }
    public void EffectTimeCloneAICapabilityUCWeakMutSetDelete(int id) {
      var effect = InternalEffectTimeCloneAICapabilityUCWeakMutSetDelete(id);
      NotifyEffect(effect);
    }
    public TimeCloneAICapabilityUCWeakMutSetDeleteEffect InternalEffectTimeCloneAICapabilityUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[id];
      rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet.Remove(id);
      return new TimeCloneAICapabilityUCWeakMutSetDeleteEffect(id);
    }

       
    public void EffectTimeCloneAICapabilityUCWeakMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasTimeCloneAICapabilityUCWeakMutSet(instanceId);
      CheckHasTimeCloneAICapabilityUC(element);
      var effect = InternalEffectTimeCloneAICapabilityUCWeakMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public TimeCloneAICapabilityUCWeakMutSetAddEffect InternalEffectTimeCloneAICapabilityUCWeakMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new TimeCloneAICapabilityUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[instanceId] =
            new VersionAndIncarnation<TimeCloneAICapabilityUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new TimeCloneAICapabilityUCWeakMutSetAddEffect(instanceId, element);
    }
    public void EffectTimeCloneAICapabilityUCWeakMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasTimeCloneAICapabilityUCWeakMutSet(instanceId);
      CheckHasTimeCloneAICapabilityUC(element);
      var effect = InternalEffectTimeCloneAICapabilityUCWeakMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public TimeCloneAICapabilityUCWeakMutSetRemoveEffect InternalEffectTimeCloneAICapabilityUCWeakMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new TimeCloneAICapabilityUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTimeCloneAICapabilityUCWeakMutSet[instanceId] =
            new VersionAndIncarnation<TimeCloneAICapabilityUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new TimeCloneAICapabilityUCWeakMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetDoomedUCWeakMutSetHash(int id, int version, DoomedUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public DoomedUCWeakMutSetIncarnation GetDoomedUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsDoomedUCWeakMutSet[id].incarnation;
    }
    public DoomedUCWeakMutSet GetDoomedUCWeakMutSet(int id) {
      return new DoomedUCWeakMutSet(this, id);
    }
    public List<DoomedUCWeakMutSet> AllDoomedUCWeakMutSet() {
      List<DoomedUCWeakMutSet> result = new List<DoomedUCWeakMutSet>(rootIncarnation.incarnationsDoomedUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsDoomedUCWeakMutSet.Keys) {
        result.Add(new DoomedUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool DoomedUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsDoomedUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasDoomedUCWeakMutSet(DoomedUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasDoomedUCWeakMutSet(thing.id);
    }
    public void CheckHasDoomedUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsDoomedUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid DoomedUCWeakMutSet}: " + id);
      }
    }
    public DoomedUCWeakMutSet EffectDoomedUCWeakMutSetCreate() {
      return TrustedEffectDoomedUCWeakMutSetCreateWithId(NewId());
    }
    public DoomedUCWeakMutSet TrustedEffectDoomedUCWeakMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new DoomedUCWeakMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateDoomedUCWeakMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new DoomedUCWeakMutSet(this, id);
    }
    public DoomedUCWeakMutSetCreateEffect InternalEffectCreateDoomedUCWeakMutSet(int id, int incarnationVersion, DoomedUCWeakMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsDoomedUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<DoomedUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new DoomedUCWeakMutSetCreateEffect(id);
    }
    public void EffectDoomedUCWeakMutSetDelete(int id) {
      var effect = InternalEffectDoomedUCWeakMutSetDelete(id);
      NotifyEffect(effect);
    }
    public DoomedUCWeakMutSetDeleteEffect InternalEffectDoomedUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsDoomedUCWeakMutSet[id];
      rootIncarnation.incarnationsDoomedUCWeakMutSet.Remove(id);
      return new DoomedUCWeakMutSetDeleteEffect(id);
    }

       
    public void EffectDoomedUCWeakMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasDoomedUCWeakMutSet(instanceId);
      CheckHasDoomedUC(element);
      var effect = InternalEffectDoomedUCWeakMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public DoomedUCWeakMutSetAddEffect InternalEffectDoomedUCWeakMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsDoomedUCWeakMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new DoomedUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDoomedUCWeakMutSet[instanceId] =
            new VersionAndIncarnation<DoomedUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new DoomedUCWeakMutSetAddEffect(instanceId, element);
    }
    public void EffectDoomedUCWeakMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasDoomedUCWeakMutSet(instanceId);
      CheckHasDoomedUC(element);
      var effect = InternalEffectDoomedUCWeakMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public DoomedUCWeakMutSetRemoveEffect InternalEffectDoomedUCWeakMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsDoomedUCWeakMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new DoomedUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDoomedUCWeakMutSet[instanceId] =
            new VersionAndIncarnation<DoomedUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new DoomedUCWeakMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetMiredUCWeakMutSetHash(int id, int version, MiredUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public MiredUCWeakMutSetIncarnation GetMiredUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsMiredUCWeakMutSet[id].incarnation;
    }
    public MiredUCWeakMutSet GetMiredUCWeakMutSet(int id) {
      return new MiredUCWeakMutSet(this, id);
    }
    public List<MiredUCWeakMutSet> AllMiredUCWeakMutSet() {
      List<MiredUCWeakMutSet> result = new List<MiredUCWeakMutSet>(rootIncarnation.incarnationsMiredUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsMiredUCWeakMutSet.Keys) {
        result.Add(new MiredUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool MiredUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsMiredUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasMiredUCWeakMutSet(MiredUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasMiredUCWeakMutSet(thing.id);
    }
    public void CheckHasMiredUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsMiredUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid MiredUCWeakMutSet}: " + id);
      }
    }
    public MiredUCWeakMutSet EffectMiredUCWeakMutSetCreate() {
      return TrustedEffectMiredUCWeakMutSetCreateWithId(NewId());
    }
    public MiredUCWeakMutSet TrustedEffectMiredUCWeakMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new MiredUCWeakMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateMiredUCWeakMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new MiredUCWeakMutSet(this, id);
    }
    public MiredUCWeakMutSetCreateEffect InternalEffectCreateMiredUCWeakMutSet(int id, int incarnationVersion, MiredUCWeakMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsMiredUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<MiredUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new MiredUCWeakMutSetCreateEffect(id);
    }
    public void EffectMiredUCWeakMutSetDelete(int id) {
      var effect = InternalEffectMiredUCWeakMutSetDelete(id);
      NotifyEffect(effect);
    }
    public MiredUCWeakMutSetDeleteEffect InternalEffectMiredUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsMiredUCWeakMutSet[id];
      rootIncarnation.incarnationsMiredUCWeakMutSet.Remove(id);
      return new MiredUCWeakMutSetDeleteEffect(id);
    }

       
    public void EffectMiredUCWeakMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasMiredUCWeakMutSet(instanceId);
      CheckHasMiredUC(element);
      var effect = InternalEffectMiredUCWeakMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public MiredUCWeakMutSetAddEffect InternalEffectMiredUCWeakMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsMiredUCWeakMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new MiredUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMiredUCWeakMutSet[instanceId] =
            new VersionAndIncarnation<MiredUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new MiredUCWeakMutSetAddEffect(instanceId, element);
    }
    public void EffectMiredUCWeakMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasMiredUCWeakMutSet(instanceId);
      CheckHasMiredUC(element);
      var effect = InternalEffectMiredUCWeakMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public MiredUCWeakMutSetRemoveEffect InternalEffectMiredUCWeakMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsMiredUCWeakMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new MiredUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMiredUCWeakMutSet[instanceId] =
            new VersionAndIncarnation<MiredUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new MiredUCWeakMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetInvincibilityUCWeakMutSetHash(int id, int version, InvincibilityUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public InvincibilityUCWeakMutSetIncarnation GetInvincibilityUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsInvincibilityUCWeakMutSet[id].incarnation;
    }
    public InvincibilityUCWeakMutSet GetInvincibilityUCWeakMutSet(int id) {
      return new InvincibilityUCWeakMutSet(this, id);
    }
    public List<InvincibilityUCWeakMutSet> AllInvincibilityUCWeakMutSet() {
      List<InvincibilityUCWeakMutSet> result = new List<InvincibilityUCWeakMutSet>(rootIncarnation.incarnationsInvincibilityUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsInvincibilityUCWeakMutSet.Keys) {
        result.Add(new InvincibilityUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool InvincibilityUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsInvincibilityUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasInvincibilityUCWeakMutSet(InvincibilityUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasInvincibilityUCWeakMutSet(thing.id);
    }
    public void CheckHasInvincibilityUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsInvincibilityUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid InvincibilityUCWeakMutSet}: " + id);
      }
    }
    public InvincibilityUCWeakMutSet EffectInvincibilityUCWeakMutSetCreate() {
      return TrustedEffectInvincibilityUCWeakMutSetCreateWithId(NewId());
    }
    public InvincibilityUCWeakMutSet TrustedEffectInvincibilityUCWeakMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new InvincibilityUCWeakMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateInvincibilityUCWeakMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new InvincibilityUCWeakMutSet(this, id);
    }
    public InvincibilityUCWeakMutSetCreateEffect InternalEffectCreateInvincibilityUCWeakMutSet(int id, int incarnationVersion, InvincibilityUCWeakMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsInvincibilityUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<InvincibilityUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new InvincibilityUCWeakMutSetCreateEffect(id);
    }
    public void EffectInvincibilityUCWeakMutSetDelete(int id) {
      var effect = InternalEffectInvincibilityUCWeakMutSetDelete(id);
      NotifyEffect(effect);
    }
    public InvincibilityUCWeakMutSetDeleteEffect InternalEffectInvincibilityUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsInvincibilityUCWeakMutSet[id];
      rootIncarnation.incarnationsInvincibilityUCWeakMutSet.Remove(id);
      return new InvincibilityUCWeakMutSetDeleteEffect(id);
    }

       
    public void EffectInvincibilityUCWeakMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasInvincibilityUCWeakMutSet(instanceId);
      CheckHasInvincibilityUC(element);
      var effect = InternalEffectInvincibilityUCWeakMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public InvincibilityUCWeakMutSetAddEffect InternalEffectInvincibilityUCWeakMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsInvincibilityUCWeakMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new InvincibilityUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsInvincibilityUCWeakMutSet[instanceId] =
            new VersionAndIncarnation<InvincibilityUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new InvincibilityUCWeakMutSetAddEffect(instanceId, element);
    }
    public void EffectInvincibilityUCWeakMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasInvincibilityUCWeakMutSet(instanceId);
      CheckHasInvincibilityUC(element);
      var effect = InternalEffectInvincibilityUCWeakMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public InvincibilityUCWeakMutSetRemoveEffect InternalEffectInvincibilityUCWeakMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsInvincibilityUCWeakMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new InvincibilityUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsInvincibilityUCWeakMutSet[instanceId] =
            new VersionAndIncarnation<InvincibilityUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new InvincibilityUCWeakMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetOnFireUCWeakMutSetHash(int id, int version, OnFireUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public OnFireUCWeakMutSetIncarnation GetOnFireUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsOnFireUCWeakMutSet[id].incarnation;
    }
    public OnFireUCWeakMutSet GetOnFireUCWeakMutSet(int id) {
      return new OnFireUCWeakMutSet(this, id);
    }
    public List<OnFireUCWeakMutSet> AllOnFireUCWeakMutSet() {
      List<OnFireUCWeakMutSet> result = new List<OnFireUCWeakMutSet>(rootIncarnation.incarnationsOnFireUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsOnFireUCWeakMutSet.Keys) {
        result.Add(new OnFireUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool OnFireUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsOnFireUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasOnFireUCWeakMutSet(OnFireUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasOnFireUCWeakMutSet(thing.id);
    }
    public void CheckHasOnFireUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsOnFireUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid OnFireUCWeakMutSet}: " + id);
      }
    }
    public OnFireUCWeakMutSet EffectOnFireUCWeakMutSetCreate() {
      return TrustedEffectOnFireUCWeakMutSetCreateWithId(NewId());
    }
    public OnFireUCWeakMutSet TrustedEffectOnFireUCWeakMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new OnFireUCWeakMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateOnFireUCWeakMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new OnFireUCWeakMutSet(this, id);
    }
    public OnFireUCWeakMutSetCreateEffect InternalEffectCreateOnFireUCWeakMutSet(int id, int incarnationVersion, OnFireUCWeakMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsOnFireUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<OnFireUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new OnFireUCWeakMutSetCreateEffect(id);
    }
    public void EffectOnFireUCWeakMutSetDelete(int id) {
      var effect = InternalEffectOnFireUCWeakMutSetDelete(id);
      NotifyEffect(effect);
    }
    public OnFireUCWeakMutSetDeleteEffect InternalEffectOnFireUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsOnFireUCWeakMutSet[id];
      rootIncarnation.incarnationsOnFireUCWeakMutSet.Remove(id);
      return new OnFireUCWeakMutSetDeleteEffect(id);
    }

       
    public void EffectOnFireUCWeakMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasOnFireUCWeakMutSet(instanceId);
      CheckHasOnFireUC(element);
      var effect = InternalEffectOnFireUCWeakMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public OnFireUCWeakMutSetAddEffect InternalEffectOnFireUCWeakMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsOnFireUCWeakMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new OnFireUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsOnFireUCWeakMutSet[instanceId] =
            new VersionAndIncarnation<OnFireUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new OnFireUCWeakMutSetAddEffect(instanceId, element);
    }
    public void EffectOnFireUCWeakMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasOnFireUCWeakMutSet(instanceId);
      CheckHasOnFireUC(element);
      var effect = InternalEffectOnFireUCWeakMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public OnFireUCWeakMutSetRemoveEffect InternalEffectOnFireUCWeakMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsOnFireUCWeakMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new OnFireUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsOnFireUCWeakMutSet[instanceId] =
            new VersionAndIncarnation<OnFireUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new OnFireUCWeakMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetDefyingUCWeakMutSetHash(int id, int version, DefyingUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public DefyingUCWeakMutSetIncarnation GetDefyingUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsDefyingUCWeakMutSet[id].incarnation;
    }
    public DefyingUCWeakMutSet GetDefyingUCWeakMutSet(int id) {
      return new DefyingUCWeakMutSet(this, id);
    }
    public List<DefyingUCWeakMutSet> AllDefyingUCWeakMutSet() {
      List<DefyingUCWeakMutSet> result = new List<DefyingUCWeakMutSet>(rootIncarnation.incarnationsDefyingUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsDefyingUCWeakMutSet.Keys) {
        result.Add(new DefyingUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool DefyingUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsDefyingUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasDefyingUCWeakMutSet(DefyingUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasDefyingUCWeakMutSet(thing.id);
    }
    public void CheckHasDefyingUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsDefyingUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid DefyingUCWeakMutSet}: " + id);
      }
    }
    public DefyingUCWeakMutSet EffectDefyingUCWeakMutSetCreate() {
      return TrustedEffectDefyingUCWeakMutSetCreateWithId(NewId());
    }
    public DefyingUCWeakMutSet TrustedEffectDefyingUCWeakMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new DefyingUCWeakMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateDefyingUCWeakMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new DefyingUCWeakMutSet(this, id);
    }
    public DefyingUCWeakMutSetCreateEffect InternalEffectCreateDefyingUCWeakMutSet(int id, int incarnationVersion, DefyingUCWeakMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsDefyingUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<DefyingUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new DefyingUCWeakMutSetCreateEffect(id);
    }
    public void EffectDefyingUCWeakMutSetDelete(int id) {
      var effect = InternalEffectDefyingUCWeakMutSetDelete(id);
      NotifyEffect(effect);
    }
    public DefyingUCWeakMutSetDeleteEffect InternalEffectDefyingUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsDefyingUCWeakMutSet[id];
      rootIncarnation.incarnationsDefyingUCWeakMutSet.Remove(id);
      return new DefyingUCWeakMutSetDeleteEffect(id);
    }

       
    public void EffectDefyingUCWeakMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasDefyingUCWeakMutSet(instanceId);
      CheckHasDefyingUC(element);
      var effect = InternalEffectDefyingUCWeakMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public DefyingUCWeakMutSetAddEffect InternalEffectDefyingUCWeakMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsDefyingUCWeakMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new DefyingUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDefyingUCWeakMutSet[instanceId] =
            new VersionAndIncarnation<DefyingUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new DefyingUCWeakMutSetAddEffect(instanceId, element);
    }
    public void EffectDefyingUCWeakMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasDefyingUCWeakMutSet(instanceId);
      CheckHasDefyingUC(element);
      var effect = InternalEffectDefyingUCWeakMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public DefyingUCWeakMutSetRemoveEffect InternalEffectDefyingUCWeakMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsDefyingUCWeakMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new DefyingUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDefyingUCWeakMutSet[instanceId] =
            new VersionAndIncarnation<DefyingUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new DefyingUCWeakMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetCounteringUCWeakMutSetHash(int id, int version, CounteringUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CounteringUCWeakMutSetIncarnation GetCounteringUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsCounteringUCWeakMutSet[id].incarnation;
    }
    public CounteringUCWeakMutSet GetCounteringUCWeakMutSet(int id) {
      return new CounteringUCWeakMutSet(this, id);
    }
    public List<CounteringUCWeakMutSet> AllCounteringUCWeakMutSet() {
      List<CounteringUCWeakMutSet> result = new List<CounteringUCWeakMutSet>(rootIncarnation.incarnationsCounteringUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsCounteringUCWeakMutSet.Keys) {
        result.Add(new CounteringUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool CounteringUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsCounteringUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasCounteringUCWeakMutSet(CounteringUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCounteringUCWeakMutSet(thing.id);
    }
    public void CheckHasCounteringUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsCounteringUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid CounteringUCWeakMutSet}: " + id);
      }
    }
    public CounteringUCWeakMutSet EffectCounteringUCWeakMutSetCreate() {
      return TrustedEffectCounteringUCWeakMutSetCreateWithId(NewId());
    }
    public CounteringUCWeakMutSet TrustedEffectCounteringUCWeakMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new CounteringUCWeakMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateCounteringUCWeakMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new CounteringUCWeakMutSet(this, id);
    }
    public CounteringUCWeakMutSetCreateEffect InternalEffectCreateCounteringUCWeakMutSet(int id, int incarnationVersion, CounteringUCWeakMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsCounteringUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<CounteringUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new CounteringUCWeakMutSetCreateEffect(id);
    }
    public void EffectCounteringUCWeakMutSetDelete(int id) {
      var effect = InternalEffectCounteringUCWeakMutSetDelete(id);
      NotifyEffect(effect);
    }
    public CounteringUCWeakMutSetDeleteEffect InternalEffectCounteringUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsCounteringUCWeakMutSet[id];
      rootIncarnation.incarnationsCounteringUCWeakMutSet.Remove(id);
      return new CounteringUCWeakMutSetDeleteEffect(id);
    }

       
    public void EffectCounteringUCWeakMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasCounteringUCWeakMutSet(instanceId);
      CheckHasCounteringUC(element);
      var effect = InternalEffectCounteringUCWeakMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public CounteringUCWeakMutSetAddEffect InternalEffectCounteringUCWeakMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsCounteringUCWeakMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new CounteringUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCounteringUCWeakMutSet[instanceId] =
            new VersionAndIncarnation<CounteringUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new CounteringUCWeakMutSetAddEffect(instanceId, element);
    }
    public void EffectCounteringUCWeakMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasCounteringUCWeakMutSet(instanceId);
      CheckHasCounteringUC(element);
      var effect = InternalEffectCounteringUCWeakMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public CounteringUCWeakMutSetRemoveEffect InternalEffectCounteringUCWeakMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsCounteringUCWeakMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new CounteringUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCounteringUCWeakMutSet[instanceId] =
            new VersionAndIncarnation<CounteringUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new CounteringUCWeakMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetAttackAICapabilityUCWeakMutSetHash(int id, int version, AttackAICapabilityUCWeakMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public AttackAICapabilityUCWeakMutSetIncarnation GetAttackAICapabilityUCWeakMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[id].incarnation;
    }
    public AttackAICapabilityUCWeakMutSet GetAttackAICapabilityUCWeakMutSet(int id) {
      return new AttackAICapabilityUCWeakMutSet(this, id);
    }
    public List<AttackAICapabilityUCWeakMutSet> AllAttackAICapabilityUCWeakMutSet() {
      List<AttackAICapabilityUCWeakMutSet> result = new List<AttackAICapabilityUCWeakMutSet>(rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.Keys) {
        result.Add(new AttackAICapabilityUCWeakMutSet(this, id));
      }
      return result;
    }
    public bool AttackAICapabilityUCWeakMutSetExists(int id) {
      return rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.ContainsKey(id);
    }
    public void CheckHasAttackAICapabilityUCWeakMutSet(AttackAICapabilityUCWeakMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasAttackAICapabilityUCWeakMutSet(thing.id);
    }
    public void CheckHasAttackAICapabilityUCWeakMutSet(int id) {
      if (!rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid AttackAICapabilityUCWeakMutSet}: " + id);
      }
    }
    public AttackAICapabilityUCWeakMutSet EffectAttackAICapabilityUCWeakMutSetCreate() {
      return TrustedEffectAttackAICapabilityUCWeakMutSetCreateWithId(NewId());
    }
    public AttackAICapabilityUCWeakMutSet TrustedEffectAttackAICapabilityUCWeakMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new AttackAICapabilityUCWeakMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateAttackAICapabilityUCWeakMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new AttackAICapabilityUCWeakMutSet(this, id);
    }
    public AttackAICapabilityUCWeakMutSetCreateEffect InternalEffectCreateAttackAICapabilityUCWeakMutSet(int id, int incarnationVersion, AttackAICapabilityUCWeakMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet
          .Add(
              id,
              new VersionAndIncarnation<AttackAICapabilityUCWeakMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new AttackAICapabilityUCWeakMutSetCreateEffect(id);
    }
    public void EffectAttackAICapabilityUCWeakMutSetDelete(int id) {
      var effect = InternalEffectAttackAICapabilityUCWeakMutSetDelete(id);
      NotifyEffect(effect);
    }
    public AttackAICapabilityUCWeakMutSetDeleteEffect InternalEffectAttackAICapabilityUCWeakMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[id];
      rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet.Remove(id);
      return new AttackAICapabilityUCWeakMutSetDeleteEffect(id);
    }

       
    public void EffectAttackAICapabilityUCWeakMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasAttackAICapabilityUCWeakMutSet(instanceId);
      CheckHasAttackAICapabilityUC(element);
      var effect = InternalEffectAttackAICapabilityUCWeakMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public AttackAICapabilityUCWeakMutSetAddEffect InternalEffectAttackAICapabilityUCWeakMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new AttackAICapabilityUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[instanceId] =
            new VersionAndIncarnation<AttackAICapabilityUCWeakMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new AttackAICapabilityUCWeakMutSetAddEffect(instanceId, element);
    }
    public void EffectAttackAICapabilityUCWeakMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasAttackAICapabilityUCWeakMutSet(instanceId);
      CheckHasAttackAICapabilityUC(element);
      var effect = InternalEffectAttackAICapabilityUCWeakMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public AttackAICapabilityUCWeakMutSetRemoveEffect InternalEffectAttackAICapabilityUCWeakMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new AttackAICapabilityUCWeakMutSetIncarnation(newMap);
        rootIncarnation.incarnationsAttackAICapabilityUCWeakMutSet[instanceId] =
            new VersionAndIncarnation<AttackAICapabilityUCWeakMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new AttackAICapabilityUCWeakMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetUnitMutSetHash(int id, int version, UnitMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public UnitMutSetIncarnation GetUnitMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsUnitMutSet[id].incarnation;
    }
    public UnitMutSet GetUnitMutSet(int id) {
      return new UnitMutSet(this, id);
    }
    public List<UnitMutSet> AllUnitMutSet() {
      List<UnitMutSet> result = new List<UnitMutSet>(rootIncarnation.incarnationsUnitMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsUnitMutSet.Keys) {
        result.Add(new UnitMutSet(this, id));
      }
      return result;
    }
    public bool UnitMutSetExists(int id) {
      return rootIncarnation.incarnationsUnitMutSet.ContainsKey(id);
    }
    public void CheckHasUnitMutSet(UnitMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasUnitMutSet(thing.id);
    }
    public void CheckHasUnitMutSet(int id) {
      if (!rootIncarnation.incarnationsUnitMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid UnitMutSet}: " + id);
      }
    }
    public UnitMutSet EffectUnitMutSetCreate() {
      return TrustedEffectUnitMutSetCreateWithId(NewId());
    }
    public UnitMutSet TrustedEffectUnitMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new UnitMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateUnitMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new UnitMutSet(this, id);
    }
    public UnitMutSetCreateEffect InternalEffectCreateUnitMutSet(int id, int incarnationVersion, UnitMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsUnitMutSet
          .Add(
              id,
              new VersionAndIncarnation<UnitMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new UnitMutSetCreateEffect(id);
    }
    public void EffectUnitMutSetDelete(int id) {
      var effect = InternalEffectUnitMutSetDelete(id);
      NotifyEffect(effect);
    }
    public UnitMutSetDeleteEffect InternalEffectUnitMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsUnitMutSet[id];
      rootIncarnation.incarnationsUnitMutSet.Remove(id);
      return new UnitMutSetDeleteEffect(id);
    }

       
    public void EffectUnitMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasUnitMutSet(instanceId);
      CheckHasUnit(element);
      var effect = InternalEffectUnitMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public UnitMutSetAddEffect InternalEffectUnitMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsUnitMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new UnitMutSetIncarnation(newMap);
        rootIncarnation.incarnationsUnitMutSet[instanceId] =
            new VersionAndIncarnation<UnitMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new UnitMutSetAddEffect(instanceId, element);
    }
    public void EffectUnitMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasUnitMutSet(instanceId);
      CheckHasUnit(element);
      var effect = InternalEffectUnitMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public UnitMutSetRemoveEffect InternalEffectUnitMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsUnitMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new UnitMutSetIncarnation(newMap);
        rootIncarnation.incarnationsUnitMutSet[instanceId] =
            new VersionAndIncarnation<UnitMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new UnitMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetSimplePresenceTriggerTTCMutSetHash(int id, int version, SimplePresenceTriggerTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public SimplePresenceTriggerTTCMutSetIncarnation GetSimplePresenceTriggerTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet[id].incarnation;
    }
    public SimplePresenceTriggerTTCMutSet GetSimplePresenceTriggerTTCMutSet(int id) {
      return new SimplePresenceTriggerTTCMutSet(this, id);
    }
    public List<SimplePresenceTriggerTTCMutSet> AllSimplePresenceTriggerTTCMutSet() {
      List<SimplePresenceTriggerTTCMutSet> result = new List<SimplePresenceTriggerTTCMutSet>(rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet.Keys) {
        result.Add(new SimplePresenceTriggerTTCMutSet(this, id));
      }
      return result;
    }
    public bool SimplePresenceTriggerTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet.ContainsKey(id);
    }
    public void CheckHasSimplePresenceTriggerTTCMutSet(SimplePresenceTriggerTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasSimplePresenceTriggerTTCMutSet(thing.id);
    }
    public void CheckHasSimplePresenceTriggerTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid SimplePresenceTriggerTTCMutSet}: " + id);
      }
    }
    public SimplePresenceTriggerTTCMutSet EffectSimplePresenceTriggerTTCMutSetCreate() {
      return TrustedEffectSimplePresenceTriggerTTCMutSetCreateWithId(NewId());
    }
    public SimplePresenceTriggerTTCMutSet TrustedEffectSimplePresenceTriggerTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new SimplePresenceTriggerTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateSimplePresenceTriggerTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new SimplePresenceTriggerTTCMutSet(this, id);
    }
    public SimplePresenceTriggerTTCMutSetCreateEffect InternalEffectCreateSimplePresenceTriggerTTCMutSet(int id, int incarnationVersion, SimplePresenceTriggerTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<SimplePresenceTriggerTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new SimplePresenceTriggerTTCMutSetCreateEffect(id);
    }
    public void EffectSimplePresenceTriggerTTCMutSetDelete(int id) {
      var effect = InternalEffectSimplePresenceTriggerTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public SimplePresenceTriggerTTCMutSetDeleteEffect InternalEffectSimplePresenceTriggerTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet[id];
      rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet.Remove(id);
      return new SimplePresenceTriggerTTCMutSetDeleteEffect(id);
    }

       
    public void EffectSimplePresenceTriggerTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasSimplePresenceTriggerTTCMutSet(instanceId);
      CheckHasSimplePresenceTriggerTTC(element);
      var effect = InternalEffectSimplePresenceTriggerTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public SimplePresenceTriggerTTCMutSetAddEffect InternalEffectSimplePresenceTriggerTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new SimplePresenceTriggerTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet[instanceId] =
            new VersionAndIncarnation<SimplePresenceTriggerTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new SimplePresenceTriggerTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectSimplePresenceTriggerTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasSimplePresenceTriggerTTCMutSet(instanceId);
      CheckHasSimplePresenceTriggerTTC(element);
      var effect = InternalEffectSimplePresenceTriggerTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public SimplePresenceTriggerTTCMutSetRemoveEffect InternalEffectSimplePresenceTriggerTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new SimplePresenceTriggerTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSimplePresenceTriggerTTCMutSet[instanceId] =
            new VersionAndIncarnation<SimplePresenceTriggerTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new SimplePresenceTriggerTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetItemTTCMutSetHash(int id, int version, ItemTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ItemTTCMutSetIncarnation GetItemTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsItemTTCMutSet[id].incarnation;
    }
    public ItemTTCMutSet GetItemTTCMutSet(int id) {
      return new ItemTTCMutSet(this, id);
    }
    public List<ItemTTCMutSet> AllItemTTCMutSet() {
      List<ItemTTCMutSet> result = new List<ItemTTCMutSet>(rootIncarnation.incarnationsItemTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsItemTTCMutSet.Keys) {
        result.Add(new ItemTTCMutSet(this, id));
      }
      return result;
    }
    public bool ItemTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsItemTTCMutSet.ContainsKey(id);
    }
    public void CheckHasItemTTCMutSet(ItemTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasItemTTCMutSet(thing.id);
    }
    public void CheckHasItemTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsItemTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ItemTTCMutSet}: " + id);
      }
    }
    public ItemTTCMutSet EffectItemTTCMutSetCreate() {
      return TrustedEffectItemTTCMutSetCreateWithId(NewId());
    }
    public ItemTTCMutSet TrustedEffectItemTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new ItemTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateItemTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new ItemTTCMutSet(this, id);
    }
    public ItemTTCMutSetCreateEffect InternalEffectCreateItemTTCMutSet(int id, int incarnationVersion, ItemTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsItemTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<ItemTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new ItemTTCMutSetCreateEffect(id);
    }
    public void EffectItemTTCMutSetDelete(int id) {
      var effect = InternalEffectItemTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public ItemTTCMutSetDeleteEffect InternalEffectItemTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsItemTTCMutSet[id];
      rootIncarnation.incarnationsItemTTCMutSet.Remove(id);
      return new ItemTTCMutSetDeleteEffect(id);
    }

       
    public void EffectItemTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasItemTTCMutSet(instanceId);
      CheckHasItemTTC(element);
      var effect = InternalEffectItemTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public ItemTTCMutSetAddEffect InternalEffectItemTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsItemTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new ItemTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsItemTTCMutSet[instanceId] =
            new VersionAndIncarnation<ItemTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new ItemTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectItemTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasItemTTCMutSet(instanceId);
      CheckHasItemTTC(element);
      var effect = InternalEffectItemTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public ItemTTCMutSetRemoveEffect InternalEffectItemTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsItemTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ItemTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsItemTTCMutSet[instanceId] =
            new VersionAndIncarnation<ItemTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new ItemTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetFlowerTTCMutSetHash(int id, int version, FlowerTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public FlowerTTCMutSetIncarnation GetFlowerTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsFlowerTTCMutSet[id].incarnation;
    }
    public FlowerTTCMutSet GetFlowerTTCMutSet(int id) {
      return new FlowerTTCMutSet(this, id);
    }
    public List<FlowerTTCMutSet> AllFlowerTTCMutSet() {
      List<FlowerTTCMutSet> result = new List<FlowerTTCMutSet>(rootIncarnation.incarnationsFlowerTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsFlowerTTCMutSet.Keys) {
        result.Add(new FlowerTTCMutSet(this, id));
      }
      return result;
    }
    public bool FlowerTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsFlowerTTCMutSet.ContainsKey(id);
    }
    public void CheckHasFlowerTTCMutSet(FlowerTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasFlowerTTCMutSet(thing.id);
    }
    public void CheckHasFlowerTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsFlowerTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid FlowerTTCMutSet}: " + id);
      }
    }
    public FlowerTTCMutSet EffectFlowerTTCMutSetCreate() {
      return TrustedEffectFlowerTTCMutSetCreateWithId(NewId());
    }
    public FlowerTTCMutSet TrustedEffectFlowerTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new FlowerTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateFlowerTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new FlowerTTCMutSet(this, id);
    }
    public FlowerTTCMutSetCreateEffect InternalEffectCreateFlowerTTCMutSet(int id, int incarnationVersion, FlowerTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsFlowerTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<FlowerTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new FlowerTTCMutSetCreateEffect(id);
    }
    public void EffectFlowerTTCMutSetDelete(int id) {
      var effect = InternalEffectFlowerTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public FlowerTTCMutSetDeleteEffect InternalEffectFlowerTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsFlowerTTCMutSet[id];
      rootIncarnation.incarnationsFlowerTTCMutSet.Remove(id);
      return new FlowerTTCMutSetDeleteEffect(id);
    }

       
    public void EffectFlowerTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasFlowerTTCMutSet(instanceId);
      CheckHasFlowerTTC(element);
      var effect = InternalEffectFlowerTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public FlowerTTCMutSetAddEffect InternalEffectFlowerTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsFlowerTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new FlowerTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFlowerTTCMutSet[instanceId] =
            new VersionAndIncarnation<FlowerTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new FlowerTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectFlowerTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasFlowerTTCMutSet(instanceId);
      CheckHasFlowerTTC(element);
      var effect = InternalEffectFlowerTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public FlowerTTCMutSetRemoveEffect InternalEffectFlowerTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsFlowerTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new FlowerTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFlowerTTCMutSet[instanceId] =
            new VersionAndIncarnation<FlowerTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new FlowerTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetLotusTTCMutSetHash(int id, int version, LotusTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public LotusTTCMutSetIncarnation GetLotusTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsLotusTTCMutSet[id].incarnation;
    }
    public LotusTTCMutSet GetLotusTTCMutSet(int id) {
      return new LotusTTCMutSet(this, id);
    }
    public List<LotusTTCMutSet> AllLotusTTCMutSet() {
      List<LotusTTCMutSet> result = new List<LotusTTCMutSet>(rootIncarnation.incarnationsLotusTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsLotusTTCMutSet.Keys) {
        result.Add(new LotusTTCMutSet(this, id));
      }
      return result;
    }
    public bool LotusTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsLotusTTCMutSet.ContainsKey(id);
    }
    public void CheckHasLotusTTCMutSet(LotusTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasLotusTTCMutSet(thing.id);
    }
    public void CheckHasLotusTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsLotusTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid LotusTTCMutSet}: " + id);
      }
    }
    public LotusTTCMutSet EffectLotusTTCMutSetCreate() {
      return TrustedEffectLotusTTCMutSetCreateWithId(NewId());
    }
    public LotusTTCMutSet TrustedEffectLotusTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new LotusTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateLotusTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new LotusTTCMutSet(this, id);
    }
    public LotusTTCMutSetCreateEffect InternalEffectCreateLotusTTCMutSet(int id, int incarnationVersion, LotusTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsLotusTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<LotusTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new LotusTTCMutSetCreateEffect(id);
    }
    public void EffectLotusTTCMutSetDelete(int id) {
      var effect = InternalEffectLotusTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public LotusTTCMutSetDeleteEffect InternalEffectLotusTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsLotusTTCMutSet[id];
      rootIncarnation.incarnationsLotusTTCMutSet.Remove(id);
      return new LotusTTCMutSetDeleteEffect(id);
    }

       
    public void EffectLotusTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasLotusTTCMutSet(instanceId);
      CheckHasLotusTTC(element);
      var effect = InternalEffectLotusTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public LotusTTCMutSetAddEffect InternalEffectLotusTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsLotusTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new LotusTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLotusTTCMutSet[instanceId] =
            new VersionAndIncarnation<LotusTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new LotusTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectLotusTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasLotusTTCMutSet(instanceId);
      CheckHasLotusTTC(element);
      var effect = InternalEffectLotusTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public LotusTTCMutSetRemoveEffect InternalEffectLotusTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsLotusTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new LotusTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLotusTTCMutSet[instanceId] =
            new VersionAndIncarnation<LotusTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new LotusTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetRoseTTCMutSetHash(int id, int version, RoseTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public RoseTTCMutSetIncarnation GetRoseTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsRoseTTCMutSet[id].incarnation;
    }
    public RoseTTCMutSet GetRoseTTCMutSet(int id) {
      return new RoseTTCMutSet(this, id);
    }
    public List<RoseTTCMutSet> AllRoseTTCMutSet() {
      List<RoseTTCMutSet> result = new List<RoseTTCMutSet>(rootIncarnation.incarnationsRoseTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsRoseTTCMutSet.Keys) {
        result.Add(new RoseTTCMutSet(this, id));
      }
      return result;
    }
    public bool RoseTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsRoseTTCMutSet.ContainsKey(id);
    }
    public void CheckHasRoseTTCMutSet(RoseTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasRoseTTCMutSet(thing.id);
    }
    public void CheckHasRoseTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsRoseTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid RoseTTCMutSet}: " + id);
      }
    }
    public RoseTTCMutSet EffectRoseTTCMutSetCreate() {
      return TrustedEffectRoseTTCMutSetCreateWithId(NewId());
    }
    public RoseTTCMutSet TrustedEffectRoseTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new RoseTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateRoseTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new RoseTTCMutSet(this, id);
    }
    public RoseTTCMutSetCreateEffect InternalEffectCreateRoseTTCMutSet(int id, int incarnationVersion, RoseTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsRoseTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<RoseTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new RoseTTCMutSetCreateEffect(id);
    }
    public void EffectRoseTTCMutSetDelete(int id) {
      var effect = InternalEffectRoseTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public RoseTTCMutSetDeleteEffect InternalEffectRoseTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsRoseTTCMutSet[id];
      rootIncarnation.incarnationsRoseTTCMutSet.Remove(id);
      return new RoseTTCMutSetDeleteEffect(id);
    }

       
    public void EffectRoseTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasRoseTTCMutSet(instanceId);
      CheckHasRoseTTC(element);
      var effect = InternalEffectRoseTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public RoseTTCMutSetAddEffect InternalEffectRoseTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsRoseTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new RoseTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsRoseTTCMutSet[instanceId] =
            new VersionAndIncarnation<RoseTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new RoseTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectRoseTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasRoseTTCMutSet(instanceId);
      CheckHasRoseTTC(element);
      var effect = InternalEffectRoseTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public RoseTTCMutSetRemoveEffect InternalEffectRoseTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsRoseTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new RoseTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsRoseTTCMutSet[instanceId] =
            new VersionAndIncarnation<RoseTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new RoseTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetLeafTTCMutSetHash(int id, int version, LeafTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public LeafTTCMutSetIncarnation GetLeafTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsLeafTTCMutSet[id].incarnation;
    }
    public LeafTTCMutSet GetLeafTTCMutSet(int id) {
      return new LeafTTCMutSet(this, id);
    }
    public List<LeafTTCMutSet> AllLeafTTCMutSet() {
      List<LeafTTCMutSet> result = new List<LeafTTCMutSet>(rootIncarnation.incarnationsLeafTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsLeafTTCMutSet.Keys) {
        result.Add(new LeafTTCMutSet(this, id));
      }
      return result;
    }
    public bool LeafTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsLeafTTCMutSet.ContainsKey(id);
    }
    public void CheckHasLeafTTCMutSet(LeafTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasLeafTTCMutSet(thing.id);
    }
    public void CheckHasLeafTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsLeafTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid LeafTTCMutSet}: " + id);
      }
    }
    public LeafTTCMutSet EffectLeafTTCMutSetCreate() {
      return TrustedEffectLeafTTCMutSetCreateWithId(NewId());
    }
    public LeafTTCMutSet TrustedEffectLeafTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new LeafTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateLeafTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new LeafTTCMutSet(this, id);
    }
    public LeafTTCMutSetCreateEffect InternalEffectCreateLeafTTCMutSet(int id, int incarnationVersion, LeafTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsLeafTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<LeafTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new LeafTTCMutSetCreateEffect(id);
    }
    public void EffectLeafTTCMutSetDelete(int id) {
      var effect = InternalEffectLeafTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public LeafTTCMutSetDeleteEffect InternalEffectLeafTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsLeafTTCMutSet[id];
      rootIncarnation.incarnationsLeafTTCMutSet.Remove(id);
      return new LeafTTCMutSetDeleteEffect(id);
    }

       
    public void EffectLeafTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasLeafTTCMutSet(instanceId);
      CheckHasLeafTTC(element);
      var effect = InternalEffectLeafTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public LeafTTCMutSetAddEffect InternalEffectLeafTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsLeafTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new LeafTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLeafTTCMutSet[instanceId] =
            new VersionAndIncarnation<LeafTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new LeafTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectLeafTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasLeafTTCMutSet(instanceId);
      CheckHasLeafTTC(element);
      var effect = InternalEffectLeafTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public LeafTTCMutSetRemoveEffect InternalEffectLeafTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsLeafTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new LeafTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLeafTTCMutSet[instanceId] =
            new VersionAndIncarnation<LeafTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new LeafTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetKamikazeTargetTTCMutSetHash(int id, int version, KamikazeTargetTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public KamikazeTargetTTCMutSetIncarnation GetKamikazeTargetTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsKamikazeTargetTTCMutSet[id].incarnation;
    }
    public KamikazeTargetTTCMutSet GetKamikazeTargetTTCMutSet(int id) {
      return new KamikazeTargetTTCMutSet(this, id);
    }
    public List<KamikazeTargetTTCMutSet> AllKamikazeTargetTTCMutSet() {
      List<KamikazeTargetTTCMutSet> result = new List<KamikazeTargetTTCMutSet>(rootIncarnation.incarnationsKamikazeTargetTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsKamikazeTargetTTCMutSet.Keys) {
        result.Add(new KamikazeTargetTTCMutSet(this, id));
      }
      return result;
    }
    public bool KamikazeTargetTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsKamikazeTargetTTCMutSet.ContainsKey(id);
    }
    public void CheckHasKamikazeTargetTTCMutSet(KamikazeTargetTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasKamikazeTargetTTCMutSet(thing.id);
    }
    public void CheckHasKamikazeTargetTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsKamikazeTargetTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid KamikazeTargetTTCMutSet}: " + id);
      }
    }
    public KamikazeTargetTTCMutSet EffectKamikazeTargetTTCMutSetCreate() {
      return TrustedEffectKamikazeTargetTTCMutSetCreateWithId(NewId());
    }
    public KamikazeTargetTTCMutSet TrustedEffectKamikazeTargetTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new KamikazeTargetTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateKamikazeTargetTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new KamikazeTargetTTCMutSet(this, id);
    }
    public KamikazeTargetTTCMutSetCreateEffect InternalEffectCreateKamikazeTargetTTCMutSet(int id, int incarnationVersion, KamikazeTargetTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsKamikazeTargetTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<KamikazeTargetTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new KamikazeTargetTTCMutSetCreateEffect(id);
    }
    public void EffectKamikazeTargetTTCMutSetDelete(int id) {
      var effect = InternalEffectKamikazeTargetTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public KamikazeTargetTTCMutSetDeleteEffect InternalEffectKamikazeTargetTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsKamikazeTargetTTCMutSet[id];
      rootIncarnation.incarnationsKamikazeTargetTTCMutSet.Remove(id);
      return new KamikazeTargetTTCMutSetDeleteEffect(id);
    }

       
    public void EffectKamikazeTargetTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasKamikazeTargetTTCMutSet(instanceId);
      CheckHasKamikazeTargetTTC(element);
      var effect = InternalEffectKamikazeTargetTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public KamikazeTargetTTCMutSetAddEffect InternalEffectKamikazeTargetTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeTargetTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new KamikazeTargetTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsKamikazeTargetTTCMutSet[instanceId] =
            new VersionAndIncarnation<KamikazeTargetTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new KamikazeTargetTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectKamikazeTargetTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasKamikazeTargetTTCMutSet(instanceId);
      CheckHasKamikazeTargetTTC(element);
      var effect = InternalEffectKamikazeTargetTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public KamikazeTargetTTCMutSetRemoveEffect InternalEffectKamikazeTargetTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeTargetTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new KamikazeTargetTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsKamikazeTargetTTCMutSet[instanceId] =
            new VersionAndIncarnation<KamikazeTargetTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new KamikazeTargetTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetWarperTTCMutSetHash(int id, int version, WarperTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public WarperTTCMutSetIncarnation GetWarperTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsWarperTTCMutSet[id].incarnation;
    }
    public WarperTTCMutSet GetWarperTTCMutSet(int id) {
      return new WarperTTCMutSet(this, id);
    }
    public List<WarperTTCMutSet> AllWarperTTCMutSet() {
      List<WarperTTCMutSet> result = new List<WarperTTCMutSet>(rootIncarnation.incarnationsWarperTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsWarperTTCMutSet.Keys) {
        result.Add(new WarperTTCMutSet(this, id));
      }
      return result;
    }
    public bool WarperTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsWarperTTCMutSet.ContainsKey(id);
    }
    public void CheckHasWarperTTCMutSet(WarperTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasWarperTTCMutSet(thing.id);
    }
    public void CheckHasWarperTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsWarperTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid WarperTTCMutSet}: " + id);
      }
    }
    public WarperTTCMutSet EffectWarperTTCMutSetCreate() {
      return TrustedEffectWarperTTCMutSetCreateWithId(NewId());
    }
    public WarperTTCMutSet TrustedEffectWarperTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new WarperTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateWarperTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new WarperTTCMutSet(this, id);
    }
    public WarperTTCMutSetCreateEffect InternalEffectCreateWarperTTCMutSet(int id, int incarnationVersion, WarperTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsWarperTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<WarperTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new WarperTTCMutSetCreateEffect(id);
    }
    public void EffectWarperTTCMutSetDelete(int id) {
      var effect = InternalEffectWarperTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public WarperTTCMutSetDeleteEffect InternalEffectWarperTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsWarperTTCMutSet[id];
      rootIncarnation.incarnationsWarperTTCMutSet.Remove(id);
      return new WarperTTCMutSetDeleteEffect(id);
    }

       
    public void EffectWarperTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasWarperTTCMutSet(instanceId);
      CheckHasWarperTTC(element);
      var effect = InternalEffectWarperTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public WarperTTCMutSetAddEffect InternalEffectWarperTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsWarperTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new WarperTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsWarperTTCMutSet[instanceId] =
            new VersionAndIncarnation<WarperTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new WarperTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectWarperTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasWarperTTCMutSet(instanceId);
      CheckHasWarperTTC(element);
      var effect = InternalEffectWarperTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public WarperTTCMutSetRemoveEffect InternalEffectWarperTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsWarperTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new WarperTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsWarperTTCMutSet[instanceId] =
            new VersionAndIncarnation<WarperTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new WarperTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetTimeAnchorTTCMutSetHash(int id, int version, TimeAnchorTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public TimeAnchorTTCMutSetIncarnation GetTimeAnchorTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsTimeAnchorTTCMutSet[id].incarnation;
    }
    public TimeAnchorTTCMutSet GetTimeAnchorTTCMutSet(int id) {
      return new TimeAnchorTTCMutSet(this, id);
    }
    public List<TimeAnchorTTCMutSet> AllTimeAnchorTTCMutSet() {
      List<TimeAnchorTTCMutSet> result = new List<TimeAnchorTTCMutSet>(rootIncarnation.incarnationsTimeAnchorTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsTimeAnchorTTCMutSet.Keys) {
        result.Add(new TimeAnchorTTCMutSet(this, id));
      }
      return result;
    }
    public bool TimeAnchorTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsTimeAnchorTTCMutSet.ContainsKey(id);
    }
    public void CheckHasTimeAnchorTTCMutSet(TimeAnchorTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasTimeAnchorTTCMutSet(thing.id);
    }
    public void CheckHasTimeAnchorTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsTimeAnchorTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid TimeAnchorTTCMutSet}: " + id);
      }
    }
    public TimeAnchorTTCMutSet EffectTimeAnchorTTCMutSetCreate() {
      return TrustedEffectTimeAnchorTTCMutSetCreateWithId(NewId());
    }
    public TimeAnchorTTCMutSet TrustedEffectTimeAnchorTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new TimeAnchorTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateTimeAnchorTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new TimeAnchorTTCMutSet(this, id);
    }
    public TimeAnchorTTCMutSetCreateEffect InternalEffectCreateTimeAnchorTTCMutSet(int id, int incarnationVersion, TimeAnchorTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsTimeAnchorTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<TimeAnchorTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new TimeAnchorTTCMutSetCreateEffect(id);
    }
    public void EffectTimeAnchorTTCMutSetDelete(int id) {
      var effect = InternalEffectTimeAnchorTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public TimeAnchorTTCMutSetDeleteEffect InternalEffectTimeAnchorTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsTimeAnchorTTCMutSet[id];
      rootIncarnation.incarnationsTimeAnchorTTCMutSet.Remove(id);
      return new TimeAnchorTTCMutSetDeleteEffect(id);
    }

       
    public void EffectTimeAnchorTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasTimeAnchorTTCMutSet(instanceId);
      CheckHasTimeAnchorTTC(element);
      var effect = InternalEffectTimeAnchorTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public TimeAnchorTTCMutSetAddEffect InternalEffectTimeAnchorTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsTimeAnchorTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new TimeAnchorTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTimeAnchorTTCMutSet[instanceId] =
            new VersionAndIncarnation<TimeAnchorTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new TimeAnchorTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectTimeAnchorTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasTimeAnchorTTCMutSet(instanceId);
      CheckHasTimeAnchorTTC(element);
      var effect = InternalEffectTimeAnchorTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public TimeAnchorTTCMutSetRemoveEffect InternalEffectTimeAnchorTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsTimeAnchorTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new TimeAnchorTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTimeAnchorTTCMutSet[instanceId] =
            new VersionAndIncarnation<TimeAnchorTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new TimeAnchorTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetFireBombTTCMutSetHash(int id, int version, FireBombTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public FireBombTTCMutSetIncarnation GetFireBombTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsFireBombTTCMutSet[id].incarnation;
    }
    public FireBombTTCMutSet GetFireBombTTCMutSet(int id) {
      return new FireBombTTCMutSet(this, id);
    }
    public List<FireBombTTCMutSet> AllFireBombTTCMutSet() {
      List<FireBombTTCMutSet> result = new List<FireBombTTCMutSet>(rootIncarnation.incarnationsFireBombTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsFireBombTTCMutSet.Keys) {
        result.Add(new FireBombTTCMutSet(this, id));
      }
      return result;
    }
    public bool FireBombTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsFireBombTTCMutSet.ContainsKey(id);
    }
    public void CheckHasFireBombTTCMutSet(FireBombTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasFireBombTTCMutSet(thing.id);
    }
    public void CheckHasFireBombTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsFireBombTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid FireBombTTCMutSet}: " + id);
      }
    }
    public FireBombTTCMutSet EffectFireBombTTCMutSetCreate() {
      return TrustedEffectFireBombTTCMutSetCreateWithId(NewId());
    }
    public FireBombTTCMutSet TrustedEffectFireBombTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new FireBombTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateFireBombTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new FireBombTTCMutSet(this, id);
    }
    public FireBombTTCMutSetCreateEffect InternalEffectCreateFireBombTTCMutSet(int id, int incarnationVersion, FireBombTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsFireBombTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<FireBombTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new FireBombTTCMutSetCreateEffect(id);
    }
    public void EffectFireBombTTCMutSetDelete(int id) {
      var effect = InternalEffectFireBombTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public FireBombTTCMutSetDeleteEffect InternalEffectFireBombTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsFireBombTTCMutSet[id];
      rootIncarnation.incarnationsFireBombTTCMutSet.Remove(id);
      return new FireBombTTCMutSetDeleteEffect(id);
    }

       
    public void EffectFireBombTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasFireBombTTCMutSet(instanceId);
      CheckHasFireBombTTC(element);
      var effect = InternalEffectFireBombTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public FireBombTTCMutSetAddEffect InternalEffectFireBombTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsFireBombTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new FireBombTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFireBombTTCMutSet[instanceId] =
            new VersionAndIncarnation<FireBombTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new FireBombTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectFireBombTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasFireBombTTCMutSet(instanceId);
      CheckHasFireBombTTC(element);
      var effect = InternalEffectFireBombTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public FireBombTTCMutSetRemoveEffect InternalEffectFireBombTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsFireBombTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new FireBombTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFireBombTTCMutSet[instanceId] =
            new VersionAndIncarnation<FireBombTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new FireBombTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetOnFireTTCMutSetHash(int id, int version, OnFireTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public OnFireTTCMutSetIncarnation GetOnFireTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsOnFireTTCMutSet[id].incarnation;
    }
    public OnFireTTCMutSet GetOnFireTTCMutSet(int id) {
      return new OnFireTTCMutSet(this, id);
    }
    public List<OnFireTTCMutSet> AllOnFireTTCMutSet() {
      List<OnFireTTCMutSet> result = new List<OnFireTTCMutSet>(rootIncarnation.incarnationsOnFireTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsOnFireTTCMutSet.Keys) {
        result.Add(new OnFireTTCMutSet(this, id));
      }
      return result;
    }
    public bool OnFireTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsOnFireTTCMutSet.ContainsKey(id);
    }
    public void CheckHasOnFireTTCMutSet(OnFireTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasOnFireTTCMutSet(thing.id);
    }
    public void CheckHasOnFireTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsOnFireTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid OnFireTTCMutSet}: " + id);
      }
    }
    public OnFireTTCMutSet EffectOnFireTTCMutSetCreate() {
      return TrustedEffectOnFireTTCMutSetCreateWithId(NewId());
    }
    public OnFireTTCMutSet TrustedEffectOnFireTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new OnFireTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateOnFireTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new OnFireTTCMutSet(this, id);
    }
    public OnFireTTCMutSetCreateEffect InternalEffectCreateOnFireTTCMutSet(int id, int incarnationVersion, OnFireTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsOnFireTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<OnFireTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new OnFireTTCMutSetCreateEffect(id);
    }
    public void EffectOnFireTTCMutSetDelete(int id) {
      var effect = InternalEffectOnFireTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public OnFireTTCMutSetDeleteEffect InternalEffectOnFireTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsOnFireTTCMutSet[id];
      rootIncarnation.incarnationsOnFireTTCMutSet.Remove(id);
      return new OnFireTTCMutSetDeleteEffect(id);
    }

       
    public void EffectOnFireTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasOnFireTTCMutSet(instanceId);
      CheckHasOnFireTTC(element);
      var effect = InternalEffectOnFireTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public OnFireTTCMutSetAddEffect InternalEffectOnFireTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsOnFireTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new OnFireTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsOnFireTTCMutSet[instanceId] =
            new VersionAndIncarnation<OnFireTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new OnFireTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectOnFireTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasOnFireTTCMutSet(instanceId);
      CheckHasOnFireTTC(element);
      var effect = InternalEffectOnFireTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public OnFireTTCMutSetRemoveEffect InternalEffectOnFireTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsOnFireTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new OnFireTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsOnFireTTCMutSet[instanceId] =
            new VersionAndIncarnation<OnFireTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new OnFireTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetMarkerTTCMutSetHash(int id, int version, MarkerTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public MarkerTTCMutSetIncarnation GetMarkerTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsMarkerTTCMutSet[id].incarnation;
    }
    public MarkerTTCMutSet GetMarkerTTCMutSet(int id) {
      return new MarkerTTCMutSet(this, id);
    }
    public List<MarkerTTCMutSet> AllMarkerTTCMutSet() {
      List<MarkerTTCMutSet> result = new List<MarkerTTCMutSet>(rootIncarnation.incarnationsMarkerTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsMarkerTTCMutSet.Keys) {
        result.Add(new MarkerTTCMutSet(this, id));
      }
      return result;
    }
    public bool MarkerTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsMarkerTTCMutSet.ContainsKey(id);
    }
    public void CheckHasMarkerTTCMutSet(MarkerTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasMarkerTTCMutSet(thing.id);
    }
    public void CheckHasMarkerTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsMarkerTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid MarkerTTCMutSet}: " + id);
      }
    }
    public MarkerTTCMutSet EffectMarkerTTCMutSetCreate() {
      return TrustedEffectMarkerTTCMutSetCreateWithId(NewId());
    }
    public MarkerTTCMutSet TrustedEffectMarkerTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new MarkerTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateMarkerTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new MarkerTTCMutSet(this, id);
    }
    public MarkerTTCMutSetCreateEffect InternalEffectCreateMarkerTTCMutSet(int id, int incarnationVersion, MarkerTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsMarkerTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<MarkerTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new MarkerTTCMutSetCreateEffect(id);
    }
    public void EffectMarkerTTCMutSetDelete(int id) {
      var effect = InternalEffectMarkerTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public MarkerTTCMutSetDeleteEffect InternalEffectMarkerTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsMarkerTTCMutSet[id];
      rootIncarnation.incarnationsMarkerTTCMutSet.Remove(id);
      return new MarkerTTCMutSetDeleteEffect(id);
    }

       
    public void EffectMarkerTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasMarkerTTCMutSet(instanceId);
      CheckHasMarkerTTC(element);
      var effect = InternalEffectMarkerTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public MarkerTTCMutSetAddEffect InternalEffectMarkerTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsMarkerTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new MarkerTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMarkerTTCMutSet[instanceId] =
            new VersionAndIncarnation<MarkerTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new MarkerTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectMarkerTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasMarkerTTCMutSet(instanceId);
      CheckHasMarkerTTC(element);
      var effect = InternalEffectMarkerTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public MarkerTTCMutSetRemoveEffect InternalEffectMarkerTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsMarkerTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new MarkerTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMarkerTTCMutSet[instanceId] =
            new VersionAndIncarnation<MarkerTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new MarkerTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetLevelLinkTTCMutSetHash(int id, int version, LevelLinkTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public LevelLinkTTCMutSetIncarnation GetLevelLinkTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsLevelLinkTTCMutSet[id].incarnation;
    }
    public LevelLinkTTCMutSet GetLevelLinkTTCMutSet(int id) {
      return new LevelLinkTTCMutSet(this, id);
    }
    public List<LevelLinkTTCMutSet> AllLevelLinkTTCMutSet() {
      List<LevelLinkTTCMutSet> result = new List<LevelLinkTTCMutSet>(rootIncarnation.incarnationsLevelLinkTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsLevelLinkTTCMutSet.Keys) {
        result.Add(new LevelLinkTTCMutSet(this, id));
      }
      return result;
    }
    public bool LevelLinkTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsLevelLinkTTCMutSet.ContainsKey(id);
    }
    public void CheckHasLevelLinkTTCMutSet(LevelLinkTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasLevelLinkTTCMutSet(thing.id);
    }
    public void CheckHasLevelLinkTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsLevelLinkTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid LevelLinkTTCMutSet}: " + id);
      }
    }
    public LevelLinkTTCMutSet EffectLevelLinkTTCMutSetCreate() {
      return TrustedEffectLevelLinkTTCMutSetCreateWithId(NewId());
    }
    public LevelLinkTTCMutSet TrustedEffectLevelLinkTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new LevelLinkTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateLevelLinkTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new LevelLinkTTCMutSet(this, id);
    }
    public LevelLinkTTCMutSetCreateEffect InternalEffectCreateLevelLinkTTCMutSet(int id, int incarnationVersion, LevelLinkTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsLevelLinkTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<LevelLinkTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new LevelLinkTTCMutSetCreateEffect(id);
    }
    public void EffectLevelLinkTTCMutSetDelete(int id) {
      var effect = InternalEffectLevelLinkTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public LevelLinkTTCMutSetDeleteEffect InternalEffectLevelLinkTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsLevelLinkTTCMutSet[id];
      rootIncarnation.incarnationsLevelLinkTTCMutSet.Remove(id);
      return new LevelLinkTTCMutSetDeleteEffect(id);
    }

       
    public void EffectLevelLinkTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasLevelLinkTTCMutSet(instanceId);
      CheckHasLevelLinkTTC(element);
      var effect = InternalEffectLevelLinkTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public LevelLinkTTCMutSetAddEffect InternalEffectLevelLinkTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsLevelLinkTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new LevelLinkTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLevelLinkTTCMutSet[instanceId] =
            new VersionAndIncarnation<LevelLinkTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new LevelLinkTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectLevelLinkTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasLevelLinkTTCMutSet(instanceId);
      CheckHasLevelLinkTTC(element);
      var effect = InternalEffectLevelLinkTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public LevelLinkTTCMutSetRemoveEffect InternalEffectLevelLinkTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsLevelLinkTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new LevelLinkTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLevelLinkTTCMutSet[instanceId] =
            new VersionAndIncarnation<LevelLinkTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new LevelLinkTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetMudTTCMutSetHash(int id, int version, MudTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public MudTTCMutSetIncarnation GetMudTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsMudTTCMutSet[id].incarnation;
    }
    public MudTTCMutSet GetMudTTCMutSet(int id) {
      return new MudTTCMutSet(this, id);
    }
    public List<MudTTCMutSet> AllMudTTCMutSet() {
      List<MudTTCMutSet> result = new List<MudTTCMutSet>(rootIncarnation.incarnationsMudTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsMudTTCMutSet.Keys) {
        result.Add(new MudTTCMutSet(this, id));
      }
      return result;
    }
    public bool MudTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsMudTTCMutSet.ContainsKey(id);
    }
    public void CheckHasMudTTCMutSet(MudTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasMudTTCMutSet(thing.id);
    }
    public void CheckHasMudTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsMudTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid MudTTCMutSet}: " + id);
      }
    }
    public MudTTCMutSet EffectMudTTCMutSetCreate() {
      return TrustedEffectMudTTCMutSetCreateWithId(NewId());
    }
    public MudTTCMutSet TrustedEffectMudTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new MudTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateMudTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new MudTTCMutSet(this, id);
    }
    public MudTTCMutSetCreateEffect InternalEffectCreateMudTTCMutSet(int id, int incarnationVersion, MudTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsMudTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<MudTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new MudTTCMutSetCreateEffect(id);
    }
    public void EffectMudTTCMutSetDelete(int id) {
      var effect = InternalEffectMudTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public MudTTCMutSetDeleteEffect InternalEffectMudTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsMudTTCMutSet[id];
      rootIncarnation.incarnationsMudTTCMutSet.Remove(id);
      return new MudTTCMutSetDeleteEffect(id);
    }

       
    public void EffectMudTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasMudTTCMutSet(instanceId);
      CheckHasMudTTC(element);
      var effect = InternalEffectMudTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public MudTTCMutSetAddEffect InternalEffectMudTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsMudTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new MudTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMudTTCMutSet[instanceId] =
            new VersionAndIncarnation<MudTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new MudTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectMudTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasMudTTCMutSet(instanceId);
      CheckHasMudTTC(element);
      var effect = InternalEffectMudTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public MudTTCMutSetRemoveEffect InternalEffectMudTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsMudTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new MudTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMudTTCMutSet[instanceId] =
            new VersionAndIncarnation<MudTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new MudTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetDirtTTCMutSetHash(int id, int version, DirtTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public DirtTTCMutSetIncarnation GetDirtTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsDirtTTCMutSet[id].incarnation;
    }
    public DirtTTCMutSet GetDirtTTCMutSet(int id) {
      return new DirtTTCMutSet(this, id);
    }
    public List<DirtTTCMutSet> AllDirtTTCMutSet() {
      List<DirtTTCMutSet> result = new List<DirtTTCMutSet>(rootIncarnation.incarnationsDirtTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsDirtTTCMutSet.Keys) {
        result.Add(new DirtTTCMutSet(this, id));
      }
      return result;
    }
    public bool DirtTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsDirtTTCMutSet.ContainsKey(id);
    }
    public void CheckHasDirtTTCMutSet(DirtTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasDirtTTCMutSet(thing.id);
    }
    public void CheckHasDirtTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsDirtTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid DirtTTCMutSet}: " + id);
      }
    }
    public DirtTTCMutSet EffectDirtTTCMutSetCreate() {
      return TrustedEffectDirtTTCMutSetCreateWithId(NewId());
    }
    public DirtTTCMutSet TrustedEffectDirtTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new DirtTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateDirtTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new DirtTTCMutSet(this, id);
    }
    public DirtTTCMutSetCreateEffect InternalEffectCreateDirtTTCMutSet(int id, int incarnationVersion, DirtTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsDirtTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<DirtTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new DirtTTCMutSetCreateEffect(id);
    }
    public void EffectDirtTTCMutSetDelete(int id) {
      var effect = InternalEffectDirtTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public DirtTTCMutSetDeleteEffect InternalEffectDirtTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsDirtTTCMutSet[id];
      rootIncarnation.incarnationsDirtTTCMutSet.Remove(id);
      return new DirtTTCMutSetDeleteEffect(id);
    }

       
    public void EffectDirtTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasDirtTTCMutSet(instanceId);
      CheckHasDirtTTC(element);
      var effect = InternalEffectDirtTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public DirtTTCMutSetAddEffect InternalEffectDirtTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsDirtTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new DirtTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDirtTTCMutSet[instanceId] =
            new VersionAndIncarnation<DirtTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new DirtTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectDirtTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasDirtTTCMutSet(instanceId);
      CheckHasDirtTTC(element);
      var effect = InternalEffectDirtTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public DirtTTCMutSetRemoveEffect InternalEffectDirtTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsDirtTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new DirtTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDirtTTCMutSet[instanceId] =
            new VersionAndIncarnation<DirtTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new DirtTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetObsidianTTCMutSetHash(int id, int version, ObsidianTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ObsidianTTCMutSetIncarnation GetObsidianTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsObsidianTTCMutSet[id].incarnation;
    }
    public ObsidianTTCMutSet GetObsidianTTCMutSet(int id) {
      return new ObsidianTTCMutSet(this, id);
    }
    public List<ObsidianTTCMutSet> AllObsidianTTCMutSet() {
      List<ObsidianTTCMutSet> result = new List<ObsidianTTCMutSet>(rootIncarnation.incarnationsObsidianTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsObsidianTTCMutSet.Keys) {
        result.Add(new ObsidianTTCMutSet(this, id));
      }
      return result;
    }
    public bool ObsidianTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsObsidianTTCMutSet.ContainsKey(id);
    }
    public void CheckHasObsidianTTCMutSet(ObsidianTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasObsidianTTCMutSet(thing.id);
    }
    public void CheckHasObsidianTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsObsidianTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ObsidianTTCMutSet}: " + id);
      }
    }
    public ObsidianTTCMutSet EffectObsidianTTCMutSetCreate() {
      return TrustedEffectObsidianTTCMutSetCreateWithId(NewId());
    }
    public ObsidianTTCMutSet TrustedEffectObsidianTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new ObsidianTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateObsidianTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new ObsidianTTCMutSet(this, id);
    }
    public ObsidianTTCMutSetCreateEffect InternalEffectCreateObsidianTTCMutSet(int id, int incarnationVersion, ObsidianTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsObsidianTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<ObsidianTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new ObsidianTTCMutSetCreateEffect(id);
    }
    public void EffectObsidianTTCMutSetDelete(int id) {
      var effect = InternalEffectObsidianTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public ObsidianTTCMutSetDeleteEffect InternalEffectObsidianTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsObsidianTTCMutSet[id];
      rootIncarnation.incarnationsObsidianTTCMutSet.Remove(id);
      return new ObsidianTTCMutSetDeleteEffect(id);
    }

       
    public void EffectObsidianTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasObsidianTTCMutSet(instanceId);
      CheckHasObsidianTTC(element);
      var effect = InternalEffectObsidianTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public ObsidianTTCMutSetAddEffect InternalEffectObsidianTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsObsidianTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new ObsidianTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsObsidianTTCMutSet[instanceId] =
            new VersionAndIncarnation<ObsidianTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new ObsidianTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectObsidianTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasObsidianTTCMutSet(instanceId);
      CheckHasObsidianTTC(element);
      var effect = InternalEffectObsidianTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public ObsidianTTCMutSetRemoveEffect InternalEffectObsidianTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsObsidianTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ObsidianTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsObsidianTTCMutSet[instanceId] =
            new VersionAndIncarnation<ObsidianTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new ObsidianTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetDownStairsTTCMutSetHash(int id, int version, DownStairsTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public DownStairsTTCMutSetIncarnation GetDownStairsTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsDownStairsTTCMutSet[id].incarnation;
    }
    public DownStairsTTCMutSet GetDownStairsTTCMutSet(int id) {
      return new DownStairsTTCMutSet(this, id);
    }
    public List<DownStairsTTCMutSet> AllDownStairsTTCMutSet() {
      List<DownStairsTTCMutSet> result = new List<DownStairsTTCMutSet>(rootIncarnation.incarnationsDownStairsTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsDownStairsTTCMutSet.Keys) {
        result.Add(new DownStairsTTCMutSet(this, id));
      }
      return result;
    }
    public bool DownStairsTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsDownStairsTTCMutSet.ContainsKey(id);
    }
    public void CheckHasDownStairsTTCMutSet(DownStairsTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasDownStairsTTCMutSet(thing.id);
    }
    public void CheckHasDownStairsTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsDownStairsTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid DownStairsTTCMutSet}: " + id);
      }
    }
    public DownStairsTTCMutSet EffectDownStairsTTCMutSetCreate() {
      return TrustedEffectDownStairsTTCMutSetCreateWithId(NewId());
    }
    public DownStairsTTCMutSet TrustedEffectDownStairsTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new DownStairsTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateDownStairsTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new DownStairsTTCMutSet(this, id);
    }
    public DownStairsTTCMutSetCreateEffect InternalEffectCreateDownStairsTTCMutSet(int id, int incarnationVersion, DownStairsTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsDownStairsTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<DownStairsTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new DownStairsTTCMutSetCreateEffect(id);
    }
    public void EffectDownStairsTTCMutSetDelete(int id) {
      var effect = InternalEffectDownStairsTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public DownStairsTTCMutSetDeleteEffect InternalEffectDownStairsTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsDownStairsTTCMutSet[id];
      rootIncarnation.incarnationsDownStairsTTCMutSet.Remove(id);
      return new DownStairsTTCMutSetDeleteEffect(id);
    }

       
    public void EffectDownStairsTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasDownStairsTTCMutSet(instanceId);
      CheckHasDownStairsTTC(element);
      var effect = InternalEffectDownStairsTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public DownStairsTTCMutSetAddEffect InternalEffectDownStairsTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsDownStairsTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new DownStairsTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDownStairsTTCMutSet[instanceId] =
            new VersionAndIncarnation<DownStairsTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new DownStairsTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectDownStairsTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasDownStairsTTCMutSet(instanceId);
      CheckHasDownStairsTTC(element);
      var effect = InternalEffectDownStairsTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public DownStairsTTCMutSetRemoveEffect InternalEffectDownStairsTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsDownStairsTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new DownStairsTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDownStairsTTCMutSet[instanceId] =
            new VersionAndIncarnation<DownStairsTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new DownStairsTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetUpStairsTTCMutSetHash(int id, int version, UpStairsTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public UpStairsTTCMutSetIncarnation GetUpStairsTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsUpStairsTTCMutSet[id].incarnation;
    }
    public UpStairsTTCMutSet GetUpStairsTTCMutSet(int id) {
      return new UpStairsTTCMutSet(this, id);
    }
    public List<UpStairsTTCMutSet> AllUpStairsTTCMutSet() {
      List<UpStairsTTCMutSet> result = new List<UpStairsTTCMutSet>(rootIncarnation.incarnationsUpStairsTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsUpStairsTTCMutSet.Keys) {
        result.Add(new UpStairsTTCMutSet(this, id));
      }
      return result;
    }
    public bool UpStairsTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsUpStairsTTCMutSet.ContainsKey(id);
    }
    public void CheckHasUpStairsTTCMutSet(UpStairsTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasUpStairsTTCMutSet(thing.id);
    }
    public void CheckHasUpStairsTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsUpStairsTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid UpStairsTTCMutSet}: " + id);
      }
    }
    public UpStairsTTCMutSet EffectUpStairsTTCMutSetCreate() {
      return TrustedEffectUpStairsTTCMutSetCreateWithId(NewId());
    }
    public UpStairsTTCMutSet TrustedEffectUpStairsTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new UpStairsTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateUpStairsTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new UpStairsTTCMutSet(this, id);
    }
    public UpStairsTTCMutSetCreateEffect InternalEffectCreateUpStairsTTCMutSet(int id, int incarnationVersion, UpStairsTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsUpStairsTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<UpStairsTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new UpStairsTTCMutSetCreateEffect(id);
    }
    public void EffectUpStairsTTCMutSetDelete(int id) {
      var effect = InternalEffectUpStairsTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public UpStairsTTCMutSetDeleteEffect InternalEffectUpStairsTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsUpStairsTTCMutSet[id];
      rootIncarnation.incarnationsUpStairsTTCMutSet.Remove(id);
      return new UpStairsTTCMutSetDeleteEffect(id);
    }

       
    public void EffectUpStairsTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasUpStairsTTCMutSet(instanceId);
      CheckHasUpStairsTTC(element);
      var effect = InternalEffectUpStairsTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public UpStairsTTCMutSetAddEffect InternalEffectUpStairsTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsUpStairsTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new UpStairsTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsUpStairsTTCMutSet[instanceId] =
            new VersionAndIncarnation<UpStairsTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new UpStairsTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectUpStairsTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasUpStairsTTCMutSet(instanceId);
      CheckHasUpStairsTTC(element);
      var effect = InternalEffectUpStairsTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public UpStairsTTCMutSetRemoveEffect InternalEffectUpStairsTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsUpStairsTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new UpStairsTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsUpStairsTTCMutSet[instanceId] =
            new VersionAndIncarnation<UpStairsTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new UpStairsTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetWallTTCMutSetHash(int id, int version, WallTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public WallTTCMutSetIncarnation GetWallTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsWallTTCMutSet[id].incarnation;
    }
    public WallTTCMutSet GetWallTTCMutSet(int id) {
      return new WallTTCMutSet(this, id);
    }
    public List<WallTTCMutSet> AllWallTTCMutSet() {
      List<WallTTCMutSet> result = new List<WallTTCMutSet>(rootIncarnation.incarnationsWallTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsWallTTCMutSet.Keys) {
        result.Add(new WallTTCMutSet(this, id));
      }
      return result;
    }
    public bool WallTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsWallTTCMutSet.ContainsKey(id);
    }
    public void CheckHasWallTTCMutSet(WallTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasWallTTCMutSet(thing.id);
    }
    public void CheckHasWallTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsWallTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid WallTTCMutSet}: " + id);
      }
    }
    public WallTTCMutSet EffectWallTTCMutSetCreate() {
      return TrustedEffectWallTTCMutSetCreateWithId(NewId());
    }
    public WallTTCMutSet TrustedEffectWallTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new WallTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateWallTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new WallTTCMutSet(this, id);
    }
    public WallTTCMutSetCreateEffect InternalEffectCreateWallTTCMutSet(int id, int incarnationVersion, WallTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsWallTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<WallTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new WallTTCMutSetCreateEffect(id);
    }
    public void EffectWallTTCMutSetDelete(int id) {
      var effect = InternalEffectWallTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public WallTTCMutSetDeleteEffect InternalEffectWallTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsWallTTCMutSet[id];
      rootIncarnation.incarnationsWallTTCMutSet.Remove(id);
      return new WallTTCMutSetDeleteEffect(id);
    }

       
    public void EffectWallTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasWallTTCMutSet(instanceId);
      CheckHasWallTTC(element);
      var effect = InternalEffectWallTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public WallTTCMutSetAddEffect InternalEffectWallTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsWallTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new WallTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsWallTTCMutSet[instanceId] =
            new VersionAndIncarnation<WallTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new WallTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectWallTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasWallTTCMutSet(instanceId);
      CheckHasWallTTC(element);
      var effect = InternalEffectWallTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public WallTTCMutSetRemoveEffect InternalEffectWallTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsWallTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new WallTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsWallTTCMutSet[instanceId] =
            new VersionAndIncarnation<WallTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new WallTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetBloodTTCMutSetHash(int id, int version, BloodTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BloodTTCMutSetIncarnation GetBloodTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBloodTTCMutSet[id].incarnation;
    }
    public BloodTTCMutSet GetBloodTTCMutSet(int id) {
      return new BloodTTCMutSet(this, id);
    }
    public List<BloodTTCMutSet> AllBloodTTCMutSet() {
      List<BloodTTCMutSet> result = new List<BloodTTCMutSet>(rootIncarnation.incarnationsBloodTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBloodTTCMutSet.Keys) {
        result.Add(new BloodTTCMutSet(this, id));
      }
      return result;
    }
    public bool BloodTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsBloodTTCMutSet.ContainsKey(id);
    }
    public void CheckHasBloodTTCMutSet(BloodTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBloodTTCMutSet(thing.id);
    }
    public void CheckHasBloodTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsBloodTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BloodTTCMutSet}: " + id);
      }
    }
    public BloodTTCMutSet EffectBloodTTCMutSetCreate() {
      return TrustedEffectBloodTTCMutSetCreateWithId(NewId());
    }
    public BloodTTCMutSet TrustedEffectBloodTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BloodTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateBloodTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new BloodTTCMutSet(this, id);
    }
    public BloodTTCMutSetCreateEffect InternalEffectCreateBloodTTCMutSet(int id, int incarnationVersion, BloodTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsBloodTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<BloodTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new BloodTTCMutSetCreateEffect(id);
    }
    public void EffectBloodTTCMutSetDelete(int id) {
      var effect = InternalEffectBloodTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public BloodTTCMutSetDeleteEffect InternalEffectBloodTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsBloodTTCMutSet[id];
      rootIncarnation.incarnationsBloodTTCMutSet.Remove(id);
      return new BloodTTCMutSetDeleteEffect(id);
    }

       
    public void EffectBloodTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBloodTTCMutSet(instanceId);
      CheckHasBloodTTC(element);
      var effect = InternalEffectBloodTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public BloodTTCMutSetAddEffect InternalEffectBloodTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBloodTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BloodTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBloodTTCMutSet[instanceId] =
            new VersionAndIncarnation<BloodTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new BloodTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectBloodTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBloodTTCMutSet(instanceId);
      CheckHasBloodTTC(element);
      var effect = InternalEffectBloodTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public BloodTTCMutSetRemoveEffect InternalEffectBloodTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBloodTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BloodTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBloodTTCMutSet[instanceId] =
            new VersionAndIncarnation<BloodTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new BloodTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetRocksTTCMutSetHash(int id, int version, RocksTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public RocksTTCMutSetIncarnation GetRocksTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsRocksTTCMutSet[id].incarnation;
    }
    public RocksTTCMutSet GetRocksTTCMutSet(int id) {
      return new RocksTTCMutSet(this, id);
    }
    public List<RocksTTCMutSet> AllRocksTTCMutSet() {
      List<RocksTTCMutSet> result = new List<RocksTTCMutSet>(rootIncarnation.incarnationsRocksTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsRocksTTCMutSet.Keys) {
        result.Add(new RocksTTCMutSet(this, id));
      }
      return result;
    }
    public bool RocksTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsRocksTTCMutSet.ContainsKey(id);
    }
    public void CheckHasRocksTTCMutSet(RocksTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasRocksTTCMutSet(thing.id);
    }
    public void CheckHasRocksTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsRocksTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid RocksTTCMutSet}: " + id);
      }
    }
    public RocksTTCMutSet EffectRocksTTCMutSetCreate() {
      return TrustedEffectRocksTTCMutSetCreateWithId(NewId());
    }
    public RocksTTCMutSet TrustedEffectRocksTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new RocksTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateRocksTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new RocksTTCMutSet(this, id);
    }
    public RocksTTCMutSetCreateEffect InternalEffectCreateRocksTTCMutSet(int id, int incarnationVersion, RocksTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsRocksTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<RocksTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new RocksTTCMutSetCreateEffect(id);
    }
    public void EffectRocksTTCMutSetDelete(int id) {
      var effect = InternalEffectRocksTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public RocksTTCMutSetDeleteEffect InternalEffectRocksTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsRocksTTCMutSet[id];
      rootIncarnation.incarnationsRocksTTCMutSet.Remove(id);
      return new RocksTTCMutSetDeleteEffect(id);
    }

       
    public void EffectRocksTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasRocksTTCMutSet(instanceId);
      CheckHasRocksTTC(element);
      var effect = InternalEffectRocksTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public RocksTTCMutSetAddEffect InternalEffectRocksTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsRocksTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new RocksTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsRocksTTCMutSet[instanceId] =
            new VersionAndIncarnation<RocksTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new RocksTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectRocksTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasRocksTTCMutSet(instanceId);
      CheckHasRocksTTC(element);
      var effect = InternalEffectRocksTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public RocksTTCMutSetRemoveEffect InternalEffectRocksTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsRocksTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new RocksTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsRocksTTCMutSet[instanceId] =
            new VersionAndIncarnation<RocksTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new RocksTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetTreeTTCMutSetHash(int id, int version, TreeTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public TreeTTCMutSetIncarnation GetTreeTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsTreeTTCMutSet[id].incarnation;
    }
    public TreeTTCMutSet GetTreeTTCMutSet(int id) {
      return new TreeTTCMutSet(this, id);
    }
    public List<TreeTTCMutSet> AllTreeTTCMutSet() {
      List<TreeTTCMutSet> result = new List<TreeTTCMutSet>(rootIncarnation.incarnationsTreeTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsTreeTTCMutSet.Keys) {
        result.Add(new TreeTTCMutSet(this, id));
      }
      return result;
    }
    public bool TreeTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsTreeTTCMutSet.ContainsKey(id);
    }
    public void CheckHasTreeTTCMutSet(TreeTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasTreeTTCMutSet(thing.id);
    }
    public void CheckHasTreeTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsTreeTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid TreeTTCMutSet}: " + id);
      }
    }
    public TreeTTCMutSet EffectTreeTTCMutSetCreate() {
      return TrustedEffectTreeTTCMutSetCreateWithId(NewId());
    }
    public TreeTTCMutSet TrustedEffectTreeTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new TreeTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateTreeTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new TreeTTCMutSet(this, id);
    }
    public TreeTTCMutSetCreateEffect InternalEffectCreateTreeTTCMutSet(int id, int incarnationVersion, TreeTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsTreeTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<TreeTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new TreeTTCMutSetCreateEffect(id);
    }
    public void EffectTreeTTCMutSetDelete(int id) {
      var effect = InternalEffectTreeTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public TreeTTCMutSetDeleteEffect InternalEffectTreeTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsTreeTTCMutSet[id];
      rootIncarnation.incarnationsTreeTTCMutSet.Remove(id);
      return new TreeTTCMutSetDeleteEffect(id);
    }

       
    public void EffectTreeTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasTreeTTCMutSet(instanceId);
      CheckHasTreeTTC(element);
      var effect = InternalEffectTreeTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public TreeTTCMutSetAddEffect InternalEffectTreeTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsTreeTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new TreeTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTreeTTCMutSet[instanceId] =
            new VersionAndIncarnation<TreeTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new TreeTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectTreeTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasTreeTTCMutSet(instanceId);
      CheckHasTreeTTC(element);
      var effect = InternalEffectTreeTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public TreeTTCMutSetRemoveEffect InternalEffectTreeTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsTreeTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new TreeTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTreeTTCMutSet[instanceId] =
            new VersionAndIncarnation<TreeTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new TreeTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetWaterTTCMutSetHash(int id, int version, WaterTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public WaterTTCMutSetIncarnation GetWaterTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsWaterTTCMutSet[id].incarnation;
    }
    public WaterTTCMutSet GetWaterTTCMutSet(int id) {
      return new WaterTTCMutSet(this, id);
    }
    public List<WaterTTCMutSet> AllWaterTTCMutSet() {
      List<WaterTTCMutSet> result = new List<WaterTTCMutSet>(rootIncarnation.incarnationsWaterTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsWaterTTCMutSet.Keys) {
        result.Add(new WaterTTCMutSet(this, id));
      }
      return result;
    }
    public bool WaterTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsWaterTTCMutSet.ContainsKey(id);
    }
    public void CheckHasWaterTTCMutSet(WaterTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasWaterTTCMutSet(thing.id);
    }
    public void CheckHasWaterTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsWaterTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid WaterTTCMutSet}: " + id);
      }
    }
    public WaterTTCMutSet EffectWaterTTCMutSetCreate() {
      return TrustedEffectWaterTTCMutSetCreateWithId(NewId());
    }
    public WaterTTCMutSet TrustedEffectWaterTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new WaterTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateWaterTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new WaterTTCMutSet(this, id);
    }
    public WaterTTCMutSetCreateEffect InternalEffectCreateWaterTTCMutSet(int id, int incarnationVersion, WaterTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsWaterTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<WaterTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new WaterTTCMutSetCreateEffect(id);
    }
    public void EffectWaterTTCMutSetDelete(int id) {
      var effect = InternalEffectWaterTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public WaterTTCMutSetDeleteEffect InternalEffectWaterTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsWaterTTCMutSet[id];
      rootIncarnation.incarnationsWaterTTCMutSet.Remove(id);
      return new WaterTTCMutSetDeleteEffect(id);
    }

       
    public void EffectWaterTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasWaterTTCMutSet(instanceId);
      CheckHasWaterTTC(element);
      var effect = InternalEffectWaterTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public WaterTTCMutSetAddEffect InternalEffectWaterTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsWaterTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new WaterTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsWaterTTCMutSet[instanceId] =
            new VersionAndIncarnation<WaterTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new WaterTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectWaterTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasWaterTTCMutSet(instanceId);
      CheckHasWaterTTC(element);
      var effect = InternalEffectWaterTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public WaterTTCMutSetRemoveEffect InternalEffectWaterTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsWaterTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new WaterTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsWaterTTCMutSet[instanceId] =
            new VersionAndIncarnation<WaterTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new WaterTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetFloorTTCMutSetHash(int id, int version, FloorTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public FloorTTCMutSetIncarnation GetFloorTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsFloorTTCMutSet[id].incarnation;
    }
    public FloorTTCMutSet GetFloorTTCMutSet(int id) {
      return new FloorTTCMutSet(this, id);
    }
    public List<FloorTTCMutSet> AllFloorTTCMutSet() {
      List<FloorTTCMutSet> result = new List<FloorTTCMutSet>(rootIncarnation.incarnationsFloorTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsFloorTTCMutSet.Keys) {
        result.Add(new FloorTTCMutSet(this, id));
      }
      return result;
    }
    public bool FloorTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsFloorTTCMutSet.ContainsKey(id);
    }
    public void CheckHasFloorTTCMutSet(FloorTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasFloorTTCMutSet(thing.id);
    }
    public void CheckHasFloorTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsFloorTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid FloorTTCMutSet}: " + id);
      }
    }
    public FloorTTCMutSet EffectFloorTTCMutSetCreate() {
      return TrustedEffectFloorTTCMutSetCreateWithId(NewId());
    }
    public FloorTTCMutSet TrustedEffectFloorTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new FloorTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateFloorTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new FloorTTCMutSet(this, id);
    }
    public FloorTTCMutSetCreateEffect InternalEffectCreateFloorTTCMutSet(int id, int incarnationVersion, FloorTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsFloorTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<FloorTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new FloorTTCMutSetCreateEffect(id);
    }
    public void EffectFloorTTCMutSetDelete(int id) {
      var effect = InternalEffectFloorTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public FloorTTCMutSetDeleteEffect InternalEffectFloorTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsFloorTTCMutSet[id];
      rootIncarnation.incarnationsFloorTTCMutSet.Remove(id);
      return new FloorTTCMutSetDeleteEffect(id);
    }

       
    public void EffectFloorTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasFloorTTCMutSet(instanceId);
      CheckHasFloorTTC(element);
      var effect = InternalEffectFloorTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public FloorTTCMutSetAddEffect InternalEffectFloorTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsFloorTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new FloorTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFloorTTCMutSet[instanceId] =
            new VersionAndIncarnation<FloorTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new FloorTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectFloorTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasFloorTTCMutSet(instanceId);
      CheckHasFloorTTC(element);
      var effect = InternalEffectFloorTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public FloorTTCMutSetRemoveEffect InternalEffectFloorTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsFloorTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new FloorTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFloorTTCMutSet[instanceId] =
            new VersionAndIncarnation<FloorTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new FloorTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetCaveWallTTCMutSetHash(int id, int version, CaveWallTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CaveWallTTCMutSetIncarnation GetCaveWallTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsCaveWallTTCMutSet[id].incarnation;
    }
    public CaveWallTTCMutSet GetCaveWallTTCMutSet(int id) {
      return new CaveWallTTCMutSet(this, id);
    }
    public List<CaveWallTTCMutSet> AllCaveWallTTCMutSet() {
      List<CaveWallTTCMutSet> result = new List<CaveWallTTCMutSet>(rootIncarnation.incarnationsCaveWallTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsCaveWallTTCMutSet.Keys) {
        result.Add(new CaveWallTTCMutSet(this, id));
      }
      return result;
    }
    public bool CaveWallTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsCaveWallTTCMutSet.ContainsKey(id);
    }
    public void CheckHasCaveWallTTCMutSet(CaveWallTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCaveWallTTCMutSet(thing.id);
    }
    public void CheckHasCaveWallTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsCaveWallTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid CaveWallTTCMutSet}: " + id);
      }
    }
    public CaveWallTTCMutSet EffectCaveWallTTCMutSetCreate() {
      return TrustedEffectCaveWallTTCMutSetCreateWithId(NewId());
    }
    public CaveWallTTCMutSet TrustedEffectCaveWallTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new CaveWallTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateCaveWallTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new CaveWallTTCMutSet(this, id);
    }
    public CaveWallTTCMutSetCreateEffect InternalEffectCreateCaveWallTTCMutSet(int id, int incarnationVersion, CaveWallTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsCaveWallTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<CaveWallTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new CaveWallTTCMutSetCreateEffect(id);
    }
    public void EffectCaveWallTTCMutSetDelete(int id) {
      var effect = InternalEffectCaveWallTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public CaveWallTTCMutSetDeleteEffect InternalEffectCaveWallTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsCaveWallTTCMutSet[id];
      rootIncarnation.incarnationsCaveWallTTCMutSet.Remove(id);
      return new CaveWallTTCMutSetDeleteEffect(id);
    }

       
    public void EffectCaveWallTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasCaveWallTTCMutSet(instanceId);
      CheckHasCaveWallTTC(element);
      var effect = InternalEffectCaveWallTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public CaveWallTTCMutSetAddEffect InternalEffectCaveWallTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsCaveWallTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new CaveWallTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCaveWallTTCMutSet[instanceId] =
            new VersionAndIncarnation<CaveWallTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new CaveWallTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectCaveWallTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasCaveWallTTCMutSet(instanceId);
      CheckHasCaveWallTTC(element);
      var effect = InternalEffectCaveWallTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public CaveWallTTCMutSetRemoveEffect InternalEffectCaveWallTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsCaveWallTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new CaveWallTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCaveWallTTCMutSet[instanceId] =
            new VersionAndIncarnation<CaveWallTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new CaveWallTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetCaveTTCMutSetHash(int id, int version, CaveTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CaveTTCMutSetIncarnation GetCaveTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsCaveTTCMutSet[id].incarnation;
    }
    public CaveTTCMutSet GetCaveTTCMutSet(int id) {
      return new CaveTTCMutSet(this, id);
    }
    public List<CaveTTCMutSet> AllCaveTTCMutSet() {
      List<CaveTTCMutSet> result = new List<CaveTTCMutSet>(rootIncarnation.incarnationsCaveTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsCaveTTCMutSet.Keys) {
        result.Add(new CaveTTCMutSet(this, id));
      }
      return result;
    }
    public bool CaveTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsCaveTTCMutSet.ContainsKey(id);
    }
    public void CheckHasCaveTTCMutSet(CaveTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCaveTTCMutSet(thing.id);
    }
    public void CheckHasCaveTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsCaveTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid CaveTTCMutSet}: " + id);
      }
    }
    public CaveTTCMutSet EffectCaveTTCMutSetCreate() {
      return TrustedEffectCaveTTCMutSetCreateWithId(NewId());
    }
    public CaveTTCMutSet TrustedEffectCaveTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new CaveTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateCaveTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new CaveTTCMutSet(this, id);
    }
    public CaveTTCMutSetCreateEffect InternalEffectCreateCaveTTCMutSet(int id, int incarnationVersion, CaveTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsCaveTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<CaveTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new CaveTTCMutSetCreateEffect(id);
    }
    public void EffectCaveTTCMutSetDelete(int id) {
      var effect = InternalEffectCaveTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public CaveTTCMutSetDeleteEffect InternalEffectCaveTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsCaveTTCMutSet[id];
      rootIncarnation.incarnationsCaveTTCMutSet.Remove(id);
      return new CaveTTCMutSetDeleteEffect(id);
    }

       
    public void EffectCaveTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasCaveTTCMutSet(instanceId);
      CheckHasCaveTTC(element);
      var effect = InternalEffectCaveTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public CaveTTCMutSetAddEffect InternalEffectCaveTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsCaveTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new CaveTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCaveTTCMutSet[instanceId] =
            new VersionAndIncarnation<CaveTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new CaveTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectCaveTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasCaveTTCMutSet(instanceId);
      CheckHasCaveTTC(element);
      var effect = InternalEffectCaveTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public CaveTTCMutSetRemoveEffect InternalEffectCaveTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsCaveTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new CaveTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCaveTTCMutSet[instanceId] =
            new VersionAndIncarnation<CaveTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new CaveTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetFallsTTCMutSetHash(int id, int version, FallsTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public FallsTTCMutSetIncarnation GetFallsTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsFallsTTCMutSet[id].incarnation;
    }
    public FallsTTCMutSet GetFallsTTCMutSet(int id) {
      return new FallsTTCMutSet(this, id);
    }
    public List<FallsTTCMutSet> AllFallsTTCMutSet() {
      List<FallsTTCMutSet> result = new List<FallsTTCMutSet>(rootIncarnation.incarnationsFallsTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsFallsTTCMutSet.Keys) {
        result.Add(new FallsTTCMutSet(this, id));
      }
      return result;
    }
    public bool FallsTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsFallsTTCMutSet.ContainsKey(id);
    }
    public void CheckHasFallsTTCMutSet(FallsTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasFallsTTCMutSet(thing.id);
    }
    public void CheckHasFallsTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsFallsTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid FallsTTCMutSet}: " + id);
      }
    }
    public FallsTTCMutSet EffectFallsTTCMutSetCreate() {
      return TrustedEffectFallsTTCMutSetCreateWithId(NewId());
    }
    public FallsTTCMutSet TrustedEffectFallsTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new FallsTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateFallsTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new FallsTTCMutSet(this, id);
    }
    public FallsTTCMutSetCreateEffect InternalEffectCreateFallsTTCMutSet(int id, int incarnationVersion, FallsTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsFallsTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<FallsTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new FallsTTCMutSetCreateEffect(id);
    }
    public void EffectFallsTTCMutSetDelete(int id) {
      var effect = InternalEffectFallsTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public FallsTTCMutSetDeleteEffect InternalEffectFallsTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsFallsTTCMutSet[id];
      rootIncarnation.incarnationsFallsTTCMutSet.Remove(id);
      return new FallsTTCMutSetDeleteEffect(id);
    }

       
    public void EffectFallsTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasFallsTTCMutSet(instanceId);
      CheckHasFallsTTC(element);
      var effect = InternalEffectFallsTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public FallsTTCMutSetAddEffect InternalEffectFallsTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsFallsTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new FallsTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFallsTTCMutSet[instanceId] =
            new VersionAndIncarnation<FallsTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new FallsTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectFallsTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasFallsTTCMutSet(instanceId);
      CheckHasFallsTTC(element);
      var effect = InternalEffectFallsTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public FallsTTCMutSetRemoveEffect InternalEffectFallsTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsFallsTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new FallsTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsFallsTTCMutSet[instanceId] =
            new VersionAndIncarnation<FallsTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new FallsTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetObsidianFloorTTCMutSetHash(int id, int version, ObsidianFloorTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ObsidianFloorTTCMutSetIncarnation GetObsidianFloorTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsObsidianFloorTTCMutSet[id].incarnation;
    }
    public ObsidianFloorTTCMutSet GetObsidianFloorTTCMutSet(int id) {
      return new ObsidianFloorTTCMutSet(this, id);
    }
    public List<ObsidianFloorTTCMutSet> AllObsidianFloorTTCMutSet() {
      List<ObsidianFloorTTCMutSet> result = new List<ObsidianFloorTTCMutSet>(rootIncarnation.incarnationsObsidianFloorTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsObsidianFloorTTCMutSet.Keys) {
        result.Add(new ObsidianFloorTTCMutSet(this, id));
      }
      return result;
    }
    public bool ObsidianFloorTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsObsidianFloorTTCMutSet.ContainsKey(id);
    }
    public void CheckHasObsidianFloorTTCMutSet(ObsidianFloorTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasObsidianFloorTTCMutSet(thing.id);
    }
    public void CheckHasObsidianFloorTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsObsidianFloorTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ObsidianFloorTTCMutSet}: " + id);
      }
    }
    public ObsidianFloorTTCMutSet EffectObsidianFloorTTCMutSetCreate() {
      return TrustedEffectObsidianFloorTTCMutSetCreateWithId(NewId());
    }
    public ObsidianFloorTTCMutSet TrustedEffectObsidianFloorTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new ObsidianFloorTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateObsidianFloorTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new ObsidianFloorTTCMutSet(this, id);
    }
    public ObsidianFloorTTCMutSetCreateEffect InternalEffectCreateObsidianFloorTTCMutSet(int id, int incarnationVersion, ObsidianFloorTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsObsidianFloorTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<ObsidianFloorTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new ObsidianFloorTTCMutSetCreateEffect(id);
    }
    public void EffectObsidianFloorTTCMutSetDelete(int id) {
      var effect = InternalEffectObsidianFloorTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public ObsidianFloorTTCMutSetDeleteEffect InternalEffectObsidianFloorTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsObsidianFloorTTCMutSet[id];
      rootIncarnation.incarnationsObsidianFloorTTCMutSet.Remove(id);
      return new ObsidianFloorTTCMutSetDeleteEffect(id);
    }

       
    public void EffectObsidianFloorTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasObsidianFloorTTCMutSet(instanceId);
      CheckHasObsidianFloorTTC(element);
      var effect = InternalEffectObsidianFloorTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public ObsidianFloorTTCMutSetAddEffect InternalEffectObsidianFloorTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsObsidianFloorTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new ObsidianFloorTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsObsidianFloorTTCMutSet[instanceId] =
            new VersionAndIncarnation<ObsidianFloorTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new ObsidianFloorTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectObsidianFloorTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasObsidianFloorTTCMutSet(instanceId);
      CheckHasObsidianFloorTTC(element);
      var effect = InternalEffectObsidianFloorTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public ObsidianFloorTTCMutSetRemoveEffect InternalEffectObsidianFloorTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsObsidianFloorTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ObsidianFloorTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsObsidianFloorTTCMutSet[instanceId] =
            new VersionAndIncarnation<ObsidianFloorTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new ObsidianFloorTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetMagmaTTCMutSetHash(int id, int version, MagmaTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public MagmaTTCMutSetIncarnation GetMagmaTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsMagmaTTCMutSet[id].incarnation;
    }
    public MagmaTTCMutSet GetMagmaTTCMutSet(int id) {
      return new MagmaTTCMutSet(this, id);
    }
    public List<MagmaTTCMutSet> AllMagmaTTCMutSet() {
      List<MagmaTTCMutSet> result = new List<MagmaTTCMutSet>(rootIncarnation.incarnationsMagmaTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsMagmaTTCMutSet.Keys) {
        result.Add(new MagmaTTCMutSet(this, id));
      }
      return result;
    }
    public bool MagmaTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsMagmaTTCMutSet.ContainsKey(id);
    }
    public void CheckHasMagmaTTCMutSet(MagmaTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasMagmaTTCMutSet(thing.id);
    }
    public void CheckHasMagmaTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsMagmaTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid MagmaTTCMutSet}: " + id);
      }
    }
    public MagmaTTCMutSet EffectMagmaTTCMutSetCreate() {
      return TrustedEffectMagmaTTCMutSetCreateWithId(NewId());
    }
    public MagmaTTCMutSet TrustedEffectMagmaTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new MagmaTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateMagmaTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new MagmaTTCMutSet(this, id);
    }
    public MagmaTTCMutSetCreateEffect InternalEffectCreateMagmaTTCMutSet(int id, int incarnationVersion, MagmaTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsMagmaTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<MagmaTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new MagmaTTCMutSetCreateEffect(id);
    }
    public void EffectMagmaTTCMutSetDelete(int id) {
      var effect = InternalEffectMagmaTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public MagmaTTCMutSetDeleteEffect InternalEffectMagmaTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsMagmaTTCMutSet[id];
      rootIncarnation.incarnationsMagmaTTCMutSet.Remove(id);
      return new MagmaTTCMutSetDeleteEffect(id);
    }

       
    public void EffectMagmaTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasMagmaTTCMutSet(instanceId);
      CheckHasMagmaTTC(element);
      var effect = InternalEffectMagmaTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public MagmaTTCMutSetAddEffect InternalEffectMagmaTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsMagmaTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new MagmaTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMagmaTTCMutSet[instanceId] =
            new VersionAndIncarnation<MagmaTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new MagmaTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectMagmaTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasMagmaTTCMutSet(instanceId);
      CheckHasMagmaTTC(element);
      var effect = InternalEffectMagmaTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public MagmaTTCMutSetRemoveEffect InternalEffectMagmaTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsMagmaTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new MagmaTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMagmaTTCMutSet[instanceId] =
            new VersionAndIncarnation<MagmaTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new MagmaTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetCliffTTCMutSetHash(int id, int version, CliffTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CliffTTCMutSetIncarnation GetCliffTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsCliffTTCMutSet[id].incarnation;
    }
    public CliffTTCMutSet GetCliffTTCMutSet(int id) {
      return new CliffTTCMutSet(this, id);
    }
    public List<CliffTTCMutSet> AllCliffTTCMutSet() {
      List<CliffTTCMutSet> result = new List<CliffTTCMutSet>(rootIncarnation.incarnationsCliffTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsCliffTTCMutSet.Keys) {
        result.Add(new CliffTTCMutSet(this, id));
      }
      return result;
    }
    public bool CliffTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsCliffTTCMutSet.ContainsKey(id);
    }
    public void CheckHasCliffTTCMutSet(CliffTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCliffTTCMutSet(thing.id);
    }
    public void CheckHasCliffTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsCliffTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid CliffTTCMutSet}: " + id);
      }
    }
    public CliffTTCMutSet EffectCliffTTCMutSetCreate() {
      return TrustedEffectCliffTTCMutSetCreateWithId(NewId());
    }
    public CliffTTCMutSet TrustedEffectCliffTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new CliffTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateCliffTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new CliffTTCMutSet(this, id);
    }
    public CliffTTCMutSetCreateEffect InternalEffectCreateCliffTTCMutSet(int id, int incarnationVersion, CliffTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsCliffTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<CliffTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new CliffTTCMutSetCreateEffect(id);
    }
    public void EffectCliffTTCMutSetDelete(int id) {
      var effect = InternalEffectCliffTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public CliffTTCMutSetDeleteEffect InternalEffectCliffTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsCliffTTCMutSet[id];
      rootIncarnation.incarnationsCliffTTCMutSet.Remove(id);
      return new CliffTTCMutSetDeleteEffect(id);
    }

       
    public void EffectCliffTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasCliffTTCMutSet(instanceId);
      CheckHasCliffTTC(element);
      var effect = InternalEffectCliffTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public CliffTTCMutSetAddEffect InternalEffectCliffTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsCliffTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new CliffTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCliffTTCMutSet[instanceId] =
            new VersionAndIncarnation<CliffTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new CliffTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectCliffTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasCliffTTCMutSet(instanceId);
      CheckHasCliffTTC(element);
      var effect = InternalEffectCliffTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public CliffTTCMutSetRemoveEffect InternalEffectCliffTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsCliffTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new CliffTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCliffTTCMutSet[instanceId] =
            new VersionAndIncarnation<CliffTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new CliffTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetRavaNestTTCMutSetHash(int id, int version, RavaNestTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public RavaNestTTCMutSetIncarnation GetRavaNestTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsRavaNestTTCMutSet[id].incarnation;
    }
    public RavaNestTTCMutSet GetRavaNestTTCMutSet(int id) {
      return new RavaNestTTCMutSet(this, id);
    }
    public List<RavaNestTTCMutSet> AllRavaNestTTCMutSet() {
      List<RavaNestTTCMutSet> result = new List<RavaNestTTCMutSet>(rootIncarnation.incarnationsRavaNestTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsRavaNestTTCMutSet.Keys) {
        result.Add(new RavaNestTTCMutSet(this, id));
      }
      return result;
    }
    public bool RavaNestTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsRavaNestTTCMutSet.ContainsKey(id);
    }
    public void CheckHasRavaNestTTCMutSet(RavaNestTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasRavaNestTTCMutSet(thing.id);
    }
    public void CheckHasRavaNestTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsRavaNestTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid RavaNestTTCMutSet}: " + id);
      }
    }
    public RavaNestTTCMutSet EffectRavaNestTTCMutSetCreate() {
      return TrustedEffectRavaNestTTCMutSetCreateWithId(NewId());
    }
    public RavaNestTTCMutSet TrustedEffectRavaNestTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new RavaNestTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateRavaNestTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new RavaNestTTCMutSet(this, id);
    }
    public RavaNestTTCMutSetCreateEffect InternalEffectCreateRavaNestTTCMutSet(int id, int incarnationVersion, RavaNestTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsRavaNestTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<RavaNestTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new RavaNestTTCMutSetCreateEffect(id);
    }
    public void EffectRavaNestTTCMutSetDelete(int id) {
      var effect = InternalEffectRavaNestTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public RavaNestTTCMutSetDeleteEffect InternalEffectRavaNestTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsRavaNestTTCMutSet[id];
      rootIncarnation.incarnationsRavaNestTTCMutSet.Remove(id);
      return new RavaNestTTCMutSetDeleteEffect(id);
    }

       
    public void EffectRavaNestTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasRavaNestTTCMutSet(instanceId);
      CheckHasRavaNestTTC(element);
      var effect = InternalEffectRavaNestTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public RavaNestTTCMutSetAddEffect InternalEffectRavaNestTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsRavaNestTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new RavaNestTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsRavaNestTTCMutSet[instanceId] =
            new VersionAndIncarnation<RavaNestTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new RavaNestTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectRavaNestTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasRavaNestTTCMutSet(instanceId);
      CheckHasRavaNestTTC(element);
      var effect = InternalEffectRavaNestTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public RavaNestTTCMutSetRemoveEffect InternalEffectRavaNestTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsRavaNestTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new RavaNestTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsRavaNestTTCMutSet[instanceId] =
            new VersionAndIncarnation<RavaNestTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new RavaNestTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetCliffLandingTTCMutSetHash(int id, int version, CliffLandingTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CliffLandingTTCMutSetIncarnation GetCliffLandingTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsCliffLandingTTCMutSet[id].incarnation;
    }
    public CliffLandingTTCMutSet GetCliffLandingTTCMutSet(int id) {
      return new CliffLandingTTCMutSet(this, id);
    }
    public List<CliffLandingTTCMutSet> AllCliffLandingTTCMutSet() {
      List<CliffLandingTTCMutSet> result = new List<CliffLandingTTCMutSet>(rootIncarnation.incarnationsCliffLandingTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsCliffLandingTTCMutSet.Keys) {
        result.Add(new CliffLandingTTCMutSet(this, id));
      }
      return result;
    }
    public bool CliffLandingTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsCliffLandingTTCMutSet.ContainsKey(id);
    }
    public void CheckHasCliffLandingTTCMutSet(CliffLandingTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCliffLandingTTCMutSet(thing.id);
    }
    public void CheckHasCliffLandingTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsCliffLandingTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid CliffLandingTTCMutSet}: " + id);
      }
    }
    public CliffLandingTTCMutSet EffectCliffLandingTTCMutSetCreate() {
      return TrustedEffectCliffLandingTTCMutSetCreateWithId(NewId());
    }
    public CliffLandingTTCMutSet TrustedEffectCliffLandingTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new CliffLandingTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateCliffLandingTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new CliffLandingTTCMutSet(this, id);
    }
    public CliffLandingTTCMutSetCreateEffect InternalEffectCreateCliffLandingTTCMutSet(int id, int incarnationVersion, CliffLandingTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsCliffLandingTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<CliffLandingTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new CliffLandingTTCMutSetCreateEffect(id);
    }
    public void EffectCliffLandingTTCMutSetDelete(int id) {
      var effect = InternalEffectCliffLandingTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public CliffLandingTTCMutSetDeleteEffect InternalEffectCliffLandingTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsCliffLandingTTCMutSet[id];
      rootIncarnation.incarnationsCliffLandingTTCMutSet.Remove(id);
      return new CliffLandingTTCMutSetDeleteEffect(id);
    }

       
    public void EffectCliffLandingTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasCliffLandingTTCMutSet(instanceId);
      CheckHasCliffLandingTTC(element);
      var effect = InternalEffectCliffLandingTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public CliffLandingTTCMutSetAddEffect InternalEffectCliffLandingTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsCliffLandingTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new CliffLandingTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCliffLandingTTCMutSet[instanceId] =
            new VersionAndIncarnation<CliffLandingTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new CliffLandingTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectCliffLandingTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasCliffLandingTTCMutSet(instanceId);
      CheckHasCliffLandingTTC(element);
      var effect = InternalEffectCliffLandingTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public CliffLandingTTCMutSetRemoveEffect InternalEffectCliffLandingTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsCliffLandingTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new CliffLandingTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCliffLandingTTCMutSet[instanceId] =
            new VersionAndIncarnation<CliffLandingTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new CliffLandingTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetStoneTTCMutSetHash(int id, int version, StoneTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public StoneTTCMutSetIncarnation GetStoneTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsStoneTTCMutSet[id].incarnation;
    }
    public StoneTTCMutSet GetStoneTTCMutSet(int id) {
      return new StoneTTCMutSet(this, id);
    }
    public List<StoneTTCMutSet> AllStoneTTCMutSet() {
      List<StoneTTCMutSet> result = new List<StoneTTCMutSet>(rootIncarnation.incarnationsStoneTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsStoneTTCMutSet.Keys) {
        result.Add(new StoneTTCMutSet(this, id));
      }
      return result;
    }
    public bool StoneTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsStoneTTCMutSet.ContainsKey(id);
    }
    public void CheckHasStoneTTCMutSet(StoneTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasStoneTTCMutSet(thing.id);
    }
    public void CheckHasStoneTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsStoneTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid StoneTTCMutSet}: " + id);
      }
    }
    public StoneTTCMutSet EffectStoneTTCMutSetCreate() {
      return TrustedEffectStoneTTCMutSetCreateWithId(NewId());
    }
    public StoneTTCMutSet TrustedEffectStoneTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new StoneTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateStoneTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new StoneTTCMutSet(this, id);
    }
    public StoneTTCMutSetCreateEffect InternalEffectCreateStoneTTCMutSet(int id, int incarnationVersion, StoneTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsStoneTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<StoneTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new StoneTTCMutSetCreateEffect(id);
    }
    public void EffectStoneTTCMutSetDelete(int id) {
      var effect = InternalEffectStoneTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public StoneTTCMutSetDeleteEffect InternalEffectStoneTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsStoneTTCMutSet[id];
      rootIncarnation.incarnationsStoneTTCMutSet.Remove(id);
      return new StoneTTCMutSetDeleteEffect(id);
    }

       
    public void EffectStoneTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasStoneTTCMutSet(instanceId);
      CheckHasStoneTTC(element);
      var effect = InternalEffectStoneTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public StoneTTCMutSetAddEffect InternalEffectStoneTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsStoneTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new StoneTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsStoneTTCMutSet[instanceId] =
            new VersionAndIncarnation<StoneTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new StoneTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectStoneTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasStoneTTCMutSet(instanceId);
      CheckHasStoneTTC(element);
      var effect = InternalEffectStoneTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public StoneTTCMutSetRemoveEffect InternalEffectStoneTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsStoneTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new StoneTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsStoneTTCMutSet[instanceId] =
            new VersionAndIncarnation<StoneTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new StoneTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetGrassTTCMutSetHash(int id, int version, GrassTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public GrassTTCMutSetIncarnation GetGrassTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsGrassTTCMutSet[id].incarnation;
    }
    public GrassTTCMutSet GetGrassTTCMutSet(int id) {
      return new GrassTTCMutSet(this, id);
    }
    public List<GrassTTCMutSet> AllGrassTTCMutSet() {
      List<GrassTTCMutSet> result = new List<GrassTTCMutSet>(rootIncarnation.incarnationsGrassTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsGrassTTCMutSet.Keys) {
        result.Add(new GrassTTCMutSet(this, id));
      }
      return result;
    }
    public bool GrassTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsGrassTTCMutSet.ContainsKey(id);
    }
    public void CheckHasGrassTTCMutSet(GrassTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasGrassTTCMutSet(thing.id);
    }
    public void CheckHasGrassTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsGrassTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid GrassTTCMutSet}: " + id);
      }
    }
    public GrassTTCMutSet EffectGrassTTCMutSetCreate() {
      return TrustedEffectGrassTTCMutSetCreateWithId(NewId());
    }
    public GrassTTCMutSet TrustedEffectGrassTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new GrassTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateGrassTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new GrassTTCMutSet(this, id);
    }
    public GrassTTCMutSetCreateEffect InternalEffectCreateGrassTTCMutSet(int id, int incarnationVersion, GrassTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsGrassTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<GrassTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new GrassTTCMutSetCreateEffect(id);
    }
    public void EffectGrassTTCMutSetDelete(int id) {
      var effect = InternalEffectGrassTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public GrassTTCMutSetDeleteEffect InternalEffectGrassTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsGrassTTCMutSet[id];
      rootIncarnation.incarnationsGrassTTCMutSet.Remove(id);
      return new GrassTTCMutSetDeleteEffect(id);
    }

       
    public void EffectGrassTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasGrassTTCMutSet(instanceId);
      CheckHasGrassTTC(element);
      var effect = InternalEffectGrassTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public GrassTTCMutSetAddEffect InternalEffectGrassTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsGrassTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new GrassTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsGrassTTCMutSet[instanceId] =
            new VersionAndIncarnation<GrassTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new GrassTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectGrassTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasGrassTTCMutSet(instanceId);
      CheckHasGrassTTC(element);
      var effect = InternalEffectGrassTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public GrassTTCMutSetRemoveEffect InternalEffectGrassTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsGrassTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new GrassTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsGrassTTCMutSet[instanceId] =
            new VersionAndIncarnation<GrassTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new GrassTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetEmberDeepLevelLinkerTTCMutSetHash(int id, int version, EmberDeepLevelLinkerTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public EmberDeepLevelLinkerTTCMutSetIncarnation GetEmberDeepLevelLinkerTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet[id].incarnation;
    }
    public EmberDeepLevelLinkerTTCMutSet GetEmberDeepLevelLinkerTTCMutSet(int id) {
      return new EmberDeepLevelLinkerTTCMutSet(this, id);
    }
    public List<EmberDeepLevelLinkerTTCMutSet> AllEmberDeepLevelLinkerTTCMutSet() {
      List<EmberDeepLevelLinkerTTCMutSet> result = new List<EmberDeepLevelLinkerTTCMutSet>(rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet.Keys) {
        result.Add(new EmberDeepLevelLinkerTTCMutSet(this, id));
      }
      return result;
    }
    public bool EmberDeepLevelLinkerTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet.ContainsKey(id);
    }
    public void CheckHasEmberDeepLevelLinkerTTCMutSet(EmberDeepLevelLinkerTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasEmberDeepLevelLinkerTTCMutSet(thing.id);
    }
    public void CheckHasEmberDeepLevelLinkerTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid EmberDeepLevelLinkerTTCMutSet}: " + id);
      }
    }
    public EmberDeepLevelLinkerTTCMutSet EffectEmberDeepLevelLinkerTTCMutSetCreate() {
      return TrustedEffectEmberDeepLevelLinkerTTCMutSetCreateWithId(NewId());
    }
    public EmberDeepLevelLinkerTTCMutSet TrustedEffectEmberDeepLevelLinkerTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new EmberDeepLevelLinkerTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateEmberDeepLevelLinkerTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new EmberDeepLevelLinkerTTCMutSet(this, id);
    }
    public EmberDeepLevelLinkerTTCMutSetCreateEffect InternalEffectCreateEmberDeepLevelLinkerTTCMutSet(int id, int incarnationVersion, EmberDeepLevelLinkerTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<EmberDeepLevelLinkerTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new EmberDeepLevelLinkerTTCMutSetCreateEffect(id);
    }
    public void EffectEmberDeepLevelLinkerTTCMutSetDelete(int id) {
      var effect = InternalEffectEmberDeepLevelLinkerTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public EmberDeepLevelLinkerTTCMutSetDeleteEffect InternalEffectEmberDeepLevelLinkerTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet[id];
      rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet.Remove(id);
      return new EmberDeepLevelLinkerTTCMutSetDeleteEffect(id);
    }

       
    public void EffectEmberDeepLevelLinkerTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasEmberDeepLevelLinkerTTCMutSet(instanceId);
      CheckHasEmberDeepLevelLinkerTTC(element);
      var effect = InternalEffectEmberDeepLevelLinkerTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public EmberDeepLevelLinkerTTCMutSetAddEffect InternalEffectEmberDeepLevelLinkerTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new EmberDeepLevelLinkerTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet[instanceId] =
            new VersionAndIncarnation<EmberDeepLevelLinkerTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new EmberDeepLevelLinkerTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectEmberDeepLevelLinkerTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasEmberDeepLevelLinkerTTCMutSet(instanceId);
      CheckHasEmberDeepLevelLinkerTTC(element);
      var effect = InternalEffectEmberDeepLevelLinkerTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public EmberDeepLevelLinkerTTCMutSetRemoveEffect InternalEffectEmberDeepLevelLinkerTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new EmberDeepLevelLinkerTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsEmberDeepLevelLinkerTTCMutSet[instanceId] =
            new VersionAndIncarnation<EmberDeepLevelLinkerTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new EmberDeepLevelLinkerTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetIncendianFallsLevelLinkerTTCMutSetHash(int id, int version, IncendianFallsLevelLinkerTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public IncendianFallsLevelLinkerTTCMutSetIncarnation GetIncendianFallsLevelLinkerTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet[id].incarnation;
    }
    public IncendianFallsLevelLinkerTTCMutSet GetIncendianFallsLevelLinkerTTCMutSet(int id) {
      return new IncendianFallsLevelLinkerTTCMutSet(this, id);
    }
    public List<IncendianFallsLevelLinkerTTCMutSet> AllIncendianFallsLevelLinkerTTCMutSet() {
      List<IncendianFallsLevelLinkerTTCMutSet> result = new List<IncendianFallsLevelLinkerTTCMutSet>(rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet.Keys) {
        result.Add(new IncendianFallsLevelLinkerTTCMutSet(this, id));
      }
      return result;
    }
    public bool IncendianFallsLevelLinkerTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet.ContainsKey(id);
    }
    public void CheckHasIncendianFallsLevelLinkerTTCMutSet(IncendianFallsLevelLinkerTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasIncendianFallsLevelLinkerTTCMutSet(thing.id);
    }
    public void CheckHasIncendianFallsLevelLinkerTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid IncendianFallsLevelLinkerTTCMutSet}: " + id);
      }
    }
    public IncendianFallsLevelLinkerTTCMutSet EffectIncendianFallsLevelLinkerTTCMutSetCreate() {
      return TrustedEffectIncendianFallsLevelLinkerTTCMutSetCreateWithId(NewId());
    }
    public IncendianFallsLevelLinkerTTCMutSet TrustedEffectIncendianFallsLevelLinkerTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new IncendianFallsLevelLinkerTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateIncendianFallsLevelLinkerTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new IncendianFallsLevelLinkerTTCMutSet(this, id);
    }
    public IncendianFallsLevelLinkerTTCMutSetCreateEffect InternalEffectCreateIncendianFallsLevelLinkerTTCMutSet(int id, int incarnationVersion, IncendianFallsLevelLinkerTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<IncendianFallsLevelLinkerTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new IncendianFallsLevelLinkerTTCMutSetCreateEffect(id);
    }
    public void EffectIncendianFallsLevelLinkerTTCMutSetDelete(int id) {
      var effect = InternalEffectIncendianFallsLevelLinkerTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public IncendianFallsLevelLinkerTTCMutSetDeleteEffect InternalEffectIncendianFallsLevelLinkerTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet[id];
      rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet.Remove(id);
      return new IncendianFallsLevelLinkerTTCMutSetDeleteEffect(id);
    }

       
    public void EffectIncendianFallsLevelLinkerTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasIncendianFallsLevelLinkerTTCMutSet(instanceId);
      CheckHasIncendianFallsLevelLinkerTTC(element);
      var effect = InternalEffectIncendianFallsLevelLinkerTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public IncendianFallsLevelLinkerTTCMutSetAddEffect InternalEffectIncendianFallsLevelLinkerTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new IncendianFallsLevelLinkerTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet[instanceId] =
            new VersionAndIncarnation<IncendianFallsLevelLinkerTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new IncendianFallsLevelLinkerTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectIncendianFallsLevelLinkerTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasIncendianFallsLevelLinkerTTCMutSet(instanceId);
      CheckHasIncendianFallsLevelLinkerTTC(element);
      var effect = InternalEffectIncendianFallsLevelLinkerTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public IncendianFallsLevelLinkerTTCMutSetRemoveEffect InternalEffectIncendianFallsLevelLinkerTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new IncendianFallsLevelLinkerTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsIncendianFallsLevelLinkerTTCMutSet[instanceId] =
            new VersionAndIncarnation<IncendianFallsLevelLinkerTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new IncendianFallsLevelLinkerTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetRavaArcanaLevelLinkerTTCMutSetHash(int id, int version, RavaArcanaLevelLinkerTTCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public RavaArcanaLevelLinkerTTCMutSetIncarnation GetRavaArcanaLevelLinkerTTCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet[id].incarnation;
    }
    public RavaArcanaLevelLinkerTTCMutSet GetRavaArcanaLevelLinkerTTCMutSet(int id) {
      return new RavaArcanaLevelLinkerTTCMutSet(this, id);
    }
    public List<RavaArcanaLevelLinkerTTCMutSet> AllRavaArcanaLevelLinkerTTCMutSet() {
      List<RavaArcanaLevelLinkerTTCMutSet> result = new List<RavaArcanaLevelLinkerTTCMutSet>(rootIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet.Keys) {
        result.Add(new RavaArcanaLevelLinkerTTCMutSet(this, id));
      }
      return result;
    }
    public bool RavaArcanaLevelLinkerTTCMutSetExists(int id) {
      return rootIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet.ContainsKey(id);
    }
    public void CheckHasRavaArcanaLevelLinkerTTCMutSet(RavaArcanaLevelLinkerTTCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasRavaArcanaLevelLinkerTTCMutSet(thing.id);
    }
    public void CheckHasRavaArcanaLevelLinkerTTCMutSet(int id) {
      if (!rootIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid RavaArcanaLevelLinkerTTCMutSet}: " + id);
      }
    }
    public RavaArcanaLevelLinkerTTCMutSet EffectRavaArcanaLevelLinkerTTCMutSetCreate() {
      return TrustedEffectRavaArcanaLevelLinkerTTCMutSetCreateWithId(NewId());
    }
    public RavaArcanaLevelLinkerTTCMutSet TrustedEffectRavaArcanaLevelLinkerTTCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new RavaArcanaLevelLinkerTTCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateRavaArcanaLevelLinkerTTCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new RavaArcanaLevelLinkerTTCMutSet(this, id);
    }
    public RavaArcanaLevelLinkerTTCMutSetCreateEffect InternalEffectCreateRavaArcanaLevelLinkerTTCMutSet(int id, int incarnationVersion, RavaArcanaLevelLinkerTTCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet
          .Add(
              id,
              new VersionAndIncarnation<RavaArcanaLevelLinkerTTCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new RavaArcanaLevelLinkerTTCMutSetCreateEffect(id);
    }
    public void EffectRavaArcanaLevelLinkerTTCMutSetDelete(int id) {
      var effect = InternalEffectRavaArcanaLevelLinkerTTCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public RavaArcanaLevelLinkerTTCMutSetDeleteEffect InternalEffectRavaArcanaLevelLinkerTTCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet[id];
      rootIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet.Remove(id);
      return new RavaArcanaLevelLinkerTTCMutSetDeleteEffect(id);
    }

       
    public void EffectRavaArcanaLevelLinkerTTCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasRavaArcanaLevelLinkerTTCMutSet(instanceId);
      CheckHasRavaArcanaLevelLinkerTTC(element);
      var effect = InternalEffectRavaArcanaLevelLinkerTTCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public RavaArcanaLevelLinkerTTCMutSetAddEffect InternalEffectRavaArcanaLevelLinkerTTCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new RavaArcanaLevelLinkerTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet[instanceId] =
            new VersionAndIncarnation<RavaArcanaLevelLinkerTTCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new RavaArcanaLevelLinkerTTCMutSetAddEffect(instanceId, element);
    }
    public void EffectRavaArcanaLevelLinkerTTCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasRavaArcanaLevelLinkerTTCMutSet(instanceId);
      CheckHasRavaArcanaLevelLinkerTTC(element);
      var effect = InternalEffectRavaArcanaLevelLinkerTTCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public RavaArcanaLevelLinkerTTCMutSetRemoveEffect InternalEffectRavaArcanaLevelLinkerTTCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new RavaArcanaLevelLinkerTTCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsRavaArcanaLevelLinkerTTCMutSet[instanceId] =
            new VersionAndIncarnation<RavaArcanaLevelLinkerTTCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new RavaArcanaLevelLinkerTTCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetDeathTriggerUCMutSetHash(int id, int version, DeathTriggerUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public DeathTriggerUCMutSetIncarnation GetDeathTriggerUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsDeathTriggerUCMutSet[id].incarnation;
    }
    public DeathTriggerUCMutSet GetDeathTriggerUCMutSet(int id) {
      return new DeathTriggerUCMutSet(this, id);
    }
    public List<DeathTriggerUCMutSet> AllDeathTriggerUCMutSet() {
      List<DeathTriggerUCMutSet> result = new List<DeathTriggerUCMutSet>(rootIncarnation.incarnationsDeathTriggerUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsDeathTriggerUCMutSet.Keys) {
        result.Add(new DeathTriggerUCMutSet(this, id));
      }
      return result;
    }
    public bool DeathTriggerUCMutSetExists(int id) {
      return rootIncarnation.incarnationsDeathTriggerUCMutSet.ContainsKey(id);
    }
    public void CheckHasDeathTriggerUCMutSet(DeathTriggerUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasDeathTriggerUCMutSet(thing.id);
    }
    public void CheckHasDeathTriggerUCMutSet(int id) {
      if (!rootIncarnation.incarnationsDeathTriggerUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid DeathTriggerUCMutSet}: " + id);
      }
    }
    public DeathTriggerUCMutSet EffectDeathTriggerUCMutSetCreate() {
      return TrustedEffectDeathTriggerUCMutSetCreateWithId(NewId());
    }
    public DeathTriggerUCMutSet TrustedEffectDeathTriggerUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new DeathTriggerUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateDeathTriggerUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new DeathTriggerUCMutSet(this, id);
    }
    public DeathTriggerUCMutSetCreateEffect InternalEffectCreateDeathTriggerUCMutSet(int id, int incarnationVersion, DeathTriggerUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsDeathTriggerUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<DeathTriggerUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new DeathTriggerUCMutSetCreateEffect(id);
    }
    public void EffectDeathTriggerUCMutSetDelete(int id) {
      var effect = InternalEffectDeathTriggerUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public DeathTriggerUCMutSetDeleteEffect InternalEffectDeathTriggerUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsDeathTriggerUCMutSet[id];
      rootIncarnation.incarnationsDeathTriggerUCMutSet.Remove(id);
      return new DeathTriggerUCMutSetDeleteEffect(id);
    }

       
    public void EffectDeathTriggerUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasDeathTriggerUCMutSet(instanceId);
      CheckHasDeathTriggerUC(element);
      var effect = InternalEffectDeathTriggerUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public DeathTriggerUCMutSetAddEffect InternalEffectDeathTriggerUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsDeathTriggerUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new DeathTriggerUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDeathTriggerUCMutSet[instanceId] =
            new VersionAndIncarnation<DeathTriggerUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new DeathTriggerUCMutSetAddEffect(instanceId, element);
    }
    public void EffectDeathTriggerUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasDeathTriggerUCMutSet(instanceId);
      CheckHasDeathTriggerUC(element);
      var effect = InternalEffectDeathTriggerUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public DeathTriggerUCMutSetRemoveEffect InternalEffectDeathTriggerUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsDeathTriggerUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new DeathTriggerUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDeathTriggerUCMutSet[instanceId] =
            new VersionAndIncarnation<DeathTriggerUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new DeathTriggerUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetBequeathUCMutSetHash(int id, int version, BequeathUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BequeathUCMutSetIncarnation GetBequeathUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBequeathUCMutSet[id].incarnation;
    }
    public BequeathUCMutSet GetBequeathUCMutSet(int id) {
      return new BequeathUCMutSet(this, id);
    }
    public List<BequeathUCMutSet> AllBequeathUCMutSet() {
      List<BequeathUCMutSet> result = new List<BequeathUCMutSet>(rootIncarnation.incarnationsBequeathUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBequeathUCMutSet.Keys) {
        result.Add(new BequeathUCMutSet(this, id));
      }
      return result;
    }
    public bool BequeathUCMutSetExists(int id) {
      return rootIncarnation.incarnationsBequeathUCMutSet.ContainsKey(id);
    }
    public void CheckHasBequeathUCMutSet(BequeathUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBequeathUCMutSet(thing.id);
    }
    public void CheckHasBequeathUCMutSet(int id) {
      if (!rootIncarnation.incarnationsBequeathUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BequeathUCMutSet}: " + id);
      }
    }
    public BequeathUCMutSet EffectBequeathUCMutSetCreate() {
      return TrustedEffectBequeathUCMutSetCreateWithId(NewId());
    }
    public BequeathUCMutSet TrustedEffectBequeathUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BequeathUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateBequeathUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new BequeathUCMutSet(this, id);
    }
    public BequeathUCMutSetCreateEffect InternalEffectCreateBequeathUCMutSet(int id, int incarnationVersion, BequeathUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsBequeathUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<BequeathUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new BequeathUCMutSetCreateEffect(id);
    }
    public void EffectBequeathUCMutSetDelete(int id) {
      var effect = InternalEffectBequeathUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public BequeathUCMutSetDeleteEffect InternalEffectBequeathUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsBequeathUCMutSet[id];
      rootIncarnation.incarnationsBequeathUCMutSet.Remove(id);
      return new BequeathUCMutSetDeleteEffect(id);
    }

       
    public void EffectBequeathUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBequeathUCMutSet(instanceId);
      CheckHasBequeathUC(element);
      var effect = InternalEffectBequeathUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public BequeathUCMutSetAddEffect InternalEffectBequeathUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBequeathUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BequeathUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBequeathUCMutSet[instanceId] =
            new VersionAndIncarnation<BequeathUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new BequeathUCMutSetAddEffect(instanceId, element);
    }
    public void EffectBequeathUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBequeathUCMutSet(instanceId);
      CheckHasBequeathUC(element);
      var effect = InternalEffectBequeathUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public BequeathUCMutSetRemoveEffect InternalEffectBequeathUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBequeathUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BequeathUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBequeathUCMutSet[instanceId] =
            new VersionAndIncarnation<BequeathUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new BequeathUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetTutorialDefyCounterUCMutSetHash(int id, int version, TutorialDefyCounterUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public TutorialDefyCounterUCMutSetIncarnation GetTutorialDefyCounterUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsTutorialDefyCounterUCMutSet[id].incarnation;
    }
    public TutorialDefyCounterUCMutSet GetTutorialDefyCounterUCMutSet(int id) {
      return new TutorialDefyCounterUCMutSet(this, id);
    }
    public List<TutorialDefyCounterUCMutSet> AllTutorialDefyCounterUCMutSet() {
      List<TutorialDefyCounterUCMutSet> result = new List<TutorialDefyCounterUCMutSet>(rootIncarnation.incarnationsTutorialDefyCounterUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsTutorialDefyCounterUCMutSet.Keys) {
        result.Add(new TutorialDefyCounterUCMutSet(this, id));
      }
      return result;
    }
    public bool TutorialDefyCounterUCMutSetExists(int id) {
      return rootIncarnation.incarnationsTutorialDefyCounterUCMutSet.ContainsKey(id);
    }
    public void CheckHasTutorialDefyCounterUCMutSet(TutorialDefyCounterUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasTutorialDefyCounterUCMutSet(thing.id);
    }
    public void CheckHasTutorialDefyCounterUCMutSet(int id) {
      if (!rootIncarnation.incarnationsTutorialDefyCounterUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid TutorialDefyCounterUCMutSet}: " + id);
      }
    }
    public TutorialDefyCounterUCMutSet EffectTutorialDefyCounterUCMutSetCreate() {
      return TrustedEffectTutorialDefyCounterUCMutSetCreateWithId(NewId());
    }
    public TutorialDefyCounterUCMutSet TrustedEffectTutorialDefyCounterUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new TutorialDefyCounterUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateTutorialDefyCounterUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new TutorialDefyCounterUCMutSet(this, id);
    }
    public TutorialDefyCounterUCMutSetCreateEffect InternalEffectCreateTutorialDefyCounterUCMutSet(int id, int incarnationVersion, TutorialDefyCounterUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsTutorialDefyCounterUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<TutorialDefyCounterUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new TutorialDefyCounterUCMutSetCreateEffect(id);
    }
    public void EffectTutorialDefyCounterUCMutSetDelete(int id) {
      var effect = InternalEffectTutorialDefyCounterUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public TutorialDefyCounterUCMutSetDeleteEffect InternalEffectTutorialDefyCounterUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsTutorialDefyCounterUCMutSet[id];
      rootIncarnation.incarnationsTutorialDefyCounterUCMutSet.Remove(id);
      return new TutorialDefyCounterUCMutSetDeleteEffect(id);
    }

       
    public void EffectTutorialDefyCounterUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasTutorialDefyCounterUCMutSet(instanceId);
      CheckHasTutorialDefyCounterUC(element);
      var effect = InternalEffectTutorialDefyCounterUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public TutorialDefyCounterUCMutSetAddEffect InternalEffectTutorialDefyCounterUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsTutorialDefyCounterUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new TutorialDefyCounterUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTutorialDefyCounterUCMutSet[instanceId] =
            new VersionAndIncarnation<TutorialDefyCounterUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new TutorialDefyCounterUCMutSetAddEffect(instanceId, element);
    }
    public void EffectTutorialDefyCounterUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasTutorialDefyCounterUCMutSet(instanceId);
      CheckHasTutorialDefyCounterUC(element);
      var effect = InternalEffectTutorialDefyCounterUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public TutorialDefyCounterUCMutSetRemoveEffect InternalEffectTutorialDefyCounterUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsTutorialDefyCounterUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new TutorialDefyCounterUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTutorialDefyCounterUCMutSet[instanceId] =
            new VersionAndIncarnation<TutorialDefyCounterUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new TutorialDefyCounterUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetLightningChargingUCMutSetHash(int id, int version, LightningChargingUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public LightningChargingUCMutSetIncarnation GetLightningChargingUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsLightningChargingUCMutSet[id].incarnation;
    }
    public LightningChargingUCMutSet GetLightningChargingUCMutSet(int id) {
      return new LightningChargingUCMutSet(this, id);
    }
    public List<LightningChargingUCMutSet> AllLightningChargingUCMutSet() {
      List<LightningChargingUCMutSet> result = new List<LightningChargingUCMutSet>(rootIncarnation.incarnationsLightningChargingUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsLightningChargingUCMutSet.Keys) {
        result.Add(new LightningChargingUCMutSet(this, id));
      }
      return result;
    }
    public bool LightningChargingUCMutSetExists(int id) {
      return rootIncarnation.incarnationsLightningChargingUCMutSet.ContainsKey(id);
    }
    public void CheckHasLightningChargingUCMutSet(LightningChargingUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasLightningChargingUCMutSet(thing.id);
    }
    public void CheckHasLightningChargingUCMutSet(int id) {
      if (!rootIncarnation.incarnationsLightningChargingUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid LightningChargingUCMutSet}: " + id);
      }
    }
    public LightningChargingUCMutSet EffectLightningChargingUCMutSetCreate() {
      return TrustedEffectLightningChargingUCMutSetCreateWithId(NewId());
    }
    public LightningChargingUCMutSet TrustedEffectLightningChargingUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new LightningChargingUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateLightningChargingUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new LightningChargingUCMutSet(this, id);
    }
    public LightningChargingUCMutSetCreateEffect InternalEffectCreateLightningChargingUCMutSet(int id, int incarnationVersion, LightningChargingUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsLightningChargingUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<LightningChargingUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new LightningChargingUCMutSetCreateEffect(id);
    }
    public void EffectLightningChargingUCMutSetDelete(int id) {
      var effect = InternalEffectLightningChargingUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public LightningChargingUCMutSetDeleteEffect InternalEffectLightningChargingUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsLightningChargingUCMutSet[id];
      rootIncarnation.incarnationsLightningChargingUCMutSet.Remove(id);
      return new LightningChargingUCMutSetDeleteEffect(id);
    }

       
    public void EffectLightningChargingUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasLightningChargingUCMutSet(instanceId);
      CheckHasLightningChargingUC(element);
      var effect = InternalEffectLightningChargingUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public LightningChargingUCMutSetAddEffect InternalEffectLightningChargingUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsLightningChargingUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new LightningChargingUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLightningChargingUCMutSet[instanceId] =
            new VersionAndIncarnation<LightningChargingUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new LightningChargingUCMutSetAddEffect(instanceId, element);
    }
    public void EffectLightningChargingUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasLightningChargingUCMutSet(instanceId);
      CheckHasLightningChargingUC(element);
      var effect = InternalEffectLightningChargingUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public LightningChargingUCMutSetRemoveEffect InternalEffectLightningChargingUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsLightningChargingUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new LightningChargingUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLightningChargingUCMutSet[instanceId] =
            new VersionAndIncarnation<LightningChargingUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new LightningChargingUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetWanderAICapabilityUCMutSetHash(int id, int version, WanderAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public WanderAICapabilityUCMutSetIncarnation GetWanderAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsWanderAICapabilityUCMutSet[id].incarnation;
    }
    public WanderAICapabilityUCMutSet GetWanderAICapabilityUCMutSet(int id) {
      return new WanderAICapabilityUCMutSet(this, id);
    }
    public List<WanderAICapabilityUCMutSet> AllWanderAICapabilityUCMutSet() {
      List<WanderAICapabilityUCMutSet> result = new List<WanderAICapabilityUCMutSet>(rootIncarnation.incarnationsWanderAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsWanderAICapabilityUCMutSet.Keys) {
        result.Add(new WanderAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool WanderAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsWanderAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasWanderAICapabilityUCMutSet(WanderAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasWanderAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasWanderAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsWanderAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid WanderAICapabilityUCMutSet}: " + id);
      }
    }
    public WanderAICapabilityUCMutSet EffectWanderAICapabilityUCMutSetCreate() {
      return TrustedEffectWanderAICapabilityUCMutSetCreateWithId(NewId());
    }
    public WanderAICapabilityUCMutSet TrustedEffectWanderAICapabilityUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new WanderAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateWanderAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new WanderAICapabilityUCMutSet(this, id);
    }
    public WanderAICapabilityUCMutSetCreateEffect InternalEffectCreateWanderAICapabilityUCMutSet(int id, int incarnationVersion, WanderAICapabilityUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsWanderAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<WanderAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new WanderAICapabilityUCMutSetCreateEffect(id);
    }
    public void EffectWanderAICapabilityUCMutSetDelete(int id) {
      var effect = InternalEffectWanderAICapabilityUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public WanderAICapabilityUCMutSetDeleteEffect InternalEffectWanderAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsWanderAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsWanderAICapabilityUCMutSet.Remove(id);
      return new WanderAICapabilityUCMutSetDeleteEffect(id);
    }

       
    public void EffectWanderAICapabilityUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasWanderAICapabilityUCMutSet(instanceId);
      CheckHasWanderAICapabilityUC(element);
      var effect = InternalEffectWanderAICapabilityUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public WanderAICapabilityUCMutSetAddEffect InternalEffectWanderAICapabilityUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsWanderAICapabilityUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new WanderAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsWanderAICapabilityUCMutSet[instanceId] =
            new VersionAndIncarnation<WanderAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new WanderAICapabilityUCMutSetAddEffect(instanceId, element);
    }
    public void EffectWanderAICapabilityUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasWanderAICapabilityUCMutSet(instanceId);
      CheckHasWanderAICapabilityUC(element);
      var effect = InternalEffectWanderAICapabilityUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public WanderAICapabilityUCMutSetRemoveEffect InternalEffectWanderAICapabilityUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsWanderAICapabilityUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new WanderAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsWanderAICapabilityUCMutSet[instanceId] =
            new VersionAndIncarnation<WanderAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new WanderAICapabilityUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetTemporaryCloneAICapabilityUCMutSetHash(int id, int version, TemporaryCloneAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public TemporaryCloneAICapabilityUCMutSetIncarnation GetTemporaryCloneAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet[id].incarnation;
    }
    public TemporaryCloneAICapabilityUCMutSet GetTemporaryCloneAICapabilityUCMutSet(int id) {
      return new TemporaryCloneAICapabilityUCMutSet(this, id);
    }
    public List<TemporaryCloneAICapabilityUCMutSet> AllTemporaryCloneAICapabilityUCMutSet() {
      List<TemporaryCloneAICapabilityUCMutSet> result = new List<TemporaryCloneAICapabilityUCMutSet>(rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet.Keys) {
        result.Add(new TemporaryCloneAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool TemporaryCloneAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasTemporaryCloneAICapabilityUCMutSet(TemporaryCloneAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasTemporaryCloneAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasTemporaryCloneAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid TemporaryCloneAICapabilityUCMutSet}: " + id);
      }
    }
    public TemporaryCloneAICapabilityUCMutSet EffectTemporaryCloneAICapabilityUCMutSetCreate() {
      return TrustedEffectTemporaryCloneAICapabilityUCMutSetCreateWithId(NewId());
    }
    public TemporaryCloneAICapabilityUCMutSet TrustedEffectTemporaryCloneAICapabilityUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new TemporaryCloneAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateTemporaryCloneAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new TemporaryCloneAICapabilityUCMutSet(this, id);
    }
    public TemporaryCloneAICapabilityUCMutSetCreateEffect InternalEffectCreateTemporaryCloneAICapabilityUCMutSet(int id, int incarnationVersion, TemporaryCloneAICapabilityUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<TemporaryCloneAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new TemporaryCloneAICapabilityUCMutSetCreateEffect(id);
    }
    public void EffectTemporaryCloneAICapabilityUCMutSetDelete(int id) {
      var effect = InternalEffectTemporaryCloneAICapabilityUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public TemporaryCloneAICapabilityUCMutSetDeleteEffect InternalEffectTemporaryCloneAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet.Remove(id);
      return new TemporaryCloneAICapabilityUCMutSetDeleteEffect(id);
    }

       
    public void EffectTemporaryCloneAICapabilityUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasTemporaryCloneAICapabilityUCMutSet(instanceId);
      CheckHasTemporaryCloneAICapabilityUC(element);
      var effect = InternalEffectTemporaryCloneAICapabilityUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public TemporaryCloneAICapabilityUCMutSetAddEffect InternalEffectTemporaryCloneAICapabilityUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new TemporaryCloneAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet[instanceId] =
            new VersionAndIncarnation<TemporaryCloneAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new TemporaryCloneAICapabilityUCMutSetAddEffect(instanceId, element);
    }
    public void EffectTemporaryCloneAICapabilityUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasTemporaryCloneAICapabilityUCMutSet(instanceId);
      CheckHasTemporaryCloneAICapabilityUC(element);
      var effect = InternalEffectTemporaryCloneAICapabilityUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public TemporaryCloneAICapabilityUCMutSetRemoveEffect InternalEffectTemporaryCloneAICapabilityUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new TemporaryCloneAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTemporaryCloneAICapabilityUCMutSet[instanceId] =
            new VersionAndIncarnation<TemporaryCloneAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new TemporaryCloneAICapabilityUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetSummonAICapabilityUCMutSetHash(int id, int version, SummonAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public SummonAICapabilityUCMutSetIncarnation GetSummonAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsSummonAICapabilityUCMutSet[id].incarnation;
    }
    public SummonAICapabilityUCMutSet GetSummonAICapabilityUCMutSet(int id) {
      return new SummonAICapabilityUCMutSet(this, id);
    }
    public List<SummonAICapabilityUCMutSet> AllSummonAICapabilityUCMutSet() {
      List<SummonAICapabilityUCMutSet> result = new List<SummonAICapabilityUCMutSet>(rootIncarnation.incarnationsSummonAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsSummonAICapabilityUCMutSet.Keys) {
        result.Add(new SummonAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool SummonAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsSummonAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasSummonAICapabilityUCMutSet(SummonAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasSummonAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasSummonAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsSummonAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid SummonAICapabilityUCMutSet}: " + id);
      }
    }
    public SummonAICapabilityUCMutSet EffectSummonAICapabilityUCMutSetCreate() {
      return TrustedEffectSummonAICapabilityUCMutSetCreateWithId(NewId());
    }
    public SummonAICapabilityUCMutSet TrustedEffectSummonAICapabilityUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new SummonAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateSummonAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new SummonAICapabilityUCMutSet(this, id);
    }
    public SummonAICapabilityUCMutSetCreateEffect InternalEffectCreateSummonAICapabilityUCMutSet(int id, int incarnationVersion, SummonAICapabilityUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsSummonAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<SummonAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new SummonAICapabilityUCMutSetCreateEffect(id);
    }
    public void EffectSummonAICapabilityUCMutSetDelete(int id) {
      var effect = InternalEffectSummonAICapabilityUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public SummonAICapabilityUCMutSetDeleteEffect InternalEffectSummonAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsSummonAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsSummonAICapabilityUCMutSet.Remove(id);
      return new SummonAICapabilityUCMutSetDeleteEffect(id);
    }

       
    public void EffectSummonAICapabilityUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasSummonAICapabilityUCMutSet(instanceId);
      CheckHasSummonAICapabilityUC(element);
      var effect = InternalEffectSummonAICapabilityUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public SummonAICapabilityUCMutSetAddEffect InternalEffectSummonAICapabilityUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsSummonAICapabilityUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new SummonAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSummonAICapabilityUCMutSet[instanceId] =
            new VersionAndIncarnation<SummonAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new SummonAICapabilityUCMutSetAddEffect(instanceId, element);
    }
    public void EffectSummonAICapabilityUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasSummonAICapabilityUCMutSet(instanceId);
      CheckHasSummonAICapabilityUC(element);
      var effect = InternalEffectSummonAICapabilityUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public SummonAICapabilityUCMutSetRemoveEffect InternalEffectSummonAICapabilityUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsSummonAICapabilityUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new SummonAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSummonAICapabilityUCMutSet[instanceId] =
            new VersionAndIncarnation<SummonAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new SummonAICapabilityUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetKamikazeAICapabilityUCMutSetHash(int id, int version, KamikazeAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public KamikazeAICapabilityUCMutSetIncarnation GetKamikazeAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet[id].incarnation;
    }
    public KamikazeAICapabilityUCMutSet GetKamikazeAICapabilityUCMutSet(int id) {
      return new KamikazeAICapabilityUCMutSet(this, id);
    }
    public List<KamikazeAICapabilityUCMutSet> AllKamikazeAICapabilityUCMutSet() {
      List<KamikazeAICapabilityUCMutSet> result = new List<KamikazeAICapabilityUCMutSet>(rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet.Keys) {
        result.Add(new KamikazeAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool KamikazeAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasKamikazeAICapabilityUCMutSet(KamikazeAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasKamikazeAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasKamikazeAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid KamikazeAICapabilityUCMutSet}: " + id);
      }
    }
    public KamikazeAICapabilityUCMutSet EffectKamikazeAICapabilityUCMutSetCreate() {
      return TrustedEffectKamikazeAICapabilityUCMutSetCreateWithId(NewId());
    }
    public KamikazeAICapabilityUCMutSet TrustedEffectKamikazeAICapabilityUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new KamikazeAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateKamikazeAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new KamikazeAICapabilityUCMutSet(this, id);
    }
    public KamikazeAICapabilityUCMutSetCreateEffect InternalEffectCreateKamikazeAICapabilityUCMutSet(int id, int incarnationVersion, KamikazeAICapabilityUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<KamikazeAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new KamikazeAICapabilityUCMutSetCreateEffect(id);
    }
    public void EffectKamikazeAICapabilityUCMutSetDelete(int id) {
      var effect = InternalEffectKamikazeAICapabilityUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public KamikazeAICapabilityUCMutSetDeleteEffect InternalEffectKamikazeAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet.Remove(id);
      return new KamikazeAICapabilityUCMutSetDeleteEffect(id);
    }

       
    public void EffectKamikazeAICapabilityUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasKamikazeAICapabilityUCMutSet(instanceId);
      CheckHasKamikazeAICapabilityUC(element);
      var effect = InternalEffectKamikazeAICapabilityUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public KamikazeAICapabilityUCMutSetAddEffect InternalEffectKamikazeAICapabilityUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new KamikazeAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet[instanceId] =
            new VersionAndIncarnation<KamikazeAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new KamikazeAICapabilityUCMutSetAddEffect(instanceId, element);
    }
    public void EffectKamikazeAICapabilityUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasKamikazeAICapabilityUCMutSet(instanceId);
      CheckHasKamikazeAICapabilityUC(element);
      var effect = InternalEffectKamikazeAICapabilityUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public KamikazeAICapabilityUCMutSetRemoveEffect InternalEffectKamikazeAICapabilityUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new KamikazeAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsKamikazeAICapabilityUCMutSet[instanceId] =
            new VersionAndIncarnation<KamikazeAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new KamikazeAICapabilityUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetGuardAICapabilityUCMutSetHash(int id, int version, GuardAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public GuardAICapabilityUCMutSetIncarnation GetGuardAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsGuardAICapabilityUCMutSet[id].incarnation;
    }
    public GuardAICapabilityUCMutSet GetGuardAICapabilityUCMutSet(int id) {
      return new GuardAICapabilityUCMutSet(this, id);
    }
    public List<GuardAICapabilityUCMutSet> AllGuardAICapabilityUCMutSet() {
      List<GuardAICapabilityUCMutSet> result = new List<GuardAICapabilityUCMutSet>(rootIncarnation.incarnationsGuardAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsGuardAICapabilityUCMutSet.Keys) {
        result.Add(new GuardAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool GuardAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsGuardAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasGuardAICapabilityUCMutSet(GuardAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasGuardAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasGuardAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsGuardAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid GuardAICapabilityUCMutSet}: " + id);
      }
    }
    public GuardAICapabilityUCMutSet EffectGuardAICapabilityUCMutSetCreate() {
      return TrustedEffectGuardAICapabilityUCMutSetCreateWithId(NewId());
    }
    public GuardAICapabilityUCMutSet TrustedEffectGuardAICapabilityUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new GuardAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateGuardAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new GuardAICapabilityUCMutSet(this, id);
    }
    public GuardAICapabilityUCMutSetCreateEffect InternalEffectCreateGuardAICapabilityUCMutSet(int id, int incarnationVersion, GuardAICapabilityUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsGuardAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<GuardAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new GuardAICapabilityUCMutSetCreateEffect(id);
    }
    public void EffectGuardAICapabilityUCMutSetDelete(int id) {
      var effect = InternalEffectGuardAICapabilityUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public GuardAICapabilityUCMutSetDeleteEffect InternalEffectGuardAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsGuardAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsGuardAICapabilityUCMutSet.Remove(id);
      return new GuardAICapabilityUCMutSetDeleteEffect(id);
    }

       
    public void EffectGuardAICapabilityUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasGuardAICapabilityUCMutSet(instanceId);
      CheckHasGuardAICapabilityUC(element);
      var effect = InternalEffectGuardAICapabilityUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public GuardAICapabilityUCMutSetAddEffect InternalEffectGuardAICapabilityUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsGuardAICapabilityUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new GuardAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsGuardAICapabilityUCMutSet[instanceId] =
            new VersionAndIncarnation<GuardAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new GuardAICapabilityUCMutSetAddEffect(instanceId, element);
    }
    public void EffectGuardAICapabilityUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasGuardAICapabilityUCMutSet(instanceId);
      CheckHasGuardAICapabilityUC(element);
      var effect = InternalEffectGuardAICapabilityUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public GuardAICapabilityUCMutSetRemoveEffect InternalEffectGuardAICapabilityUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsGuardAICapabilityUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new GuardAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsGuardAICapabilityUCMutSet[instanceId] =
            new VersionAndIncarnation<GuardAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new GuardAICapabilityUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetEvolvifyAICapabilityUCMutSetHash(int id, int version, EvolvifyAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public EvolvifyAICapabilityUCMutSetIncarnation GetEvolvifyAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsEvolvifyAICapabilityUCMutSet[id].incarnation;
    }
    public EvolvifyAICapabilityUCMutSet GetEvolvifyAICapabilityUCMutSet(int id) {
      return new EvolvifyAICapabilityUCMutSet(this, id);
    }
    public List<EvolvifyAICapabilityUCMutSet> AllEvolvifyAICapabilityUCMutSet() {
      List<EvolvifyAICapabilityUCMutSet> result = new List<EvolvifyAICapabilityUCMutSet>(rootIncarnation.incarnationsEvolvifyAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsEvolvifyAICapabilityUCMutSet.Keys) {
        result.Add(new EvolvifyAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool EvolvifyAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsEvolvifyAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasEvolvifyAICapabilityUCMutSet(EvolvifyAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasEvolvifyAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasEvolvifyAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsEvolvifyAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid EvolvifyAICapabilityUCMutSet}: " + id);
      }
    }
    public EvolvifyAICapabilityUCMutSet EffectEvolvifyAICapabilityUCMutSetCreate() {
      return TrustedEffectEvolvifyAICapabilityUCMutSetCreateWithId(NewId());
    }
    public EvolvifyAICapabilityUCMutSet TrustedEffectEvolvifyAICapabilityUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new EvolvifyAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateEvolvifyAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new EvolvifyAICapabilityUCMutSet(this, id);
    }
    public EvolvifyAICapabilityUCMutSetCreateEffect InternalEffectCreateEvolvifyAICapabilityUCMutSet(int id, int incarnationVersion, EvolvifyAICapabilityUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsEvolvifyAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<EvolvifyAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new EvolvifyAICapabilityUCMutSetCreateEffect(id);
    }
    public void EffectEvolvifyAICapabilityUCMutSetDelete(int id) {
      var effect = InternalEffectEvolvifyAICapabilityUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public EvolvifyAICapabilityUCMutSetDeleteEffect InternalEffectEvolvifyAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsEvolvifyAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsEvolvifyAICapabilityUCMutSet.Remove(id);
      return new EvolvifyAICapabilityUCMutSetDeleteEffect(id);
    }

       
    public void EffectEvolvifyAICapabilityUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasEvolvifyAICapabilityUCMutSet(instanceId);
      CheckHasEvolvifyAICapabilityUC(element);
      var effect = InternalEffectEvolvifyAICapabilityUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public EvolvifyAICapabilityUCMutSetAddEffect InternalEffectEvolvifyAICapabilityUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsEvolvifyAICapabilityUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new EvolvifyAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsEvolvifyAICapabilityUCMutSet[instanceId] =
            new VersionAndIncarnation<EvolvifyAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new EvolvifyAICapabilityUCMutSetAddEffect(instanceId, element);
    }
    public void EffectEvolvifyAICapabilityUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasEvolvifyAICapabilityUCMutSet(instanceId);
      CheckHasEvolvifyAICapabilityUC(element);
      var effect = InternalEffectEvolvifyAICapabilityUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public EvolvifyAICapabilityUCMutSetRemoveEffect InternalEffectEvolvifyAICapabilityUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsEvolvifyAICapabilityUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new EvolvifyAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsEvolvifyAICapabilityUCMutSet[instanceId] =
            new VersionAndIncarnation<EvolvifyAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new EvolvifyAICapabilityUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetTimeCloneAICapabilityUCMutSetHash(int id, int version, TimeCloneAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public TimeCloneAICapabilityUCMutSetIncarnation GetTimeCloneAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[id].incarnation;
    }
    public TimeCloneAICapabilityUCMutSet GetTimeCloneAICapabilityUCMutSet(int id) {
      return new TimeCloneAICapabilityUCMutSet(this, id);
    }
    public List<TimeCloneAICapabilityUCMutSet> AllTimeCloneAICapabilityUCMutSet() {
      List<TimeCloneAICapabilityUCMutSet> result = new List<TimeCloneAICapabilityUCMutSet>(rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.Keys) {
        result.Add(new TimeCloneAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool TimeCloneAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasTimeCloneAICapabilityUCMutSet(TimeCloneAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasTimeCloneAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasTimeCloneAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid TimeCloneAICapabilityUCMutSet}: " + id);
      }
    }
    public TimeCloneAICapabilityUCMutSet EffectTimeCloneAICapabilityUCMutSetCreate() {
      return TrustedEffectTimeCloneAICapabilityUCMutSetCreateWithId(NewId());
    }
    public TimeCloneAICapabilityUCMutSet TrustedEffectTimeCloneAICapabilityUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new TimeCloneAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateTimeCloneAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new TimeCloneAICapabilityUCMutSet(this, id);
    }
    public TimeCloneAICapabilityUCMutSetCreateEffect InternalEffectCreateTimeCloneAICapabilityUCMutSet(int id, int incarnationVersion, TimeCloneAICapabilityUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<TimeCloneAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new TimeCloneAICapabilityUCMutSetCreateEffect(id);
    }
    public void EffectTimeCloneAICapabilityUCMutSetDelete(int id) {
      var effect = InternalEffectTimeCloneAICapabilityUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public TimeCloneAICapabilityUCMutSetDeleteEffect InternalEffectTimeCloneAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet.Remove(id);
      return new TimeCloneAICapabilityUCMutSetDeleteEffect(id);
    }

       
    public void EffectTimeCloneAICapabilityUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasTimeCloneAICapabilityUCMutSet(instanceId);
      CheckHasTimeCloneAICapabilityUC(element);
      var effect = InternalEffectTimeCloneAICapabilityUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public TimeCloneAICapabilityUCMutSetAddEffect InternalEffectTimeCloneAICapabilityUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new TimeCloneAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[instanceId] =
            new VersionAndIncarnation<TimeCloneAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new TimeCloneAICapabilityUCMutSetAddEffect(instanceId, element);
    }
    public void EffectTimeCloneAICapabilityUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasTimeCloneAICapabilityUCMutSet(instanceId);
      CheckHasTimeCloneAICapabilityUC(element);
      var effect = InternalEffectTimeCloneAICapabilityUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public TimeCloneAICapabilityUCMutSetRemoveEffect InternalEffectTimeCloneAICapabilityUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new TimeCloneAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsTimeCloneAICapabilityUCMutSet[instanceId] =
            new VersionAndIncarnation<TimeCloneAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new TimeCloneAICapabilityUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetDoomedUCMutSetHash(int id, int version, DoomedUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public DoomedUCMutSetIncarnation GetDoomedUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsDoomedUCMutSet[id].incarnation;
    }
    public DoomedUCMutSet GetDoomedUCMutSet(int id) {
      return new DoomedUCMutSet(this, id);
    }
    public List<DoomedUCMutSet> AllDoomedUCMutSet() {
      List<DoomedUCMutSet> result = new List<DoomedUCMutSet>(rootIncarnation.incarnationsDoomedUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsDoomedUCMutSet.Keys) {
        result.Add(new DoomedUCMutSet(this, id));
      }
      return result;
    }
    public bool DoomedUCMutSetExists(int id) {
      return rootIncarnation.incarnationsDoomedUCMutSet.ContainsKey(id);
    }
    public void CheckHasDoomedUCMutSet(DoomedUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasDoomedUCMutSet(thing.id);
    }
    public void CheckHasDoomedUCMutSet(int id) {
      if (!rootIncarnation.incarnationsDoomedUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid DoomedUCMutSet}: " + id);
      }
    }
    public DoomedUCMutSet EffectDoomedUCMutSetCreate() {
      return TrustedEffectDoomedUCMutSetCreateWithId(NewId());
    }
    public DoomedUCMutSet TrustedEffectDoomedUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new DoomedUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateDoomedUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new DoomedUCMutSet(this, id);
    }
    public DoomedUCMutSetCreateEffect InternalEffectCreateDoomedUCMutSet(int id, int incarnationVersion, DoomedUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsDoomedUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<DoomedUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new DoomedUCMutSetCreateEffect(id);
    }
    public void EffectDoomedUCMutSetDelete(int id) {
      var effect = InternalEffectDoomedUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public DoomedUCMutSetDeleteEffect InternalEffectDoomedUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsDoomedUCMutSet[id];
      rootIncarnation.incarnationsDoomedUCMutSet.Remove(id);
      return new DoomedUCMutSetDeleteEffect(id);
    }

       
    public void EffectDoomedUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasDoomedUCMutSet(instanceId);
      CheckHasDoomedUC(element);
      var effect = InternalEffectDoomedUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public DoomedUCMutSetAddEffect InternalEffectDoomedUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsDoomedUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new DoomedUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDoomedUCMutSet[instanceId] =
            new VersionAndIncarnation<DoomedUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new DoomedUCMutSetAddEffect(instanceId, element);
    }
    public void EffectDoomedUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasDoomedUCMutSet(instanceId);
      CheckHasDoomedUC(element);
      var effect = InternalEffectDoomedUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public DoomedUCMutSetRemoveEffect InternalEffectDoomedUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsDoomedUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new DoomedUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDoomedUCMutSet[instanceId] =
            new VersionAndIncarnation<DoomedUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new DoomedUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetMiredUCMutSetHash(int id, int version, MiredUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public MiredUCMutSetIncarnation GetMiredUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsMiredUCMutSet[id].incarnation;
    }
    public MiredUCMutSet GetMiredUCMutSet(int id) {
      return new MiredUCMutSet(this, id);
    }
    public List<MiredUCMutSet> AllMiredUCMutSet() {
      List<MiredUCMutSet> result = new List<MiredUCMutSet>(rootIncarnation.incarnationsMiredUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsMiredUCMutSet.Keys) {
        result.Add(new MiredUCMutSet(this, id));
      }
      return result;
    }
    public bool MiredUCMutSetExists(int id) {
      return rootIncarnation.incarnationsMiredUCMutSet.ContainsKey(id);
    }
    public void CheckHasMiredUCMutSet(MiredUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasMiredUCMutSet(thing.id);
    }
    public void CheckHasMiredUCMutSet(int id) {
      if (!rootIncarnation.incarnationsMiredUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid MiredUCMutSet}: " + id);
      }
    }
    public MiredUCMutSet EffectMiredUCMutSetCreate() {
      return TrustedEffectMiredUCMutSetCreateWithId(NewId());
    }
    public MiredUCMutSet TrustedEffectMiredUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new MiredUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateMiredUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new MiredUCMutSet(this, id);
    }
    public MiredUCMutSetCreateEffect InternalEffectCreateMiredUCMutSet(int id, int incarnationVersion, MiredUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsMiredUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<MiredUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new MiredUCMutSetCreateEffect(id);
    }
    public void EffectMiredUCMutSetDelete(int id) {
      var effect = InternalEffectMiredUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public MiredUCMutSetDeleteEffect InternalEffectMiredUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsMiredUCMutSet[id];
      rootIncarnation.incarnationsMiredUCMutSet.Remove(id);
      return new MiredUCMutSetDeleteEffect(id);
    }

       
    public void EffectMiredUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasMiredUCMutSet(instanceId);
      CheckHasMiredUC(element);
      var effect = InternalEffectMiredUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public MiredUCMutSetAddEffect InternalEffectMiredUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsMiredUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new MiredUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMiredUCMutSet[instanceId] =
            new VersionAndIncarnation<MiredUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new MiredUCMutSetAddEffect(instanceId, element);
    }
    public void EffectMiredUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasMiredUCMutSet(instanceId);
      CheckHasMiredUC(element);
      var effect = InternalEffectMiredUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public MiredUCMutSetRemoveEffect InternalEffectMiredUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsMiredUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new MiredUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsMiredUCMutSet[instanceId] =
            new VersionAndIncarnation<MiredUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new MiredUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetOnFireUCMutSetHash(int id, int version, OnFireUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public OnFireUCMutSetIncarnation GetOnFireUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsOnFireUCMutSet[id].incarnation;
    }
    public OnFireUCMutSet GetOnFireUCMutSet(int id) {
      return new OnFireUCMutSet(this, id);
    }
    public List<OnFireUCMutSet> AllOnFireUCMutSet() {
      List<OnFireUCMutSet> result = new List<OnFireUCMutSet>(rootIncarnation.incarnationsOnFireUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsOnFireUCMutSet.Keys) {
        result.Add(new OnFireUCMutSet(this, id));
      }
      return result;
    }
    public bool OnFireUCMutSetExists(int id) {
      return rootIncarnation.incarnationsOnFireUCMutSet.ContainsKey(id);
    }
    public void CheckHasOnFireUCMutSet(OnFireUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasOnFireUCMutSet(thing.id);
    }
    public void CheckHasOnFireUCMutSet(int id) {
      if (!rootIncarnation.incarnationsOnFireUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid OnFireUCMutSet}: " + id);
      }
    }
    public OnFireUCMutSet EffectOnFireUCMutSetCreate() {
      return TrustedEffectOnFireUCMutSetCreateWithId(NewId());
    }
    public OnFireUCMutSet TrustedEffectOnFireUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new OnFireUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateOnFireUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new OnFireUCMutSet(this, id);
    }
    public OnFireUCMutSetCreateEffect InternalEffectCreateOnFireUCMutSet(int id, int incarnationVersion, OnFireUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsOnFireUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<OnFireUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new OnFireUCMutSetCreateEffect(id);
    }
    public void EffectOnFireUCMutSetDelete(int id) {
      var effect = InternalEffectOnFireUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public OnFireUCMutSetDeleteEffect InternalEffectOnFireUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsOnFireUCMutSet[id];
      rootIncarnation.incarnationsOnFireUCMutSet.Remove(id);
      return new OnFireUCMutSetDeleteEffect(id);
    }

       
    public void EffectOnFireUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasOnFireUCMutSet(instanceId);
      CheckHasOnFireUC(element);
      var effect = InternalEffectOnFireUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public OnFireUCMutSetAddEffect InternalEffectOnFireUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsOnFireUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new OnFireUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsOnFireUCMutSet[instanceId] =
            new VersionAndIncarnation<OnFireUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new OnFireUCMutSetAddEffect(instanceId, element);
    }
    public void EffectOnFireUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasOnFireUCMutSet(instanceId);
      CheckHasOnFireUC(element);
      var effect = InternalEffectOnFireUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public OnFireUCMutSetRemoveEffect InternalEffectOnFireUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsOnFireUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new OnFireUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsOnFireUCMutSet[instanceId] =
            new VersionAndIncarnation<OnFireUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new OnFireUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetAttackAICapabilityUCMutSetHash(int id, int version, AttackAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public AttackAICapabilityUCMutSetIncarnation GetAttackAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsAttackAICapabilityUCMutSet[id].incarnation;
    }
    public AttackAICapabilityUCMutSet GetAttackAICapabilityUCMutSet(int id) {
      return new AttackAICapabilityUCMutSet(this, id);
    }
    public List<AttackAICapabilityUCMutSet> AllAttackAICapabilityUCMutSet() {
      List<AttackAICapabilityUCMutSet> result = new List<AttackAICapabilityUCMutSet>(rootIncarnation.incarnationsAttackAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsAttackAICapabilityUCMutSet.Keys) {
        result.Add(new AttackAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool AttackAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsAttackAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasAttackAICapabilityUCMutSet(AttackAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasAttackAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasAttackAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsAttackAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid AttackAICapabilityUCMutSet}: " + id);
      }
    }
    public AttackAICapabilityUCMutSet EffectAttackAICapabilityUCMutSetCreate() {
      return TrustedEffectAttackAICapabilityUCMutSetCreateWithId(NewId());
    }
    public AttackAICapabilityUCMutSet TrustedEffectAttackAICapabilityUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new AttackAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateAttackAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new AttackAICapabilityUCMutSet(this, id);
    }
    public AttackAICapabilityUCMutSetCreateEffect InternalEffectCreateAttackAICapabilityUCMutSet(int id, int incarnationVersion, AttackAICapabilityUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsAttackAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<AttackAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new AttackAICapabilityUCMutSetCreateEffect(id);
    }
    public void EffectAttackAICapabilityUCMutSetDelete(int id) {
      var effect = InternalEffectAttackAICapabilityUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public AttackAICapabilityUCMutSetDeleteEffect InternalEffectAttackAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsAttackAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsAttackAICapabilityUCMutSet.Remove(id);
      return new AttackAICapabilityUCMutSetDeleteEffect(id);
    }

       
    public void EffectAttackAICapabilityUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasAttackAICapabilityUCMutSet(instanceId);
      CheckHasAttackAICapabilityUC(element);
      var effect = InternalEffectAttackAICapabilityUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public AttackAICapabilityUCMutSetAddEffect InternalEffectAttackAICapabilityUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsAttackAICapabilityUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new AttackAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsAttackAICapabilityUCMutSet[instanceId] =
            new VersionAndIncarnation<AttackAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new AttackAICapabilityUCMutSetAddEffect(instanceId, element);
    }
    public void EffectAttackAICapabilityUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasAttackAICapabilityUCMutSet(instanceId);
      CheckHasAttackAICapabilityUC(element);
      var effect = InternalEffectAttackAICapabilityUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public AttackAICapabilityUCMutSetRemoveEffect InternalEffectAttackAICapabilityUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsAttackAICapabilityUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new AttackAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsAttackAICapabilityUCMutSet[instanceId] =
            new VersionAndIncarnation<AttackAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new AttackAICapabilityUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetCounteringUCMutSetHash(int id, int version, CounteringUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public CounteringUCMutSetIncarnation GetCounteringUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsCounteringUCMutSet[id].incarnation;
    }
    public CounteringUCMutSet GetCounteringUCMutSet(int id) {
      return new CounteringUCMutSet(this, id);
    }
    public List<CounteringUCMutSet> AllCounteringUCMutSet() {
      List<CounteringUCMutSet> result = new List<CounteringUCMutSet>(rootIncarnation.incarnationsCounteringUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsCounteringUCMutSet.Keys) {
        result.Add(new CounteringUCMutSet(this, id));
      }
      return result;
    }
    public bool CounteringUCMutSetExists(int id) {
      return rootIncarnation.incarnationsCounteringUCMutSet.ContainsKey(id);
    }
    public void CheckHasCounteringUCMutSet(CounteringUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasCounteringUCMutSet(thing.id);
    }
    public void CheckHasCounteringUCMutSet(int id) {
      if (!rootIncarnation.incarnationsCounteringUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid CounteringUCMutSet}: " + id);
      }
    }
    public CounteringUCMutSet EffectCounteringUCMutSetCreate() {
      return TrustedEffectCounteringUCMutSetCreateWithId(NewId());
    }
    public CounteringUCMutSet TrustedEffectCounteringUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new CounteringUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateCounteringUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new CounteringUCMutSet(this, id);
    }
    public CounteringUCMutSetCreateEffect InternalEffectCreateCounteringUCMutSet(int id, int incarnationVersion, CounteringUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsCounteringUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<CounteringUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new CounteringUCMutSetCreateEffect(id);
    }
    public void EffectCounteringUCMutSetDelete(int id) {
      var effect = InternalEffectCounteringUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public CounteringUCMutSetDeleteEffect InternalEffectCounteringUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsCounteringUCMutSet[id];
      rootIncarnation.incarnationsCounteringUCMutSet.Remove(id);
      return new CounteringUCMutSetDeleteEffect(id);
    }

       
    public void EffectCounteringUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasCounteringUCMutSet(instanceId);
      CheckHasCounteringUC(element);
      var effect = InternalEffectCounteringUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public CounteringUCMutSetAddEffect InternalEffectCounteringUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsCounteringUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new CounteringUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCounteringUCMutSet[instanceId] =
            new VersionAndIncarnation<CounteringUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new CounteringUCMutSetAddEffect(instanceId, element);
    }
    public void EffectCounteringUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasCounteringUCMutSet(instanceId);
      CheckHasCounteringUC(element);
      var effect = InternalEffectCounteringUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public CounteringUCMutSetRemoveEffect InternalEffectCounteringUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsCounteringUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new CounteringUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsCounteringUCMutSet[instanceId] =
            new VersionAndIncarnation<CounteringUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new CounteringUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetLightningChargedUCMutSetHash(int id, int version, LightningChargedUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public LightningChargedUCMutSetIncarnation GetLightningChargedUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsLightningChargedUCMutSet[id].incarnation;
    }
    public LightningChargedUCMutSet GetLightningChargedUCMutSet(int id) {
      return new LightningChargedUCMutSet(this, id);
    }
    public List<LightningChargedUCMutSet> AllLightningChargedUCMutSet() {
      List<LightningChargedUCMutSet> result = new List<LightningChargedUCMutSet>(rootIncarnation.incarnationsLightningChargedUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsLightningChargedUCMutSet.Keys) {
        result.Add(new LightningChargedUCMutSet(this, id));
      }
      return result;
    }
    public bool LightningChargedUCMutSetExists(int id) {
      return rootIncarnation.incarnationsLightningChargedUCMutSet.ContainsKey(id);
    }
    public void CheckHasLightningChargedUCMutSet(LightningChargedUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasLightningChargedUCMutSet(thing.id);
    }
    public void CheckHasLightningChargedUCMutSet(int id) {
      if (!rootIncarnation.incarnationsLightningChargedUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid LightningChargedUCMutSet}: " + id);
      }
    }
    public LightningChargedUCMutSet EffectLightningChargedUCMutSetCreate() {
      return TrustedEffectLightningChargedUCMutSetCreateWithId(NewId());
    }
    public LightningChargedUCMutSet TrustedEffectLightningChargedUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new LightningChargedUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateLightningChargedUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new LightningChargedUCMutSet(this, id);
    }
    public LightningChargedUCMutSetCreateEffect InternalEffectCreateLightningChargedUCMutSet(int id, int incarnationVersion, LightningChargedUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsLightningChargedUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<LightningChargedUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new LightningChargedUCMutSetCreateEffect(id);
    }
    public void EffectLightningChargedUCMutSetDelete(int id) {
      var effect = InternalEffectLightningChargedUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public LightningChargedUCMutSetDeleteEffect InternalEffectLightningChargedUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsLightningChargedUCMutSet[id];
      rootIncarnation.incarnationsLightningChargedUCMutSet.Remove(id);
      return new LightningChargedUCMutSetDeleteEffect(id);
    }

       
    public void EffectLightningChargedUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasLightningChargedUCMutSet(instanceId);
      CheckHasLightningChargedUC(element);
      var effect = InternalEffectLightningChargedUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public LightningChargedUCMutSetAddEffect InternalEffectLightningChargedUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsLightningChargedUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new LightningChargedUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLightningChargedUCMutSet[instanceId] =
            new VersionAndIncarnation<LightningChargedUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new LightningChargedUCMutSetAddEffect(instanceId, element);
    }
    public void EffectLightningChargedUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasLightningChargedUCMutSet(instanceId);
      CheckHasLightningChargedUC(element);
      var effect = InternalEffectLightningChargedUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public LightningChargedUCMutSetRemoveEffect InternalEffectLightningChargedUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsLightningChargedUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new LightningChargedUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsLightningChargedUCMutSet[instanceId] =
            new VersionAndIncarnation<LightningChargedUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new LightningChargedUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetInvincibilityUCMutSetHash(int id, int version, InvincibilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public InvincibilityUCMutSetIncarnation GetInvincibilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsInvincibilityUCMutSet[id].incarnation;
    }
    public InvincibilityUCMutSet GetInvincibilityUCMutSet(int id) {
      return new InvincibilityUCMutSet(this, id);
    }
    public List<InvincibilityUCMutSet> AllInvincibilityUCMutSet() {
      List<InvincibilityUCMutSet> result = new List<InvincibilityUCMutSet>(rootIncarnation.incarnationsInvincibilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsInvincibilityUCMutSet.Keys) {
        result.Add(new InvincibilityUCMutSet(this, id));
      }
      return result;
    }
    public bool InvincibilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsInvincibilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasInvincibilityUCMutSet(InvincibilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasInvincibilityUCMutSet(thing.id);
    }
    public void CheckHasInvincibilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsInvincibilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid InvincibilityUCMutSet}: " + id);
      }
    }
    public InvincibilityUCMutSet EffectInvincibilityUCMutSetCreate() {
      return TrustedEffectInvincibilityUCMutSetCreateWithId(NewId());
    }
    public InvincibilityUCMutSet TrustedEffectInvincibilityUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new InvincibilityUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateInvincibilityUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new InvincibilityUCMutSet(this, id);
    }
    public InvincibilityUCMutSetCreateEffect InternalEffectCreateInvincibilityUCMutSet(int id, int incarnationVersion, InvincibilityUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsInvincibilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<InvincibilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new InvincibilityUCMutSetCreateEffect(id);
    }
    public void EffectInvincibilityUCMutSetDelete(int id) {
      var effect = InternalEffectInvincibilityUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public InvincibilityUCMutSetDeleteEffect InternalEffectInvincibilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsInvincibilityUCMutSet[id];
      rootIncarnation.incarnationsInvincibilityUCMutSet.Remove(id);
      return new InvincibilityUCMutSetDeleteEffect(id);
    }

       
    public void EffectInvincibilityUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasInvincibilityUCMutSet(instanceId);
      CheckHasInvincibilityUC(element);
      var effect = InternalEffectInvincibilityUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public InvincibilityUCMutSetAddEffect InternalEffectInvincibilityUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsInvincibilityUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new InvincibilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsInvincibilityUCMutSet[instanceId] =
            new VersionAndIncarnation<InvincibilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new InvincibilityUCMutSetAddEffect(instanceId, element);
    }
    public void EffectInvincibilityUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasInvincibilityUCMutSet(instanceId);
      CheckHasInvincibilityUC(element);
      var effect = InternalEffectInvincibilityUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public InvincibilityUCMutSetRemoveEffect InternalEffectInvincibilityUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsInvincibilityUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new InvincibilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsInvincibilityUCMutSet[instanceId] =
            new VersionAndIncarnation<InvincibilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new InvincibilityUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetDefyingUCMutSetHash(int id, int version, DefyingUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public DefyingUCMutSetIncarnation GetDefyingUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsDefyingUCMutSet[id].incarnation;
    }
    public DefyingUCMutSet GetDefyingUCMutSet(int id) {
      return new DefyingUCMutSet(this, id);
    }
    public List<DefyingUCMutSet> AllDefyingUCMutSet() {
      List<DefyingUCMutSet> result = new List<DefyingUCMutSet>(rootIncarnation.incarnationsDefyingUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsDefyingUCMutSet.Keys) {
        result.Add(new DefyingUCMutSet(this, id));
      }
      return result;
    }
    public bool DefyingUCMutSetExists(int id) {
      return rootIncarnation.incarnationsDefyingUCMutSet.ContainsKey(id);
    }
    public void CheckHasDefyingUCMutSet(DefyingUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasDefyingUCMutSet(thing.id);
    }
    public void CheckHasDefyingUCMutSet(int id) {
      if (!rootIncarnation.incarnationsDefyingUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid DefyingUCMutSet}: " + id);
      }
    }
    public DefyingUCMutSet EffectDefyingUCMutSetCreate() {
      return TrustedEffectDefyingUCMutSetCreateWithId(NewId());
    }
    public DefyingUCMutSet TrustedEffectDefyingUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new DefyingUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateDefyingUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new DefyingUCMutSet(this, id);
    }
    public DefyingUCMutSetCreateEffect InternalEffectCreateDefyingUCMutSet(int id, int incarnationVersion, DefyingUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsDefyingUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<DefyingUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new DefyingUCMutSetCreateEffect(id);
    }
    public void EffectDefyingUCMutSetDelete(int id) {
      var effect = InternalEffectDefyingUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public DefyingUCMutSetDeleteEffect InternalEffectDefyingUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsDefyingUCMutSet[id];
      rootIncarnation.incarnationsDefyingUCMutSet.Remove(id);
      return new DefyingUCMutSetDeleteEffect(id);
    }

       
    public void EffectDefyingUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasDefyingUCMutSet(instanceId);
      CheckHasDefyingUC(element);
      var effect = InternalEffectDefyingUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public DefyingUCMutSetAddEffect InternalEffectDefyingUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsDefyingUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new DefyingUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDefyingUCMutSet[instanceId] =
            new VersionAndIncarnation<DefyingUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new DefyingUCMutSetAddEffect(instanceId, element);
    }
    public void EffectDefyingUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasDefyingUCMutSet(instanceId);
      CheckHasDefyingUC(element);
      var effect = InternalEffectDefyingUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public DefyingUCMutSetRemoveEffect InternalEffectDefyingUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsDefyingUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new DefyingUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsDefyingUCMutSet[instanceId] =
            new VersionAndIncarnation<DefyingUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new DefyingUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetBideAICapabilityUCMutSetHash(int id, int version, BideAICapabilityUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BideAICapabilityUCMutSetIncarnation GetBideAICapabilityUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBideAICapabilityUCMutSet[id].incarnation;
    }
    public BideAICapabilityUCMutSet GetBideAICapabilityUCMutSet(int id) {
      return new BideAICapabilityUCMutSet(this, id);
    }
    public List<BideAICapabilityUCMutSet> AllBideAICapabilityUCMutSet() {
      List<BideAICapabilityUCMutSet> result = new List<BideAICapabilityUCMutSet>(rootIncarnation.incarnationsBideAICapabilityUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBideAICapabilityUCMutSet.Keys) {
        result.Add(new BideAICapabilityUCMutSet(this, id));
      }
      return result;
    }
    public bool BideAICapabilityUCMutSetExists(int id) {
      return rootIncarnation.incarnationsBideAICapabilityUCMutSet.ContainsKey(id);
    }
    public void CheckHasBideAICapabilityUCMutSet(BideAICapabilityUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBideAICapabilityUCMutSet(thing.id);
    }
    public void CheckHasBideAICapabilityUCMutSet(int id) {
      if (!rootIncarnation.incarnationsBideAICapabilityUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BideAICapabilityUCMutSet}: " + id);
      }
    }
    public BideAICapabilityUCMutSet EffectBideAICapabilityUCMutSetCreate() {
      return TrustedEffectBideAICapabilityUCMutSetCreateWithId(NewId());
    }
    public BideAICapabilityUCMutSet TrustedEffectBideAICapabilityUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BideAICapabilityUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateBideAICapabilityUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new BideAICapabilityUCMutSet(this, id);
    }
    public BideAICapabilityUCMutSetCreateEffect InternalEffectCreateBideAICapabilityUCMutSet(int id, int incarnationVersion, BideAICapabilityUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsBideAICapabilityUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<BideAICapabilityUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new BideAICapabilityUCMutSetCreateEffect(id);
    }
    public void EffectBideAICapabilityUCMutSetDelete(int id) {
      var effect = InternalEffectBideAICapabilityUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public BideAICapabilityUCMutSetDeleteEffect InternalEffectBideAICapabilityUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsBideAICapabilityUCMutSet[id];
      rootIncarnation.incarnationsBideAICapabilityUCMutSet.Remove(id);
      return new BideAICapabilityUCMutSetDeleteEffect(id);
    }

       
    public void EffectBideAICapabilityUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBideAICapabilityUCMutSet(instanceId);
      CheckHasBideAICapabilityUC(element);
      var effect = InternalEffectBideAICapabilityUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public BideAICapabilityUCMutSetAddEffect InternalEffectBideAICapabilityUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBideAICapabilityUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BideAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBideAICapabilityUCMutSet[instanceId] =
            new VersionAndIncarnation<BideAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new BideAICapabilityUCMutSetAddEffect(instanceId, element);
    }
    public void EffectBideAICapabilityUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBideAICapabilityUCMutSet(instanceId);
      CheckHasBideAICapabilityUC(element);
      var effect = InternalEffectBideAICapabilityUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public BideAICapabilityUCMutSetRemoveEffect InternalEffectBideAICapabilityUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBideAICapabilityUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BideAICapabilityUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBideAICapabilityUCMutSet[instanceId] =
            new VersionAndIncarnation<BideAICapabilityUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new BideAICapabilityUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetBaseSightRangeUCMutSetHash(int id, int version, BaseSightRangeUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BaseSightRangeUCMutSetIncarnation GetBaseSightRangeUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBaseSightRangeUCMutSet[id].incarnation;
    }
    public BaseSightRangeUCMutSet GetBaseSightRangeUCMutSet(int id) {
      return new BaseSightRangeUCMutSet(this, id);
    }
    public List<BaseSightRangeUCMutSet> AllBaseSightRangeUCMutSet() {
      List<BaseSightRangeUCMutSet> result = new List<BaseSightRangeUCMutSet>(rootIncarnation.incarnationsBaseSightRangeUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBaseSightRangeUCMutSet.Keys) {
        result.Add(new BaseSightRangeUCMutSet(this, id));
      }
      return result;
    }
    public bool BaseSightRangeUCMutSetExists(int id) {
      return rootIncarnation.incarnationsBaseSightRangeUCMutSet.ContainsKey(id);
    }
    public void CheckHasBaseSightRangeUCMutSet(BaseSightRangeUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBaseSightRangeUCMutSet(thing.id);
    }
    public void CheckHasBaseSightRangeUCMutSet(int id) {
      if (!rootIncarnation.incarnationsBaseSightRangeUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BaseSightRangeUCMutSet}: " + id);
      }
    }
    public BaseSightRangeUCMutSet EffectBaseSightRangeUCMutSetCreate() {
      return TrustedEffectBaseSightRangeUCMutSetCreateWithId(NewId());
    }
    public BaseSightRangeUCMutSet TrustedEffectBaseSightRangeUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BaseSightRangeUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateBaseSightRangeUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new BaseSightRangeUCMutSet(this, id);
    }
    public BaseSightRangeUCMutSetCreateEffect InternalEffectCreateBaseSightRangeUCMutSet(int id, int incarnationVersion, BaseSightRangeUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsBaseSightRangeUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<BaseSightRangeUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new BaseSightRangeUCMutSetCreateEffect(id);
    }
    public void EffectBaseSightRangeUCMutSetDelete(int id) {
      var effect = InternalEffectBaseSightRangeUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public BaseSightRangeUCMutSetDeleteEffect InternalEffectBaseSightRangeUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsBaseSightRangeUCMutSet[id];
      rootIncarnation.incarnationsBaseSightRangeUCMutSet.Remove(id);
      return new BaseSightRangeUCMutSetDeleteEffect(id);
    }

       
    public void EffectBaseSightRangeUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBaseSightRangeUCMutSet(instanceId);
      CheckHasBaseSightRangeUC(element);
      var effect = InternalEffectBaseSightRangeUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public BaseSightRangeUCMutSetAddEffect InternalEffectBaseSightRangeUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBaseSightRangeUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BaseSightRangeUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBaseSightRangeUCMutSet[instanceId] =
            new VersionAndIncarnation<BaseSightRangeUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new BaseSightRangeUCMutSetAddEffect(instanceId, element);
    }
    public void EffectBaseSightRangeUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBaseSightRangeUCMutSet(instanceId);
      CheckHasBaseSightRangeUC(element);
      var effect = InternalEffectBaseSightRangeUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public BaseSightRangeUCMutSetRemoveEffect InternalEffectBaseSightRangeUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBaseSightRangeUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BaseSightRangeUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBaseSightRangeUCMutSet[instanceId] =
            new VersionAndIncarnation<BaseSightRangeUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new BaseSightRangeUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetBaseMovementTimeUCMutSetHash(int id, int version, BaseMovementTimeUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BaseMovementTimeUCMutSetIncarnation GetBaseMovementTimeUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBaseMovementTimeUCMutSet[id].incarnation;
    }
    public BaseMovementTimeUCMutSet GetBaseMovementTimeUCMutSet(int id) {
      return new BaseMovementTimeUCMutSet(this, id);
    }
    public List<BaseMovementTimeUCMutSet> AllBaseMovementTimeUCMutSet() {
      List<BaseMovementTimeUCMutSet> result = new List<BaseMovementTimeUCMutSet>(rootIncarnation.incarnationsBaseMovementTimeUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBaseMovementTimeUCMutSet.Keys) {
        result.Add(new BaseMovementTimeUCMutSet(this, id));
      }
      return result;
    }
    public bool BaseMovementTimeUCMutSetExists(int id) {
      return rootIncarnation.incarnationsBaseMovementTimeUCMutSet.ContainsKey(id);
    }
    public void CheckHasBaseMovementTimeUCMutSet(BaseMovementTimeUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBaseMovementTimeUCMutSet(thing.id);
    }
    public void CheckHasBaseMovementTimeUCMutSet(int id) {
      if (!rootIncarnation.incarnationsBaseMovementTimeUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BaseMovementTimeUCMutSet}: " + id);
      }
    }
    public BaseMovementTimeUCMutSet EffectBaseMovementTimeUCMutSetCreate() {
      return TrustedEffectBaseMovementTimeUCMutSetCreateWithId(NewId());
    }
    public BaseMovementTimeUCMutSet TrustedEffectBaseMovementTimeUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BaseMovementTimeUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateBaseMovementTimeUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new BaseMovementTimeUCMutSet(this, id);
    }
    public BaseMovementTimeUCMutSetCreateEffect InternalEffectCreateBaseMovementTimeUCMutSet(int id, int incarnationVersion, BaseMovementTimeUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsBaseMovementTimeUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<BaseMovementTimeUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new BaseMovementTimeUCMutSetCreateEffect(id);
    }
    public void EffectBaseMovementTimeUCMutSetDelete(int id) {
      var effect = InternalEffectBaseMovementTimeUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public BaseMovementTimeUCMutSetDeleteEffect InternalEffectBaseMovementTimeUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsBaseMovementTimeUCMutSet[id];
      rootIncarnation.incarnationsBaseMovementTimeUCMutSet.Remove(id);
      return new BaseMovementTimeUCMutSetDeleteEffect(id);
    }

       
    public void EffectBaseMovementTimeUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBaseMovementTimeUCMutSet(instanceId);
      CheckHasBaseMovementTimeUC(element);
      var effect = InternalEffectBaseMovementTimeUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public BaseMovementTimeUCMutSetAddEffect InternalEffectBaseMovementTimeUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBaseMovementTimeUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BaseMovementTimeUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBaseMovementTimeUCMutSet[instanceId] =
            new VersionAndIncarnation<BaseMovementTimeUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new BaseMovementTimeUCMutSetAddEffect(instanceId, element);
    }
    public void EffectBaseMovementTimeUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBaseMovementTimeUCMutSet(instanceId);
      CheckHasBaseMovementTimeUC(element);
      var effect = InternalEffectBaseMovementTimeUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public BaseMovementTimeUCMutSetRemoveEffect InternalEffectBaseMovementTimeUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBaseMovementTimeUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BaseMovementTimeUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBaseMovementTimeUCMutSet[instanceId] =
            new VersionAndIncarnation<BaseMovementTimeUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new BaseMovementTimeUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetBaseCombatTimeUCMutSetHash(int id, int version, BaseCombatTimeUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BaseCombatTimeUCMutSetIncarnation GetBaseCombatTimeUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBaseCombatTimeUCMutSet[id].incarnation;
    }
    public BaseCombatTimeUCMutSet GetBaseCombatTimeUCMutSet(int id) {
      return new BaseCombatTimeUCMutSet(this, id);
    }
    public List<BaseCombatTimeUCMutSet> AllBaseCombatTimeUCMutSet() {
      List<BaseCombatTimeUCMutSet> result = new List<BaseCombatTimeUCMutSet>(rootIncarnation.incarnationsBaseCombatTimeUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBaseCombatTimeUCMutSet.Keys) {
        result.Add(new BaseCombatTimeUCMutSet(this, id));
      }
      return result;
    }
    public bool BaseCombatTimeUCMutSetExists(int id) {
      return rootIncarnation.incarnationsBaseCombatTimeUCMutSet.ContainsKey(id);
    }
    public void CheckHasBaseCombatTimeUCMutSet(BaseCombatTimeUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBaseCombatTimeUCMutSet(thing.id);
    }
    public void CheckHasBaseCombatTimeUCMutSet(int id) {
      if (!rootIncarnation.incarnationsBaseCombatTimeUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BaseCombatTimeUCMutSet}: " + id);
      }
    }
    public BaseCombatTimeUCMutSet EffectBaseCombatTimeUCMutSetCreate() {
      return TrustedEffectBaseCombatTimeUCMutSetCreateWithId(NewId());
    }
    public BaseCombatTimeUCMutSet TrustedEffectBaseCombatTimeUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BaseCombatTimeUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateBaseCombatTimeUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new BaseCombatTimeUCMutSet(this, id);
    }
    public BaseCombatTimeUCMutSetCreateEffect InternalEffectCreateBaseCombatTimeUCMutSet(int id, int incarnationVersion, BaseCombatTimeUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsBaseCombatTimeUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<BaseCombatTimeUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new BaseCombatTimeUCMutSetCreateEffect(id);
    }
    public void EffectBaseCombatTimeUCMutSetDelete(int id) {
      var effect = InternalEffectBaseCombatTimeUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public BaseCombatTimeUCMutSetDeleteEffect InternalEffectBaseCombatTimeUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsBaseCombatTimeUCMutSet[id];
      rootIncarnation.incarnationsBaseCombatTimeUCMutSet.Remove(id);
      return new BaseCombatTimeUCMutSetDeleteEffect(id);
    }

       
    public void EffectBaseCombatTimeUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBaseCombatTimeUCMutSet(instanceId);
      CheckHasBaseCombatTimeUC(element);
      var effect = InternalEffectBaseCombatTimeUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public BaseCombatTimeUCMutSetAddEffect InternalEffectBaseCombatTimeUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBaseCombatTimeUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BaseCombatTimeUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBaseCombatTimeUCMutSet[instanceId] =
            new VersionAndIncarnation<BaseCombatTimeUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new BaseCombatTimeUCMutSetAddEffect(instanceId, element);
    }
    public void EffectBaseCombatTimeUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBaseCombatTimeUCMutSet(instanceId);
      CheckHasBaseCombatTimeUC(element);
      var effect = InternalEffectBaseCombatTimeUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public BaseCombatTimeUCMutSetRemoveEffect InternalEffectBaseCombatTimeUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBaseCombatTimeUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BaseCombatTimeUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBaseCombatTimeUCMutSet[instanceId] =
            new VersionAndIncarnation<BaseCombatTimeUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new BaseCombatTimeUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetManaPotionMutSetHash(int id, int version, ManaPotionMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ManaPotionMutSetIncarnation GetManaPotionMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsManaPotionMutSet[id].incarnation;
    }
    public ManaPotionMutSet GetManaPotionMutSet(int id) {
      return new ManaPotionMutSet(this, id);
    }
    public List<ManaPotionMutSet> AllManaPotionMutSet() {
      List<ManaPotionMutSet> result = new List<ManaPotionMutSet>(rootIncarnation.incarnationsManaPotionMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsManaPotionMutSet.Keys) {
        result.Add(new ManaPotionMutSet(this, id));
      }
      return result;
    }
    public bool ManaPotionMutSetExists(int id) {
      return rootIncarnation.incarnationsManaPotionMutSet.ContainsKey(id);
    }
    public void CheckHasManaPotionMutSet(ManaPotionMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasManaPotionMutSet(thing.id);
    }
    public void CheckHasManaPotionMutSet(int id) {
      if (!rootIncarnation.incarnationsManaPotionMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ManaPotionMutSet}: " + id);
      }
    }
    public ManaPotionMutSet EffectManaPotionMutSetCreate() {
      return TrustedEffectManaPotionMutSetCreateWithId(NewId());
    }
    public ManaPotionMutSet TrustedEffectManaPotionMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new ManaPotionMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateManaPotionMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new ManaPotionMutSet(this, id);
    }
    public ManaPotionMutSetCreateEffect InternalEffectCreateManaPotionMutSet(int id, int incarnationVersion, ManaPotionMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsManaPotionMutSet
          .Add(
              id,
              new VersionAndIncarnation<ManaPotionMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new ManaPotionMutSetCreateEffect(id);
    }
    public void EffectManaPotionMutSetDelete(int id) {
      var effect = InternalEffectManaPotionMutSetDelete(id);
      NotifyEffect(effect);
    }
    public ManaPotionMutSetDeleteEffect InternalEffectManaPotionMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsManaPotionMutSet[id];
      rootIncarnation.incarnationsManaPotionMutSet.Remove(id);
      return new ManaPotionMutSetDeleteEffect(id);
    }

       
    public void EffectManaPotionMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasManaPotionMutSet(instanceId);
      CheckHasManaPotion(element);
      var effect = InternalEffectManaPotionMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public ManaPotionMutSetAddEffect InternalEffectManaPotionMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsManaPotionMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new ManaPotionMutSetIncarnation(newMap);
        rootIncarnation.incarnationsManaPotionMutSet[instanceId] =
            new VersionAndIncarnation<ManaPotionMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new ManaPotionMutSetAddEffect(instanceId, element);
    }
    public void EffectManaPotionMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasManaPotionMutSet(instanceId);
      CheckHasManaPotion(element);
      var effect = InternalEffectManaPotionMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public ManaPotionMutSetRemoveEffect InternalEffectManaPotionMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsManaPotionMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ManaPotionMutSetIncarnation(newMap);
        rootIncarnation.incarnationsManaPotionMutSet[instanceId] =
            new VersionAndIncarnation<ManaPotionMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new ManaPotionMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetHealthPotionMutSetHash(int id, int version, HealthPotionMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public HealthPotionMutSetIncarnation GetHealthPotionMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsHealthPotionMutSet[id].incarnation;
    }
    public HealthPotionMutSet GetHealthPotionMutSet(int id) {
      return new HealthPotionMutSet(this, id);
    }
    public List<HealthPotionMutSet> AllHealthPotionMutSet() {
      List<HealthPotionMutSet> result = new List<HealthPotionMutSet>(rootIncarnation.incarnationsHealthPotionMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsHealthPotionMutSet.Keys) {
        result.Add(new HealthPotionMutSet(this, id));
      }
      return result;
    }
    public bool HealthPotionMutSetExists(int id) {
      return rootIncarnation.incarnationsHealthPotionMutSet.ContainsKey(id);
    }
    public void CheckHasHealthPotionMutSet(HealthPotionMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasHealthPotionMutSet(thing.id);
    }
    public void CheckHasHealthPotionMutSet(int id) {
      if (!rootIncarnation.incarnationsHealthPotionMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid HealthPotionMutSet}: " + id);
      }
    }
    public HealthPotionMutSet EffectHealthPotionMutSetCreate() {
      return TrustedEffectHealthPotionMutSetCreateWithId(NewId());
    }
    public HealthPotionMutSet TrustedEffectHealthPotionMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new HealthPotionMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateHealthPotionMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new HealthPotionMutSet(this, id);
    }
    public HealthPotionMutSetCreateEffect InternalEffectCreateHealthPotionMutSet(int id, int incarnationVersion, HealthPotionMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsHealthPotionMutSet
          .Add(
              id,
              new VersionAndIncarnation<HealthPotionMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new HealthPotionMutSetCreateEffect(id);
    }
    public void EffectHealthPotionMutSetDelete(int id) {
      var effect = InternalEffectHealthPotionMutSetDelete(id);
      NotifyEffect(effect);
    }
    public HealthPotionMutSetDeleteEffect InternalEffectHealthPotionMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsHealthPotionMutSet[id];
      rootIncarnation.incarnationsHealthPotionMutSet.Remove(id);
      return new HealthPotionMutSetDeleteEffect(id);
    }

       
    public void EffectHealthPotionMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasHealthPotionMutSet(instanceId);
      CheckHasHealthPotion(element);
      var effect = InternalEffectHealthPotionMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public HealthPotionMutSetAddEffect InternalEffectHealthPotionMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsHealthPotionMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new HealthPotionMutSetIncarnation(newMap);
        rootIncarnation.incarnationsHealthPotionMutSet[instanceId] =
            new VersionAndIncarnation<HealthPotionMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new HealthPotionMutSetAddEffect(instanceId, element);
    }
    public void EffectHealthPotionMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasHealthPotionMutSet(instanceId);
      CheckHasHealthPotion(element);
      var effect = InternalEffectHealthPotionMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public HealthPotionMutSetRemoveEffect InternalEffectHealthPotionMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsHealthPotionMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new HealthPotionMutSetIncarnation(newMap);
        rootIncarnation.incarnationsHealthPotionMutSet[instanceId] =
            new VersionAndIncarnation<HealthPotionMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new HealthPotionMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetSpeedRingMutSetHash(int id, int version, SpeedRingMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public SpeedRingMutSetIncarnation GetSpeedRingMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsSpeedRingMutSet[id].incarnation;
    }
    public SpeedRingMutSet GetSpeedRingMutSet(int id) {
      return new SpeedRingMutSet(this, id);
    }
    public List<SpeedRingMutSet> AllSpeedRingMutSet() {
      List<SpeedRingMutSet> result = new List<SpeedRingMutSet>(rootIncarnation.incarnationsSpeedRingMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsSpeedRingMutSet.Keys) {
        result.Add(new SpeedRingMutSet(this, id));
      }
      return result;
    }
    public bool SpeedRingMutSetExists(int id) {
      return rootIncarnation.incarnationsSpeedRingMutSet.ContainsKey(id);
    }
    public void CheckHasSpeedRingMutSet(SpeedRingMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasSpeedRingMutSet(thing.id);
    }
    public void CheckHasSpeedRingMutSet(int id) {
      if (!rootIncarnation.incarnationsSpeedRingMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid SpeedRingMutSet}: " + id);
      }
    }
    public SpeedRingMutSet EffectSpeedRingMutSetCreate() {
      return TrustedEffectSpeedRingMutSetCreateWithId(NewId());
    }
    public SpeedRingMutSet TrustedEffectSpeedRingMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new SpeedRingMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateSpeedRingMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new SpeedRingMutSet(this, id);
    }
    public SpeedRingMutSetCreateEffect InternalEffectCreateSpeedRingMutSet(int id, int incarnationVersion, SpeedRingMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsSpeedRingMutSet
          .Add(
              id,
              new VersionAndIncarnation<SpeedRingMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new SpeedRingMutSetCreateEffect(id);
    }
    public void EffectSpeedRingMutSetDelete(int id) {
      var effect = InternalEffectSpeedRingMutSetDelete(id);
      NotifyEffect(effect);
    }
    public SpeedRingMutSetDeleteEffect InternalEffectSpeedRingMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsSpeedRingMutSet[id];
      rootIncarnation.incarnationsSpeedRingMutSet.Remove(id);
      return new SpeedRingMutSetDeleteEffect(id);
    }

       
    public void EffectSpeedRingMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasSpeedRingMutSet(instanceId);
      CheckHasSpeedRing(element);
      var effect = InternalEffectSpeedRingMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public SpeedRingMutSetAddEffect InternalEffectSpeedRingMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsSpeedRingMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new SpeedRingMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSpeedRingMutSet[instanceId] =
            new VersionAndIncarnation<SpeedRingMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new SpeedRingMutSetAddEffect(instanceId, element);
    }
    public void EffectSpeedRingMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasSpeedRingMutSet(instanceId);
      CheckHasSpeedRing(element);
      var effect = InternalEffectSpeedRingMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public SpeedRingMutSetRemoveEffect InternalEffectSpeedRingMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsSpeedRingMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new SpeedRingMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSpeedRingMutSet[instanceId] =
            new VersionAndIncarnation<SpeedRingMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new SpeedRingMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetGlaiveMutSetHash(int id, int version, GlaiveMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public GlaiveMutSetIncarnation GetGlaiveMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsGlaiveMutSet[id].incarnation;
    }
    public GlaiveMutSet GetGlaiveMutSet(int id) {
      return new GlaiveMutSet(this, id);
    }
    public List<GlaiveMutSet> AllGlaiveMutSet() {
      List<GlaiveMutSet> result = new List<GlaiveMutSet>(rootIncarnation.incarnationsGlaiveMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsGlaiveMutSet.Keys) {
        result.Add(new GlaiveMutSet(this, id));
      }
      return result;
    }
    public bool GlaiveMutSetExists(int id) {
      return rootIncarnation.incarnationsGlaiveMutSet.ContainsKey(id);
    }
    public void CheckHasGlaiveMutSet(GlaiveMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasGlaiveMutSet(thing.id);
    }
    public void CheckHasGlaiveMutSet(int id) {
      if (!rootIncarnation.incarnationsGlaiveMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid GlaiveMutSet}: " + id);
      }
    }
    public GlaiveMutSet EffectGlaiveMutSetCreate() {
      return TrustedEffectGlaiveMutSetCreateWithId(NewId());
    }
    public GlaiveMutSet TrustedEffectGlaiveMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new GlaiveMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateGlaiveMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new GlaiveMutSet(this, id);
    }
    public GlaiveMutSetCreateEffect InternalEffectCreateGlaiveMutSet(int id, int incarnationVersion, GlaiveMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsGlaiveMutSet
          .Add(
              id,
              new VersionAndIncarnation<GlaiveMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new GlaiveMutSetCreateEffect(id);
    }
    public void EffectGlaiveMutSetDelete(int id) {
      var effect = InternalEffectGlaiveMutSetDelete(id);
      NotifyEffect(effect);
    }
    public GlaiveMutSetDeleteEffect InternalEffectGlaiveMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsGlaiveMutSet[id];
      rootIncarnation.incarnationsGlaiveMutSet.Remove(id);
      return new GlaiveMutSetDeleteEffect(id);
    }

       
    public void EffectGlaiveMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasGlaiveMutSet(instanceId);
      CheckHasGlaive(element);
      var effect = InternalEffectGlaiveMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public GlaiveMutSetAddEffect InternalEffectGlaiveMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsGlaiveMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new GlaiveMutSetIncarnation(newMap);
        rootIncarnation.incarnationsGlaiveMutSet[instanceId] =
            new VersionAndIncarnation<GlaiveMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new GlaiveMutSetAddEffect(instanceId, element);
    }
    public void EffectGlaiveMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasGlaiveMutSet(instanceId);
      CheckHasGlaive(element);
      var effect = InternalEffectGlaiveMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public GlaiveMutSetRemoveEffect InternalEffectGlaiveMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsGlaiveMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new GlaiveMutSetIncarnation(newMap);
        rootIncarnation.incarnationsGlaiveMutSet[instanceId] =
            new VersionAndIncarnation<GlaiveMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new GlaiveMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetSlowRodMutSetHash(int id, int version, SlowRodMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public SlowRodMutSetIncarnation GetSlowRodMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsSlowRodMutSet[id].incarnation;
    }
    public SlowRodMutSet GetSlowRodMutSet(int id) {
      return new SlowRodMutSet(this, id);
    }
    public List<SlowRodMutSet> AllSlowRodMutSet() {
      List<SlowRodMutSet> result = new List<SlowRodMutSet>(rootIncarnation.incarnationsSlowRodMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsSlowRodMutSet.Keys) {
        result.Add(new SlowRodMutSet(this, id));
      }
      return result;
    }
    public bool SlowRodMutSetExists(int id) {
      return rootIncarnation.incarnationsSlowRodMutSet.ContainsKey(id);
    }
    public void CheckHasSlowRodMutSet(SlowRodMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasSlowRodMutSet(thing.id);
    }
    public void CheckHasSlowRodMutSet(int id) {
      if (!rootIncarnation.incarnationsSlowRodMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid SlowRodMutSet}: " + id);
      }
    }
    public SlowRodMutSet EffectSlowRodMutSetCreate() {
      return TrustedEffectSlowRodMutSetCreateWithId(NewId());
    }
    public SlowRodMutSet TrustedEffectSlowRodMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new SlowRodMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateSlowRodMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new SlowRodMutSet(this, id);
    }
    public SlowRodMutSetCreateEffect InternalEffectCreateSlowRodMutSet(int id, int incarnationVersion, SlowRodMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsSlowRodMutSet
          .Add(
              id,
              new VersionAndIncarnation<SlowRodMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new SlowRodMutSetCreateEffect(id);
    }
    public void EffectSlowRodMutSetDelete(int id) {
      var effect = InternalEffectSlowRodMutSetDelete(id);
      NotifyEffect(effect);
    }
    public SlowRodMutSetDeleteEffect InternalEffectSlowRodMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsSlowRodMutSet[id];
      rootIncarnation.incarnationsSlowRodMutSet.Remove(id);
      return new SlowRodMutSetDeleteEffect(id);
    }

       
    public void EffectSlowRodMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasSlowRodMutSet(instanceId);
      CheckHasSlowRod(element);
      var effect = InternalEffectSlowRodMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public SlowRodMutSetAddEffect InternalEffectSlowRodMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsSlowRodMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new SlowRodMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSlowRodMutSet[instanceId] =
            new VersionAndIncarnation<SlowRodMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new SlowRodMutSetAddEffect(instanceId, element);
    }
    public void EffectSlowRodMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasSlowRodMutSet(instanceId);
      CheckHasSlowRod(element);
      var effect = InternalEffectSlowRodMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public SlowRodMutSetRemoveEffect InternalEffectSlowRodMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsSlowRodMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new SlowRodMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSlowRodMutSet[instanceId] =
            new VersionAndIncarnation<SlowRodMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new SlowRodMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetExplosionRodMutSetHash(int id, int version, ExplosionRodMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ExplosionRodMutSetIncarnation GetExplosionRodMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsExplosionRodMutSet[id].incarnation;
    }
    public ExplosionRodMutSet GetExplosionRodMutSet(int id) {
      return new ExplosionRodMutSet(this, id);
    }
    public List<ExplosionRodMutSet> AllExplosionRodMutSet() {
      List<ExplosionRodMutSet> result = new List<ExplosionRodMutSet>(rootIncarnation.incarnationsExplosionRodMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsExplosionRodMutSet.Keys) {
        result.Add(new ExplosionRodMutSet(this, id));
      }
      return result;
    }
    public bool ExplosionRodMutSetExists(int id) {
      return rootIncarnation.incarnationsExplosionRodMutSet.ContainsKey(id);
    }
    public void CheckHasExplosionRodMutSet(ExplosionRodMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasExplosionRodMutSet(thing.id);
    }
    public void CheckHasExplosionRodMutSet(int id) {
      if (!rootIncarnation.incarnationsExplosionRodMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ExplosionRodMutSet}: " + id);
      }
    }
    public ExplosionRodMutSet EffectExplosionRodMutSetCreate() {
      return TrustedEffectExplosionRodMutSetCreateWithId(NewId());
    }
    public ExplosionRodMutSet TrustedEffectExplosionRodMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new ExplosionRodMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateExplosionRodMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new ExplosionRodMutSet(this, id);
    }
    public ExplosionRodMutSetCreateEffect InternalEffectCreateExplosionRodMutSet(int id, int incarnationVersion, ExplosionRodMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsExplosionRodMutSet
          .Add(
              id,
              new VersionAndIncarnation<ExplosionRodMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new ExplosionRodMutSetCreateEffect(id);
    }
    public void EffectExplosionRodMutSetDelete(int id) {
      var effect = InternalEffectExplosionRodMutSetDelete(id);
      NotifyEffect(effect);
    }
    public ExplosionRodMutSetDeleteEffect InternalEffectExplosionRodMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsExplosionRodMutSet[id];
      rootIncarnation.incarnationsExplosionRodMutSet.Remove(id);
      return new ExplosionRodMutSetDeleteEffect(id);
    }

       
    public void EffectExplosionRodMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasExplosionRodMutSet(instanceId);
      CheckHasExplosionRod(element);
      var effect = InternalEffectExplosionRodMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public ExplosionRodMutSetAddEffect InternalEffectExplosionRodMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsExplosionRodMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new ExplosionRodMutSetIncarnation(newMap);
        rootIncarnation.incarnationsExplosionRodMutSet[instanceId] =
            new VersionAndIncarnation<ExplosionRodMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new ExplosionRodMutSetAddEffect(instanceId, element);
    }
    public void EffectExplosionRodMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasExplosionRodMutSet(instanceId);
      CheckHasExplosionRod(element);
      var effect = InternalEffectExplosionRodMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public ExplosionRodMutSetRemoveEffect InternalEffectExplosionRodMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsExplosionRodMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ExplosionRodMutSetIncarnation(newMap);
        rootIncarnation.incarnationsExplosionRodMutSet[instanceId] =
            new VersionAndIncarnation<ExplosionRodMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new ExplosionRodMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetBlazeRodMutSetHash(int id, int version, BlazeRodMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BlazeRodMutSetIncarnation GetBlazeRodMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBlazeRodMutSet[id].incarnation;
    }
    public BlazeRodMutSet GetBlazeRodMutSet(int id) {
      return new BlazeRodMutSet(this, id);
    }
    public List<BlazeRodMutSet> AllBlazeRodMutSet() {
      List<BlazeRodMutSet> result = new List<BlazeRodMutSet>(rootIncarnation.incarnationsBlazeRodMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBlazeRodMutSet.Keys) {
        result.Add(new BlazeRodMutSet(this, id));
      }
      return result;
    }
    public bool BlazeRodMutSetExists(int id) {
      return rootIncarnation.incarnationsBlazeRodMutSet.ContainsKey(id);
    }
    public void CheckHasBlazeRodMutSet(BlazeRodMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBlazeRodMutSet(thing.id);
    }
    public void CheckHasBlazeRodMutSet(int id) {
      if (!rootIncarnation.incarnationsBlazeRodMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BlazeRodMutSet}: " + id);
      }
    }
    public BlazeRodMutSet EffectBlazeRodMutSetCreate() {
      return TrustedEffectBlazeRodMutSetCreateWithId(NewId());
    }
    public BlazeRodMutSet TrustedEffectBlazeRodMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BlazeRodMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateBlazeRodMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new BlazeRodMutSet(this, id);
    }
    public BlazeRodMutSetCreateEffect InternalEffectCreateBlazeRodMutSet(int id, int incarnationVersion, BlazeRodMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsBlazeRodMutSet
          .Add(
              id,
              new VersionAndIncarnation<BlazeRodMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new BlazeRodMutSetCreateEffect(id);
    }
    public void EffectBlazeRodMutSetDelete(int id) {
      var effect = InternalEffectBlazeRodMutSetDelete(id);
      NotifyEffect(effect);
    }
    public BlazeRodMutSetDeleteEffect InternalEffectBlazeRodMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsBlazeRodMutSet[id];
      rootIncarnation.incarnationsBlazeRodMutSet.Remove(id);
      return new BlazeRodMutSetDeleteEffect(id);
    }

       
    public void EffectBlazeRodMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBlazeRodMutSet(instanceId);
      CheckHasBlazeRod(element);
      var effect = InternalEffectBlazeRodMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public BlazeRodMutSetAddEffect InternalEffectBlazeRodMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBlazeRodMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BlazeRodMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBlazeRodMutSet[instanceId] =
            new VersionAndIncarnation<BlazeRodMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new BlazeRodMutSetAddEffect(instanceId, element);
    }
    public void EffectBlazeRodMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBlazeRodMutSet(instanceId);
      CheckHasBlazeRod(element);
      var effect = InternalEffectBlazeRodMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public BlazeRodMutSetRemoveEffect InternalEffectBlazeRodMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBlazeRodMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BlazeRodMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBlazeRodMutSet[instanceId] =
            new VersionAndIncarnation<BlazeRodMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new BlazeRodMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetBlastRodMutSetHash(int id, int version, BlastRodMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BlastRodMutSetIncarnation GetBlastRodMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBlastRodMutSet[id].incarnation;
    }
    public BlastRodMutSet GetBlastRodMutSet(int id) {
      return new BlastRodMutSet(this, id);
    }
    public List<BlastRodMutSet> AllBlastRodMutSet() {
      List<BlastRodMutSet> result = new List<BlastRodMutSet>(rootIncarnation.incarnationsBlastRodMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBlastRodMutSet.Keys) {
        result.Add(new BlastRodMutSet(this, id));
      }
      return result;
    }
    public bool BlastRodMutSetExists(int id) {
      return rootIncarnation.incarnationsBlastRodMutSet.ContainsKey(id);
    }
    public void CheckHasBlastRodMutSet(BlastRodMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBlastRodMutSet(thing.id);
    }
    public void CheckHasBlastRodMutSet(int id) {
      if (!rootIncarnation.incarnationsBlastRodMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BlastRodMutSet}: " + id);
      }
    }
    public BlastRodMutSet EffectBlastRodMutSetCreate() {
      return TrustedEffectBlastRodMutSetCreateWithId(NewId());
    }
    public BlastRodMutSet TrustedEffectBlastRodMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BlastRodMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateBlastRodMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new BlastRodMutSet(this, id);
    }
    public BlastRodMutSetCreateEffect InternalEffectCreateBlastRodMutSet(int id, int incarnationVersion, BlastRodMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsBlastRodMutSet
          .Add(
              id,
              new VersionAndIncarnation<BlastRodMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new BlastRodMutSetCreateEffect(id);
    }
    public void EffectBlastRodMutSetDelete(int id) {
      var effect = InternalEffectBlastRodMutSetDelete(id);
      NotifyEffect(effect);
    }
    public BlastRodMutSetDeleteEffect InternalEffectBlastRodMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsBlastRodMutSet[id];
      rootIncarnation.incarnationsBlastRodMutSet.Remove(id);
      return new BlastRodMutSetDeleteEffect(id);
    }

       
    public void EffectBlastRodMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBlastRodMutSet(instanceId);
      CheckHasBlastRod(element);
      var effect = InternalEffectBlastRodMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public BlastRodMutSetAddEffect InternalEffectBlastRodMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBlastRodMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BlastRodMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBlastRodMutSet[instanceId] =
            new VersionAndIncarnation<BlastRodMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new BlastRodMutSetAddEffect(instanceId, element);
    }
    public void EffectBlastRodMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBlastRodMutSet(instanceId);
      CheckHasBlastRod(element);
      var effect = InternalEffectBlastRodMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public BlastRodMutSetRemoveEffect InternalEffectBlastRodMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBlastRodMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BlastRodMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBlastRodMutSet[instanceId] =
            new VersionAndIncarnation<BlastRodMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new BlastRodMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetArmorMutSetHash(int id, int version, ArmorMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public ArmorMutSetIncarnation GetArmorMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsArmorMutSet[id].incarnation;
    }
    public ArmorMutSet GetArmorMutSet(int id) {
      return new ArmorMutSet(this, id);
    }
    public List<ArmorMutSet> AllArmorMutSet() {
      List<ArmorMutSet> result = new List<ArmorMutSet>(rootIncarnation.incarnationsArmorMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsArmorMutSet.Keys) {
        result.Add(new ArmorMutSet(this, id));
      }
      return result;
    }
    public bool ArmorMutSetExists(int id) {
      return rootIncarnation.incarnationsArmorMutSet.ContainsKey(id);
    }
    public void CheckHasArmorMutSet(ArmorMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasArmorMutSet(thing.id);
    }
    public void CheckHasArmorMutSet(int id) {
      if (!rootIncarnation.incarnationsArmorMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid ArmorMutSet}: " + id);
      }
    }
    public ArmorMutSet EffectArmorMutSetCreate() {
      return TrustedEffectArmorMutSetCreateWithId(NewId());
    }
    public ArmorMutSet TrustedEffectArmorMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new ArmorMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateArmorMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new ArmorMutSet(this, id);
    }
    public ArmorMutSetCreateEffect InternalEffectCreateArmorMutSet(int id, int incarnationVersion, ArmorMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsArmorMutSet
          .Add(
              id,
              new VersionAndIncarnation<ArmorMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new ArmorMutSetCreateEffect(id);
    }
    public void EffectArmorMutSetDelete(int id) {
      var effect = InternalEffectArmorMutSetDelete(id);
      NotifyEffect(effect);
    }
    public ArmorMutSetDeleteEffect InternalEffectArmorMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsArmorMutSet[id];
      rootIncarnation.incarnationsArmorMutSet.Remove(id);
      return new ArmorMutSetDeleteEffect(id);
    }

       
    public void EffectArmorMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasArmorMutSet(instanceId);
      CheckHasArmor(element);
      var effect = InternalEffectArmorMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public ArmorMutSetAddEffect InternalEffectArmorMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsArmorMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new ArmorMutSetIncarnation(newMap);
        rootIncarnation.incarnationsArmorMutSet[instanceId] =
            new VersionAndIncarnation<ArmorMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new ArmorMutSetAddEffect(instanceId, element);
    }
    public void EffectArmorMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasArmorMutSet(instanceId);
      CheckHasArmor(element);
      var effect = InternalEffectArmorMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public ArmorMutSetRemoveEffect InternalEffectArmorMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsArmorMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new ArmorMutSetIncarnation(newMap);
        rootIncarnation.incarnationsArmorMutSet[instanceId] =
            new VersionAndIncarnation<ArmorMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new ArmorMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetSorcerousUCMutSetHash(int id, int version, SorcerousUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public SorcerousUCMutSetIncarnation GetSorcerousUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsSorcerousUCMutSet[id].incarnation;
    }
    public SorcerousUCMutSet GetSorcerousUCMutSet(int id) {
      return new SorcerousUCMutSet(this, id);
    }
    public List<SorcerousUCMutSet> AllSorcerousUCMutSet() {
      List<SorcerousUCMutSet> result = new List<SorcerousUCMutSet>(rootIncarnation.incarnationsSorcerousUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsSorcerousUCMutSet.Keys) {
        result.Add(new SorcerousUCMutSet(this, id));
      }
      return result;
    }
    public bool SorcerousUCMutSetExists(int id) {
      return rootIncarnation.incarnationsSorcerousUCMutSet.ContainsKey(id);
    }
    public void CheckHasSorcerousUCMutSet(SorcerousUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasSorcerousUCMutSet(thing.id);
    }
    public void CheckHasSorcerousUCMutSet(int id) {
      if (!rootIncarnation.incarnationsSorcerousUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid SorcerousUCMutSet}: " + id);
      }
    }
    public SorcerousUCMutSet EffectSorcerousUCMutSetCreate() {
      return TrustedEffectSorcerousUCMutSetCreateWithId(NewId());
    }
    public SorcerousUCMutSet TrustedEffectSorcerousUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new SorcerousUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateSorcerousUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new SorcerousUCMutSet(this, id);
    }
    public SorcerousUCMutSetCreateEffect InternalEffectCreateSorcerousUCMutSet(int id, int incarnationVersion, SorcerousUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsSorcerousUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<SorcerousUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new SorcerousUCMutSetCreateEffect(id);
    }
    public void EffectSorcerousUCMutSetDelete(int id) {
      var effect = InternalEffectSorcerousUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public SorcerousUCMutSetDeleteEffect InternalEffectSorcerousUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsSorcerousUCMutSet[id];
      rootIncarnation.incarnationsSorcerousUCMutSet.Remove(id);
      return new SorcerousUCMutSetDeleteEffect(id);
    }

       
    public void EffectSorcerousUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasSorcerousUCMutSet(instanceId);
      CheckHasSorcerousUC(element);
      var effect = InternalEffectSorcerousUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public SorcerousUCMutSetAddEffect InternalEffectSorcerousUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsSorcerousUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new SorcerousUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSorcerousUCMutSet[instanceId] =
            new VersionAndIncarnation<SorcerousUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new SorcerousUCMutSetAddEffect(instanceId, element);
    }
    public void EffectSorcerousUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasSorcerousUCMutSet(instanceId);
      CheckHasSorcerousUC(element);
      var effect = InternalEffectSorcerousUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public SorcerousUCMutSetRemoveEffect InternalEffectSorcerousUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsSorcerousUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new SorcerousUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsSorcerousUCMutSet[instanceId] =
            new VersionAndIncarnation<SorcerousUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new SorcerousUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetBaseOffenseUCMutSetHash(int id, int version, BaseOffenseUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BaseOffenseUCMutSetIncarnation GetBaseOffenseUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBaseOffenseUCMutSet[id].incarnation;
    }
    public BaseOffenseUCMutSet GetBaseOffenseUCMutSet(int id) {
      return new BaseOffenseUCMutSet(this, id);
    }
    public List<BaseOffenseUCMutSet> AllBaseOffenseUCMutSet() {
      List<BaseOffenseUCMutSet> result = new List<BaseOffenseUCMutSet>(rootIncarnation.incarnationsBaseOffenseUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBaseOffenseUCMutSet.Keys) {
        result.Add(new BaseOffenseUCMutSet(this, id));
      }
      return result;
    }
    public bool BaseOffenseUCMutSetExists(int id) {
      return rootIncarnation.incarnationsBaseOffenseUCMutSet.ContainsKey(id);
    }
    public void CheckHasBaseOffenseUCMutSet(BaseOffenseUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBaseOffenseUCMutSet(thing.id);
    }
    public void CheckHasBaseOffenseUCMutSet(int id) {
      if (!rootIncarnation.incarnationsBaseOffenseUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BaseOffenseUCMutSet}: " + id);
      }
    }
    public BaseOffenseUCMutSet EffectBaseOffenseUCMutSetCreate() {
      return TrustedEffectBaseOffenseUCMutSetCreateWithId(NewId());
    }
    public BaseOffenseUCMutSet TrustedEffectBaseOffenseUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BaseOffenseUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateBaseOffenseUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new BaseOffenseUCMutSet(this, id);
    }
    public BaseOffenseUCMutSetCreateEffect InternalEffectCreateBaseOffenseUCMutSet(int id, int incarnationVersion, BaseOffenseUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsBaseOffenseUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<BaseOffenseUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new BaseOffenseUCMutSetCreateEffect(id);
    }
    public void EffectBaseOffenseUCMutSetDelete(int id) {
      var effect = InternalEffectBaseOffenseUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public BaseOffenseUCMutSetDeleteEffect InternalEffectBaseOffenseUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsBaseOffenseUCMutSet[id];
      rootIncarnation.incarnationsBaseOffenseUCMutSet.Remove(id);
      return new BaseOffenseUCMutSetDeleteEffect(id);
    }

       
    public void EffectBaseOffenseUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBaseOffenseUCMutSet(instanceId);
      CheckHasBaseOffenseUC(element);
      var effect = InternalEffectBaseOffenseUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public BaseOffenseUCMutSetAddEffect InternalEffectBaseOffenseUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBaseOffenseUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BaseOffenseUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBaseOffenseUCMutSet[instanceId] =
            new VersionAndIncarnation<BaseOffenseUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new BaseOffenseUCMutSetAddEffect(instanceId, element);
    }
    public void EffectBaseOffenseUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBaseOffenseUCMutSet(instanceId);
      CheckHasBaseOffenseUC(element);
      var effect = InternalEffectBaseOffenseUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public BaseOffenseUCMutSetRemoveEffect InternalEffectBaseOffenseUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBaseOffenseUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BaseOffenseUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBaseOffenseUCMutSet[instanceId] =
            new VersionAndIncarnation<BaseOffenseUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new BaseOffenseUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetBaseDefenseUCMutSetHash(int id, int version, BaseDefenseUCMutSetIncarnation incarnation) {
      int result = id * version;
      foreach (var element in incarnation.elements) {
        result += id * version * element.GetDeterministicHashCode();
      }
      return result;
    }
    public BaseDefenseUCMutSetIncarnation GetBaseDefenseUCMutSetIncarnation(int id) {
      return rootIncarnation.incarnationsBaseDefenseUCMutSet[id].incarnation;
    }
    public BaseDefenseUCMutSet GetBaseDefenseUCMutSet(int id) {
      return new BaseDefenseUCMutSet(this, id);
    }
    public List<BaseDefenseUCMutSet> AllBaseDefenseUCMutSet() {
      List<BaseDefenseUCMutSet> result = new List<BaseDefenseUCMutSet>(rootIncarnation.incarnationsBaseDefenseUCMutSet.Count);
      foreach (var id in rootIncarnation.incarnationsBaseDefenseUCMutSet.Keys) {
        result.Add(new BaseDefenseUCMutSet(this, id));
      }
      return result;
    }
    public bool BaseDefenseUCMutSetExists(int id) {
      return rootIncarnation.incarnationsBaseDefenseUCMutSet.ContainsKey(id);
    }
    public void CheckHasBaseDefenseUCMutSet(BaseDefenseUCMutSet thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasBaseDefenseUCMutSet(thing.id);
    }
    public void CheckHasBaseDefenseUCMutSet(int id) {
      if (!rootIncarnation.incarnationsBaseDefenseUCMutSet.ContainsKey(id)) {
        throw new System.Exception("Invalid BaseDefenseUCMutSet}: " + id);
      }
    }
    public BaseDefenseUCMutSet EffectBaseDefenseUCMutSetCreate() {
      return TrustedEffectBaseDefenseUCMutSetCreateWithId(NewId());
    }
    public BaseDefenseUCMutSet TrustedEffectBaseDefenseUCMutSetCreateWithId(int id) {
      CheckUnlocked();
      var incarnation = new BaseDefenseUCMutSetIncarnation(new SortedSet<int>());
      var effect = InternalEffectCreateBaseDefenseUCMutSet(id, rootIncarnation.version, incarnation);
      NotifyEffect(effect);
      return new BaseDefenseUCMutSet(this, id);
    }
    public BaseDefenseUCMutSetCreateEffect InternalEffectCreateBaseDefenseUCMutSet(int id, int incarnationVersion, BaseDefenseUCMutSetIncarnation incarnation) {
      rootIncarnation.incarnationsBaseDefenseUCMutSet
          .Add(
              id,
              new VersionAndIncarnation<BaseDefenseUCMutSetIncarnation>(
                  incarnationVersion,
                  incarnation));

      return new BaseDefenseUCMutSetCreateEffect(id);
    }
    public void EffectBaseDefenseUCMutSetDelete(int id) {
      var effect = InternalEffectBaseDefenseUCMutSetDelete(id);
      NotifyEffect(effect);
    }
    public BaseDefenseUCMutSetDeleteEffect InternalEffectBaseDefenseUCMutSetDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsBaseDefenseUCMutSet[id];
      rootIncarnation.incarnationsBaseDefenseUCMutSet.Remove(id);
      return new BaseDefenseUCMutSetDeleteEffect(id);
    }

       
    public void EffectBaseDefenseUCMutSetAdd(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBaseDefenseUCMutSet(instanceId);
      CheckHasBaseDefenseUC(element);
      var effect = InternalEffectBaseDefenseUCMutSetAdd(instanceId, element);
      NotifyEffect(effect);
    }
    public BaseDefenseUCMutSetAddEffect InternalEffectBaseDefenseUCMutSetAdd(int instanceId, int element) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBaseDefenseUCMutSet[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.Contains(element)) {
        throw new Exception("Element already exists!");
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(element);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Add(element);
        var newIncarnation = new BaseDefenseUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBaseDefenseUCMutSet[instanceId] =
            new VersionAndIncarnation<BaseDefenseUCMutSetIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new BaseDefenseUCMutSetAddEffect(instanceId, element);
    }
    public void EffectBaseDefenseUCMutSetRemove(int instanceId, int element) {
      CheckUnlocked();
      CheckHasBaseDefenseUCMutSet(instanceId);
      CheckHasBaseDefenseUC(element);
      var effect = InternalEffectBaseDefenseUCMutSetRemove(instanceId, element);
      NotifyEffect(effect);
    }
    public BaseDefenseUCMutSetRemoveEffect InternalEffectBaseDefenseUCMutSetRemove(int instanceId, int elementId) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsBaseDefenseUCMutSet[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.Contains(elementId)) {
        throw new Exception("Element not found! " + elementId);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Remove(elementId);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedSet<int>(oldMap);
        newMap.Remove(elementId);
        var newIncarnation = new BaseDefenseUCMutSetIncarnation(newMap);
        rootIncarnation.incarnationsBaseDefenseUCMutSet[instanceId] =
            new VersionAndIncarnation<BaseDefenseUCMutSetIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new BaseDefenseUCMutSetRemoveEffect(instanceId, elementId);
    }

       
    public int GetTerrainTileByLocationMutMapHash(int id, int version, TerrainTileByLocationMutMapIncarnation incarnation) {
      int result = id * version;
      foreach (var entry in incarnation.elements) {
        result += id * version * entry.Key.GetDeterministicHashCode() * entry.Value.GetDeterministicHashCode();
      }
      return result;
    }
    public TerrainTileByLocationMutMapIncarnation GetTerrainTileByLocationMutMapIncarnation(int id) {
      return rootIncarnation.incarnationsTerrainTileByLocationMutMap[id].incarnation;
    }
    public TerrainTileByLocationMutMap GetTerrainTileByLocationMutMap(int id) {
      return new TerrainTileByLocationMutMap(this, id);
    }
    public List<TerrainTileByLocationMutMap> AllTerrainTileByLocationMutMap() {
      List<TerrainTileByLocationMutMap> result = new List<TerrainTileByLocationMutMap>(rootIncarnation.incarnationsTerrainTileByLocationMutMap.Count);
      foreach (var id in rootIncarnation.incarnationsTerrainTileByLocationMutMap.Keys) {
        result.Add(new TerrainTileByLocationMutMap(this, id));
      }
      return result;
    }
    public bool TerrainTileByLocationMutMapExists(int id) {
      return rootIncarnation.incarnationsTerrainTileByLocationMutMap.ContainsKey(id);
    }
    public void CheckHasTerrainTileByLocationMutMap(TerrainTileByLocationMutMap thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasTerrainTileByLocationMutMap(thing.id);
    }
    public void CheckHasTerrainTileByLocationMutMap(int id) {
      if (!rootIncarnation.incarnationsTerrainTileByLocationMutMap.ContainsKey(id)) {
        throw new System.Exception("Invalid TerrainTileByLocationMutMap}: " + id);
      }
    }
    public TerrainTileByLocationMutMap EffectTerrainTileByLocationMutMapCreate() {
      return TrustedEffectTerrainTileByLocationMutMapCreateWithId(NewId());
    }
    public TerrainTileByLocationMutMap TrustedEffectTerrainTileByLocationMutMapCreateWithId(int id) {
      CheckUnlocked();
      Asserts.Assert(!rootIncarnation.incarnationsTerrainTileByLocationMutMap.ContainsKey(id));
      var effect =
        InternalEffectCreateTerrainTileByLocationMutMap(
          id,
          rootIncarnation.version,
          new TerrainTileByLocationMutMapIncarnation(
              new SortedDictionary<Location, int>()));
      NotifyEffect(effect);
      return new TerrainTileByLocationMutMap(this, id);
    }
       
    public TerrainTileByLocationMutMapCreateEffect InternalEffectCreateTerrainTileByLocationMutMap(int id, int incarnationVersion, TerrainTileByLocationMutMapIncarnation incarnation) {
      rootIncarnation.incarnationsTerrainTileByLocationMutMap
          .Add(
              id,
              new VersionAndIncarnation<TerrainTileByLocationMutMapIncarnation>(
                  incarnationVersion,
                  incarnation));
    return new TerrainTileByLocationMutMapCreateEffect(id);
    }
    public void EffectTerrainTileByLocationMutMapDelete(int id) {
      var effect = InternalEffectTerrainTileByLocationMutMapDelete(id);
      NotifyEffect(effect);
    }
    public TerrainTileByLocationMutMapDeleteEffect InternalEffectTerrainTileByLocationMutMapDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsTerrainTileByLocationMutMap[id];
      rootIncarnation.incarnationsTerrainTileByLocationMutMap.Remove(id);
        return new TerrainTileByLocationMutMapDeleteEffect(id);
    }
    public void EffectTerrainTileByLocationMutMapAdd(int instanceId, Location key, int value) {
      CheckUnlocked();
      CheckHasTerrainTileByLocationMutMap(instanceId);
      CheckHasTerrainTile(value);
      var effect = InternalEffectTerrainTileByLocationMutMapAdd(instanceId, key, value);
      NotifyEffect(effect);
    }
    public TerrainTileByLocationMutMapAddEffect InternalEffectTerrainTileByLocationMutMapAdd(int instanceId, Location key, int value) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsTerrainTileByLocationMutMap[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.ContainsKey(key)) {
        throw new Exception("Key exists! " + key);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(key, value);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedDictionary<Location, int>(oldMap);
        newMap.Add(key, value);
        var newIncarnation = new TerrainTileByLocationMutMapIncarnation(newMap);
        rootIncarnation.incarnationsTerrainTileByLocationMutMap[instanceId] =
            new VersionAndIncarnation<TerrainTileByLocationMutMapIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new TerrainTileByLocationMutMapAddEffect(instanceId, key, value);
    }
       
    public void EffectTerrainTileByLocationMutMapRemove(int instanceId, Location key) {
      CheckUnlocked();
      CheckHasTerrainTileByLocationMutMap(instanceId);
      var effect = InternalEffectTerrainTileByLocationMutMapRemove(instanceId, key);
      NotifyEffect(effect);
    }
    public TerrainTileByLocationMutMapRemoveEffect InternalEffectTerrainTileByLocationMutMapRemove(int instanceId, Location key) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsTerrainTileByLocationMutMap[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.ContainsKey(key)) {
        throw new Exception("Key doesnt exist! " + key);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        var oldValue = oldIncarnationAndVersion.incarnation.elements[key];
        oldIncarnationAndVersion.incarnation.elements.Remove(key);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedDictionary<Location, int>(oldMap);
        newMap.Remove(key);
        var newIncarnation = new TerrainTileByLocationMutMapIncarnation(newMap);
        rootIncarnation.incarnationsTerrainTileByLocationMutMap[instanceId] =
            new VersionAndIncarnation<TerrainTileByLocationMutMapIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new TerrainTileByLocationMutMapRemoveEffect(instanceId, key);
    }

    public int GetKamikazeTargetTTCStrongByLocationMutMapHash(int id, int version, KamikazeTargetTTCStrongByLocationMutMapIncarnation incarnation) {
      int result = id * version;
      foreach (var entry in incarnation.elements) {
        result += id * version * entry.Key.GetDeterministicHashCode() * entry.Value.GetDeterministicHashCode();
      }
      return result;
    }
    public KamikazeTargetTTCStrongByLocationMutMapIncarnation GetKamikazeTargetTTCStrongByLocationMutMapIncarnation(int id) {
      return rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap[id].incarnation;
    }
    public KamikazeTargetTTCStrongByLocationMutMap GetKamikazeTargetTTCStrongByLocationMutMap(int id) {
      return new KamikazeTargetTTCStrongByLocationMutMap(this, id);
    }
    public List<KamikazeTargetTTCStrongByLocationMutMap> AllKamikazeTargetTTCStrongByLocationMutMap() {
      List<KamikazeTargetTTCStrongByLocationMutMap> result = new List<KamikazeTargetTTCStrongByLocationMutMap>(rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap.Count);
      foreach (var id in rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap.Keys) {
        result.Add(new KamikazeTargetTTCStrongByLocationMutMap(this, id));
      }
      return result;
    }
    public bool KamikazeTargetTTCStrongByLocationMutMapExists(int id) {
      return rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap.ContainsKey(id);
    }
    public void CheckHasKamikazeTargetTTCStrongByLocationMutMap(KamikazeTargetTTCStrongByLocationMutMap thing) {
      CheckRootsEqual(this, thing.root);
      CheckHasKamikazeTargetTTCStrongByLocationMutMap(thing.id);
    }
    public void CheckHasKamikazeTargetTTCStrongByLocationMutMap(int id) {
      if (!rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap.ContainsKey(id)) {
        throw new System.Exception("Invalid KamikazeTargetTTCStrongByLocationMutMap}: " + id);
      }
    }
    public KamikazeTargetTTCStrongByLocationMutMap EffectKamikazeTargetTTCStrongByLocationMutMapCreate() {
      return TrustedEffectKamikazeTargetTTCStrongByLocationMutMapCreateWithId(NewId());
    }
    public KamikazeTargetTTCStrongByLocationMutMap TrustedEffectKamikazeTargetTTCStrongByLocationMutMapCreateWithId(int id) {
      CheckUnlocked();
      Asserts.Assert(!rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap.ContainsKey(id));
      var effect =
        InternalEffectCreateKamikazeTargetTTCStrongByLocationMutMap(
          id,
          rootIncarnation.version,
          new KamikazeTargetTTCStrongByLocationMutMapIncarnation(
              new SortedDictionary<Location, int>()));
      NotifyEffect(effect);
      return new KamikazeTargetTTCStrongByLocationMutMap(this, id);
    }
       
    public KamikazeTargetTTCStrongByLocationMutMapCreateEffect InternalEffectCreateKamikazeTargetTTCStrongByLocationMutMap(int id, int incarnationVersion, KamikazeTargetTTCStrongByLocationMutMapIncarnation incarnation) {
      rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap
          .Add(
              id,
              new VersionAndIncarnation<KamikazeTargetTTCStrongByLocationMutMapIncarnation>(
                  incarnationVersion,
                  incarnation));
    return new KamikazeTargetTTCStrongByLocationMutMapCreateEffect(id);
    }
    public void EffectKamikazeTargetTTCStrongByLocationMutMapDelete(int id) {
      var effect = InternalEffectKamikazeTargetTTCStrongByLocationMutMapDelete(id);
      NotifyEffect(effect);
    }
    public KamikazeTargetTTCStrongByLocationMutMapDeleteEffect InternalEffectKamikazeTargetTTCStrongByLocationMutMapDelete(int id) {
      CheckUnlocked();
      var versionAndIncarnation = rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap[id];
      rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap.Remove(id);
        return new KamikazeTargetTTCStrongByLocationMutMapDeleteEffect(id);
    }
    public void EffectKamikazeTargetTTCStrongByLocationMutMapAdd(int instanceId, Location key, int value) {
      CheckUnlocked();
      CheckHasKamikazeTargetTTCStrongByLocationMutMap(instanceId);
      CheckHasKamikazeTargetTTC(value);
      var effect = InternalEffectKamikazeTargetTTCStrongByLocationMutMapAdd(instanceId, key, value);
      NotifyEffect(effect);
    }
    public KamikazeTargetTTCStrongByLocationMutMapAddEffect InternalEffectKamikazeTargetTTCStrongByLocationMutMapAdd(int instanceId, Location key, int value) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap[instanceId];
      if (oldIncarnationAndVersion.incarnation.elements.ContainsKey(key)) {
        throw new Exception("Key exists! " + key);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        oldIncarnationAndVersion.incarnation.elements.Add(key, value);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedDictionary<Location, int>(oldMap);
        newMap.Add(key, value);
        var newIncarnation = new KamikazeTargetTTCStrongByLocationMutMapIncarnation(newMap);
        rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap[instanceId] =
            new VersionAndIncarnation<KamikazeTargetTTCStrongByLocationMutMapIncarnation>(
                rootIncarnation.version,
                newIncarnation);
      }
      return new KamikazeTargetTTCStrongByLocationMutMapAddEffect(instanceId, key, value);
    }
       
    public void EffectKamikazeTargetTTCStrongByLocationMutMapRemove(int instanceId, Location key) {
      CheckUnlocked();
      CheckHasKamikazeTargetTTCStrongByLocationMutMap(instanceId);
      var effect = InternalEffectKamikazeTargetTTCStrongByLocationMutMapRemove(instanceId, key);
      NotifyEffect(effect);
    }
    public KamikazeTargetTTCStrongByLocationMutMapRemoveEffect InternalEffectKamikazeTargetTTCStrongByLocationMutMapRemove(int instanceId, Location key) {
      var oldIncarnationAndVersion = rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap[instanceId];
      if (!oldIncarnationAndVersion.incarnation.elements.ContainsKey(key)) {
        throw new Exception("Key doesnt exist! " + key);
      }
      if (oldIncarnationAndVersion.version == rootIncarnation.version) {
        var oldValue = oldIncarnationAndVersion.incarnation.elements[key];
        oldIncarnationAndVersion.incarnation.elements.Remove(key);
      } else {
        var oldMap = oldIncarnationAndVersion.incarnation.elements;
        var newMap = new SortedDictionary<Location, int>(oldMap);
        newMap.Remove(key);
        var newIncarnation = new KamikazeTargetTTCStrongByLocationMutMapIncarnation(newMap);
        rootIncarnation.incarnationsKamikazeTargetTTCStrongByLocationMutMap[instanceId] =
            new VersionAndIncarnation<KamikazeTargetTTCStrongByLocationMutMapIncarnation>(
                rootIncarnation.version, newIncarnation);
      }
      return new KamikazeTargetTTCStrongByLocationMutMapRemoveEffect(instanceId, key);
    }
}

}
